<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>04-方法的缓存原理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="04-方法的缓存原理"><meta property="og:url" content="http://evilimo.com/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050d86059e8d45"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050e19dca9c7b2"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050e7a42f1fea4"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050f4b80003468"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050fcf4e4c3dbd"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/170511b2721d737e"><meta property="article:published_time" content="2020-12-16T09:34:17.071Z"><meta property="article:modified_time" content="2020-12-27T07:07:33.368Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050d86059e8d45"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"},"headline":"IMO's Blog","image":[],"datePublished":"2020-12-16T09:34:17.071Z","dateModified":"2020-12-27T07:07:33.368Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-12-16T09:34:17.071Z" title="2020-12-16T09:34:17.071Z">2020-12-16</time>发表</span><span class="level-item"><time dateTime="2020-12-27T07:07:33.368Z" title="2020-12-27T07:07:33.368Z">2020-12-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">04-方法的缓存原理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="一、-cache-t源码分析"><a href="#一、-cache-t源码分析" class="headerlink" title="一、 cache_t源码分析"></a>一、 <code>cache_t</code>源码分析</h2><p>当<code>OC</code>项目编译完成后，类的实例方法（方法编号<code>SEL</code> 和 函数地址<code>IMP</code>）就保存在类的方法列表中。我们知道 <code>OC</code> 为了实现其动态性，将 <strong>方法的调用包装成了 <code>SEL</code> 寻找 <code>IMP</code> 的过程</strong>。试想一下，如果每次调用方法，都要去类的方法列表（甚至父类、根类的方法列表）中查询其函数地址，势必会对性能造成极大的损耗。</p>
<p>为了解决这一问题，<code>OC</code> 采用了方法缓存的机制来提高调用效率，也就是<code>cache_t</code>，其作用就是缓存已调用的方法。当调用方法时，<code>objc_msgSend</code>会先去缓存中查找，如果找到就执行该方法；如果不在缓存中，则去类的方法列表（包括父类、根类的方法列表）查找，找到后会将方法的<code>SEL</code>和<code>IMP</code>缓存到<code>cache_t</code>中，以便下次调用时能够快速执行。</p>
<h3 id="1-1-cache-t结构"><a href="#1-1-cache-t结构" class="headerlink" title="1.1 cache_t结构"></a>1.1 <code>cache_t</code>结构</h3><p>源码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;  <span class="comment">// 缓存数组，即哈希桶</span></span><br><span class="line">    mask_t _mask;               <span class="comment">// 缓存数组的容量临界值</span></span><br><span class="line">    mask_t _occupied;           <span class="comment">// 缓存数组中已缓存方法数量</span></span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 一些函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line"><span class="keyword">typedef</span> uint32_t mask_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> uint16_t mask_t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64__</span></span><br><span class="line">    uintptr_t _imp;</span><br><span class="line">    SEL _sel;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    SEL _sel;</span><br><span class="line">    uintptr_t _imp;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ... <span class="comment">// 一些方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面源码不难看出，在<code>64</code>位CPU架构下，<code>cache_t</code>长度是16字节。单从结构来看，方法是缓存在<code>bucket_t</code>（又称哈希桶）中，接下来用个例子验证一下<code>cache_t</code>是否缓存了已调用的方法。</p>
<h3 id="1-2-方法缓存的验证"><a href="#1-2-方法缓存的验证" class="headerlink" title="1.2 方法缓存的验证"></a>1.2 方法缓存的验证</h3><p>1.创建一个简单的<code>Person</code>类，代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodFirst;</span><br><span class="line">- (<span class="keyword">void</span>)methodSecond;</span><br><span class="line">- (<span class="keyword">void</span>)methodThird;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodFirst &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodSecond &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)methodThird &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>2.<strong>方法调用前的<code>cache_t</code></strong></p>
<p>在方法调用前打个断点，看看<code>cache_t</code>的缓存情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050d86059e8d45"></p>
<p><strong>说明：</strong></p>
<ul>
<li><p><code>objc_class</code>结构中<code>ISA</code>占8字节，<code>superClass</code>占8字节，由于我们是按照8字节为一段打印的，所以刚好<code>0x1000011d8</code>就是<code>cache_t</code>首地址。</p>
</li>
<li><p>由于还没有任何方法调用，所以<code>_mask</code>和<code>_occupied</code>都是0，即还没有方法缓存。</p>
</li>
<li><p>为什么调用了<strong>alloc</strong>和<strong>class</strong>，但是这两个方法怎么没有缓存，这里要提到我们之前探索类的方法存储中说到的，<strong>对象的方法存在类中，类的类方法以实例方法的形式存在元类中</strong>，我们这里探索的是<strong>类的cache</strong>缓存，所以只能找到实例方法。下面直接给大家看一下元类里的<strong>cache</strong>以及<strong>bucket</strong>，也找到了<strong>alloc</strong>方法的缓存，这也说明，我们的思路是正确的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p/x <span class="number">0x001d8001000012b9</span> &amp; <span class="number">0x00007ffffffffff8</span>ULL</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) $<span class="number">5</span> = <span class="number">0x00000001000012b8</span></span><br><span class="line"><span class="comment">// 0x00000001000012b8这个玩意就是元类的地址了。之前的isa原理，里面介绍到了如何从类查找到元类</span></span><br><span class="line">(lldb) x/<span class="number">4</span>gx <span class="number">0x00000001000012b8</span></span><br><span class="line"><span class="number">0x1000012b8</span>: <span class="number">0x001d800100b360f1</span> <span class="number">0x0000000100b360f0</span></span><br><span class="line"><span class="number">0x1000012c8</span>: <span class="number">0x0000000101e236c0</span> <span class="number">0x0000000200000003</span></span><br><span class="line">(lldb) p (cache_t *)<span class="number">0x1000012c8</span></span><br><span class="line">(cache_t *) $<span class="number">6</span> = <span class="number">0x00000001000012c8</span></span><br><span class="line">(lldb) p *$<span class="number">6</span></span><br><span class="line">(cache_t) $<span class="number">7</span> = &#123;</span><br><span class="line">  _buckets = <span class="number">0x0000000101e236c0</span></span><br><span class="line">  _mask = <span class="number">3</span></span><br><span class="line">  _occupied = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">(lldb) p $<span class="number">7.</span>_buckets</span><br><span class="line">(bucket_t *) $<span class="number">8</span> = <span class="number">0x0000000101e236c0</span></span><br><span class="line">(lldb) p *$<span class="number">8</span></span><br><span class="line">(bucket_t) $<span class="number">9</span> = &#123;</span><br><span class="line">  _key = <span class="number">4298994200</span></span><br><span class="line">  _imp = <span class="number">0x00000001003cc3b0</span> (libobjc.A.dylib`::+[<span class="built_in">NSObject</span> alloc]() at <span class="built_in">NSObject</span>.mm:<span class="number">2294</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p>3.<strong>方法调用后的<code>cache_t</code></strong></p>
<p>执行<code>alloc</code>和<code>init</code>这两个方法后，<code>cache_t</code>变化如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050e19dca9c7b2"></p>
<p>从上图可知，调用<code>init</code>后，<code>_mask</code>的值是3，<code>_occupied</code>则是1。<code>_buckets</code>指针的值（数组首地址）发生了变化（从<code>0x1003db250</code>变成<code>0x101700090</code>），同时缓存了<code>init</code>方法的<code>SEL</code>和<code>IMP</code>。</p>
<blockquote>
<p>思考： 1. alloc 方法调用后，缓存在哪里？ 2. 为什么 init 方法不在 _buckets 第一个位置？ </p>
</blockquote>
<p>继续执行<code>methodFirst</code>，再看<code>cache_t</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050e7a42f1fea4"></p>
<p>此时，<code>_mask</code>的值是3（没发生变化），<code>_occupied</code>则变成了2，<code>_buckets</code>指针地址没变，增加缓存了<code>methodFirst</code>方法的<code>SEL</code>和<code>IMP</code>。</p>
<p>接着是执行<code>methodSecond</code>，且看</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050f4b80003468"></p>
<p>显然，<code>_occupied</code>变成了3，而<code>_buckets</code>指针地址不改变，同时新增<code>methodSecond</code>的方法缓存。</p>
<p>最后执行<code>methodThird</code>后，再看<code>cache_t</code>变化</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17050fcf4e4c3dbd"></p>
<p>这次的结果就完全不同了。<code>_mask</code>的值变成7，<code>_occupied</code>则重新变成了1，而<code>_buckets</code>不仅首地址变了，之前缓存的<code>init</code>、<code>methodFirst</code>和<code>methodSecond</code>方法也没了，仅存在的只有新增的<code>methodThird</code>方法。看来，<code>cache_t</code>并非是如我们所愿的那样——调用一个方法就缓存一个方法。</p>
<blockquote>
<p>思考：之前缓存的方法（init、methodFirst 和 methodSecond）哪去了？</p>
</blockquote>
<h3 id="1-3-cache-t小结"><a href="#1-3-cache-t小结" class="headerlink" title="1.3 cache_t小结"></a>1.3 <code>cache_t</code>小结</h3><p>让我们梳理一下上面的例子。在依次执行<code>Person</code>的实例方法<code>init</code>、<code>methodFirst</code>、<code>methodSecond</code>、<code>methodThird</code>后，<code>cache_t</code>变化如下</p>
<table>
<thead>
<tr>
<th>调用的方法</th>
<th>_buckets</th>
<th>_mask</th>
<th>_occupied</th>
</tr>
</thead>
<tbody><tr>
<td>未调用方法</td>
<td>空</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>init</td>
<td>init</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>init、methodFirst</td>
<td>init、methodFirst</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>init、methodFirst、methodSecond</td>
<td>init、methodFirst、methodSecond</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>init、methodFirst、methodSecond、methodThird</td>
<td>methodThird</td>
<td>7</td>
<td>1</td>
</tr>
</tbody></table>
<p>可见，**<code>cache_t</code>的确能实时缓存已调用的方法**。</p>
<p>上面的验证过程也可以帮助我们理解<code>cache_t</code>三个成员变量的意义。</p>
<p><code>bucket</code>可译为桶（即哈希桶），用于装方法；</p>
<p><code>occupied</code>可译为已占有，表示已缓存的方法数量；</p>
<p><code>mask</code>可译为面具、掩饰物，乍看无头绪，但是注意到<code>cache_t</code>中有获取容量的函数（<code>capacity</code>），其源码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    ...</span><br><span class="line">    mask_t mask();</span><br><span class="line">    mask_t capacity();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mask_t cache_t::mask() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _mask; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mask_t cache_t::capacity() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mask() ? mask()+<span class="number">1</span> : <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从capacity方法看出：当<code>_mask</code>不等于0的时候，意味着已经调用过实例方法，此时桶的容量为<code>_mask + 1</code>，如果<code>_mask</code>是0，说明未调用实例方法，即桶的容量为0。故，<code>_mask</code>从侧面反映了桶的容量。</p>
<h2 id="二、cache-t的方法缓存原理"><a href="#二、cache-t的方法缓存原理" class="headerlink" title="二、cache_t的方法缓存原理"></a>二、<code>cache_t</code>的方法缓存原理</h2><p>接下来，从方法的调用过程开始分析<code>cache_t</code>的方法缓存原理。</p>
<h3 id="2-1-cache-fill"><a href="#2-1-cache-fill" class="headerlink" title="2.1 cache_fill"></a>2.1 <code>cache_fill</code></h3><p><code>OC</code>方法的本质是 **消息发送（即<code>objc_msgSend</code>），底层是通过方法的 <code>SEL</code> 查找 <code>IMP</code>**。</p>
<p>简要流程：</p>
<p>1.调用方法时，<code>objc_msgSend</code>会去<code>cache_t</code>即缓存中查询方法的函数实现（这部分是由汇编代码实现的，非常高效），在缓存中找的过程暂且不表</p>
<p>2.当缓存中没有的时候，则去类的方法列表中查找，直至找到后，再调用<code>cache_fill</code>，目的是为了将方法缓存到<code>cache_t</code>中，其源码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_fill(Class cls, SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DEBUG_TASK_THREADS</span></span><br><span class="line">    mutex_locker_t lock(cacheUpdateLock);</span><br><span class="line">    cache_fill_nolock(cls, sel, imp, receiver);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _collecting_in_critical();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>objc_msgSend</code>的具体流程将另起一文分析，这里不作赘述。</p>
</blockquote>
<h3 id="2-2-cache-fill-nolock"><a href="#2-2-cache-fill-nolock" class="headerlink" title="2.2 cache_fill_nolock"></a>2.2 <code>cache_fill_nolock</code></h3><p><code>cache_fill</code>又会来到<code>cache_fill_nolock</code>，这个函数的作用是将方法的<code>SEL</code>和<code>IMP</code>写入<code>_buckets</code>，同时更新<code>_mask</code>和<code>_occupied</code>。</p>
<p>其源码以及详细分析如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> cache_fill_nolock(Class cls, SEL sel, IMP imp, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果类未初始化</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isInitialized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache_getImp(cls, sel)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 cls 的 cache_t指针</span></span><br><span class="line">    cache_t *cache = getCache(cls);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// newOccupied为新的方法缓存数，等于 当前方法缓存数+1</span></span><br><span class="line">    mask_t newOccupied = cache-&gt;occupied() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取当前cache_t的总容量，即 mask+1</span></span><br><span class="line">    mask_t capacity = cache-&gt;capacity();</span><br><span class="line">    <span class="keyword">if</span> (cache-&gt;isConstantEmptyCache()) &#123;</span><br><span class="line">        <span class="comment">// 当第一次调用类的实例方法时（如本文的【1.2】例中的`init`）</span></span><br><span class="line">        cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (newOccupied &lt;= capacity / <span class="number">4</span> * <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新的方法缓存数 大于 总容量的3/4，需要扩容</span></span><br><span class="line">        cache-&gt;expand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法），</span></span><br><span class="line">    <span class="comment">// 也可能与实参sel相等（hash冲突，可能性很低）</span></span><br><span class="line">    bucket_t *bucket = cache-&gt;find(sel, receiver);</span><br><span class="line">    <span class="comment">// 当且仅当bucket的sel为0时，执行_occupied++</span></span><br><span class="line">    <span class="keyword">if</span> (bucket-&gt;sel() == <span class="number">0</span>) cache-&gt;incrementOccupied();</span><br><span class="line">    <span class="comment">// 更新bucket的sel和imp</span></span><br><span class="line">    bucket-&gt;set&lt;Atomic&gt;(sel, imp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// INIT_CACHE_SIZE 即为4</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的源码不难看出，<code>cache_fill_nolock</code>主要是<code>cache_t</code>缓存方法的调度中心，在这里会：</p>
<p>1.决定执行<code>_buckets</code>的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）；</p>
<p>2.然后通过方法的<code>sel</code>找到一个<code>bucket</code>，并更新这个<code>bucket</code>的<code>sel</code>和<code>imp</code>。（如果这个<code>bucket</code>的<code>sel</code>为0，说明是个空桶，正好可以缓存方法，于是执行<code>_occupied++</code>）。</p>
<blockquote>
<p>思考：为什么扩容临界点是 3/4？</p>
</blockquote>
<h3 id="2-3-reallocate"><a href="#2-3-reallocate" class="headerlink" title="2.3 reallocate"></a>2.3 <code>reallocate</code></h3><p>在下面这两种情况下会执行<code>reallocate</code>：</p>
<ul>
<li>一是第一次初始化<code>_buckets</code>的时候</li>
<li>另一种则是<code>_buckets</code>扩容的时候</li>
</ul>
<p>我们来看一下<code>reallocate</code>做了哪些事情</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当且仅当`_buckets`中有缓存方法时，feeOld为true</span></span><br><span class="line">    <span class="keyword">bool</span> freeOld = canBeFreed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前buckets指针，即_buckets</span></span><br><span class="line">    bucket_t *oldBuckets = buckets();</span><br><span class="line">    <span class="comment">// 开辟新的buckets指针</span></span><br><span class="line">    bucket_t *newBuckets = allocateBuckets(newCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache&#x27;s old contents are not propagated. </span></span><br><span class="line">    <span class="comment">// This is thought to save cache memory at the cost of extra cache fills.</span></span><br><span class="line">    <span class="comment">// fixme re-measure this</span></span><br><span class="line"></span><br><span class="line">    assert(newCapacity &gt; <span class="number">0</span>);</span><br><span class="line">    assert((uintptr_t)(mask_t)(newCapacity<span class="number">-1</span>) == newCapacity<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新buckets、新mask（newCapacity-1）分别赋值跟当前的 _buckets 和 _mask</span></span><br><span class="line">    setBucketsAndMask(newBuckets, newCapacity - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (freeOld) &#123;</span><br><span class="line">        <span class="comment">// 释放旧的buckets内存空间</span></span><br><span class="line">        cache_collect_free(oldBuckets, oldCapacity);</span><br><span class="line">        cache_collect(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>reallocate</code>完美解释了在例【1.2】中的几个情况：</p>
<ul>
<li><code>init</code>执行完后，<code>_buckets</code>指针地址变了，<code>_mask</code>变成了3；</li>
<li><code>methodThird</code>执行完后，<code>_buckets</code>不仅指针地址变了，同时之前缓存的<code>init</code>、<code>methodFirst</code>和<code>methodSecond</code>方法也都不在了</li>
</ul>
<p>注意，<code>_occupied</code>的变化是在回到<code>cache_fill_nolock</code>后发生的。</p>
<blockquote>
<p>思考：扩容后，为什么不直接把之前缓存的方法加入新的buckets中？</p>
</blockquote>
<h3 id="2-4-expand"><a href="#2-4-expand" class="headerlink" title="2.4 expand"></a>2.4 <code>expand</code></h3><p>从<code>cache_fill_nolock</code>源码来看，当新的方法缓存数（_occupied+1）大于总容量（_mask+1）时，会对<code>_buckets</code>进行扩容，也就是执行<code>expand</code>函数，其源码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> cache_t::expand()</span><br><span class="line">&#123;</span><br><span class="line">    cacheUpdateLock.assertLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前总容量，即_mask+1</span></span><br><span class="line">    uint32_t oldCapacity = capacity();</span><br><span class="line">    <span class="comment">// 新的容量 = 旧容量 * 2</span></span><br><span class="line">    uint32_t newCapacity = oldCapacity ? oldCapacity*<span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((uint32_t)(mask_t)newCapacity != newCapacity) &#123;</span><br><span class="line">        <span class="comment">// mask overflow - can&#x27;t grow further</span></span><br><span class="line">        <span class="comment">// fixme this wastes one bit of mask</span></span><br><span class="line">        newCapacity = oldCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reallocate(oldCapacity, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数非常简单，仅仅是计算好新的容量后，就去调用<code>reallocate</code>函数。需要注意的是：</p>
<ul>
<li>在不超过<code>uint32_t</code>大小（4字节）时，每次扩容为原来的2倍</li>
<li>如果超过了<code>uint32_t</code>，则重新申请跟原来一样大小的<code>buckets</code></li>
</ul>
<h3 id="2-5-find"><a href="#2-5-find" class="headerlink" title="2.5 find"></a>2.5 <code>find</code></h3><p>在执行完相应的<code>buckets</code>策略后，接下来就需要找到合适的位置（<code>bucket</code>），以存储 方法的<code>SEL</code>和<code>IMP</code>。<code>find</code>具体做的事情就是根据方法的<code>SEL</code>，返回一个符合要求的<code>bucket</code>，同样上源码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">bucket_t * cache_t::find(SEL s, <span class="keyword">id</span> receiver)</span><br><span class="line">&#123;</span><br><span class="line">    assert(s != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 获取当前buckets，即_buckets</span></span><br><span class="line">    bucket_t *b = buckets();</span><br><span class="line">    <span class="comment">// 获取当前mask，即_mask</span></span><br><span class="line">    mask_t m = mask();</span><br><span class="line">    <span class="comment">// 由 sel &amp; mask 得出起始索引值</span></span><br><span class="line">    mask_t begin = cache_hash(s, m);</span><br><span class="line">    mask_t i = begin;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// sel为0：说明 i 这个位置尚未缓存方法；</span></span><br><span class="line">        <span class="comment">// sel等于s：命中缓存，说明 i 这个位置已缓存方法，可能是hash冲突</span></span><br><span class="line">        <span class="keyword">if</span> (b[i].sel() == <span class="number">0</span>  ||  b[i].sel() == s) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((i = cache_next(i, m)) != begin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hack</span></span><br><span class="line">    <span class="comment">// 找不到多余的哈希桶（出错的处理，打印问题）。一般不会走到这里！</span></span><br><span class="line">    Class cls = (Class)((uintptr_t)<span class="keyword">this</span> - offsetof(objc_class, cache));</span><br><span class="line">    cache_t::bad_cache(receiver, (SEL)s, cls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t cache_hash(SEL sel, mask_t mask) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (mask_t)(uintptr_t)sel &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm__  ||  __x86_64__  ||  __i386__</span></span><br><span class="line"><span class="comment">// objc_msgSend has few registers available.</span></span><br><span class="line"><span class="comment">// Cache scan increments and wraps at special end-marking bucket.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_END_MARKER 1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    <span class="keyword">return</span> (i+<span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> __arm64__</span></span><br><span class="line"><span class="comment">// objc_msgSend has lots of registers available.</span></span><br><span class="line"><span class="comment">// Cache scan decrements. No end marker needed.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHE_END_MARKER 0</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> mask_t cache_next(mask_t i, mask_t mask) &#123;</span><br><span class="line">    <span class="keyword">return</span> i ? i<span class="number">-1</span> : mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> unknown architecture</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>从源码可以发现，<code>find</code>找<code>bucket</code>的方式用到了<code>hash</code>的思想：以<code>_buckets</code>作为哈希桶，以<code>cache_hash</code>作为哈希函数，进行哈希运算后得出索引值<code>index</code>（本质是<code>xx &amp; mask</code>，所以<code>index</code>最大值就是<code>_mask</code>的值）。</p>
<p>由于索引值是通过<code>哈希运算</code>得出的，其结果自然是无序的，这也是为什么上例中<code>init</code>方法不在<code>_buckets</code>第一个位置的原因。</p>
<h2 id="三、多线程对方法缓存的影响"><a href="#三、多线程对方法缓存的影响" class="headerlink" title="三、多线程对方法缓存的影响"></a>三、多线程对方法缓存的影响</h2><p>既然哈希桶的数量是在运行时动态增加的，那么在多线程环境下调用方法时，对方法的缓存有没有什么影响呢？看下面的分析。</p>
<h3 id="3-1-多线程同时读取缓存"><a href="#3-1-多线程同时读取缓存" class="headerlink" title="3.1 多线程同时读取缓存"></a>3.1 多线程同时读取缓存</h3><p>在整个<code>objc_msgSend</code>函数中，为了达到最佳的性能，对方法缓存的读取操作是没有添加任何锁的。而多个线程同时调用已缓存的方法，并不会引发<code>_buckets</code>和<code>_mask</code>的变化，<strong>因此多个线程同时读取方法缓存的操作是不会有安全隐患的</strong>。</p>
<h3 id="3-2-多线程同时写缓存"><a href="#3-2-多线程同时写缓存" class="headerlink" title="3.2 多线程同时写缓存"></a>3.2 多线程同时写缓存</h3><p>从写缓存的<code>cache_fill_nolock</code>方法中我们知道在桶数量扩容和写桶数据之前，系统使用了一个全局的互斥锁（<code>cacheUpdateLock.assertLocked()</code>）来保证写入的同步处理，并且在锁住的范围内部还做了一次查缓存的操作（<code>if (cache_getImp(cls, sel)) return;</code>），这样就 <strong>保证了哪怕多个线程同时写同一个方法的缓存也只会产生写一次的效果，即多线程同时写缓存的操作也不会有安全隐患</strong>。</p>
<h3 id="3-3-多线程同时读写缓存"><a href="#3-3-多线程同时读写缓存" class="headerlink" title="3.3 多线程同时读写缓存"></a>3.3 多线程同时读写缓存</h3><p>这个情况就比较复杂了，我们先看一下<code>objc_msgSend</code>读缓存的代码（以 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm64.s.auto.html">arm64架构汇编</a> 为例）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup</span><br><span class="line">	<span class="comment">// x1 = SEL, x16 = isa</span></span><br><span class="line">	ldp	x10, x11, [x16, #<span class="built_in">CACHE</span>]	<span class="comment">// x10 = buckets, x11 = occupied|mask</span></span><br><span class="line">	and	w12, w1, w11		<span class="comment">// x12 = _cmd &amp; mask</span></span><br><span class="line">	add	x12, x10, x12, LSL #<span class="number">4</span>	<span class="comment">// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line">	ldp	x9, x17, [x12]		<span class="comment">// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:	cmp	x9, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">	b.ne	<span class="number">2</span>f			<span class="comment">//     scan more</span></span><br><span class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">	b.eq	<span class="number">3</span>f</span><br><span class="line">	ldp	x9, x17, [x12, #<span class="number">-16</span>]!	<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line">	b	<span class="number">1</span>b			<span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:	<span class="comment">// wrap: x12 = first bucket, w11 = mask</span></span><br><span class="line">	add	x12, x12, w11, UXTW #<span class="number">4</span>	<span class="comment">// x12 = buckets+(mask&lt;&lt;4)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Clone scanning loop to miss instead of hang when cache is corrupt.</span></span><br><span class="line">	<span class="comment">// The slow path may detect any corruption and halt later.</span></span><br><span class="line"></span><br><span class="line">	ldp	x9, x17, [x12]		<span class="comment">// &#123;x9, x17&#125; = *bucket</span></span><br><span class="line"><span class="number">1</span>:	cmp	x9, x1			<span class="comment">// if (bucket-&gt;sel != _cmd)</span></span><br><span class="line">	b.ne	<span class="number">2</span>f			<span class="comment">//     scan more</span></span><br><span class="line">	CacheHit $<span class="number">0</span>			<span class="comment">// call or return imp</span></span><br><span class="line">	</span><br><span class="line"><span class="number">2</span>:	<span class="comment">// not hit: x12 = not-hit bucket</span></span><br><span class="line">	CheckMiss $<span class="number">0</span>			<span class="comment">// miss if bucket-&gt;sel == 0</span></span><br><span class="line">	cmp	x12, x10		<span class="comment">// wrap if bucket == buckets</span></span><br><span class="line">	b.eq	<span class="number">3</span>f</span><br><span class="line">	ldp	x9, x17, [x12, #<span class="number">-16</span>]!	<span class="comment">// &#123;x9, x17&#125; = *--bucket</span></span><br><span class="line">	b	<span class="number">1</span>b			<span class="comment">// loop</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:	<span class="comment">// double wrap</span></span><br><span class="line">	JumpMiss $<span class="number">0</span></span><br><span class="line">	</span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure>

<p>其中，<code>ldp</code>指令的作用是将数据从内存读取出来存到寄存器，第一个<code>ldp</code>代码会 <strong>把<code>cache_t</code>中的<code>_buckets</code> 和 <code>_occupied | _mask</code>整个结构体成员分别读取到<code>x10</code>和<code>x11</code>两个寄存器中</strong>，并且<code>CacheLookup</code>的后续代码没有再次读取<code>cache_t</code>的成员数据，而是一直使用<code>x10</code>和<code>x11</code>中的值进行哈希查找。由于CPU能保证单条指令执行的原子性，所以 <strong>只要保证<code>ldp x10, x11, [x16, #CACHE]</code>这段代码读取到的<code>_buckets</code>与<code>_mask</code>是互相匹配的（即要么同时是扩容前的数据，要么同时是扩容后的数据），那么多个线程同时读写方法缓存也是没有安全隐患的</strong>。</p>
<h4 id="3-3-1-编译内存屏障"><a href="#3-3-1-编译内存屏障" class="headerlink" title="3.3.1 编译内存屏障"></a>3.3.1 编译内存屏障</h4><p>这里有个疑问，即系统是如何确保<code>_buckets</code>与<code>_mask</code>的这种一致性的呢？让我们看一下这两个变量的写入源码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::setBucketsAndMask</span><span class="params">(struct <span class="keyword">bucket_t</span> *newBuckets, <span class="keyword">mask_t</span> newMask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// objc_msgSend uses mask and buckets with no locks.</span></span><br><span class="line">    <span class="comment">// It is safe for objc_msgSend to see new buckets but old mask.</span></span><br><span class="line">    <span class="comment">// (It will get a cache miss but not overrun the buckets&#x27; bounds).</span></span><br><span class="line">    <span class="comment">// It is unsafe for objc_msgSend to see old buckets and new mask.</span></span><br><span class="line">    <span class="comment">// Therefore we write new buckets, wait a lot, then write new mask.</span></span><br><span class="line">    <span class="comment">// objc_msgSend reads mask first, then buckets.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure other threads see buckets contents before buckets pointer</span></span><br><span class="line">    mega_barrier();</span><br><span class="line"></span><br><span class="line">    _buckets = newBuckets;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ensure other threads see new buckets before new mask</span></span><br><span class="line">    mega_barrier();</span><br><span class="line">    </span><br><span class="line">    _mask = newMask;</span><br><span class="line">    _occupied = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段<code>C++</code>代码先修改<code>_buckets</code>，然后再更新<code>_mask</code>的值，为了确保这个顺序不被编译器优化，这里使用了<code>mega_baerrier()</code>来实现 <strong>编译内存屏障（Compiler Memory Barrier）</strong>。</p>
<blockquote>
<p>如果不设置 <code>编译内存屏障</code> 的话，编译器有可能会优化代码先赋值<code>_mask</code>，然后才是赋值<code>_buckets</code>，两者的赋值之间，如果另一个线程执行<code>ldp x10, x11, [x16, #0x10]</code>指令，得到的就是<code>旧_buckets</code>和<code>新_mask</code>，进而出现内存数组越界引发程序崩溃。</p>
<p>而加入了<code>编译内存屏障</code>后，就算得到的是<code>新_buckets</code>和<code>旧_mask</code>，也不会导致程序崩溃。</p>
</blockquote>
<p><code>编译内存屏障</code>仅仅是确保<code>_buckets</code>的赋值会优先于<code>_mask</code>的赋值，也就是说，在任何场景下当指令<code>ldp x10, x11, [x16, #CACHE]</code>执行后，得到的<code>_buckets</code>数组的长度一定是大于或等于<code>_mask+1</code>的，如此就保证了不会出现内存数组越界导致的程序崩溃。<strong>可见，借助编译内存屏障的技巧在一定的程度上可以实现无锁读写技术。</strong></p>
<blockquote>
<p>对<code>内存屏障</code>感兴趣的同学可戳 <a target="_blank" rel="noopener" href="https://blog.csdn.net/world_hello_100/article/details/50131497">理解 Memory barrier（内存屏障）</a></p>
</blockquote>
<h4 id="3-3-2-内存垃圾回收"><a href="#3-3-2-内存垃圾回收" class="headerlink" title="3.3.2 内存垃圾回收"></a>3.3.2 内存垃圾回收</h4><p>我们知道，在多线程读写方法缓存时，写线程可能会扩容<code>_buckets</code>（开辟新的<code>_buckets</code>内存，同时销毁旧的<code>_buckets</code>），此时，如果其他线程读取到的<code>_buckets</code>是旧的内存，就有可能会发生读内存异常而系统崩溃。为了解决这个问题，<code>OC</code>使用了两个全局数组<code>objc_entryPoints</code>、<code>objc_exitPoints</code>，分别保存所有会访问到<code>cache</code>的函数的起始地址、结束地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">uintptr_t</span> objc_entryPoints[];</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">uintptr_t</span> objc_exitPoints[];</span><br></pre></td></tr></table></figure>

<p>下面列出这些函数（同样以 <a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/objc4-723/runtime/Messengers.subproj/objc-msg-arm64.s.auto.html">arm64架构汇编</a> 为例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.private_extern _objc_entryPoints</span><br><span class="line">_objc_entryPoints:</span><br><span class="line">	.quad   _cache_getImp</span><br><span class="line">	.quad   _objc_msgSend</span><br><span class="line">	.quad   _objc_msgSendSuper</span><br><span class="line">	.quad   _objc_msgSendSuper2</span><br><span class="line">	.quad   _objc_msgLookup</span><br><span class="line">	.quad   _objc_msgLookupSuper2</span><br><span class="line">	.quad   0</span><br><span class="line"></span><br><span class="line">.private_extern _objc_exitPoints</span><br><span class="line">_objc_exitPoints:</span><br><span class="line">	.quad   LExit_cache_getImp</span><br><span class="line">	.quad   LExit_objc_msgSend</span><br><span class="line">	.quad   LExit_objc_msgSendSuper</span><br><span class="line">	.quad   LExit_objc_msgSendSuper2</span><br><span class="line">	.quad   LExit_objc_msgLookup</span><br><span class="line">	.quad   LExit_objc_msgLookupSuper2</span><br><span class="line">	.quad   0</span><br></pre></td></tr></table></figure>

<p>当线程扩容哈希桶时，会先把旧的桶内存保存在一个全局的垃圾回收数组变量<code>garbage_refs</code>中，然后再遍历当前进程（在<code>iOS</code>中，一个进程就是一个应用程序）中的所有线程，查看是否有线程正在执行<code>objc_entryPoints</code>列表中的函数（原理是<code>PC寄存器</code>中的值是否在<code>objc_entryPoints</code>和<code>objc_exitPoints</code>这个范围内），如果没有则说明没有任何线程访问<code>cache</code>，可以放心地对<code>garbage_refs</code>中的所有待销毁的哈希桶内存块执行真正的销毁操作；如果有则说明有线程访问<code>cache</code>，这次就不做处理，下次再检查并在适当的时候进行销毁。</p>
<p>以上，**<code>OC 2.0</code>的<code>runtime</code>巧妙的利用了<code>ldp汇编指令</code>、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。**</p>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/df6629ec9a25">深入解构objc_msgSend函数的实现</a> 这篇博文会帮助你进一步了解Runtime的实现，尤其在多线程读写方法缓存方面</p>
</blockquote>
<h2 id="四、问题讨论"><a href="#四、问题讨论" class="headerlink" title="四、问题讨论"></a>四、问题讨论</h2><p>来到这里，相信大家对<code>cache_t</code>缓存方法的原理已经有了一定的理解。现在请看下面的几个问题：</p>
<h3 id="4-1-类方法的缓存位置"><a href="#4-1-类方法的缓存位置" class="headerlink" title="4.1 类方法的缓存位置"></a>4.1 类方法的缓存位置</h3><p><strong>Q</strong>：<code>Person</code>类调用<code>alloc</code>方法后，缓存在哪里？</p>
<p><strong>A</strong>：缓存在 <code>Person</code>元类 的 <code>cache_t</code> 中。证明如下图</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/170511b2721d737e"></p>
<h3 id="4-2-mask的作用"><a href="#4-2-mask的作用" class="headerlink" title="4.2 _mask的作用"></a>4.2 <code>_mask</code>的作用</h3><p><strong>Q</strong>：请说明<code>cache_t</code>中<code>_mask</code>的作用</p>
<p><strong>A</strong>：<code>_mask</code>从侧面反映了<code>cache_t</code>中哈希桶的数量（<code>哈希桶的数量 = _mask + 1</code>），保证了查找哈希桶时不会出现越界的情况。</p>
<p><strong>题解</strong>：从上面的源码分析，我们知道<code>cache_t</code>在任何一次缓存方法的时候，哈希桶的数量一定是 <strong><code>&gt;=4</code>且能被 4整除的</strong>，<code>_mask</code>则等于哈希桶的数量-1，也就是说，<strong>缓存方法的时候，<code>_mask</code>的二进制位上全都是1</strong>。当循环查询哈希桶的时候，索引值是由<code>xx &amp; _mask</code>运算得出的，因此索引值是小于哈希桶的数量的（<code>index &lt;= _mask</code>，故<code>index &lt; capacity</code>），也就不会出现越界的情况。</p>
<h3 id="4-3-关于扩容临界点3-4的讨论"><a href="#4-3-关于扩容临界点3-4的讨论" class="headerlink" title="4.3 关于扩容临界点3/4的讨论"></a>4.3 关于扩容临界点<code>3/4</code>的讨论</h3><p><strong>Q</strong>：为什么扩容临界点是3/4？</p>
<p><strong>A</strong>：一般设定临界点就不得不权衡 <strong>空间利用率</strong> 和 <strong>时间利用率</strong> 。在 <code>3/4</code> 这个临界点的时候，空间利用率比较高，同时又避免了相当多的哈希冲突，时间利用率也比较高。</p>
<p><strong>题解</strong>：扩容临界点直接影响循环查找哈希桶的效率。设想两个极端情况：</p>
<p>当临界点是1的时候，也就是说当全部的哈希桶都缓存有方法时，才会扩容。这虽然让开辟出来的内存空间的利用率达到100%，但是会造成大量的哈希冲突，加剧了查找索引的时间成本，导致时间利用率低下，这与高速缓存的目的相悖；</p>
<p>当临界点是0.5的时候，意味着哈希桶的占用量达到总数一半的时候，就会扩容。这虽然极大避免了哈希冲突，时间利用率非常高，却浪费了一半的空间，使得空间利用率低下。这种以空间换取时间的做法同样不可取；</p>
<p>两相权衡下，<strong>当扩容临界点是3/4的时候，空间利用率 和 时间利用率 都相对比较高</strong>。</p>
<h3 id="4-4-缓存循环查找的死循环情况"><a href="#4-4-缓存循环查找的死循环情况" class="headerlink" title="4.4 缓存循环查找的死循环情况"></a>4.4 缓存循环查找的死循环情况</h3><p><strong>Q</strong>：缓存循环查找哈希桶是否会出现死循环的情况？</p>
<p><strong>A</strong>：不会出现。</p>
<p><strong>题解</strong>：当哈希桶的利用率达到3/4的时候，下次缓存的时候就会进行扩容，即空桶的数量最少也会有总数的1/4，因此循环查询索引的时候，一定会出现命中缓存或者空桶的情况，从而结束循环。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>通过以上例子的验证、源码的分析以及问题的讨论，现在总结一下<code>cache_t</code>的几个结论：</p>
<p>1.<code>cache_t</code>能缓存调用过的方法。</p>
<p>2.<code>cache_t</code>的三个成员变量中，</p>
<ul>
<li><code>_buckets</code>的类型是<code>struct bucket_t *</code>，也就是指针数组，它表示一系列的哈希桶（已调用的方法的<code>SEL</code>和<code>IMP</code>就缓存在哈希桶中），一个桶可以缓存一个方法。</li>
<li><code>_mask</code>的类型是<code>mask_t</code>（<code>mask_t</code>在<code>64</code>位架构下就是<code>uint32_t</code>，长度为4个字节），它的值等于哈希桶的总数-1（<code>capacity - 1</code>），侧面反映了哈希桶的总数。</li>
<li><code>_occupied</code>的类型也是<code>mask_t</code>，它代表的是当前<code>_buckets</code>已缓存的方法数。</li>
</ul>
<p>3.当缓存的方法数到达临界点（桶总数的3/4）时，下次再缓存新的方法时，首先会丢弃旧的桶，同时开辟新的内存，也就是扩容（扩容后都是全新的桶，以后每个方法都要重新缓存的），然后再把新的方法缓存下来，此时<code>_occupied</code>为1。</p>
<p>4.当多个线程同时调用一个方法时，可分以下几种情况：</p>
<ul>
<li>多线程读缓存：读缓存由汇编实现，无锁且高效，由于并没有改变<code>_buckets</code>和<code>_mask</code>，所以并无安全隐患。</li>
<li>多线程写缓存：<code>OC</code>用了个全局的互斥锁（<code>cacheUpdateLock.assertLocked()</code>）来保证不会出现写两次缓存的情况。</li>
<li>多线程读写缓存：<code>OC</code>使用了<code>ldp汇编指令</code>、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904070596001806">https://juejin.cn/post/6844904070596001806</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">05-方法的本质和消息查找流程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/16/%E5%8D%9A%E5%AE%A2/Hexo%20%E9%85%8D%E7%BD%AE/"><span class="level-item">Hexo 配置</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#一、-cache-t源码分析"><span class="level-left"><span class="level-item">一、 cache_t源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-cache-t结构"><span class="level-left"><span class="level-item">1.1 cache_t结构</span></span></a></li><li><a class="level is-mobile" href="#1-2-方法缓存的验证"><span class="level-left"><span class="level-item">1.2 方法缓存的验证</span></span></a></li><li><a class="level is-mobile" href="#1-3-cache-t小结"><span class="level-left"><span class="level-item">1.3 cache_t小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、cache-t的方法缓存原理"><span class="level-left"><span class="level-item">二、cache_t的方法缓存原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-cache-fill"><span class="level-left"><span class="level-item">2.1 cache_fill</span></span></a></li><li><a class="level is-mobile" href="#2-2-cache-fill-nolock"><span class="level-left"><span class="level-item">2.2 cache_fill_nolock</span></span></a></li><li><a class="level is-mobile" href="#2-3-reallocate"><span class="level-left"><span class="level-item">2.3 reallocate</span></span></a></li><li><a class="level is-mobile" href="#2-4-expand"><span class="level-left"><span class="level-item">2.4 expand</span></span></a></li><li><a class="level is-mobile" href="#2-5-find"><span class="level-left"><span class="level-item">2.5 find</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、多线程对方法缓存的影响"><span class="level-left"><span class="level-item">三、多线程对方法缓存的影响</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-多线程同时读取缓存"><span class="level-left"><span class="level-item">3.1 多线程同时读取缓存</span></span></a></li><li><a class="level is-mobile" href="#3-2-多线程同时写缓存"><span class="level-left"><span class="level-item">3.2 多线程同时写缓存</span></span></a></li><li><a class="level is-mobile" href="#3-3-多线程同时读写缓存"><span class="level-left"><span class="level-item">3.3 多线程同时读写缓存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-编译内存屏障"><span class="level-left"><span class="level-item">3.3.1 编译内存屏障</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-内存垃圾回收"><span class="level-left"><span class="level-item">3.3.2 内存垃圾回收</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、问题讨论"><span class="level-left"><span class="level-item">四、问题讨论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-类方法的缓存位置"><span class="level-left"><span class="level-item">4.1 类方法的缓存位置</span></span></a></li><li><a class="level is-mobile" href="#4-2-mask的作用"><span class="level-left"><span class="level-item">4.2 _mask的作用</span></span></a></li><li><a class="level is-mobile" href="#4-3-关于扩容临界点3-4的讨论"><span class="level-left"><span class="level-item">4.3 关于扩容临界点3/4的讨论</span></span></a></li><li><a class="level is-mobile" href="#4-4-缓存循环查找的死循环情况"><span class="level-left"><span class="level-item">4.4 缓存循环查找的死循环情况</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、总结"><span class="level-left"><span class="level-item">五、总结</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>