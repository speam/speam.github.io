<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>01-对象的创建 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="01-对象的创建"><meta property="og:url" content="http://evilimo.com/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/Xnip2020-09-09_19-55-47.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/16f6e7a7aa7829cc"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114633906.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114647948.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114703615.png"><meta property="article:published_time" content="2020-10-29T09:34:46.000Z"><meta property="article:modified_time" content="2020-12-29T00:57:42.363Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/Xnip2020-09-09_19-55-47.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/Xnip2020-09-09_19-55-47.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114633906.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114647948.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114703615.png"],"datePublished":"2020-10-29T09:34:46.000Z","dateModified":"2020-12-29T00:57:42.363Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2020-10-29T09:34:46.000Z" title="2020-10-29T09:34:46.000Z">2020-10-29</time>发表</span><span class="level-item"><time dateTime="2020-12-29T00:57:42.363Z" title="2020-12-29T00:57:42.363Z">2020-12-29</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">01-对象的创建</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>看一个简单的例子：</p>
<p><a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/Xnip2020-09-09_19-55-47.png"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/Xnip2020-09-09_19-55-47.png" alt="img"></a></p>
<p>思考<code>alloc</code>和<code>init</code>底层到底做了什么？带着这些问题，我们从源码的角度探索。</p>
<h2 id="二、分析-alloc-源码"><a href="#二、分析-alloc-源码" class="headerlink" title="二、分析 alloc 源码"></a>二、分析 alloc 源码</h2><h3 id="1-0-准备工作"><a href="#1-0-准备工作" class="headerlink" title="1.0 准备工作"></a>1.0 准备工作</h3><p>1.从 <a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs">苹果官方开源代码列表</a> 找到 <code>objc4</code>源码。</p>
<blockquote>
<p>苹果于 2006 年发布 Objective-C 2.0 ，重写了 Objective-C 1.0 中类与对象的定义，命名为 objc4</p>
</blockquote>
<p>2.下载到本地后，需要对工程进行一番编译调试，具体步骤可参考 <strong>Cooci 的博客</strong> <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903959161733133">iOS_objc4-756.2 最新源码编译调试</a>。</p>
<p>3.编译通过后，就可以新建个 target 调试了</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/16f6e7a7aa7829cc"></p>
<blockquote>
<p>我 Github 上的源码：<a target="_blank" rel="noopener" href="https://github.com/speam/OjbcSuorce.git">https://github.com/speam/OjbcSuorce.git</a></p>
</blockquote>
<p>4.常用的代码跟踪方式：</p>
<ul>
<li>Xcode 菜单栏依次点击<code>Debug</code>-&gt;<code>Debug Workflow</code>-&gt;<code>Always show Disassembly</code></li>
<li><code>control</code> + <code>step into</code></li>
<li>下符号断点，如<code>alloc</code></li>
</ul>
<h3 id="1-1-objc-alloc—alloc的真正入口"><a href="#1-1-objc-alloc—alloc的真正入口" class="headerlink" title="1.1 objc_alloc—alloc的真正入口"></a>1.1 <code>objc_alloc</code>—<code>alloc</code>的真正入口</h3><p>给<code>[Person alloc]</code>加断点</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1.png" alt="img"></p>
<p>此时，在Xcode的菜单栏依次点击<code>Debug</code>-&gt;<code>Debug Workflow</code>-&gt;<code>Always show Disassembly</code>，得到汇编代码，发现调用了<code>objc_alloc</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114633906.png" alt="img"></p>
<p>定位到<code>objc_alloc()</code>，发现内部调用<code>callAlloc()</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114647948.png" alt="img"></p>
<h3 id="1-2-callAlloc分析"><a href="#1-2-callAlloc分析" class="headerlink" title="1.2 callAlloc分析"></a>1.2 <code>callAlloc</code>分析</h3><p><code>objc_alloc()</code>内部调用<code>callAlloc()</code>，其源码为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast&#x27;s summary</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;	<span class="comment">// 永远不走这里</span></span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize());</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;	<span class="comment">// 永远走这里</span></span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>对<code>callAlloc()</code>的分析如下：</strong></p>
<p>①<code>__OBJC2__</code>在 OC2.0 以后为1，源码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define __OBJC2__ for the benefit of our asm files.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OBJC2__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">if</span> TARGET_OS_OSX  &amp;&amp;  !TARGET_OS_IOSMAC  &amp;&amp;  __i386__		</span></span><br><span class="line">        <span class="comment">// old ABI</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> __OBJC2__ 1	<span class="comment">// 总之都是1</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<p>②<code>slowpath(bool)</code>与<code>fastpath(bool)</code>：常用于<code>if-else</code>，可以优化判断的速度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fastpath(x)：表示返回值为x，且x很有可能为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) (__builtin_expect(bool(x), 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// slowpath(x)：表示返回值为x，且x很有可能为0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) (__builtin_expect(bool(x), 0))</span></span><br></pre></td></tr></table></figure>



<p>③<code>hasCustomAWZ()</code>：意思是<code>hasCustomAllocWithZone</code>，即是否有重写类的<code>+allocWithZone:</code>方法，但是它的值并不能简单地这么判断！先看源码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> hasCustomAWZ() &#123;</span><br><span class="line">    <span class="keyword">return</span> ! bits.hasDefaultAWZ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：<code>hasCustomAWZ()</code>的值问题</strong>【非常重要，设置初始化顺序，很多博客中根本没有提到！】</p>
<ul>
<li>类的<code>+initialize</code>方法主要用于初始化静态变量。在其执行之前，<code>hasDefaultAWZ()</code>值为<code>false</code>，即<code>hasCustomAWZ()</code>为<code>true</code>；其执行之后，如果当前类重写了<code>+allocWithZone:</code>方法，<code>hasCustomAWZ()</code>为<code>true</code>，否则为<code>false</code>（一般情况下不会重写，即<code>hasCustomAWZ</code>为<code>false</code>）。</li>
<li>类的<code>+initialize</code>方法会在第一次初始化该类之前调用。当调用<code>[cls alloc]</code>时，会触发<code>objc_msgSend</code>，然后会执行<code>+initialize:</code>。（感兴趣的同学可以分别打印<code>+alloc</code>和<code>+initialize:</code>方法加以验证）</li>
</ul>
</blockquote>
<p><strong>因此，当类第一次来到<code>callAlloc()</code>时，最终会执行<code>[cls alloc]</code>。</strong></p>
<p>④<code>canAllocFast()</code>源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">    assert(!isFuture());</span><br><span class="line">    <span class="keyword">return</span> bits.canAllocFast();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再往底层找<code>bits.canAllocFast()</code>，发现关键宏<code>FAST_ALLOC</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> FAST_ALLOC</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; FAST_ALLOC;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">bool</span> canAllocFast() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>继续深入，来到了<code>FAST_ALLOC</code>宏定义之处</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__   <span class="comment">// 当前操作系统不是64位</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1         <span class="comment">// 当前操作系统是64位</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>					</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_ALLOC     (1UL&lt;&lt;2)			<span class="comment">// 找到了</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>从上面宏代码可以得出这样的结论，即无论当前操作系统是不是64位，都没有定义<code>FAST_ALLOC</code>，也就是说，<code>canAllocFast()</code>永远是<code>false</code>!</p>
<p>因此，如果<code>hasCustomAWZ()</code>为<code>false</code>时，会直接去到<code>class_createInstance()</code>。</p>
<h3 id="1-3-alloc-gt-objc-rootAlloc-gt-callAlloc-gt-class-createInstance"><a href="#1-3-alloc-gt-objc-rootAlloc-gt-callAlloc-gt-class-createInstance" class="headerlink" title="1.3 alloc-&gt;_objc_rootAlloc-&gt;callAlloc-&gt;class_createInstance"></a>1.3 <code>alloc</code>-&gt;<code>_objc_rootAlloc</code>-&gt;<code>callAlloc</code>-&gt;<code>class_createInstance</code></h3><p>通过对<code>hasCustomAWZ()</code>的分析，我们知道类的第一次初始化最终是走到<code>callAlloc</code>的最后，即<code>return [cls alloc];</code></p>
<p>①由于执行了<code>[cls alloc]</code>，这次真的来到<code>alloc()</code>方法了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>②接着是<code>_objc_rootAlloc()</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls allocWithZone:nil].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);	<span class="comment">// 注意这里的三个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>③再次来到<code>callAlloc</code>，此时<code>hasCustomAWZ()</code>的值取决于当前类是否重写了<code>+allocWithZone:</code>方法。</p>
<p>由于<code>Person</code>类没有重写，<code>fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())</code>为true，而<code>canAllocFast()</code>永远为<code>false</code>。</p>
<p>因此，接下来会走到<code>class_createInstance()</code>，其源码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> </span><br><span class="line">class_createInstance(Class cls, size_t extraBytes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _class_createInstanceFromZone(cls, extraBytes, <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-class-createInstanceFromZone"><a href="#1-4-class-createInstanceFromZone" class="headerlink" title="1.4 _class_createInstanceFromZone"></a>1.4 <code>_class_createInstanceFromZone</code></h3><p>顾名思义，这是要创建对象</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __attribute__((always_inline)) </span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone, </span><br><span class="line">                              <span class="keyword">bool</span> cxxConstruct = <span class="literal">true</span>, </span><br><span class="line">                              size_t *outAllocatedSize = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次读取类的信息位以提高性能</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxCtor = cls-&gt;hasCxxCtor();    <span class="comment">// 是否有构造函数</span></span><br><span class="line">    <span class="keyword">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();    <span class="comment">// 是否有析构函数</span></span><br><span class="line">    <span class="keyword">bool</span> fast = cls-&gt;canAllocNonpointer();  <span class="comment">// OC 2.0以上基本上返回的都是true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算内存</span></span><br><span class="line">    size_t size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (!zone  &amp;&amp;  fast) &#123;</span><br><span class="line">        <span class="comment">// 分配1块大小为size的连续内存</span></span><br><span class="line">        obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">// 初始化对象的isa</span></span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">            obj = (<span class="keyword">id</span>)malloc_zone_calloc ((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be </span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cxxConstruct &amp;&amp; hasCxxCtor) &#123;</span><br><span class="line">        obj = _objc_constructOrFree(obj, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>对<code>_class_createInstanceFromZone()</code>的分析如下：</strong></p>
<p>①<code>cls-&gt;instanceSize(extraBytes)</code>计算内存，此时的<code>extraBytes</code>是<code>0</code>，其源码是</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line">size_t instanceSize(size_t extraBytes) &#123;</span><br><span class="line">    size_t size = alignedInstanceSize() + extraBytes;</span><br><span class="line">    <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line">uint32_t alignedInstanceSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> word_align(unalignedInstanceSize());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 字节对齐</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> uint32_t word_align(uint32_t x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> size_t word_align(size_t x) &#123;</span><br><span class="line">    <span class="keyword">return</span> (x + WORD_MASK) &amp; ~WORD_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 7UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_SHIFT 2UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_MASK 3UL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> WORD_BITS 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可见，<code>WORD_MASK</code>在<code>64</code>位系统下是<code>7</code>，否则是<code>3</code>，<code>word_align()</code>方法就是进行字节对齐的。</p>
<p><strong>字节对齐算法：(x + WORD_MASK) &amp; ~WORD_MASK</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">假如： x &#x3D; 9，已知 WORD_MASK &#x3D; 7</span><br><span class="line"></span><br><span class="line"> x + WORD_MASK &#x3D; 9 + 7 &#x3D; 16</span><br><span class="line"> </span><br><span class="line"> WORD_MASK 二进制 ：0000 0111 &#x3D; 7 （4+2+1）</span><br><span class="line"> ~WORD_MASK 二进制 : 1111 1000</span><br><span class="line"> </span><br><span class="line"> 16的二进制为  : 0001 0000</span><br><span class="line"> </span><br><span class="line"> 0001 0000</span><br><span class="line"> &amp;</span><br><span class="line"> 1111 1000</span><br><span class="line">---------------</span><br><span class="line"> 0001 0000 &#x3D; 16</span><br><span class="line"></span><br><span class="line">所以字节对齐后返回16    也就是8的倍数对齐，即8字节对齐</span><br></pre></td></tr></table></figure>

<p>因此，<code>word_align()</code>在<code>64</code>位系统下是<code>8字节对齐</code>，否则是<code>4字节对齐</code>。</p>
<p>同时，<code>instanceSize()</code>函数又对内存大小又进行了最小<code>16字节</code>的限制。</p>
<p>②<code>canAllocNonpointer()</code>是对isa的类型的区分，如果一个类使用<code>isa_t</code>类型的<code>isa</code>的话就返回true，我们不用太关心，OC 2.0以上基本上返回的都是true，所以<code>fast</code>就是<code>true</code>；而在<code>__OBJC2__</code>中，<code>zone</code>会被忽略，所以<code>!zone</code>也是<code>true</code>；</p>
<p>综上，接着就是<code>calloc()</code>和<code>initInstanceIsa()</code>。</p>
<p>③<code>size_t size = cls-&gt;instanceSize(extraBytes);</code>这一步得到了计算后的<code>size</code>，传到<code>calloc(1, size)</code>中进行分配内存。</p>
<p>④<code>calloc()</code>的底层源码是在苹果开源的<strong>libmalloc</strong>源码中(<a target="_blank" rel="noopener" href="https://github.com/speam/mallcoSource.git">我Github中</a>也准备了)，经过断点跟踪(中间过程比较复杂，略过先)，发现<code>calloc()</code>分配的内存大小受<code>segregated_size_to_fit()</code>影响，看下面源码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> MALLOC_INLINE size_t</span><br><span class="line">segregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey)	<span class="comment">// 这里的size就是calloc(1, size)中传过来的</span></span><br><span class="line">&#123;</span><br><span class="line">	size_t k, slot_bytes;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> == size) &#123;</span><br><span class="line">	    <span class="comment">// Historical behavior</span></span><br><span class="line">	    size = NANO_REGIME_QUANTA_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// round up and shift for number of quanta</span></span><br><span class="line">	k = (size + NANO_REGIME_QUANTA_SIZE - <span class="number">1</span>) &gt;&gt; SHIFT_NANO_QUANTUM; </span><br><span class="line">	<span class="comment">// multiply by power of two quanta size</span></span><br><span class="line">	slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM;							</span><br><span class="line">	<span class="comment">// Zero-based!</span></span><br><span class="line">	*pKey = k - <span class="number">1</span>;													</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slot_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT_NANO_QUANTUM	        4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NANO_REGIME_QUANTA_SIZE	    (1 &lt;&lt; SHIFT_NANO_QUANTUM)	<span class="comment">// 16</span></span></span><br></pre></td></tr></table></figure>

<p>从代码可以看出，<code>slot_bytes</code>等于<code>(size + 16-1) &gt;&gt; 4 &lt;&lt; 4</code>，是<code>16字节对齐</code>，所以就是将计算得到的<code>size</code>进行一次16字节对齐，因此<code>calloc()</code>分配的内存大小必然是<code>16字节</code>的整数倍，因此为对象分配的内存空间一定是16字节对齐的。</p>
<p>⑤<code>initInstanceIsa()</code>就是初始化<code>isa</code>，并且关联<code>cls</code>。</p>
<p>从上面的代码可以看出，<code>_class_createInstanceFromZone()</code>做了很多事情，并且最终确实创建了对象，几乎干了所有事情，那么，<code>init</code>又到底做了什么呢？</p>
<h2 id="三、init和new"><a href="#三、init和new" class="headerlink" title="三、init和new"></a>三、init和new</h2><h3 id="1-init"><a href="#1-init" class="headerlink" title="1. init"></a>1. <code>init</code></h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootInit(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootInit(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// In practice, it will be hard to rely on this function.</span></span><br><span class="line">    <span class="comment">// Many classes do not properly chain -init calls.</span></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非常简单，<code>init</code>仅仅是将<code>alloc</code>创建的对象返回。是一种工厂设计方案，方便子类重写。</p>
<h3 id="2-new"><a href="#2-new" class="headerlink" title="2. new"></a>2. <code>new</code></h3><p>我们再看看<code>new</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)new &#123;</span><br><span class="line">    <span class="keyword">return</span> [callAlloc(<span class="keyword">self</span>, <span class="literal">false</span><span class="comment">/*checkNil*/</span>) init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，<code>new</code>相当于<code>alloc</code>+<code>init</code>。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>关于<code>alloc</code>、<code>init</code>以及<code>new</code>的源码分析就到这了。在<code>alloc</code>的过程中，<code>callAlloc</code>和<code>_class_createInstanceFromZone</code>这两个函数是重点。</p>
<blockquote>
<p>以上源码流程分析，是建立在<code>objc4-756.2</code>源码的基础上的，<code>756.2</code>是目前最新的版本。</p>
</blockquote>
<p>下面用流程图总结一下<code>alloc</code>创建对象的过程：（这是我看过的博客中，最准确的图）</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20201203114703615.png" alt="img"></p>
<h2 id="五、源码"><a href="#五、源码" class="headerlink" title="五、源码"></a>五、源码</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/mallcoSource.git">我的 malloc 源码</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/speam/OjbcSuorce.git">我的 libobjc 源码</a></p>
<p><a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/objc4/">苹果官方 objc4 源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>红酒牛排 <a target="_blank" rel="noopener" href="https://juejin.im/post/6844904038467633160#heading-15">https://juejin.im/post/6844904038467633160#heading-15</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2020/11/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-isa%E5%8E%9F%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">02-isa原理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URL%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B/"><span class="level-item">URL编码和解码</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、前言"><span class="level-left"><span class="level-item">一、前言</span></span></a></li><li><a class="level is-mobile" href="#二、分析-alloc-源码"><span class="level-left"><span class="level-item">二、分析 alloc 源码</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-0-准备工作"><span class="level-left"><span class="level-item">1.0 准备工作</span></span></a></li><li><a class="level is-mobile" href="#1-1-objc-alloc—alloc的真正入口"><span class="level-left"><span class="level-item">1.1 objc_alloc—alloc的真正入口</span></span></a></li><li><a class="level is-mobile" href="#1-2-callAlloc分析"><span class="level-left"><span class="level-item">1.2 callAlloc分析</span></span></a></li><li><a class="level is-mobile" href="#1-3-alloc-gt-objc-rootAlloc-gt-callAlloc-gt-class-createInstance"><span class="level-left"><span class="level-item">1.3 alloc-&gt;_objc_rootAlloc-&gt;callAlloc-&gt;class_createInstance</span></span></a></li><li><a class="level is-mobile" href="#1-4-class-createInstanceFromZone"><span class="level-left"><span class="level-item">1.4 _class_createInstanceFromZone</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、init和new"><span class="level-left"><span class="level-item">三、init和new</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-init"><span class="level-left"><span class="level-item">1. init</span></span></a></li><li><a class="level is-mobile" href="#2-new"><span class="level-left"><span class="level-item">2. new</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、总结"><span class="level-left"><span class="level-item">四、总结</span></span></a></li><li><a class="level is-mobile" href="#五、源码"><span class="level-left"><span class="level-item">五、源码</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>