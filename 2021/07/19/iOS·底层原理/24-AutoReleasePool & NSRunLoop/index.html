<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>24-AutoReleasePool &amp; NSRunLoop - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="24-AutoReleasePool &amp; NSRunLoop"><meta property="og:url" content="http://evilimo.com/2021/07/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/24-AutoReleasePool%20&amp;%20NSRunLoop/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/bffbf488f0664a6eb888f9ecc2e46d32%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/5a274d73cebf42e1808d778f4ea06250%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/feecced976b04b45bc95eced8f11eccf%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/59b00e1ba367465b930cc79b901c02c8%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/6b63be3989c245f396a3e44b50a2eb9b%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/4e73b8d7015546c3b700f1bc265e4438%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/e65e2e2809a74ae48cbf52e3396a8ffd%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/33beebb613234383ba208f3093abc87d%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/551b44ed1d024fbb9ae331144b216778%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/bbf6e09e02664a029486f316abdeedc0%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/83acfdef9b934b3e91231cdeb878f42b%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/f6f9f4fb76c748b0a144b9c960d3b700%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/c1c442cd21cb4b909a99ddc57ef49d4c%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/386376033b964146b9ae3163f11324d0%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/8ed6fdcddc384cc9b4c2ee1cee565072%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/32510b5efaef44a7b23753a0d70ebb35%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/6dc0c9a4f9cc4534b16ab6b8d73dae7e%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="article:published_time" content="2021-07-19T07:37:14.151Z"><meta property="article:modified_time" content="2021-07-19T07:37:14.151Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/bffbf488f0664a6eb888f9ecc2e46d32%7Etplv-k3u1fbpfcp-zoom-1.image"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/07/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/24-AutoReleasePool%20&%20NSRunLoop/"},"headline":"IMO's Blog","image":[],"datePublished":"2021-07-19T07:37:14.151Z","dateModified":"2021-07-19T07:37:14.151Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/07/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/24-AutoReleasePool%20&amp;%20NSRunLoop/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-19T07:37:14.151Z" title="2021-07-19T07:37:14.151Z">2021-07-19</time>发表</span><span class="level-item"><time dateTime="2021-07-19T07:37:14.151Z" title="2021-07-19T07:37:14.151Z">2021-07-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">24-AutoReleasePool &amp; NSRunLoop</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、AutoReleasePool"><a href="#一、AutoReleasePool" class="headerlink" title="一、AutoReleasePool"></a>一、AutoReleasePool</h2><p><code>自动释放池</code>是OC中的一种<code>内存自动回收机制</code>，它可以将加入AutoreleasePool中的<code>变量release的时机延迟</code>，简单来说，就是当创建一个<code>对象</code>，在正常情况下，变量会在超出其作用域的时立即release。如果将对象加入到了自动释放池中，这个对象并<code>不会立即释放</code>，会<code>等到runloop休眠/超出autoreleasepool作用域&#123;&#125;</code>之后才会<code>被释放</code>。其机制如下图所示 <img src="https://raw.githubusercontent.com/speam/blogImgs/main/bffbf488f0664a6eb888f9ecc2e46d32%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>1、从程序启动到加载完成，主线程对应的runloop会处于休眠状态，等待用户交互来唤醒runloop</li>
<li>2、用户的每一次交互都会启动一次runloop，用于处理用户的所有点击、触摸事件等</li>
<li>3、runloop在监听到交互事件后，就会<code>创建</code>自动释放池，并将所有延迟释放的对象添加到自动释放池中</li>
<li>4、在一次完整的runloop结束之前，会向自动释放池中所有对象<code>发送release消息</code>，然后<code>销毁</code>自动释放池</li>
</ul>
<p><strong>Clang分析</strong></p>
<p>通过<code>clang</code>命令对空白的<code>main.m</code>输出一份<code>main.cpp</code>文件来查看<code>@autoreleasepool</code>的底层结构</p>
<ul>
<li>定义如下代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过clang编译成底层实现，命令为：<code>xcrun -sdk iphonesimulator clang -arch x86_64 -rewrite-objc main.m</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    __AtAutoreleasePool() &#123;</span><br><span class="line">            atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~__AtAutoreleasePool() &#123;</span><br><span class="line">            objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">   &#123; </span><br><span class="line">        <span class="comment">//是一个结构体</span></span><br><span class="line">         __AtAutoreleasePool __autoreleasepool; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单来说，自动释放池其本质也是一个<code>对象</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">&#123;__AtAutoreleasePool __autoreleasepool; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__AtAutoreleasePool</code>是一个结构体，有<code>构造函数 + 析构函数</code>，结构体定义的对象在作用域结束后，会自动调用析构函数</li>
<li>其中<code>&#123;&#125;</code> 是 作用域 ，优点是<code>结构清晰，可读性强</code>，可以<code>及时创建销毁</code></li>
</ul>
<p>关于涉及的构造和析构函数的调用时机，可以通过下面一个案例来验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CJLTest</span>&#123;</span></span><br><span class="line">    CJLTest</span><br><span class="line">()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1123 - %s\n&quot;</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">    ~CJLTest()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5667 - %s\n&quot;</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        CJLTest test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********运行结果**********</span></span><br><span class="line"><span class="number">1123</span> - CJLTest</span><br><span class="line"><span class="number">5667</span> - ~CJLTest</span><br></pre></td></tr></table></figure>

<p>从而可以得出，在<code>CJLTest</code>创建对象时，会自动调用<code>构造函数</code>，在出了{}作用域后，会自动调用<code>析构函数</code></p>
<p><strong>汇编分析</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSObject *obj = [NSObject alloc];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main代码部分加断点，运行程序，并开启汇编调试</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/5a274d73cebf42e1808d778f4ea06250%7Etplv-k3u1fbpfcp-zoom-1.image"> </p>
<p>发现：</p>
<ul>
<li><code>autoreleasepool</code>在加入要释放的对象时，底层调用的是<code>objc_autoreleasePoolPush</code>方法</li>
<li><code>autoreleasepool</code>在调用析构函数释放时，底层调用<code>objc_autoreleasePoolPop</code>方法</li>
</ul>
<h3 id="1-1-源码分析"><a href="#1-1-源码分析" class="headerlink" title="1.1 源码分析"></a>1.1 源码分析</h3><p><a target="_blank" rel="noopener" href="https://github.com/speam/autoreleaseSourceCode.git">我的autorelease源码</a></p>
<p>在<code>objc</code>源码中，对<code>AutoreleasePool</code>的解释如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Autorelease pool implementation</span><br><span class="line"></span><br><span class="line">- A thread&#39;s autorelease pool is a stack of pointers. </span><br><span class="line">线程的自动释放池是指针的堆栈</span><br><span class="line"></span><br><span class="line">- Each pointer is either an object to release, or POOL_BOUNDARY which is an autorelease pool boundary.</span><br><span class="line">每个指针都是要释放的对象，或者是POOL_BOUNDARY，它是自动释放池的边界。</span><br><span class="line"></span><br><span class="line">- A pool token is a pointer to the POOL_BOUNDARY for that pool. When the pool is popped, every object hotter than the sentinel is released.</span><br><span class="line">池令牌是指向该池的POOL_BOUNDARY的指针。弹出池后，将释放比哨点更热的每个对象。</span><br><span class="line"></span><br><span class="line">- The stack is divided into a doubly-linked list of pages. Pages are added and deleted as necessary. </span><br><span class="line">堆栈分为两个双向链接的页面列表。根据需要添加和删除页面。</span><br><span class="line"></span><br><span class="line">- Thread-local storage points to the hot page, where newly autoreleased objects are stored. </span><br><span class="line">线程本地存储指向热页面，该页面存储新自动释放的对象。</span><br></pre></td></tr></table></figure>

<p>通过描述，有以下几点说明</p>
<ul>
<li>1、自动释放池 是一个 关于<code>指针</code>的<code>栈</code>结构</li>
<li>2、其中的指针是指要<code>释放的对象</code>或者 <code>pool_boundary</code> 哨兵（现在经常被称为 <code>边界</code>）</li>
<li>3、自动释放池是一个<code>页</code>的结构（虚拟内存中提及过） ，而且这个<code>页是一个双向链表</code>（表示有父节点 和 子节点，在类中提及过，即类的继承链）</li>
<li>4、自动释放池和<code>线程</code>有关系</li>
</ul>
<p>对于<code>自动释放池</code>，我们主要关心的点有以下三点：</p>
<ul>
<li>1、自动释放池什么时候<code>创建</code>？</li>
<li>2、对象是<code>如何加入自动释放池</code>的？</li>
<li>3、<code>哪些对象才会加入</code>自动释放池？</li>
</ul>
<p>下面带着这些问题，我们来一步步探索自动释放池的底层原理</p>
<h4 id="1-1-1-AutoreleasePoolPage"><a href="#1-1-1-AutoreleasePoolPage" class="headerlink" title="1.1.1 AutoreleasePoolPage"></a>1.1.1 AutoreleasePoolPage</h4><p>从最初的<code>clang</code>或者<code>汇编</code>分析我们了解了自动释放池其底层是调用的<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>两个方法，其源码实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//***********push方法***********</span></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line">objc_autoreleasePoolPush(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***********pop方法***********</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码中我们可以发现，都是调用的<code>AutoreleasePoolPage</code>的<code>push</code>和<code>pop</code>实现，以下是其定义，从定义中可以看出，自动释放池是一个页，同时也是一个<code>对象</code>，这个页的大小是<code>4096</code>字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************宏定义************</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_MIN_SIZE           PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE               I386_PGBYTES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES            4096            <span class="comment">/* bytes per 80386 page */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//************类定义************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> :</span> <span class="keyword">private</span> AutoreleasePoolPageData</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">thread_data_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//页的大小</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE =</span><br><span class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br><span class="line">		PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		PAGE_MIN_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">		AutoreleasePoolPageData(begin(),<span class="comment">//开始存储的位置</span></span><br><span class="line">								objc_thread_self(),<span class="comment">//传的是当前线程，当前线程时通过tls获取的</span></span><br><span class="line">								newParent,</span><br><span class="line">								newParent ? <span class="number">1</span>+newParent-&gt;depth : <span class="number">0</span>,<span class="comment">//如果是第一页深度为0，往后是前一个的深度+1</span></span><br><span class="line">								newParent ? newParent-&gt;hiwat : <span class="number">0</span>)</span><br><span class="line">    &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~AutoreleasePoolPage() &#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//页的开始位置</span></span><br><span class="line">    <span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//页的结束位置</span></span><br><span class="line">    <span class="function">id * <span class="title">end</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//页是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//页是否满了</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//页的存储是否少于一半</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lessThanHalfFull</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//添加释放对象</span></span><br><span class="line">    <span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放所有对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseAll</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放到stop位置之前的所有对象</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//杀掉</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放本地线程存储空间</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tls_dealloc</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取AutoreleasePoolPage</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> AutoreleasePoolPage *<span class="title">pageForPointer</span><span class="params">(<span class="keyword">uintptr_t</span> p)</span>  </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否有空池占位符</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">haveEmptyPoolPlaceholder</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置空池占位符</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id* <span class="title">setEmptyPoolPlaceholder</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前操作页</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置当前操作页</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setHotPage</span><span class="params">(AutoreleasePoolPage *page)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取coldPage</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">coldPage</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span>&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//添加自动释放对象，当页满的时候调用这个方法</span></span><br><span class="line">    <span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line">    <span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加自动释放对象，当没页的时候使用这个方法</span></span><br><span class="line">    <span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line">    <span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span>&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//创建新页</span></span><br><span class="line">    <span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line">    <span class="function">id *<span class="title">autoreleaseNewPage</span><span class="params">(id obj)</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//自动释放</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span>&#123;...&#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//兼容老的 SDK 出栈方法</span></span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">badPop</span><span class="params">(<span class="keyword">void</span> *token)</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出栈页面</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">bool</span> allowDebug&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    popPage(<span class="keyword">void</span> *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    popPageDebug(<span class="keyword">void</span> *token, AutoreleasePoolPage *page, id *stop)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">    pop(<span class="keyword">void</span> *token)&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印</span></span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印所有</span></span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printAll</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印Hiwat</span></span><br><span class="line">    __attribute__((noinline, cold))</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHiwat</span><span class="params">()</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>从其定义中发现，<code>AutoreleasePoolPage</code>是继承自<code>AutoreleasePoolPageData</code>,且该类的属性也是来自父类，以下是<code>AutoreleasePoolPageData</code>的定义，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoreleasePoolPageData</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//用来校验AutoreleasePoolPage的结构是否完整</span></span><br><span class="line">	<span class="keyword">magic_t</span> <span class="keyword">const</span> magic;<span class="comment">//16个字节</span></span><br><span class="line">    <span class="comment">//指向最新添加的autoreleased对象的下一个位置，初始化时指向begin()</span></span><br><span class="line">	__unsafe_unretained id *next;<span class="comment">//8字节</span></span><br><span class="line">    <span class="comment">//指向当前线程</span></span><br><span class="line">	<span class="keyword">pthread_t</span> <span class="keyword">const</span> thread;<span class="comment">//8字节</span></span><br><span class="line">    <span class="comment">//指向父节点，第一个结点的parent值为nil</span></span><br><span class="line">	AutoreleasePoolPage * <span class="keyword">const</span> parent;<span class="comment">//8字节</span></span><br><span class="line">    <span class="comment">//指向子节点，最后一个结点的child值为nil</span></span><br><span class="line">	AutoreleasePoolPage *child;<span class="comment">//8字节</span></span><br><span class="line">    <span class="comment">//表示深度，从0开始，往后递增1</span></span><br><span class="line">	<span class="keyword">uint32_t</span> <span class="keyword">const</span> depth;<span class="comment">//4字节</span></span><br><span class="line">    <span class="comment">//表示high water mark 最大入栈数量标记</span></span><br><span class="line">	<span class="keyword">uint32_t</span> hiwat;<span class="comment">//4字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">	AutoreleasePoolPageData(__unsafe_unretained id* _next, <span class="keyword">pthread_t</span> _thread, AutoreleasePoolPage* _parent, <span class="keyword">uint32_t</span> _depth, <span class="keyword">uint32_t</span> _hiwat)</span><br><span class="line">		: magic(), next(_next), thread(_thread),</span><br><span class="line">		  parent(_parent), child(nil),</span><br><span class="line">		  depth(_depth), hiwat(_hiwat)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>发现其中有<code>AutoreleasePoolPage</code>对象，所以有以下一个关系链<code>AutoreleasePoolPage -&gt; AutoreleasePoolPageData -&gt;  AutoreleasePoolPage</code>，从这里可以说明自动释放池除了是一个页，还是一个<code>双向链表</code>结构</p>
<p>其中<code>AutoreleasePoolPageData</code>结构体的内存大小为<code>56</code>字节：</p>
<ul>
<li>属性<code>magic</code> 的类型是<code>magic_t</code>结构体，所占内存大小为<code>m[4];</code>所占内存（即4*4=<code>16</code>字节）</li>
<li>属性<code>next（指针）、thread（对象）、parent（对象）、child（对象）</code>均占<code>8</code>字节（即4*8=32字节）</li>
<li>属性<code>depth、hiwat</code>类型为<code>uint32_t</code>，实际类型是<code>unsigned int</code>类型，均占<code>4</code>字节（即2*4=8字节）</li>
</ul>
<h4 id="1-1-2-objc-autoreleasePoolPush"><a href="#1-1-2-objc-autoreleasePoolPush" class="headerlink" title="1.1.2 objc_autoreleasePoolPush"></a>1.1.2 objc_autoreleasePoolPush</h4><p>进入<code>push</code>源码实现，有以下逻辑</p>
<ul>
<li>判断是否为有 pool</li>
<li>如果没有，则通过<code>autoreleaseNewPage</code>方法创建</li>
<li>如果有，则通过<code>autoreleaseFast</code>压栈<code>哨兵对象</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id *dest;</span><br><span class="line">    <span class="comment">//判断是否有pool</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(DebugPoolAllocation)) &#123;</span><br><span class="line">        <span class="comment">// Each autorelease pool starts on a new pool page.自动释放池从新池页面开始</span></span><br><span class="line">        <span class="comment">//如果没有，则创建</span></span><br><span class="line">        dest = autoreleaseNewPage(POOL_BOUNDARY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//压栈一个POOL_BOUNDARY，即压栈哨兵</span></span><br><span class="line">        dest = autoreleaseFast(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="autoreleaseNewPage"><a href="#autoreleaseNewPage" class="headerlink" title="autoreleaseNewPage"></a>autoreleaseNewPage</h5><p>进入objc_autoreleasePoolPush -&gt; push -&gt; autoreleaseNewPage源码实现，主要是通过<code>hotPage</code>获取当前页，判断当前页是否存在</p>
<ul>
<li>如果存在，则通过<code>autoreleaseFullPage</code>方法<code>压栈对象</code></li>
<li>如果不存在，则通过<code>autoreleaseNoPage</code>方法<code>创建页</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建新页</span></span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNewPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前操作页</span></span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="comment">//如果存在，则压栈对象</span></span><br><span class="line">    <span class="keyword">if</span> (page) <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    <span class="comment">//如果不存在，则创建页</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******** hotPage方法 ********</span></span><br><span class="line"><span class="comment">//获取当前操作页</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> AutoreleasePoolPage *<span class="title">hotPage</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前页</span></span><br><span class="line">    AutoreleasePoolPage *result = (AutoreleasePoolPage *)</span><br><span class="line">        tls_get_direct(key);</span><br><span class="line">    <span class="comment">//如果是一个空池，则返回nil，否则，返回当前线程的自动释放池</span></span><br><span class="line">    <span class="keyword">if</span> ((id *)result == EMPTY_POOL_PLACEHOLDER) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">if</span> (result) result-&gt;fastcheck();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//******** autoreleaseNoPage方法 ********</span></span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseNoPage</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// &quot;No page&quot; could mean no pool has been pushed</span></span><br><span class="line">    <span class="comment">// or an empty placeholder pool has been pushed and has no contents yet</span></span><br><span class="line">    ASSERT(!hotPage());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> pushExtraBoundary = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断是否是空占位符，如果是，则压栈哨兵标识符置为YES</span></span><br><span class="line">    <span class="keyword">if</span> (haveEmptyPoolPlaceholder()) &#123;</span><br><span class="line">        <span class="comment">// We are pushing a second pool over the empty placeholder pool</span></span><br><span class="line">        <span class="comment">// or pushing the first object into the empty placeholder pool.</span></span><br><span class="line">        <span class="comment">// Before doing that, push a pool boundary on behalf of the pool </span></span><br><span class="line">        <span class="comment">// that is currently represented by the empty placeholder.</span></span><br><span class="line">        pushExtraBoundary = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果对象不是哨兵对象，且没有Pool，则报错</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj != POOL_BOUNDARY  &amp;&amp;  DebugMissingPools) &#123;</span><br><span class="line">        <span class="comment">// We are pushing an object with no pool in place, </span></span><br><span class="line">        <span class="comment">// and no-pool debugging was requested by environment.</span></span><br><span class="line">        _objc_inform(<span class="string">&quot;MISSING POOLS: (%p) Object %p of class %s &quot;</span></span><br><span class="line">                     <span class="string">&quot;autoreleased with no pool in place - &quot;</span></span><br><span class="line">                     <span class="string">&quot;just leaking - break on &quot;</span></span><br><span class="line">                     <span class="string">&quot;objc_autoreleaseNoPool() to debug&quot;</span>, </span><br><span class="line">                     objc_thread_self(), (<span class="keyword">void</span>*)obj, object_getClassName(obj));</span><br><span class="line">        objc_autoreleaseNoPool(obj);</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果对象是哨兵对象，且没有申请自动释放池内存，则设置一个空占位符存储在tls中，其目的是为了节省内存</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (obj == POOL_BOUNDARY  &amp;&amp;  !DebugPoolAllocation) &#123;<span class="comment">//如果传入参数为哨兵</span></span><br><span class="line">        <span class="comment">// We are pushing a pool with no pool in place,</span></span><br><span class="line">        <span class="comment">// and alloc-per-pool debugging was not requested.</span></span><br><span class="line">        <span class="comment">// Install and return the empty pool placeholder.</span></span><br><span class="line">        <span class="keyword">return</span> setEmptyPoolPlaceholder();<span class="comment">//设置空的占位符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are pushing an object or a non-placeholder&#x27;d pool.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install the first page.</span></span><br><span class="line">    <span class="comment">//初始化第一页</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">new</span> AutoreleasePoolPage(nil);</span><br><span class="line">    <span class="comment">//设置page为当前聚焦页</span></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push a boundary on behalf of the previously-placeholder&#x27;d pool.</span></span><br><span class="line">    <span class="comment">//压栈哨兵的标识符为YES，则压栈哨兵对象</span></span><br><span class="line">    <span class="keyword">if</span> (pushExtraBoundary) &#123;</span><br><span class="line">        <span class="comment">//压栈哨兵</span></span><br><span class="line">        page-&gt;add(POOL_BOUNDARY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Push the requested object or pool.</span></span><br><span class="line">    <span class="comment">//压栈对象</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>autoreleaseNoPage</code>方法中发现<code>当前线程的自动释放池</code>是通过<code>AutoreleasePoolPage</code>创建的，其定义中有<code>构造方法</code>，而构造方法的实现是通过父类<code>AutoreleasePoolPageData</code>的初始化方法（从上面的定义中可以得知）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//**********AutoreleasePoolPage构造方法**********</span></span><br><span class="line">	AutoreleasePoolPage(AutoreleasePoolPage *newParent) :</span><br><span class="line">		AutoreleasePoolPageData(begin(),<span class="comment">//开始存储的位置</span></span><br><span class="line">								objc_thread_self(),<span class="comment">//传的是当前线程，当前线程时通过tls获取的</span></span><br><span class="line">								newParent,</span><br><span class="line">								newParent ? <span class="number">1</span>+newParent-&gt;depth : <span class="number">0</span>,<span class="comment">//如果是第一页深度为0，往后是前一个的深度+1</span></span><br><span class="line">								newParent ? newParent-&gt;hiwat : <span class="number">0</span>)</span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">        parent-&gt;check();</span><br><span class="line">        ASSERT(!parent-&gt;child);</span><br><span class="line">        parent-&gt;unprotect();</span><br><span class="line">        <span class="comment">//this 表示 新建页面，将当前页面的子节点 赋值为新建页面</span></span><br><span class="line">        parent-&gt;child = <span class="keyword">this</span>;</span><br><span class="line">        parent-&gt;protect();</span><br><span class="line">    &#125;</span><br><span class="line">    protect();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**********AutoreleasePoolPageData初始化方法**********</span></span><br><span class="line">AutoreleasePoolPageData(__unsafe_unretained id* _next, <span class="keyword">pthread_t</span> _thread, AutoreleasePoolPage* _parent, <span class="keyword">uint32_t</span> _depth, <span class="keyword">uint32_t</span> _hiwat)</span><br><span class="line">		: magic(), next(_next), thread(_thread),</span><br><span class="line">		  parent(_parent), child(nil),</span><br><span class="line">		  depth(_depth), hiwat(_hiwat)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>AutoreleasePoolPageData</code>方法传入的参数含义为：</p>
<ul>
<li><code>begin()</code>表示<code>压栈</code>的位置（即下一个要释放对象的压栈地址）。可以通过源码调试<code>begin</code>，发现其具体实现等于<code>页首地址+56</code>，其中的<code>56</code>就是结构体<code>AutoreleasePoolPageData</code>的内存大小</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/feecced976b04b45bc95eced8f11eccf%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//********begin()********</span></span><br><span class="line"><span class="comment">//页的开始位置</span></span><br><span class="line"><span class="function">id * <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等于 首地址+56（AutoreleasePoolPage类所占内存大小）</span></span><br><span class="line">    <span class="keyword">return</span> (id *) ((<span class="keyword">uint8_t</span> *)<span class="keyword">this</span>+<span class="keyword">sizeof</span>(*<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>objc_thread_self()</code> 表示的是<code>当前线程</code>，而当前线程时通过<code>tls</code>获取的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="keyword">const</span>))</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">pthread_t</span> <span class="title">objc_thread_self</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过tls获取当前线程</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">pthread_t</span>)tls_get_direct(_PTHREAD_TSD_SLOT_PTHREAD_SELF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>newParent</code>表示<code>父节点</code></li>
<li>后续两个参数是<code>通过父节点的深度、最大入栈个数</code>计算<code>depth</code>以及<code>hiwat</code></li>
</ul>
<p><strong>查看自动释放池内存结构</strong></p>
<p>由于在ARC模式下，是无法手动调用<code>autorelease</code>，所以将Demo切换至MRC模式（<code>Build Settings -&gt; Objectice-C Automatic Reference Counting</code>设置为<code>NO</code>）</p>
<p> <img src="https://raw.githubusercontent.com/speam/blogImgs/main/59b00e1ba367465b930cc79b901c02c8%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>定义如下代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************打印自动释放池结构************</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _objc_autoreleasePoolPrint(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//************运行代码************</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="comment">//循环创建对象，并加入自动释放池</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">             NSObject *objc = [[NSObject alloc] sutorelease];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用</span></span><br><span class="line">        _objc_autoreleasePoolPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，发现是6个，但是我们压栈的对象其实只有5个，其中的<code>POOL</code>表示<code>哨兵</code>，即<code>边界</code>，其目的是<code>为了防止越界</code> </p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/6b63be3989c245f396a3e44b50a2eb9b%7Etplv-k3u1fbpfcp-zoom-1.image"> 查看自动释放池的内存结构，发现，页的首地址与<code>哨兵对象</code>相差<code>0x38</code>，转换成十进制刚好是<code>56</code>，也就是 <code>AutoreleasePoolPage</code>自己本身的内存大小</p>
<p>将上述的测试代码的数据改为<code>505</code>，其内存结构如下，发现第一页满了，存储了<code>504</code>个要释放的对象，第二页只存储了一个</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/4e73b8d7015546c3b700f1bc265e4438%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>再将数据改为<code>505+506</code>，来验证第二页是否也是存储504个对象</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/e65e2e2809a74ae48cbf52e3396a8ffd%7Etplv-k3u1fbpfcp-zoom-1.image"> 通过运行发现，第一页存储<code>504</code>，第二页存储<code>505</code>，第三页存储<code>2</code>个</p>
<p><strong>结论</strong></p>
<p>所以通过上述测试，可以得出以下结论：</p>
<ul>
<li>第一页可以存放<code>504</code>个对象，且<code>只有第一页有哨兵</code>，当一页压栈满了，就会开辟新的一页</li>
<li>第二页开始，最多可以存放<code>505</code>个对象</li>
<li>一页的大小等于 505 * 8 = 4040</li>
</ul>
<p>这个结论同样可以通过<code>AutoreleasePoolPage</code>中的<code>SIZE</code>来得到印证，从其定义中我们可以得出，一页的大小是<code>4096</code>字节，而在其构造函数中<code>对象的压栈位置</code>，是从<code>首地址+56</code>开始的，所以可以一页中实际可以存储<code> 4096-56 = 4040字节</code>，转换成对象是<code> 4040 / 8 = 505</code>个,即一页最多可以<code>存储505个对象</code>，其中<code>第一页有哨兵对象</code>只能存储<code>504</code>个。</p>
<h5 id="autoreleaseFast"><a href="#autoreleaseFast" class="headerlink" title="autoreleaseFast"></a>autoreleaseFast</h5><p>进入autoreleaseFast源码，主要有以下几步：</p>
<ul>
<li>获取当前操作页，并判断页是否存在以及是否满了</li>
<li>如果页<code>存在，且未满</code>，则通过<code>add</code>方法压栈对象</li>
<li>如果页<code>存在，且满了</code>，则通过<code>autoreleaseFullPage</code>方法安排新的页面</li>
<li>如果<code>页不存在</code>，则通过<code>autoreleaseNoPage</code>方法创建新页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前操作页</span></span><br><span class="line">    AutoreleasePoolPage *page = hotPage();</span><br><span class="line">    <span class="comment">//判断页是否满了</span></span><br><span class="line">    <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">        <span class="comment">//如果未满，则压栈</span></span><br><span class="line">        <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        <span class="comment">//如果满了，则安排新的页面</span></span><br><span class="line">        <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//页不存在，则新建页</span></span><br><span class="line">        <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>autoreleaseFullPage</strong> </p>
<p>这个方法主要是用于判断当前页是否已经存储满了，如果当前页已经满了，通过<code>do-while循环</code>查找<code>子节点对应的页</code>，如果不存在，则<code>新建页</code>，并<code>压栈对象</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加自动释放对象，当页满的时候调用这个方法</span></span><br><span class="line"><span class="keyword">static</span> __attribute__((noinline))</span><br><span class="line"><span class="function">id *<span class="title">autoreleaseFullPage</span><span class="params">(id obj, AutoreleasePoolPage *page)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// The hot page is full. </span></span><br><span class="line">    <span class="comment">// Step to the next non-full page, adding a new page if necessary.</span></span><br><span class="line">    <span class="comment">// Then add the object to that page.</span></span><br><span class="line">    ASSERT(page == hotPage());</span><br><span class="line">    ASSERT(page-&gt;full()  ||  DebugPoolAllocation);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do-while遍历循环查找界面是否满了</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//如果子页面存在，则将页面替换为子页面</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="comment">//如果子页面不存在，则新建页面</span></span><br><span class="line">        <span class="keyword">else</span> page = <span class="keyword">new</span> AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为当前操作页面</span></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="comment">//对象压栈</span></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<code>AutoreleasePoolPage</code>初始化方法中可以看出，主要是通过操作<code>child</code>对象，将<code>当前页的child指向新建页面</code>，由此可以得出<code>页是通过双向链表连接</code></p>
<p><strong>add 方法</strong></p>
<p>这个方法主要是<code>添加释放对象</code>，其底层是实现是通过<code>next</code>指针存储释放对象，并将<code>next指针递增</code>，表示下一个释放对象存储的位置。从这里可以看出<code>页</code>是通过<code>栈结构存储</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加释放对象</span></span><br><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(!full());</span><br><span class="line">    unprotect();</span><br><span class="line">    <span class="comment">//传入对象存储的位置</span></span><br><span class="line">    id *ret = next;  <span class="comment">// faster than `return next-1` because of aliasing</span></span><br><span class="line">    <span class="comment">//将obj压栈到next指针位置，然后next进行++，即下一个对象存储的位置</span></span><br><span class="line">    *next++ = obj;</span><br><span class="line">    protect();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h5><p>在demo中，我们通过<code>autorelease</code>方法，在MRC模式下，将对象压栈到自动释放池，下面来分析其底层实现</p>
<p>查看<code>autorelease</code>方法源码</p>
<ul>
<li>如果不是对象 或者 是小对象，则直接返回</li>
<li>如果是对象，则调用对象的<code>autorelease</code>进行释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((aligned(<span class="number">16</span>), flatten, noinline))</span><br><span class="line">id</span><br><span class="line">objc_autorelease(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果不是对象，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//如果是小对象，也直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">return</span> obj-&gt;autorelease();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入对象的<code>autorelease</code>实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">👇</span><br><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::autorelease()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="comment">//判断是否是自定义类</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootAutorelease();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, @selector(autorelease));</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::rootAutorelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果是小对象，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line">__attribute__((noinline,used))</span><br><span class="line">id </span><br><span class="line">objc_object::rootAutorelease2()</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(!isTaggedPointer());</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((id)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">👇</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id <span class="title">autorelease</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ASSERT(obj);</span><br><span class="line">    ASSERT(!obj-&gt;isTaggedPointer());</span><br><span class="line">    <span class="comment">//autoreleaseFast 压栈操作</span></span><br><span class="line">    id *dest __unused = autoreleaseFast(obj);</span><br><span class="line">    ASSERT(!dest  ||  dest == EMPTY_POOL_PLACEHOLDER  ||  *dest == obj);</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这里看出，无论是<code>压栈哨兵对象，还是普通对象</code>，都会来到<code>autoreleaseFast</code>方法，只是<code>区别标识不同</code>而以</p>
<h4 id="1-1-3-objc-autoreleasePoolPop"><a href="#1-1-3-objc-autoreleasePoolPop" class="headerlink" title="1.1.3 objc_autoreleasePoolPop"></a>1.1.3 objc_autoreleasePoolPop</h4><p>在<code>objc_autoreleasePoolPop</code>方法中有个参数，在clang分析时，发现传入的参数是<code>push压栈后返回的哨兵对象</code>，即<code>ctxt</code>，其目的是<code>避免出栈混乱，防止将别的对象出栈</code></p>
<p>进入<code>pop</code>源码实现，主要由以下几步</p>
<ul>
<li>空页面的处理，并<code>根据token获取page</code></li>
<li>容错处理</li>
<li>通过<code>popPage</code>出栈页</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">pop(<span class="keyword">void</span> *token)</span><br><span class="line">&#123;</span><br><span class="line">    AutoreleasePoolPage *page;</span><br><span class="line">    id *stop;</span><br><span class="line">   <span class="comment">//判断对象是否是空占位符</span></span><br><span class="line">    <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">        <span class="comment">//如果当是空占位符</span></span><br><span class="line">        <span class="comment">// Popping the top-level placeholder pool.</span></span><br><span class="line">        <span class="comment">//获取当前页</span></span><br><span class="line">        page = hotPage();</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">// Pool was never used. Clear the placeholder.</span></span><br><span class="line">            <span class="comment">//如果当前页不存在，则清除空占位符</span></span><br><span class="line">            <span class="keyword">return</span> setHotPage(nil);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Pool was used. Pop its contents normally.</span></span><br><span class="line">        <span class="comment">// Pool pages remain allocated for re-use as usual.</span></span><br><span class="line">        <span class="comment">//如果当前页存在，则将当前页设置为coldPage,token设置为coldPage的开始位置</span></span><br><span class="line">        page = coldPage();</span><br><span class="line">        token = page-&gt;begin();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取token所在的页</span></span><br><span class="line">        page = pageForPointer(token);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    stop = (id *)token;</span><br><span class="line">    <span class="comment">//判断最后一个位置，是否是哨兵</span></span><br><span class="line">    <span class="keyword">if</span> (*stop != POOL_BOUNDARY) &#123;</span><br><span class="line">        <span class="comment">//最后一个位置不是哨兵，即最后一个位置是一个对象</span></span><br><span class="line">        <span class="keyword">if</span> (stop == page-&gt;begin()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">            <span class="comment">//如果是第一个位置，且没有父节点，什么也不做</span></span><br><span class="line">            <span class="comment">// Start of coldest page may correctly not be POOL_BOUNDARY:</span></span><br><span class="line">            <span class="comment">// 1. top-level pool is popped, leaving the cold page in place</span></span><br><span class="line">            <span class="comment">// 2. an object is autoreleased with no pool</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果是第一个位置，且有父节点，则出现了混乱</span></span><br><span class="line">            <span class="comment">// Error. For bincompat purposes this is not </span></span><br><span class="line">            <span class="comment">// fatal in executables built with old SDKs.</span></span><br><span class="line">            <span class="keyword">return</span> badPop(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(PrintPoolHiwat || DebugPoolAllocation || DebugMissingPools)) &#123;</span><br><span class="line">        <span class="keyword">return</span> popPageDebug(token, page, stop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈页</span></span><br><span class="line">    <span class="keyword">return</span> popPage&lt;<span class="literal">false</span>&gt;(token, page, stop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>popPage</code>源码，其中传入的<code>allowDebug</code>为false，则通过<code>releaseUntil</code>出栈当前页<code>stop</code>位置之前的所有对象，即向栈中的对象<code>发送release消息</code>，直到遇到传入的<code>哨兵对象</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈页面</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> allowDebug&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">    popPage(<span class="keyword">void</span> *token, AutoreleasePoolPage *page, id *stop)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (allowDebug &amp;&amp; PrintPoolHiwat) printHiwat();</span><br><span class="line">    <span class="comment">//出栈当前操作页面对象</span></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// memory: delete empty children 删除空子项</span></span><br><span class="line">    <span class="keyword">if</span> (allowDebug &amp;&amp; DebugPoolAllocation  &amp;&amp;  page-&gt;empty()) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything during page-per-pool debugging</span></span><br><span class="line">        <span class="comment">//调试期间删除每个特殊情况下的所有池</span></span><br><span class="line">        <span class="comment">//获取当前页面的父节点</span></span><br><span class="line">        AutoreleasePoolPage *parent = page-&gt;parent;</span><br><span class="line">        <span class="comment">//将当前页面杀掉</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        <span class="comment">//设置操作页面为父节点页面</span></span><br><span class="line">        setHotPage(parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (allowDebug &amp;&amp; DebugMissingPools  &amp;&amp;  page-&gt;empty()  &amp;&amp;  !page-&gt;parent) &#123;</span><br><span class="line">        <span class="comment">// special case: delete everything for pop(top)</span></span><br><span class="line">        <span class="comment">// when debugging missing autorelease pools</span></span><br><span class="line">        <span class="comment">//特殊情况：调试丢失的自动释放池时删除pop（top）的所有内容</span></span><br><span class="line">        page-&gt;kill();</span><br><span class="line">        setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="comment">// hysteresis: keep one empty child if page is more than half full 如果页面已满一半以上，则保留一个空子级</span></span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>releaseUntil</code>实现，主要是通过循环遍历，判断对象是否等于stop，其的是释放stop之前的所有的对象，</p>
<ul>
<li>首先通过<code>获取page的next释放对象（即page的最后一个对象）</code>，并对<code>next</code>进行<code>递减</code>，获取<code>上一个对象</code></li>
<li>判断<code>是否是哨兵对象</code>，如果不是则自动调用<code>objc_release</code>释放</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放到stop位置之前的所有对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseUntil</span><span class="params">(id *stop)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack  不是递归的：我们不想破坏堆栈</span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    <span class="comment">//判断下一个对象是否等于stop，如果不等于，则进入while循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        <span class="comment">// Restart from hotPage() every time, in case -release </span></span><br><span class="line">        <span class="comment">// autoreleased more objects 每次从hotPage（）重新启动，以防-release自动释放更多对象</span></span><br><span class="line">        <span class="comment">//获取当前操作页面，即hot页面</span></span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fixme I think this `while` can be `if`, but I can&#x27;t prove it</span></span><br><span class="line">        <span class="comment">//如果当前页是空的</span></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            <span class="comment">//将page赋值为父节点页</span></span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            <span class="comment">//并设置当前页为父节点页</span></span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        <span class="comment">//next进行--操作，即出栈</span></span><br><span class="line">        id obj = *--page-&gt;next;</span><br><span class="line">        <span class="comment">//将页索引位置置为SCRIBBLE，表示已经被释放</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_BOUNDARY) &#123;</span><br><span class="line">            <span class="comment">//释放</span></span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置当前页</span></span><br><span class="line">    setHotPage(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line">    <span class="comment">// we expect any children to be completely empty</span></span><br><span class="line">    <span class="keyword">for</span> (AutoreleasePoolPage *page = child; page; page = page-&gt;child) &#123;</span><br><span class="line">        ASSERT(page-&gt;empty());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>kill</code>实现，主要是销毁当前页，将<code>当前页赋值为父节点页</code>，并将<code>父节点页的child对象指针置为nil</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//销毁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kill</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Not recursive: we don&#x27;t want to blow out the stack </span></span><br><span class="line">    <span class="comment">// if a thread accumulates a stupendous amount of garbage</span></span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//获取最后一个页</span></span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        <span class="comment">//子节点 变成 父节点</span></span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            <span class="comment">//子节点为nil</span></span><br><span class="line">            page-&gt;child = nil;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-autoreleasepool结构图"><a href="#1-2-autoreleasepool结构图" class="headerlink" title="1.2 autoreleasepool结构图"></a>1.2 autoreleasepool结构图</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/33beebb613234383ba208f3093abc87d%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><ul>
<li><p><code>autoreleasepool</code>其本质是一个结构体<code>对象</code>，一个自动释放池对象就是页，是是<code>栈结构存储</code>，符合<code>先进后出</code>的原则</p>
</li>
<li><p>页的栈底是一个<code>56</code>字节大小的<code>空占位符</code>，一页总大小为<code>4096</code>字节</p>
</li>
<li><p>只有<code>第一页</code>有<code>哨兵</code>对象，第一页最多存储<code>504</code>个对象，从第二页开始最多存储<code>505</code>个对象</p>
</li>
<li><p>在自动释放池的压栈（即push）操作中</p>
<ul>
<li>当没有pool，即只有空占位符（存储在tls中）时，则创建页，<code>压栈哨兵对象</code></li>
<li>在页中<code>压栈普通对象</code>主要是通过<code>next</code>指针<code>递增</code>进行的，</li>
<li>当<code>页满</code>了时，需要设置页的<code>child</code>对象为<code>新建页</code></li>
</ul>
</li>
<li><p>在自动释放池的出栈（即pop）操作中</p>
<ul>
<li>在页中<code>出栈普通对象</code>主要是通过<code>next</code>指针<code>递减</code>进行的，</li>
<li>当<code>页空</code>了时，需要赋值页的<code>parent</code>对象为<code>当前页</code></li>
</ul>
</li>
</ul>
<h2 id="二、RunLoop"><a href="#二、RunLoop" class="headerlink" title="二、RunLoop"></a>二、RunLoop</h2><p>对于RunLoop，主要关心的点有以下几个</p>
<ul>
<li>1、runloop是什么？</li>
<li>2、runloop和线程的关系？</li>
<li>3、runloop是什么时候创建的？</li>
</ul>
<h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p><code>RunLoop</code>是事件接收和分发机制的一个实现，是线程相关的基础框架的一部分，一个RunLoop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。</p>
<p><code>RunLoop</code>本质是一个 <code>do-while循环</code>，没事做就休息，来活了就干活。与普通的<code>while</code>循环是有区别的，普通的<code>while循环</code>会导致CPU进入<code>忙等待状态</code>，即一直消耗cpu，而RunLoop则不会，RunLoop是一种<code>闲等待</code>，即RunLoop具备<code>休眠功能</code>。</p>
<p><strong>RunLoop的作用</strong></p>
<ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（触摸、定时器、performSelector）</li>
<li>节省cpu资源，提供程序的性能，<code>该做事就做事，该休息就休息</code></li>
</ul>
<h3 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2 源码分析"></a>2.2 源码分析</h3><p>使用<a target="_blank" rel="noopener" href="https://github.com/speam/runloopSourceCode.git">我的runloop源码</a>分析</p>
<h4 id="2-2-1-RunLoop和线程的关系"><a href="#2-2-1-RunLoop和线程的关系" class="headerlink" title="2.2.1 RunLoop和线程的关系"></a>2.2.1 RunLoop和线程的关系</h4><p>一般在日常开发中，对于<code>RunLoop的获取</code>主要有以下两种方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主运行循环</span></span><br><span class="line"> CFRunLoopRef mainRunloop = CFRunLoopGetMain();</span><br><span class="line"> <span class="comment">// 当前运行循环</span></span><br><span class="line"> CFRunLoopRef currentRunloop = CFRunLoopGetCurrent();</span><br></pre></td></tr></table></figure>

<p>进入<code>CFRunLoopGetMain</code>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">static</span> CFRunLoopRef __main = <span class="literal">NULL</span>; <span class="comment">// no retain needed</span></span><br><span class="line">    <span class="comment">//pthread_main_thread_np 主线程</span></span><br><span class="line">    <span class="keyword">if</span> (!__main) __main = _CFRunLoopGet0(pthread_main_thread_np()); <span class="comment">// no CAS needed</span></span><br><span class="line">    <span class="keyword">return</span> __main;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>_CFRunLoopGet0</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// should only be called by Foundation</span></span><br><span class="line"><span class="comment">// t==0 is a synonym for &quot;main thread&quot; that always works</span></span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    <span class="comment">//如果t不存在，则标记为主线程（即默认情况，默认是主线程）</span></span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">        t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!__CFRunLoops) &#123;</span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建全局字典，标记为kCFAllocatorSystemDefault</span></span><br><span class="line">        CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        <span class="comment">//通过主线程 创建主运行循环</span></span><br><span class="line">        CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">        <span class="comment">//利用dict，进行key-value绑定操作，即可以说明，线程和runloop是一一对应的</span></span><br><span class="line">        <span class="comment">// dict : key value</span></span><br><span class="line">        CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(<span class="literal">NULL</span>, dict, (<span class="keyword">void</span> * <span class="keyword">volatile</span> *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">            CFRelease(dict);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CFRelease(mainLoop);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过其他线程获取runloop</span></span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">//如果没有获取到，则新建一个运行循环</span></span><br><span class="line">        CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFSpinLock(&amp;loopsLock);</span><br><span class="line">        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">        <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">            <span class="comment">//将新建的runloop 与 线程进行key-value绑定</span></span><br><span class="line">            CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">            loop = newLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span></span><br><span class="line">        __CFSpinUnlock(&amp;loopsLock);</span><br><span class="line">        CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="keyword">void</span> *)loop, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="keyword">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS<span class="number">-1</span>), (<span class="keyword">void</span> (*)(<span class="keyword">void</span> *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这里可以说明，<code>Runloop</code>只有两种，一种是<code>主线程</code>的， 一个是<code>其他线程</code>的。即runloop和线程是<code>一一对应的</code></p>
<h4 id="2-2-2-RunLoop的创建"><a href="#2-2-2-RunLoop的创建" class="headerlink" title="2.2.2 RunLoop的创建"></a>2.2.2 RunLoop的创建</h4><p>进入<code>__CFRunLoopCreate</code>源码，其中主要是对runloop属性的赋值操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> CFRunLoopRef __CFRunLoopCreate(<span class="keyword">pthread_t</span> t) &#123;</span><br><span class="line">    CFRunLoopRef loop = <span class="literal">NULL</span>;</span><br><span class="line">    CFRunLoopModeRef rlm;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(struct __CFRunLoop) - <span class="keyword">sizeof</span>(CFRuntimeBase);</span><br><span class="line">    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果loop为空，则直接返回NULL</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == loop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//runloop属性配置</span></span><br><span class="line">    (<span class="keyword">void</span>)__CFRunLoopPushPerRunData(loop);</span><br><span class="line">    __CFRunLoopLockInit(&amp;loop-&gt;_lock);</span><br><span class="line">    loop-&gt;_wakeUpPort = __CFPortAllocate();</span><br><span class="line">    <span class="keyword">if</span> (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;</span><br><span class="line">    __CFRunLoopSetIgnoreWakeUps(loop);</span><br><span class="line">    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);</span><br><span class="line">    loop-&gt;_commonModeItems = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_currentMode = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">    loop-&gt;_blocks_head = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_blocks_tail = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_counterpart = <span class="literal">NULL</span>;</span><br><span class="line">    loop-&gt;_pthread = t;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">    loop-&gt;_winthread = GetCurrentThreadId();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    loop-&gt;_winthread = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) __CFRunLoopModeUnlock(rlm);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进入<code>CFRunLoopRef</code>的定义,根据定义得知，其实<code>RunLoop也是一个对象</code>。是<code>__CFRunLoop</code>结构体的<code>指针类型</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></span><br><span class="line">👇</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _lock;            <span class="comment">/* locked for accessing mode list */</span></span><br><span class="line">    __CFPort _wakeUpPort;            <span class="comment">// used for CFRunLoopWakeUp</span></span><br><span class="line">    Boolean _unused;</span><br><span class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">    <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">    <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从定义中可以得出，<code>一个RunLoop依赖于多个Mode</code>，意味着一个RunLoop需要处理多个事务，即<code>一个Mode对应多个Item</code>，而一个item中，包含了timer、source、observer，如下所示 <img src="https://raw.githubusercontent.com/speam/blogImgs/main/551b44ed1d024fbb9ae331144b216778%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p><strong>Mode类型</strong> 其中<code>mode</code>在苹果文档中提及的有五个，而在iOS中公开暴露出来的只有 <code>NSDefaultRunLoopMode</code> 和 <code>NSRunLoopCommonModes</code>。 <code>NSRunLoopCommonModes</code> 实际上是一个 Mode 的集合，默认<code>包括 NSDefaultRunLoopMode 和 NSEventTrackingRunLoopMode</code>。</p>
<ul>
<li><code>NSDefaultRunLoopMode</code>：<code>默认</code>的mode，正常情况下都是在这个mode</li>
<li><code>NSConnectionReplyMode</code></li>
<li><code>NSModalPanelRunLoopMode</code></li>
<li><code>NSEventTrackingRunLoopMode</code>：使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）</li>
<li>NSRunLoopCommonModes：伪模式，灵活性更好</li>
</ul>
<p><strong>Source &amp; Timer &amp; Observer</strong></p>
<ul>
<li><code>Source</code>表示可以<code>唤醒RunLoop的一些事件</code>，例如用户点击了屏幕，就会创建一个RunLoop，主要分为<code>Source0</code>和<code>Source1</code><ul>
<li><code>Source0</code> 表示 非系统事件，即用户自定义的事件</li>
<li><code>Source1</code> 表示系统事件，主要负责底层的通讯，具备唤醒能力</li>
</ul>
</li>
<li><code>Timer</code> 就是常用<code>NSTimer</code>定时器这一类</li>
<li><code>Observer</code> 主要用于监听RunLoop的状态变化，并作出一定响应，主要有以下一些状态</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//进入RunLoop</span></span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    <span class="comment">//即将处理Timers</span></span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    <span class="comment">//即将处理Source</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    <span class="comment">//即将进入休眠</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    <span class="comment">//被唤醒</span></span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    <span class="comment">//退出RunLoop</span></span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>验证：RunLoop和mode是一对多</strong> 下面，通过上面的代码调试来验证我们上面提及的关系</p>
<p>通过lldb命令获取mainRunloop、currentRunloop的currentMode</p>
<ul>
<li>po CFRunLoopCopyCurrentMode(mainRunloop)</li>
<li>po CFRunLoopCopyCurrentMode(currentRunloop)</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/bbf6e09e02664a029486f316abdeedc0%7Etplv-k3u1fbpfcp-zoom-1.image"> 从这里，可以说明，<code>runloop在运行时的mode只有一个</code></p>
<p>获取<code>mainRunloop</code>的所有模型，即<code>po CFRunLoopCopyAllModes(mainRunloop)</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/83acfdef9b934b3e91231cdeb878f42b%7Etplv-k3u1fbpfcp-zoom-1.image"> 从结果可以验证<code>runloop</code> 和 <code>CFRunloopMode</code> 具有 <code>一对多</code>的关系</p>
<p><strong>验证：mode和Item也是一对多</strong></p>
<p>在上述代码中，加断点，通过bt查看堆栈信息，从这里看出timer的item类型如下所示</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/f6f9f4fb76c748b0a144b9c960d3b700%7Etplv-k3u1fbpfcp-zoom-1.image" alt="timer的item类型"></p>
<p>在RunLoop源码中查看Item类型，有以下几种</p>
<ul>
<li>block应用:<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</code></li>
<li>调用timer:<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code></li>
<li>响应source0: <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code></li>
<li>响应source1: <code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></li>
<li>GCD主队列:<code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code></li>
<li>observer源: <code>__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/c1c442cd21cb4b909a99ddc57ef49d4c%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>在这里以Timer为例，一般初始化timer时，都会将timer通addTimer:forMode:方法添加到Runloop中，于是在源码中查找addTimer的相关方法，即CFRunLoopAddTimer方法，其源码实现如下，其实现主要判断是否是kCFRunLoopCommonModes，然后查找runloop的mode进行匹配处理</p>
<ul>
<li>其中<code>kCFRunLoopCommonModes</code> 不是一种模式，是一种抽象的<code>伪模式</code>，比defaultMode更加灵活</li>
<li>通过<code>CFSetAddValue(rl-&gt;_commonModeItems, rlt);</code>可以得知，<code>runloop</code>与<code>mode</code> 是<code>一对多</code>的，同时可以得出<code>mode</code> 与 <code>item</code> 也是<code>一对多</code>的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddTimer</span><span class="params">(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName)</span> </span>&#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!__CFIsValid(rlt) || (<span class="literal">NULL</span> != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) <span class="keyword">return</span>;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重点 : kCFRunLoopCommonModes</span></span><br><span class="line">    <span class="keyword">if</span> (modeName == kCFRunLoopCommonModes) &#123;</span><br><span class="line">        <span class="comment">//如果是kCFRunLoopCommonModes 类型</span></span><br><span class="line">       </span><br><span class="line">        CFSetRef <span class="built_in">set</span> = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == rl-&gt;_commonModeItems) &#123;</span><br><span class="line">            rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;kCFTypeSetCallBacks);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//runloop与mode 是一对多的， mode与item也是一对多的</span></span><br><span class="line">        CFSetAddValue(rl-&gt;_commonModeItems, rlt);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != <span class="built_in">set</span>) &#123;</span><br><span class="line">            CFTypeRef context[<span class="number">2</span>] = &#123;rl, rlt&#125;;</span><br><span class="line">            <span class="comment">/* add new item to all common-modes */</span></span><br><span class="line">            <span class="comment">//执行</span></span><br><span class="line">            CFSetApplyFunction(<span class="built_in">set</span>, (__CFRunLoopAddItemToCommonModes), (<span class="keyword">void</span> *)context);</span><br><span class="line">            CFRelease(<span class="built_in">set</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是非commonMode类型</span></span><br><span class="line">        <span class="comment">//查找runloop的模型</span></span><br><span class="line">        CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlm-&gt;_timers) &#123;</span><br><span class="line">                CFArrayCallBacks cb = kCFTypeArrayCallBacks;</span><br><span class="line">                cb.equal = <span class="literal">NULL</span>;</span><br><span class="line">                rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, <span class="number">0</span>, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断mode是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) &#123;</span><br><span class="line">            __CFRunLoopTimerLock(rlt);</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> == rlt-&gt;_runLoop) &#123;</span><br><span class="line">                rlt-&gt;_runLoop = rl;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl != rlt-&gt;_runLoop) &#123;</span><br><span class="line">                __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">                __CFRunLoopModeUnlock(rlm);</span><br><span class="line">                __CFRunLoopUnlock(rl);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果匹配，则将runloop加进去，而runloop的执行依赖于  [runloop run]</span></span><br><span class="line">            CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);</span><br><span class="line">            __CFRunLoopTimerUnlock(rlt);</span><br><span class="line">            __CFRunLoopTimerFireTSRLock();</span><br><span class="line">            __CFRepositionTimerInMode(rlm, rlt, <span class="literal">false</span>);</span><br><span class="line">            __CFRunLoopTimerFireTSRUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) &#123;</span><br><span class="line">                <span class="comment">// Normally we don&#x27;t do this on behalf of clients, but for</span></span><br><span class="line">                <span class="comment">// backwards compatibility due to the change in timer handling...</span></span><br><span class="line">                <span class="keyword">if</span> (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> != rlm) &#123;</span><br><span class="line">            __CFRunLoopModeUnlock(rlm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    __CFRunLoopUnlock(rl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-RunLoop执行"><a href="#2-2-3-RunLoop执行" class="headerlink" title="2.2.3 RunLoop执行"></a>2.2.3 RunLoop执行</h4><p>众所周知，RunLoop的执行依赖于<code>run</code>方法，从下面的堆栈信息中可以看出，其底层执行的是<code>__CFRunLoopRun</code>方法 <img src="https://raw.githubusercontent.com/speam/blogImgs/main/386376033b964146b9ae3163f11324d0%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>进入<code>__CFRunLoopRun</code>源码，针对不同的对象，有不同的处理</p>
<ul>
<li>如果有<code>observer</code>，则调用 <code>__CFRunLoopDoObservers</code></li>
<li>如果有<code>block</code>，则调用<code>__CFRunLoopDoBlocks</code></li>
<li>如果有<code>timer</code>，则调用 <code>__CFRunLoopDoTimers</code></li>
<li>如果是<code>source0</code>，则调用<code>__CFRunLoopDoSources0</code></li>
<li>如果是<code>source1</code>，则调用<code>__CFRunLoopDoSource1</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* rl, rlm are locked on entrance and exit */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">         <span class="comment">//通知 Observers: 即将处理timer事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        <span class="comment">//通知 Observers: 即将处理Source事件</span></span><br><span class="line">        <span class="keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line">        <span class="comment">//处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        <span class="comment">//处理sources0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        <span class="comment">//处理sources0返回为YES</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是timer</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</span><br><span class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</span><br><span class="line">            <span class="keyword">if</span> (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</span><br><span class="line">                <span class="comment">// Re-arm the next timer, because we apparently fired early</span></span><br><span class="line">                __CFArmNextTimerInMode(rlm, rl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果是source1</span></span><br><span class="line">        CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</span><br><span class="line">        <span class="keyword">if</span> (rls) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</span></span><br><span class="line">            <span class="keyword">mach_msg_header_t</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">NULL</span> != reply) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">                CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> DEPLOYMENT_TARGET_WINDOWS</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>__CFRunLoopDoTimers</code>源码，主要是通过for循环，对单个timer进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoTimers(CFRunLoopRef rl, CFRunLoopModeRef rlm, <span class="keyword">uint64_t</span> limitTSR) &#123;    <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//循环遍历，做下层单个timer的执行</span></span><br><span class="line">    <span class="keyword">for</span> (CFIndex idx = <span class="number">0</span>, cnt = timers ? CFArrayGetCount(timers) : <span class="number">0</span>; idx &lt; cnt; idx++) &#123;</span><br><span class="line">        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);</span><br><span class="line">        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);</span><br><span class="line">        timerHandled = timerHandled || did;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>__CFRunLoopDoTimer</code>源码，主要逻辑是<code>timer</code>执行完毕后，会主动调用<code>__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code>函数，正好与timer堆栈调用中的一致</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/8ed6fdcddc384cc9b4c2ee1cee565072%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mode and rl are locked on entry and exit</span></span><br><span class="line"><span class="keyword">static</span> Boolean __CFRunLoopDoTimer(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) &#123; </span><br><span class="line">    ...</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>timer执行总结</strong></p>
<ul>
<li>为自定义的timer，<code>设置Mode</code>，并将其<code>加入RunLoop</code>中</li>
<li>在RunLoop的<code>run</code>方法执行时，会调用<code>__CFRunLoopDoTimers</code>执行所有timer</li>
<li>在<code>__CFRunLoopDoTimers</code>方法中，会通过for循环执行单个timer的操作</li>
<li>在<code>__CFRunLoopDoTimer</code>方法中，timer执行完毕后，会执行对应的timer回调函数</li>
</ul>
<p>以上，是针对<code>timer</code>的执行分析，对于<code>observer、block、source0、source1</code>，其执行原理与timer是类似的，这里就不再重复说明以下是<a href="https://link.juejin.cn/?target=https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%23//apple_ref/doc/uid/10000057i-CH16-SW1">苹果官方文档</a>针对RunLoop处理不同源的图示 <img src="https://raw.githubusercontent.com/speam/blogImgs/main/32510b5efaef44a7b23753a0d70ebb35%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="2-2-4-RunLoop-底层原理"><a href="#2-2-4-RunLoop-底层原理" class="headerlink" title="2.2.4 RunLoop 底层原理"></a>2.2.4 RunLoop 底层原理</h4><p>从上述的堆栈信息中可以看出，run在底层的实现路径为<code>CFRunLoopRun -&gt; CFRunLoopRun -&gt; __CFRunLoopRun</code></p>
<p>进入<code>CFRunLoopRun</code>源码，其中传入的参数<code>1.0e10</code>（科学计数） 等于 1* e^10，用于表示<code>超时时间</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1.0e10 : 科学技术 1*10^10</span></span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; <span class="keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入CFRunLoopRunSpecific源码，首先根据modeName找到对应的mode，然后主要分为三种情况：</p>
<ul>
<li>如果是<code>entry</code>，则通知observer，即将<code>进入runloop</code></li>
<li>如果是<code>exit</code>，则通过observer，即将<code>退出runloop</code></li>
<li>如果是其他中间状态，主要是通过<code>runloop</code>处理各种源</li>
</ul>
<p>其伪代码表示如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunSpecific</span><span class="params">(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled)</span> </span>&#123;     <span class="comment">/* DOES CALLOUT */</span></span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="keyword">return</span> kCFRunLoopRunFinished;</span><br><span class="line">    __CFRunLoopLock(rl);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先根据modeName找到对应mode</span></span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部函数，进入loop</span></span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>__CFRunLoopRun</code>源码，由于这部分代码较多，于是这里用伪代码代替。其主要逻辑是<code>根据不同的事件源进行不同的处理</code>，当RunLoop休眠时，可以通过相应的事件唤醒RunLoop</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心函数</span></span><br><span class="line"><span class="comment">/* rl, rlm are locked on entrance and exit */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int32_t</span> __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过GCD开启一个定时器，然后开始跑圈</span></span><br><span class="line">    <span class="keyword">dispatch_source_t</span> timeout_timer = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    dispatch_resume(timeout_timer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int32_t</span> retVal = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理事务,即处理items</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers: 即将处理timer事件</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers: 即将处理Source事件</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理Blocks</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理sources0</span></span><br><span class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理sources0返回为YES</span></span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">            <span class="comment">// 处理Blocks</span></span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断有无端口消息(Source1)</span></span><br><span class="line">        <span class="keyword">if</span> (__CFRunLoopWaitForMultipleObjects(<span class="literal">NULL</span>, &amp;dispatchPort, <span class="number">0</span>, <span class="number">0</span>, &amp;livePort, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="comment">// 处理消息</span></span><br><span class="line">            <span class="keyword">goto</span> handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers: 即将进入休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待被唤醒</span></span><br><span class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort, poll ? <span class="number">0</span> : TIMEOUT_INFINITY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// user callouts now OK again</span></span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知 Observers: 被唤醒，结束休眠</span></span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    handle_msg:</span><br><span class="line">        <span class="keyword">if</span> (被timer唤醒) &#123;</span><br><span class="line">            <span class="comment">// 处理Timers</span></span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time())；</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (被GCD唤醒)&#123;</span><br><span class="line">            <span class="comment">// 处理gcd</span></span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (被source1唤醒)&#123;</span><br><span class="line">            <span class="comment">// 被Source1唤醒，处理Source1</span></span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理block</span></span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;<span class="comment">//处理源</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;<span class="comment">//超时</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;<span class="comment">//停止</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = <span class="literal">false</span>;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;<span class="comment">//停止</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;<span class="comment">//结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">while</span> (<span class="number">0</span> == retVal);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，综上所述，<code>RunLoop</code>的执行流程，如下所示 <img src="https://raw.githubusercontent.com/speam/blogImgs/main/6dc0c9a4f9cc4534b16ab6b8d73dae7e%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<h2 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h2><h3 id="3-1-AutoreleasePool-相关"><a href="#3-1-AutoreleasePool-相关" class="headerlink" title="3.1 AutoreleasePool 相关"></a>3.1 AutoreleasePool 相关</h3><p><strong>题1：临时变量什么时候释放？</strong></p>
<ul>
<li>如果在<code>正常情况</code>下，一般是<code>超出其作用域就会立即释放</code></li>
<li>如果将临时变量加入了<code>自动释放池</code>，会延迟释放，即在<code>runloop休眠或者autoreleasepool作用域之后释放</code></li>
</ul>
<p><strong>题2：AutoreleasePool原理</strong></p>
<ul>
<li>自动释放池的本质是一个<code>AutoreleasePoolPage结构体对象</code>，是一个<code>栈结构存储</code>的页，每一个AutoreleasePoolPage都是以<code>双向链表</code>的形式连接</li>
<li>自动释放池的<code>压栈</code>和<code>出栈</code>主要是通过结构体的构造函数和析构函数调用底层的<code>objc_autoreleasePoolPush</code>和<code>objc_autoreleasePoolPop</code>，实际上是调用<code>AutoreleasePoolPage</code>的<code>push</code>和<code>pop</code>两个方法</li>
<li>每次调用<code>push</code>操作其实就是创建一个新的<code>AutoreleasePoolPage</code>，而<code>AutoreleasePoolPage</code>的具体操作就是插入一个<code>POOL_BOUNDARY</code>，并返回插入<code>POOL_BOUNDARY</code>的内存地址。而push内部调用<code>autoreleaseFast</code>方法处理，主要有以下三种情况<ul>
<li>当<code>page存在，且不满</code>时，调用add方法将对象添加至page的next指针处，并next递增</li>
<li>当<code>page存在，且已满</code>时，调用<code>autoreleaseFullPage</code>初始化一个新的page，然后调用add方法将对象添加至page栈中</li>
<li>当<code>page不存在</code>时，调用<code>autoreleaseNoPage</code>创建一个hotPage，然后调用add方法将对象添加至page栈中</li>
</ul>
</li>
<li>当执行<code>pop</code>操作时，会传入一个值，这个值就是push操作的返回值，即<code>POOL_BOUNDARY</code>的内存地址<code>token</code>。所以pop内部的实现就是根据token找到哨兵对象所处的page中，然后使用 <code>objc_release</code> 释放 token之前的对象，并把<code>next</code> 指针到正确位置</li>
</ul>
<p><strong>题3：AutoreleasePool能否嵌套使用？</strong></p>
<ul>
<li>可以嵌套使用，其目的是可以<code>控制应用程序的内存峰值</code>，使其不要太高</li>
<li>可以嵌套的原因是因为自动释放池是以栈为节点，通过双向链表的形式连接的，且是和线程一一对应的</li>
<li>自动释放池的<code>多层嵌套</code>其实就是不停的<code>pushs哨兵对象</code>，在pop时，会先释放里面的，在释放外面的</li>
</ul>
<p><strong>题4：哪些对象可以加入AutoreleasePool？alloc创建可以吗？</strong></p>
<ul>
<li>使用<code>new、alloc、copy</code>关键字生成的对象和<code>retain</code>了的对象<code>需要手动释放</code>，不会被添加到自动释放池中</li>
<li>设置为<code>autorelease</code>的对象<code>不需要手动释放</code>，会直接进入自动释放池</li>
<li>所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中</li>
</ul>
<p><strong>题5：AutoreleasePool的释放时机是什么时候？</strong></p>
<ul>
<li>App 启动后，苹果在主线程 <code>RunLoop</code> 里注册了两个 <code>Observer</code>，其回调都是<code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</li>
<li>第一个 Observer 监视的事件是 <code>Entry</code>(即将进入 Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush</code>() <code>创建自动释放池</code>。其 order 是 -2147483647，<code>优先级最高</code>，保证创 建释放池发生在其他所有回调之前。</li>
<li>第二个 Observer 监视了两个事件: <code>BeforeWaiting</code>(准备进入休眠) 时<code>调用 _objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池</code>;<code>Exit</code>(即 将退出 Loop) 时调用 <code>_objc_autoreleasePoolPop() 来释放自动释放池</code>。这个 Observer 的 order 是 2147483647，<code>优先级最低</code>，保证其释放池子发生在其他所有回调之后。</li>
</ul>
<p><strong>题6：thread 和 AutoreleasePool的关系</strong></p>
<p>在<a href="https://link.juejin.cn/?target=https://developer.apple.com/documentation/foundation/nsautoreleasepool%23//apple_ref/doc/uid/TP40003623">官方文档</a>中，找到如下说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects (see Threads). As new pools are created, they get added to the top of the stack. When pools are deallocated, they are removed from the stack. Autoreleased objects are placed into the top autorelease pool for the current thread. When a thread terminates, it automatically drains all of the autorelease pools associated with itself.</span><br></pre></td></tr></table></figure>

<p>大致意思如下：</p>
<ul>
<li><code>每个线程</code>，包括主线程在内都维护了<code>自己的自动释放池堆栈结构</code></li>
<li>新的自动释放池在被创建时，会被添加到<code>栈顶</code>；当自动释放池销毁时，会从栈中移除</li>
<li>对于<code>当前线程</code>来说，会<code>将自动释放的对象</code>放入自动释放池的<code>栈顶</code>；在线程停止时，会<code>自动释放掉与该线程关联的所有自动释放池</code></li>
</ul>
<p><strong>总结</strong>：每个线程都有与之关联的自动释放池堆栈结构，新的pool在创建时会被压栈到栈顶，pool销毁时，会被出栈，对于当前线程来说，释放对象会被压栈到栈顶，线程停止时，会自动释放与之关联的自动释放池</p>
<p><strong>题7：RunLoop 和 AutoreleasePool的关系</strong> 在<a href="https://link.juejin.cn/?target=https://developer.apple.com/documentation/foundation/nsautoreleasepool%23//apple_ref/doc/uid/TP40003623">官方文档</a>中，找到如下说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</span><br></pre></td></tr></table></figure>

<p>大致意思如下：</p>
<ul>
<li>主程序的<code>RunLoop</code>在每次<code>事件循环</code>之前之前，会自动创建一个 <code>autoreleasePool</code></li>
<li>并且会在<code>事件循环</code>结束时，执行<code>drain</code>操作，释放其中的对象</li>
</ul>
<h3 id="3-2-RunLoop相关"><a href="#3-2-RunLoop相关" class="headerlink" title="3.2 RunLoop相关"></a>3.2 RunLoop相关</h3><p><strong>题1：</strong>当前有个子线程，子线程中有个<code>timer</code>。timer是否能够执行 并进行持续的打印？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CJLThread *thread = [[CJLThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// thread.name = nil 因为这个变量只是捕捉</span></span><br><span class="line">       <span class="comment">// CJLThread *thread = nil</span></span><br><span class="line">       <span class="comment">// thread = 初始化 捕捉一个nil进来</span></span><br><span class="line">       NSLog(@<span class="string">&quot;%@---%@&quot;</span>,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">       [NSTimer scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">           NSLog(@<span class="string">&quot;hello word&quot;</span>);            <span class="comment">// 退出线程--结果runloop也停止了</span></span><br><span class="line">           <span class="keyword">if</span> (self.isStopping) &#123;</span><br><span class="line">               [NSThread <span class="built_in">exit</span>];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;];</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   thread.name = @<span class="string">&quot;lgcode.com&quot;</span>;</span><br><span class="line">   [thread start];</span><br></pre></td></tr></table></figure>

<p>不可以，因为<code>子线程的runloop默认不启动</code>， 需要<code>runloop run</code>启动，需要将上述代码改成下面这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改成</span></span><br><span class="line"> CJLThread *thread = [[CJLThread alloc] initWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thread.name = nil 因为这个变量只是捕捉</span></span><br><span class="line">    <span class="comment">// CJLThread *thread = nil</span></span><br><span class="line">    <span class="comment">// thread = 初始化 捕捉一个nil进来</span></span><br><span class="line">    NSLog(@<span class="string">&quot;%@---%@&quot;</span>,[NSThread currentThread],[[NSThread currentThread] name]);</span><br><span class="line">    [NSTimer scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:YES block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">        NSLog(@<span class="string">&quot;hello word&quot;</span>);            <span class="comment">// 退出线程--结果runloop也停止了</span></span><br><span class="line">        <span class="keyword">if</span> (self.isStopping) &#123;</span><br><span class="line">            [NSThread <span class="built_in">exit</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">     [[NSRunLoop currentRunLoop] run];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">thread.name = @<span class="string">&quot;lgcode.com&quot;</span>;</span><br><span class="line">[thread start];</span><br></pre></td></tr></table></figure>

<p><strong>题2：RunLoop和线程的关系</strong></p>
<ul>
<li>每个线程都有一个与之对应的RunLoop，所以<code>RunLoop与线程是一一对应的</code>，其绑定关系通过一个<code>全局的DIctionary存储</code>，线程为key，runloop为value。</li>
<li>线程中的RunLoop主要是用来管理线程的，当线程的RunLoop开启后，会在执行完任务后进行休眠状态，当有事件触发唤醒时，又开始工作，即<code>有活时干活，没活就休息</code></li>
<li><code>主线程</code>的<code>RunLoop</code>是<code>默认开启</code>的，在程序启动之后，会一直运行，不会退出</li>
<li>其他线程的RunLoop默认是不开启的，如果需要，则手动开启</li>
</ul>
<p><strong>题3：NSRunLoop 和 CFRunLoopRef 区别</strong></p>
<ul>
<li><code>NSRunLoop</code>是基于CFRunLoopRef面向对象的API，是<code>不安全</code>的</li>
<li><code>CFRunLoopRef</code>是基于C语言，是<code>线程安全</code>的</li>
</ul>
<p><strong>题4：Runloop的mode作用是什么？</strong></p>
<p>mode主要是用于指定RunLoop中事件优先级的</p>
<p><strong>题5：以+scheduledTimerWithTimeInterval:的方式触发的timer，在滑动页面上的列表时，timer会暂停回调， 为什么？如何解决？</strong></p>
<ul>
<li>timer停止的原因是因为滑动<code>scrollView</code>时，主线程的RunLoop会从<code>NSDefaultRunLoopMode</code>切换到<code>UITrackingRunLoopMode</code>，而timer是添加在<code>NSDefaultRunLoopMode</code>。所以timer不会执行</li>
<li>将<code>timer</code>放入<code>NSRunLoopCommonModes</code>中执行</li>
</ul>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/autoreleaseSourceCode.git">我的autorelease源码</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/speam/runloopSourceCode.git">我的runloop源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6949591601714823199#heading-6">iOS-底层原理 33：内存管理（三）</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/19/%E8%A7%82%E5%BD%B1%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%A4%A7%E5%9D%82%E7%9B%B4%E7%BE%8E%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《大坂直美》观后感</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/23-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="level-item">23-内存管理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、AutoReleasePool"><span class="level-left"><span class="level-item">一、AutoReleasePool</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-源码分析"><span class="level-left"><span class="level-item">1.1 源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-AutoreleasePoolPage"><span class="level-left"><span class="level-item">1.1.1 AutoreleasePoolPage</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-objc-autoreleasePoolPush"><span class="level-left"><span class="level-item">1.1.2 objc_autoreleasePoolPush</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#autoreleaseNewPage"><span class="level-left"><span class="level-item">autoreleaseNewPage</span></span></a></li><li><a class="level is-mobile" href="#autoreleaseFast"><span class="level-left"><span class="level-item">autoreleaseFast</span></span></a></li><li><a class="level is-mobile" href="#autorelease"><span class="level-left"><span class="level-item">autorelease</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-1-3-objc-autoreleasePoolPop"><span class="level-left"><span class="level-item">1.1.3 objc_autoreleasePoolPop</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-autoreleasepool结构图"><span class="level-left"><span class="level-item">1.2 autoreleasepool结构图</span></span></a></li><li><a class="level is-mobile" href="#1-3-总结"><span class="level-left"><span class="level-item">1.3 总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、RunLoop"><span class="level-left"><span class="level-item">二、RunLoop</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-介绍"><span class="level-left"><span class="level-item">2.1 介绍</span></span></a></li><li><a class="level is-mobile" href="#2-2-源码分析"><span class="level-left"><span class="level-item">2.2 源码分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-RunLoop和线程的关系"><span class="level-left"><span class="level-item">2.2.1 RunLoop和线程的关系</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-RunLoop的创建"><span class="level-left"><span class="level-item">2.2.2 RunLoop的创建</span></span></a></li><li><a class="level is-mobile" href="#2-2-3-RunLoop执行"><span class="level-left"><span class="level-item">2.2.3 RunLoop执行</span></span></a></li><li><a class="level is-mobile" href="#2-2-4-RunLoop-底层原理"><span class="level-left"><span class="level-item">2.2.4 RunLoop 底层原理</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#三、问题"><span class="level-left"><span class="level-item">三、问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-AutoreleasePool-相关"><span class="level-left"><span class="level-item">3.1 AutoreleasePool 相关</span></span></a></li><li><a class="level is-mobile" href="#3-2-RunLoop相关"><span class="level-left"><span class="level-item">3.2 RunLoop相关</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>