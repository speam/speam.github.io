<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>22-iOS App 启动优化 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="22-iOS App 启动优化"><meta property="og:url" content="http://evilimo.com/2021/07/13/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/22-iOS%20App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713215312178.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713225024936.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172017185"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/703.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/682.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/686.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713173152551.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/adsfasdf13452134.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714212000142.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224506249.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224616613.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715091804019.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122616789.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122742992.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/5177724-47d666821d7c49aa.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715123751080.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715170912891.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172737346"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172748356"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172759405"><meta property="article:published_time" content="2021-07-13T07:36:25.224Z"><meta property="article:modified_time" content="2021-07-15T09:32:03.953Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713215312178.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/07/13/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/22-iOS%20App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713215312178.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713225024936.png","https://raw.githubusercontent.com/speam/blogImgs/main/703.png","https://raw.githubusercontent.com/speam/blogImgs/main/682.png","https://raw.githubusercontent.com/speam/blogImgs/main/686.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713173152551.png","https://raw.githubusercontent.com/speam/blogImgs/main/adsfasdf13452134.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714212000142.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224506249.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224616613.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715091804019.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122616789.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122742992.png","https://raw.githubusercontent.com/speam/blogImgs/main/5177724-47d666821d7c49aa.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715123751080.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715170912891.png"],"datePublished":"2021-07-13T07:36:25.224Z","dateModified":"2021-07-15T09:32:03.953Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/07/13/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/22-iOS%20App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-13T07:36:25.224Z" title="2021-07-13T07:36:25.224Z">2021-07-13</time>发表</span><span class="level-item"><time dateTime="2021-07-15T09:32:03.953Z" title="2021-07-15T09:32:03.953Z">2021-07-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">22-iOS App 启动优化</h1><div class="content"><hr>
<a id="more"></a>



<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>冷启动时长是 App 性能的重要指标，决定着用户对 App 的第一印象。本文将重点探究如何缩短 App 的冷启动时长。</p>
<h2 id="二、冷启动定义"><a href="#二、冷启动定义" class="headerlink" title="二、冷启动定义"></a>二、冷启动定义</h2><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713215312178.png"></p>
<p>我们把冷启动过程定义为：<strong>从用户点击 App 图标开始到用户能看到 App 主界面内容为止这个过程，即 T1+T2+T3。</strong>在App冷启动过程当中，这三个阶段中的每个阶段都存在很多可以被优化的点。</p>
<h2 id="三、pre-main-阶段分析"><a href="#三、pre-main-阶段分析" class="headerlink" title="三、pre-main 阶段分析"></a>三、pre-main 阶段分析</h2><p>pre-main 阶段的流程图：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713225024936.png"></p>
<p>加载过程从 exec( ) 函数开始，exec( ) 是一个系统调用，为进程分配一段内存空间。</p>
<p>然后看剩下的阶段并分析可优化点：</p>
<h4 id="Load-dylibs"><a href="#Load-dylibs" class="headerlink" title="Load dylibs"></a>Load dylibs</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172017185"></p>
<p>这一阶段 dyld 会分析应用依赖的 dylib，找到其 Mach-O 文件，打开和读取这些文件并验证其有效性，接着会找到代码签名注册到内核，最后对 dylib 的每一个 segment 调用 mmap( )。</p>
<p>一般情况下，会加载100-400个 dylibs，其中大部分是系统库，这部分 dylib 的加载系统已经做了优化。</p>
<p>我们可优化项：</p>
<ul>
<li>减少或者合并 dylibs，将动态库换成静态库</li>
</ul>
<h4 id="Rebase-amp-Bind"><a href="#Rebase-amp-Bind" class="headerlink" title="Rebase &amp; Bind"></a>Rebase &amp; Bind</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/703.png"></p>
<p>在 dylib 的加载过程中，系统为了安全考虑，引入了ASLR（Address Space Layout Randomization）技术和代码签名。由于 ASLR 的存在，镜像（Image，包括可执行文件、dylib 和 bundle）会在随机的地址上加载，和之前指针指向的地址会有一个偏差，dyld 需要修正这个偏差，来指向正确的地址。</p>
<p>Rebase 在前，Bind 在后，Rebase 在 Image 内部调整指针的指向，Bind是把指针正确地指向 Image 外部的内容。</p>
<p>所以，指针数量越少越好，我们可优化项：</p>
<ul>
<li>减少类、方法、分类数量</li>
</ul>
<h4 id="Objc-setup"><a href="#Objc-setup" class="headerlink" title="Objc setup"></a>Objc setup</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/682.png"></p>
<p>大部分 ObjC 初始化工作已经在 Rebase &amp; Bind 阶段做完了，这一步 dyld 会注册所有声明过的 ObjC 类，将分类的定义插入到类的方法列表里，再检查每个 selector 的唯一性。</p>
<p>在这一步倒没什么优化可做的，Rebase/Bind 阶段优化好了，这一步的耗时也会减少。</p>
<h4 id="Initializers"><a href="#Initializers" class="headerlink" title="Initializers"></a>Initializers</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/686.png"></p>
<p>调用 Objc 的 +load() 函数，调用 C++ 的构造函数属性函数，创建非基本类型的 C++ 静态全局变量(通常是类或结构体)。</p>
<p>我们可优化项：</p>
<ul>
<li><p>少在类的 +load 方法里做事情，尽量把这些事情推迟到 +initiailize</p>
</li>
<li><p>减少构造器函数（constructor），在构造器函数里少做些事情</p>
</li>
<li><p>减少 C++ 静态全局变量</p>
</li>
</ul>
<h2 id="四、pre-main-阶段优化"><a href="#四、pre-main-阶段优化" class="headerlink" title="四、pre-main 阶段优化"></a>四、pre-main 阶段优化</h2><p>想要优化，首先要知道如何测量这个过程的时长。</p>
<h3 id="4-1-时长测量"><a href="#4-1-时长测量" class="headerlink" title="4.1 时长测量"></a>4.1 时长测量</h3><h4 id="4-1-1-使用-Xcode-自带的静态打印功能"><a href="#4-1-1-使用-Xcode-自带的静态打印功能" class="headerlink" title="4.1.1 使用 Xcode 自带的静态打印功能"></a>4.1.1 使用 Xcode 自带的静态打印功能</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210713173152551.png"></p>
<p>在开发环境下，Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 <code>DYLD_PRINT_STATISTICS</code>设置为1会打印 pre-main 阶段耗时的简要信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 341.32 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 154.88 milliseconds (45.3%)</span><br><span class="line">        rebase&#x2F;binding time:  37.20 milliseconds (10.8%)</span><br><span class="line">            ObjC setup time:  52.62 milliseconds (15.4%)</span><br><span class="line">           initializer time:  96.50 milliseconds (28.2%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">               libSystem.dylib :   4.07 milliseconds (1.1%)</span><br><span class="line">    libMainThreadChecker.dylib :  30.75 milliseconds (9.0%)</span><br><span class="line">                  AFNetworking :  19.08 milliseconds (5.5%)</span><br><span class="line">                        LDXLog :  10.06 milliseconds (2.9%)</span><br><span class="line">                        Bigger :   7.05 milliseconds (2.0%)</span><br></pre></td></tr></table></figure>

<p>将<code>DYLD_PRINT_STATISTICS_DETAILS</code>设置为1，会打印 pre-main 阶段耗时的详细信息。</p>
<p>这种方式简单、准确，但只适合开发阶段使用，线上想统计时长的话，需要使用下面的纯代码方式。</p>
<h4 id="4-1-2-使用纯代码方式"><a href="#4-1-2-使用纯代码方式" class="headerlink" title="4.1.2 使用纯代码方式"></a>4.1.2 使用纯代码方式</h4><p>我们可以通过 sysctl 函数获得进程的有关信息，其中就包括进程创建的时间戳(即 exec 函数执行的时间戳)，这个时间戳就是 pre-main 阶段的起始点，然后再在项目中 的 main 函数处获取此时的时间戳，<code>main函数中的时间戳</code> - <code>进程创建的时间戳</code>即是用代码方式得到的 pre-main 时长。</p>
<p>main.m 中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">        gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">long</span> timeStamp = tv.tv_sec * <span class="number">1000</span> + tv.tv_usec / <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main函数中的时间戳：%ld\n&quot;</span>, timeStamp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> UIApplicationMain(argc, argv, nil, NSStringFromClass([EcmcAppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>AppDelegate.m 中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> start = [<span class="keyword">self</span> processStartTime];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;进程创建的时间戳：%ld\n&quot;</span>, start);</span><br><span class="line">    </span><br><span class="line">  	...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)processInfoForPID:(<span class="keyword">int</span>)pid procInfo:(<span class="keyword">struct</span> kinfo_proc*)procInfo &#123;</span><br><span class="line">    <span class="keyword">int</span> cmd[<span class="number">4</span>] = &#123;<span class="built_in">CTL_KERN</span>, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size = <span class="keyword">sizeof</span>(*procInfo);</span><br><span class="line">    <span class="keyword">return</span> sysctl(cmd, <span class="keyword">sizeof</span>(cmd)/<span class="keyword">sizeof</span>(*cmd), procInfo, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">long</span>)processStartTime &#123;</span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc kProcInfo;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> processInfoForPID:[[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        <span class="keyword">return</span> kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * <span class="number">1000.0</span> + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@&quot;无法取得进程的信息&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-优化"><a href="#4-2-优化" class="headerlink" title="4.2 优化"></a>4.2 优化</h3><p>我们可以分析出一些影响 T1 时间的因素：</p>
<ol>
<li>动态库加载越多，启动越慢。</li>
<li>ObjC 类，方法越多，启动越慢。</li>
<li>ObjC 的 +load 越多，启动越慢。</li>
<li>C 的 constructor 函数越多，启动越慢。</li>
<li>C++ 静态对象越多，启动越慢。</li>
</ol>
<p>那么总结一下 pre-main 阶段我们能做的事情：</p>
<ul>
<li><p>Load dylibs 阶段：减少或者合并 dylibs，将动态库换成静态库</p>
</li>
<li><p>Rebase &amp; Bind 阶段：减少类、方法、分类数量</p>
</li>
<li><p>Objc setup 阶段：无事可做</p>
</li>
<li><p>Initializers 阶段：①少在类的 +load 方法里做事情，尽量把这些事情推迟到 +initiailize；②减少构造器函数（constructor）；③减少 C++ 静态全局变量</p>
</li>
</ul>
<h4 id="4-2-1-优化库"><a href="#4-2-1-优化库" class="headerlink" title="4.2.1 优化库"></a>4.2.1 优化库</h4><p>推动把项目中使用的动态库改为静态库。</p>
<p>去掉一些不必要的库：创建一个新的工程，使用 pod 将主项目中的每个库逐个导入进新项目，然后使用前面提到的两种时长测量方式统计每个库带来的 pre-main 耗时，对于那些不重要的，但是却在 pre-main 阶段耗时达几十毫秒的库就可以移除并自己手写。</p>
<h4 id="4-2-2-代码瘦身"><a href="#4-2-2-代码瘦身" class="headerlink" title="4.2.2 代码瘦身"></a>4.2.2 代码瘦身</h4><p>工程中经常有无用的代码和文件被遗弃在角落里，没有及时被清理掉。这些无用的部分一方面增大了 App 的包体积，另一方便也拖慢了 App 的冷启动速度，所以及时清理掉这些无用的代码和资源十分有必要。</p>
<p>在这里我们使用<a target="_blank" rel="noopener" href="https://github.com/speam/SelectorsUnrefs">SelectorsUnrefs</a>来筛选项目中未使用到的方法。</p>
<p><strong>使用方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python FindSelectorsUnrefs.py -a &#x2F;Users&#x2F;...&#x2F;Build&#x2F;Products&#x2F;Debug-iphonesimulator&#x2F;XXX.app -p &#x2F;Users&#x2F;...&#x2F;ProjectPath -w WB,JD</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数说明</p>
<p>-a Xcode运行之后的，项目 Product 的路径</p>
<p>-p 项目的路径</p>
<p>-w 结果白名单处理（可不加）。检测结果只想要以什么开头的类的方法，多个用逗号隔开，比如JD,BD,AL</p>
<p>-b 结果黑名单处理（可不加）。检测结果不想要以什么开头的类的方法，多个用逗号隔开，比如Pod,AF,SD</p>
<p>-w 和 -b 不能共存，共存会报错</p>
</blockquote>
<p><strong>运行结果示例</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">获取所有的protocol中的方法...</span><br><span class="line">获取所有被调用的方法...</span><br><span class="line">获取所有的方法，除了setter and getter方法...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查找到未被使用的方法: 5074个</span><br><span class="line"></span><br><span class="line">1 : -[PNColor imageFromColor:]</span><br><span class="line">2 : +[CMAllMediaVoiceDictationConfig isDot]</span><br><span class="line">3 : +[UIImage(PMExtension) imageNamedForOriginal:bundel:]</span><br><span class="line">4 : -[NSObject(LKModel) setValue:forUndefinedKey:]</span><br><span class="line">5 : -[NSString(MGPAdd) enumerateUTF32CharInRange:usingBlock:]</span><br><span class="line">6 : +[IFlyResourceUtil ENGINE_DESTROY]</span><br><span class="line">7 : +[ShareSDK(SSUI) showShareActionSheet:customItems:sheetConfiguration:onStateChanged:]</span><br><span class="line">8 : +[SAPassThroughValueTransformer allowsReverseTransformation]</span><br><span class="line">9 : -[NSData(MIGUSSZipArchive) _migubase64RFC4648]</span><br><span class="line">10 : -[MCOIMAPBaseOperation isUrgent]</span><br><span class="line">11 : +[XWSignStore loadURL]</span><br><span class="line">12 : -[NSData(WYEncryption) WYAES128DecryptWithMD5Key:]</span><br><span class="line">...</span><br><span class="line">5069 : -[UIView(IQToolbarAddition) addPreviousNextRightOnKeyboardWithTarget:rightButtonTitle:previousAction:nextAction:rightButtonAction:]</span><br><span class="line">5070 : +[IFlyVerifierUtil ARGBToGray:]</span><br><span class="line">5071 : -[ASLoginEngine getVerifyCode:]</span><br><span class="line">5072 : -[UICKeyChainStore(Deprecation) synchronizeWithError:]</span><br><span class="line">5073 : -[SSDKRegister setupPocketWithConsumerKey:redirectUrl:]</span><br><span class="line">5074 : +[UIImage(GIF) sd_imageWithGIFData:]</span><br><span class="line"></span><br><span class="line">项目中未使用方法检测完毕，相关结果存储到当前目录 selector_unrefs.txt 中</span><br><span class="line">请在项目中进行二次确认后处理</span><br></pre></td></tr></table></figure>



<p><strong>缺陷：</strong></p>
<ol>
<li><p>方法1调用方法2，但是没有类调用方法1。只能检测出方法1，将方法1删除之后才会检测出方法2，所以需要检测多次</p>
</li>
<li><p>Swift 测不到</p>
</li>
<li><p>C 语言方法检测不到，会被认为是已使用方法</p>
</li>
<li><p>通过字符串转化成 Selector 检测不到，会被认为是为被调用的方法</p>
</li>
</ol>
<h4 id="4-2-3-二进制重排"><a href="#4-2-3-二进制重排" class="headerlink" title="4.2.3 二进制重排"></a>4.2.3 二进制重排</h4><h5 id="①前言"><a href="#①前言" class="headerlink" title="①前言"></a>①前言</h5><p>要实施二进制重排，首先要了解<strong>虚拟内存：</strong></p>
<p>应用程序的可执行文件是装在磁盘上的，启动应用，则需要将可执行文件加载进内存,早期计算机是没有虚拟内存的，一旦加载，就会全部加载到内存中，并且进程都是按照顺序在物理内存上排列的，这样就会导致两个问题：</p>
<p>1.由于地址连续，所以上一个进程的地址加一些地址就能访问到下一个进程，安全性很低。</p>
<p>2.软件越来越大，开启多个软件时直接全部加载进内存会导致内存不够用，而且我们使用软件的时候只使用其中一部分的功能，如果软件一打开就全部加载到内存，会很浪费内存空间。基于以上两个原因，虛拟内存技术出现了。</p>
<p>每个进程在创建加载时，会被分配一个1-2倍真实内存大小的连续的虛拟地址空间，让当前软件认为自己有拥有一大片内存空间，实际上是把磁盘的一部分作为假想内存来使用。</p>
<p>虚拟内存和实际内存是通过一张页表来关联的。程序在加载时，会根据 page 大小（16kb）将程序分割成一页一页的，启动时部分的页加载进真实内存，部分页在虚拟内存（磁盘）中，中间的调度记录在一张页表内，这个页表的作用主要是用来调度磁盘与内存两者之间数据的交换，如下图：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/adsfasdf13452134.png"></p>
<p>系统使用某一页内存时，先去页表中查找，如果页表的标记为1，代表该页数据已经在内存中，就可以直接访问对应的物理内存；如果页表标记为0，说明数据未在物理内存上，这时候系统会阻塞进程，这个行为叫做**缺页中断 (page fault )**，等将对应<br>的 page 从虚拟内存（磁盘）加载进物理内存之后再进行访问，这个过程称为 page in，如果此时内存不够用，系统会通过判断覆盖掉不活跃的部分。如下图：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714212000142.png"></p>
<p>因为磁盘的访问速度较慢，page fault 发生后的 page in 这个操作比较耗时，并且 iOS 不仅仅是将数据加载到内存，还要对这页做签名认证，所以 iOS 耗时更长，那么如果我们把所有启动时候的代码都放在前一两页，这样就不会频繁出现 page fault，减少了 page in 的次数，这样就能一定程度上优化启动速度，这种方法就叫做二进制重排。</p>
<h5 id="②使用Instrument得到应用启动时的page-in"><a href="#②使用Instrument得到应用启动时的page-in" class="headerlink" title="②使用Instrument得到应用启动时的page in"></a>②使用Instrument得到应用启动时的page in</h5><p>启动 Instrument，选中 System Trace，调试应用的启动阶段，然后选应用的 MainThread，然后下面选择 Summary:Virtual Memory，然后就能看到未进行二进制重排时应用启动的 Page In 的次数和耗时。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png"></p>
<blockquote>
<p>注意：如果我们的应用启动一次后，杀死应用，然后接着重新启动，再次测试，发现这次的 Page In 的数量会减少。这是因为手机内存中存在上次启动的缓存。在这里需要应用冷启动进行测试，要么重装，要么多开几个其他应用等系统杀掉这个应用的进程。</p>
</blockquote>
<h5 id="③查看整个项目的符号顺序"><a href="#③查看整个项目的符号顺序" class="headerlink" title="③查看整个项目的符号顺序"></a>③查看整个项目的符号顺序</h5><p>在 Xcode 的 Build Setting 设置中搜索 Link Map，Link Map 就是我们链接的符号表，然后将 Write Link Map FIle 设置为 YES，这样编译的时候就会把链接的符号表给我们写出来</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224506249.png"></p>
<p>重新 build 一下，然后我们就可以到对象的目录下去查找 link map 文件了。文件目录位于 Products 同级目录 Intermediates.noindex/项目名.build/Debug-Debug-iphoneos/项目名.build/<em>LinkMap</em>.text 文件。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714224616613.png"></p>
<p>LinkMap 文件内容主要是链接的文件、函数等相关内容。<br> 主要包含三部分：</p>
<ol>
<li><code># Object files</code>:生成的.o文件，按照顺序排列；</li>
<li><code># Sections</code>: 代码块、数据块的地址以及大小；</li>
<li><code># Symbols</code>:函数的地址、占用大小、所属的文件以及函数名，按照编译的顺序排列。</li>
</ol>
<p>我们要找的符号顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># Address	Size    	File  Name</span><br><span class="line">0x100007AC0	0x0000020C	[  2] -[NSData(WTProtectedAdditionsAES) wt_AES256EncryptWithKey:]</span><br><span class="line">0x100007CCC	0x00000210	[  2] -[NSData(WTProtectedAdditionsAES) wt_AES256DecryptWithKey:]</span><br><span class="line">0x100007EDC	0x000001FC	[  2] -[NSData(WTProtectedAdditionsAES) initVectorWithLength:]</span><br><span class="line">0x1000080D8	0x00000280	[  2] -[NSData(WTProtectedAdditionsAES) getUniqueId]</span><br><span class="line">0x100008358	0x00000044	[  3] -[NSDate(WTProtectedAdditions) wt_timestamp]</span><br><span class="line">0x10000839C	0x000000B8	[  3] -[NSDate(WTProtectedAdditions) wt_timestampString]</span><br><span class="line">0x100008454	0x0000004C	[  3] +[NSDate(WTProtectedAdditions) wt_dateWithWTTimestamp:]</span><br><span class="line">0x1000084A0	0x00000090	[  4] +[UIResponder(WTAutomatics) load]</span><br><span class="line">0x100008530	0x000000B4	[  4] +[UIResponder(WTAutomatics) swizzleAppDelegateMethods]</span><br><span class="line">0x1000085E4	0x000002E4	[  4] ___54+[UIResponder(WTAutomatics) swizzleAppDelegateMethods]_block_invoke</span><br><span class="line">0x1000088C8	0x00000014	[  4] ___copy_helper_block_</span><br><span class="line">0x1000088DC	0x00000010	[  4] ___destroy_helper_block_</span><br><span class="line">0x1000088EC	0x00000208	[  4] +[UIResponder(WTAutomatics) wt_swizzleAppDelegate:with:forProtocol:]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>从上面的 Symbols 可以看出，函数加载的顺序是按照文件顺序来排列的。我们二进制重排就需要把这里面的顺序改为应用启动时调用方法的符号顺序，但是我们怎么知道应用启动时调用了哪些方法呢？</p>
<h5 id="④获得应用启动时调用方法的符号"><a href="#④获得应用启动时调用方法的符号" class="headerlink" title="④获得应用启动时调用方法的符号"></a>④获得应用启动时调用方法的符号</h5><p>我们可以在 Xcode 进行二进制重排的操作，Xcode 使用的链接器叫做 ld，ld 有个不常用的参数叫 order_file，这个文件中的符号会按照顺序排列在对应 section 的开始，二进制重排排的就是这里面的符号顺序。</p>
<p>我们可以将文件的路径告诉 Xcode，在 order_file 文件中把符号的顺序写进去，之后 Xcode 编译的时候就会按照文件中的符号顺序打包成二进制可执行文件。</p>
<p>现在我们需要获取应用启动时调用方法的顺序作为符号顺序，有两种方式：</p>
<p><strong>方式一：通过 fishhook 拦截 objc_msgSend() 函数</strong></p>
<p>fishhook 可以 hook 系统函数，而所有的 OC 方法调用都会执行 objc_msgSend() 这个方法，所有通过拦截 objc_msgSend() 就可以 hook 所有的 OC 方法。但是因为 objc_msgSend() 的参数是可变的，所以无法直接过去到第二个参数(也就是 OC 方法的 SEL)，只能通过寄存器获取，那么就需要使用汇编代码了。可以参考抖音团队的文章：<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q">https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q</a></p>
<p>通过上面的动态 hook 的方式，我们只能拦截 OC 的方法。而通过 clang 插桩的方式不仅可以 Hook OC 方法，可以 hook 函数、block 等，实现全部的 hook。</p>
<p><strong>方式二：clang插桩</strong>【采用】</p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/SanitizerCoverage.html">clang</a></p>
<p>LLVM 有个代码覆盖的工具在 SanitizerCoverage 中，它可以覆盖我们自定义的所有的方法、bloc、函数，也就是在我们所有的自定义方法中插入一个回调方法，这样任何自定义方法的调用都会调用回调函数。</p>
<p>使用方式：</p>
<ul>
<li><p>首先在 Build Setting 中的 Other C Flag 中添加<code>-fsanitize-coverage=func,trace-pc-guard</code></p>
</li>
<li><p>然后在任意的类中实现下面两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(uint32_t *start,</span><br><span class="line">                                                    uint32_t *stop) &#123;</span><br><span class="line">  <span class="keyword">static</span> uint64_t N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  printf(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (uint32_t *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!*guard) <span class="keyword">return</span>;  <span class="comment">// Duplicate the guard check.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过断点查看汇编代码发现，编译器会在所有自定义方法中插入<code>__sanitizer_cov_trace_pc_guard</code>函数的调用：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715091804019.png"></p>
<p>由于底层实现中每一个函数调用完成后都会返回下一个需要调用的函数的地址，所以<code>__sanitizer_cov_trace_pc_guard</code>中的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>拿到的就是下一个要调用的函数的地址，又因为<code>__sanitizer_cov_trace_pc_guard</code>函数都是在 hook 函数前执行的，所以在这里面拿到的函数地址就是我们 hook 的函数地址。既然能拿到函数地址，我们就可以通过这个函数去拿到函数名称等一系列的信息，这样就拿到了我们需要的符号。拿到符号之后就需要统一保存起来，完整代码：</p>
<h5 id="⑤拿启动时函数符号并保存的完整代码"><a href="#⑤拿启动时函数符号并保存的完整代码" class="headerlink" title="⑤拿启动时函数符号并保存的完整代码"></a>⑤拿启动时函数符号并保存的完整代码</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原子队列</span></span><br><span class="line"><span class="keyword">static</span>  OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;</span><br><span class="line"><span class="comment">//定义符号结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *pc;</span><br><span class="line">    <span class="keyword">void</span> *next;</span><br><span class="line">&#125;SYNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(uint32_t *start,</span><br><span class="line">                                                    uint32_t *stop) &#123;</span><br><span class="line">  <span class="keyword">static</span> uint64_t N;  <span class="comment">// Counter for the guards.</span></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;  <span class="comment">// Initialize only once.</span></span><br><span class="line">  printf(<span class="string">&quot;INIT: %p %p\n&quot;</span>, start, stop);</span><br><span class="line">  <span class="keyword">for</span> (uint32_t *x = start; x &lt; stop; x++)</span><br><span class="line">    *x = ++N;  <span class="comment">// Guards should start from 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(uint32_t *guard) &#123;</span><br><span class="line"><span class="comment">//    if (!*guard) return;  </span></span><br><span class="line">    <span class="comment">/*在这里做判断，哪里开始 到哪里结束*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *PC = __builtin_return_address(<span class="number">0</span>);</span><br><span class="line">    SYNode *node = malloc(<span class="keyword">sizeof</span>(SYNode));</span><br><span class="line">    *node = (SYNode)&#123;PC,<span class="literal">NULL</span>&#125;;</span><br><span class="line">    OSAtomicEnqueue(&amp;symbolList, node, offsetof(SYNode, next));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="built_in">NSMutableArray</span> &lt;<span class="built_in">NSString</span> *&gt; * symbolNames = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        SYNode * node = OSAtomicDequeue(&amp;symbolList, offsetof(SYNode, next));</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Dl_info info;</span><br><span class="line">        dladdr(node-&gt;pc, &amp;info);</span><br><span class="line">        <span class="built_in">NSString</span> * name = @(info.dli_sname);</span><br><span class="line">        <span class="built_in">BOOL</span>  isObjc = [name hasPrefix:<span class="string">@&quot;+[&quot;</span>] || [name hasPrefix:<span class="string">@&quot;-[&quot;</span>];</span><br><span class="line">        <span class="built_in">NSString</span> * symbolName = isObjc ? name: [<span class="string">@&quot;_&quot;</span> stringByAppendingString:name];</span><br><span class="line">        [symbolNames addObject:symbolName];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="built_in">NSEnumerator</span> * emt = [symbolNames reverseObjectEnumerator];</span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *funcs = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:symbolNames.count];</span><br><span class="line">    <span class="built_in">NSString</span> * name;</span><br><span class="line">    <span class="keyword">while</span> (name = [emt nextObject]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![funcs containsObject:name]) &#123;</span><br><span class="line">            [funcs addObject:name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 排除当前函数</span></span><br><span class="line"><span class="comment">//    [funcs removeObject:[NSString stringWithFormat:@&quot;%s&quot;,__FUNCTION__]];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数组变成字符串</span></span><br><span class="line">    <span class="built_in">NSString</span> * funcStr = [funcs  componentsJoinedByString:<span class="string">@&quot;\n&quot;</span>];</span><br><span class="line">    <span class="comment">// 写入文件到本地</span></span><br><span class="line">    <span class="built_in">NSString</span> * filePath = [<span class="built_in">NSTemporaryDirectory</span>() stringByAppendingPathComponent:<span class="string">@&quot;test.order&quot;</span>];</span><br><span class="line">    <span class="built_in">NSData</span> * fileContents = [funcStr dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] createFileAtPath:filePath contents:fileContents attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;order文件路径：%@&quot;</span>, filePath);</span><br><span class="line"><span class="comment">//    NSLog(@&quot;%@&quot;,funcStr);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行应用，打印出 test.order 文件的路径，前往查看此文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+[XWDevice load]</span><br><span class="line">+[XWConfigNavigationBar load]</span><br><span class="line">+[UIColor(extend) getColor:]</span><br><span class="line">+[UIImage(extend) createImageWithColor:]</span><br><span class="line">_CGRectMake</span><br><span class="line">_UIOffsetMake</span><br><span class="line">+[BaseModel load]</span><br><span class="line">___copy_helper_block_e8_</span><br><span class="line">___copy_helper_block_e8_32w</span><br><span class="line">___copy_helper_block_e8_32s40b</span><br><span class="line">___copy_helper_block_e8_32b</span><br><span class="line">___destroy_helper_block_e8_32s40s</span><br><span class="line">+[UIButton(UITableViewRowAction) load]</span><br><span class="line">+[NSObject(AOP) aop_changeMethod:newMethod:]</span><br><span class="line">+[UITextField(padding) load]</span><br><span class="line">___28+[UITextField(padding) load]_block_invoke</span><br><span class="line">+[UINavigationController(AOP) load]</span><br><span class="line">__ZNSt3__127__tree_balance_after_insertIPNS_16__tree_node_baseIPvEEEEvT_S5_</span><br><span class="line">__ZNKSt3__116__tree_node_baseIPvE15__parent_unsafeEv</span><br><span class="line">__ZNSt3__1L20__tree_is_left_childIPNS_16__tree_node_baseIPvEEEEbT_</span><br><span class="line">__ZNSt3__119__tree_right_rotateIPNS_16__tree_node_baseIPvEEEEvT_</span><br><span class="line">__ZNSt3__116__tree_node_baseIPvE12__set_parentEPS2_</span><br><span class="line">__ZNSt3__118__tree_left_rotateIPNS_16__tree_node_baseIPvEEEEvT_</span><br><span class="line">__ZN2VA4Json5ValueC1ENS0_9ValueTypeE</span><br><span class="line">__ZN2VA4Json5ValueC2ENS0_9ValueTypeE</span><br><span class="line">__ZN2VA4Json5Value9initBasicENS0_9ValueTypeEb</span><br><span class="line">_main</span><br><span class="line">-[UIButton(UITableViewRowAction) aop_setTitle:forState:]</span><br><span class="line">___copy_helper_block_e8_32s40s</span><br><span class="line">-[EcmcAppDelegate application:didFinishLaunchingWithOptions:]</span><br><span class="line">-[EcmcAppDelegate setWindow:]</span><br><span class="line">-[EcmcAppDelegate window]</span><br><span class="line">-[EcmcAppDelegate root]</span><br><span class="line">-[EcmcAppDelegate application:supportedInterfaceOrientationsForWindow:]</span><br><span class="line">-[EcmcAppDelegate keyWindow]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="⑥让项目使用我们的-order-file"><a href="#⑥让项目使用我们的-order-file" class="headerlink" title="⑥让项目使用我们的 order file"></a>⑥让项目使用我们的 order file</h5><p>在项目的 Build setting 中搜索 order file，然后将 test.order 路径添加进去，在这里我们写的是项目的根目录，即<code>./test.order</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122616789.png"></p>
<p>然后把上一步得到的 test.order 放到项目的根目录中：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715122742992.png"></p>
<p>这样 Xcode 在编译时候就会按照 test.order 文件中的符号顺序链接代码了，我们编译一下，再看一下 LinkMap-normal-arm64.txt 文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Symbols:</span><br><span class="line"># Address	Size    	File  Name</span><br><span class="line">0x100005D00	0x0000009C	[266] +[XWDevice load]</span><br><span class="line">0x100005D9C	0x00000380	[306] +[XWConfigNavigationBar load]</span><br><span class="line">0x10000611C	0x000002C4	[686] +[UIColor(extend) getColor:]</span><br><span class="line">0x1000063E0	0x0000011C	[826] +[UIImage(extend) createImageWithColor:]</span><br><span class="line">0x1000064FC	0x00000084	[ 78] _CGRectMake</span><br><span class="line">0x100006580	0x00000054	[306] _UIOffsetMake</span><br><span class="line">0x1000065D4	0x00000074	[1207] +[BaseModel load]</span><br><span class="line">0x100006648	0x0000003C	[320] ___copy_helper_block_e8_</span><br><span class="line">0x100006684	0x00000050	[ 79] ___copy_helper_block_e8_32w</span><br><span class="line">0x1000066D4	0x00000074	[274] ___copy_helper_block_e8_32s40b</span><br><span class="line">0x100006748	0x00000054	[136] ___copy_helper_block_e8_32b</span><br><span class="line">0x10000679C	0x0000005C	[ 78] ___destroy_helper_block_e8_32s40s</span><br><span class="line">0x1000067F8	0x0000005C	[563] +[UIButton(UITableViewRowAction) load]</span><br><span class="line">0x100006854	0x0000009C	[158] +[NSObject(AOP) aop_changeMethod:newMethod:]</span><br><span class="line">0x1000068F0	0x000000BC	[700] +[UITextField(padding) load]</span><br><span class="line">0x1000069AC	0x00000228	[700] ___28+[UITextField(padding) load]_block_invoke</span><br><span class="line">0x100006BD4	0x00000060	[1143] +[UINavigationController(AOP) load]</span><br><span class="line">0x100006C34	0x0000024C	[614] __ZNSt3__127__tree_balance_after_insertIPNS_16__tree_node_baseIPvEEEEvT_S5_</span><br><span class="line">0x100006E80	0x00000038	[614] __ZNKSt3__116__tree_node_baseIPvE15__parent_unsafeEv</span><br><span class="line">0x100006EB8	0x0000004C	[614] __ZNSt3__1L20__tree_is_left_childIPNS_16__tree_node_baseIPvEEEEbT_</span><br><span class="line">0x100006F04	0x000000C8	[614] __ZNSt3__119__tree_right_rotateIPNS_16__tree_node_baseIPvEEEEvT_</span><br><span class="line">0x100006FCC	0x00000048	[614] __ZNSt3__116__tree_node_baseIPvE12__set_parentEPS2_</span><br><span class="line">0x100007014	0x000000CC	[614] __ZNSt3__118__tree_left_rotateIPNS_16__tree_node_baseIPvEEEEvT_</span><br><span class="line">0x1000070E0	0x00000050	[614] __ZN2VA4Json5ValueC1ENS0_9ValueTypeE</span><br><span class="line">0x100007130	0x000000DC	[614] __ZN2VA4Json5ValueC2ENS0_9ValueTypeE</span><br><span class="line">0x10000720C	0x00000094	[614] __ZN2VA4Json5Value9initBasicENS0_9ValueTypeEb</span><br><span class="line">0x1000072A0	0x00000098	[185] _main</span><br><span class="line">0x100007338	0x00000258	[563] -[UIButton(UITableViewRowAction) aop_setTitle:forState:]</span><br><span class="line">0x100007590	0x00000074	[ 78] ___copy_helper_block_e8_32s40s</span><br><span class="line">0x100007604	0x00000820	[930] -[EcmcAppDelegate application:didFinishLaunchingWithOptions:]</span><br><span class="line">0x100007E24	0x00000060	[930] -[EcmcAppDelegate setWindow:]</span><br><span class="line">0x100007E84	0x0000004C	[930] -[EcmcAppDelegate window]</span><br><span class="line">0x100007ED0	0x000000E8	[930] -[EcmcAppDelegate root]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们发现是按照 test.order 的符号顺序来的，而且如果 order 里面写了项目中不存在的方法符号，XCode 会自动过滤掉，不影响。</p>
<h5 id="⑦-swift的处理"><a href="#⑦-swift的处理" class="headerlink" title="⑦(swift的处理)"></a>⑦(swift的处理)</h5><p>项目如果是用的 swift 的话，我们需在 Building Setting 中的 Other Swift Flags 中添加<code>-sanitize-coverage=func</code>和<code>-sanitize=undefined</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/5177724-47d666821d7c49aa.png"></p>
<p> 因为swift的命名空间的原因，swift函数的名字显示不太友好，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_<span class="variable">$s9TraceDemo9SwiftTestC05swiftD4LoadyyFZTo</span></span><br><span class="line">_<span class="variable">$s9TraceDemo9SwiftTestC05swiftD4LoadyyFZ</span></span><br><span class="line">_<span class="variable">$ss5print_9separator10terminatoryypd_S2StFfA0_</span></span><br><span class="line">_<span class="variable">$ss5print_9separator10terminatoryypd_S2StFfA1_</span></span><br></pre></td></tr></table></figure>

<h5 id="⑧还原Other-C-Flags设置"><a href="#⑧还原Other-C-Flags设置" class="headerlink" title="⑧还原Other C Flags设置"></a>⑧还原Other C Flags设置</h5><p>前面的步骤都完成后，要将 Other C Flags 和 Other Swift Flags 中做的配置去掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OC 配置的是 -fsanitize-coverage&#x3D;func,trace-pc-guard</span><br><span class="line"></span><br><span class="line">Swift 配置的是 -sanitize-coverage&#x3D;func 和 -sanitize&#x3D;undefined</span><br></pre></td></tr></table></figure>

<p>因为只要存在这个配置，编译器每次编译的时候都会进行插桩，会影响启动速度。</p>
<h5 id="⑨重新冷启动，再次查看page-in"><a href="#⑨重新冷启动，再次查看page-in" class="headerlink" title="⑨重新冷启动，再次查看page in"></a>⑨重新冷启动，再次查看page in</h5><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715123751080.png"></p>
<p>与之前的进行对比：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210714220057680.png"></p>
<p>减少了795次 page in，少了0.15s，略有成效，这样我们就完成了二进制重排。</p>
<h2 id="五、准备和渲染首页阶段分析"><a href="#五、准备和渲染首页阶段分析" class="headerlink" title="五、准备和渲染首页阶段分析"></a>五、准备和渲染首页阶段分析</h2><p>这一阶段的优化主要是减少<code>didFinishLaunchingWithOptions</code>方法里的工作，在此方法里，我们会创建应用的 window，指定其 rootViewController，调用 window 的<code>makeKeyAndVisible</code>方法让其可见。由于业务需要，我们会初始化各个第二方/三方库，设置系统 UI 风格，检查是否需要显示引导页、是否需要登录、是否有新版本等。这里的代码容易变得比较庞大，启动耗时难以控制。</p>
<p>所以，满足业务需要的前提下，<code>didFinishLaunchingWithOptions</code>在主线程里做的事情越少越好。我们可优化项：</p>
<ul>
<li><p>梳理各个第二方/三方库，找到可以延迟加载的库，做延迟加载处理，比如放到首页控制器的<code>viewDidAppear</code>方法里。</p>
</li>
<li><p>梳理业务逻辑，把可以延迟执行的逻辑，做延迟执行处理。比如检查新版本、注册推送通知等逻辑。</p>
</li>
<li><p>避免复杂/多余的计算。</p>
</li>
<li><p>采用性能更好的 API。</p>
</li>
<li><p>避免在首页控制器的<code>viewDidLoad</code>和<code>viewWillAppear</code>做太多事情，这2个方法执行完，首页控制器才能显示，部分可以延迟创建的视图应做延迟创建/懒加载处理。</p>
</li>
</ul>
<h2 id="六、准备和渲染首页阶段阶段优化"><a href="#六、准备和渲染首页阶段阶段优化" class="headerlink" title="六、准备和渲染首页阶段阶段优化"></a>六、准备和渲染首页阶段阶段优化</h2><h3 id="6-1-时长测量"><a href="#6-1-时长测量" class="headerlink" title="6.1 时长测量"></a>6.1 时长测量</h3><h4 id="方式一：代码打点"><a href="#方式一：代码打点" class="headerlink" title="方式一：代码打点"></a>方式一：代码打点</h4><p>使用插桩打点的方式通过 NSLog 统计每个方法执行的时间，对耗时高的进行耗时细分，可延后的进行延后。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过这个方式来统计每个方法同步的耗时</span></span><br><span class="line"><span class="built_in">CFAbsoluteTime</span> start = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">[<span class="keyword">self</span> doSomething];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;doSomething : %f&quot;</span>,<span class="built_in">CFAbsoluteTimeGetCurrent</span>() - start);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以在main函数调用的时候设置一个全局开始时间，</span></span><br><span class="line"><span class="comment">// 在其他类里面通过extern关键字取main的时间，如在main.m内:</span></span><br><span class="line"><span class="built_in">CFAbsoluteTime</span> kAppStartTime;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    kAppStartTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// someClass.m</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">CFAbsoluteTime</span> kAppStartTime;</span><br><span class="line"><span class="built_in">CFAbsoluteTime</span> duration = (<span class="built_in">CFAbsoluteTimeGetCurrent</span>() - kAppStartTime);</span><br></pre></td></tr></table></figure>

<h4 id="方式二：App-Launch-工具"><a href="#方式二：App-Launch-工具" class="headerlink" title="方式二：App Launch 工具"></a>方式二：App Launch 工具</h4><ul>
<li><p>首先在 Xcode 的 build settings 中 Debug Information Format 设置为 DWARF with dsYM File (用于符号化地址)</p>
</li>
<li><p>command + i –&gt; Instruments –&gt; APP Launch 启动应用</p>
</li>
<li><p>如果得到的分析数据没有符号化，在APP Launch选择屏幕左上角的file –&gt; Symbols 选择亮绿灯的符号, 重新在在APP Launch运行项目。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210715170912891.png"></p>
<p>得出主线程的所有任务耗时时间，每个任务根据图右侧的堆栈挨个排查是否是启动链路中可优化的（几毫秒的也别放过）。</p>
<h3 id="6-2-优化串行操作"><a href="#6-2-优化串行操作" class="headerlink" title="6.2 优化串行操作"></a>6.2 优化串行操作</h3><p>在冷启动过程中，有很多操作是串行执行的，若干个任务串行执行，时间必然比较长。如果能变串行为并行，那么冷启动时间就能够大大缩短。</p>
<h4 id="启动页的使用"><a href="#启动页的使用" class="headerlink" title="启动页的使用"></a>启动页的使用</h4><p>现在许多App在启动时并不直接进入首页，而是会向用户展示一个持续一小段时间的启动页，如果使用恰当，这个启动页就能帮我们节省一些启动时间。因为当一个App比较复杂的时候，启动时首次构建App的UI就是一个比较耗时的过程，假定这个时间是0.2秒，如果我们是先构建首页UI，然后再在Window上加上这个启动页，那么冷启动时，App就会实实在在地卡住0.2秒，但是如果我们是先把启动页作为App的RootViewController，那么这个构建过程就会很快。因为启动页只有一个简单的ImageView，而这个ImageView则会向用户展示一小段时间，这时我们就可以利用这一段时间来构建首页UI了，一举两得。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172737346"></p>
<h4 id="缓存定位-amp-首页预请求"><a href="#缓存定位-amp-首页预请求" class="headerlink" title="缓存定位&amp;首页预请求"></a>缓存定位&amp;首页预请求</h4><p>冷启动过程中一个重要的串行流程就是：首页定位–&gt;首页请求–&gt;首页渲染过程，这三个操作占了整个首页加载时间的77%左右，所以想要缩短冷启动时间，就一定要从这三点出发进行优化。</p>
<p>之前串行操作流程如下：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172748356"></p>
<p>优化后的设计，在发起定位的同时，使用客户端缓存定位，进行首页数据的预请求，使定位和请求并行进行。然后当用户真实定位成功后，判断真实定位是否命中缓存定位，如果命中，则刚才的预请求数据有效，这样可以节省大概40%的时间首页加载时间，效果非常明显；如果未命中，则弃用预请求数据，重新请求。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/webp-20210715172759405"></p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/SelectorsUnrefs/tree/master">我 Github 上检测项目未使用到的方法</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8e0b38719278">iOS App冷启动治理：来自美团外卖的实践</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d62db6c082e9">iOS 脚本查看项目未使用到的方法</a></p>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/B8m2HrJwBryR7TasURHq">抖音研发实践：基于二进制文件重排的解决方案，APP 启动速度提升超 15%</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/af714f0b753a">app启动优化</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904095921209351">iOS基于二进制重排的启动优化</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904194877587469#heading-16">iOS 启动优化 + 监控实践</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/09/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/21-LLVM%E5%88%9D%E6%8E%A2/"><span class="level-item">21-LLVM初探</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、背景"><span class="level-left"><span class="level-item">一、背景</span></span></a></li><li><a class="level is-mobile" href="#二、冷启动定义"><span class="level-left"><span class="level-item">二、冷启动定义</span></span></a></li><li><a class="level is-mobile" href="#三、pre-main-阶段分析"><span class="level-left"><span class="level-item">三、pre-main 阶段分析</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#Load-dylibs"><span class="level-left"><span class="level-item">Load dylibs</span></span></a></li><li><a class="level is-mobile" href="#Rebase-amp-Bind"><span class="level-left"><span class="level-item">Rebase &amp; Bind</span></span></a></li><li><a class="level is-mobile" href="#Objc-setup"><span class="level-left"><span class="level-item">Objc setup</span></span></a></li><li><a class="level is-mobile" href="#Initializers"><span class="level-left"><span class="level-item">Initializers</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#四、pre-main-阶段优化"><span class="level-left"><span class="level-item">四、pre-main 阶段优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-时长测量"><span class="level-left"><span class="level-item">4.1 时长测量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-使用-Xcode-自带的静态打印功能"><span class="level-left"><span class="level-item">4.1.1 使用 Xcode 自带的静态打印功能</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-使用纯代码方式"><span class="level-left"><span class="level-item">4.1.2 使用纯代码方式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-优化"><span class="level-left"><span class="level-item">4.2 优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-优化库"><span class="level-left"><span class="level-item">4.2.1 优化库</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-代码瘦身"><span class="level-left"><span class="level-item">4.2.2 代码瘦身</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-二进制重排"><span class="level-left"><span class="level-item">4.2.3 二进制重排</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#①前言"><span class="level-left"><span class="level-item">①前言</span></span></a></li><li><a class="level is-mobile" href="#②使用Instrument得到应用启动时的page-in"><span class="level-left"><span class="level-item">②使用Instrument得到应用启动时的page in</span></span></a></li><li><a class="level is-mobile" href="#③查看整个项目的符号顺序"><span class="level-left"><span class="level-item">③查看整个项目的符号顺序</span></span></a></li><li><a class="level is-mobile" href="#④获得应用启动时调用方法的符号"><span class="level-left"><span class="level-item">④获得应用启动时调用方法的符号</span></span></a></li><li><a class="level is-mobile" href="#⑤拿启动时函数符号并保存的完整代码"><span class="level-left"><span class="level-item">⑤拿启动时函数符号并保存的完整代码</span></span></a></li><li><a class="level is-mobile" href="#⑥让项目使用我们的-order-file"><span class="level-left"><span class="level-item">⑥让项目使用我们的 order file</span></span></a></li><li><a class="level is-mobile" href="#⑦-swift的处理"><span class="level-left"><span class="level-item">⑦(swift的处理)</span></span></a></li><li><a class="level is-mobile" href="#⑧还原Other-C-Flags设置"><span class="level-left"><span class="level-item">⑧还原Other C Flags设置</span></span></a></li><li><a class="level is-mobile" href="#⑨重新冷启动，再次查看page-in"><span class="level-left"><span class="level-item">⑨重新冷启动，再次查看page in</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、准备和渲染首页阶段分析"><span class="level-left"><span class="level-item">五、准备和渲染首页阶段分析</span></span></a></li><li><a class="level is-mobile" href="#六、准备和渲染首页阶段阶段优化"><span class="level-left"><span class="level-item">六、准备和渲染首页阶段阶段优化</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-时长测量"><span class="level-left"><span class="level-item">6.1 时长测量</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#方式一：代码打点"><span class="level-left"><span class="level-item">方式一：代码打点</span></span></a></li><li><a class="level is-mobile" href="#方式二：App-Launch-工具"><span class="level-left"><span class="level-item">方式二：App Launch 工具</span></span></a></li></ul></li><li><a class="level is-mobile" href="#6-2-优化串行操作"><span class="level-left"><span class="level-item">6.2 优化串行操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#启动页的使用"><span class="level-left"><span class="level-item">启动页的使用</span></span></a></li><li><a class="level is-mobile" href="#缓存定位-amp-首页预请求"><span class="level-left"><span class="level-item">缓存定位&amp;首页预请求</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>