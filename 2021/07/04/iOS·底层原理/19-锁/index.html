<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>19-锁 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="19-锁"><meta property="og:url" content="http://evilimo.com/2021/07/04/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/19-%E9%94%81/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120252280.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120313833.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210704093016811.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120353100.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120409673.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120425194.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120438866.png"><meta property="article:published_time" content="2021-07-04T04:05:46.818Z"><meta property="article:modified_time" content="2021-07-06T13:46:06.540Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120252280.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/07/04/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/19-%E9%94%81/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120252280.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120313833.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210704093016811.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120353100.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120409673.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120425194.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120438866.png"],"datePublished":"2021-07-04T04:05:46.818Z","dateModified":"2021-07-06T13:46:06.540Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/07/04/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/19-%E9%94%81/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-04T04:05:46.818Z" title="2021-07-04T04:05:46.818Z">2021-07-04</time>发表</span><span class="level-item"><time dateTime="2021-07-06T13:46:06.540Z" title="2021-07-06T13:46:06.540Z">2021-07-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">19-锁</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h2><h3 id="1-1-线程安全"><a href="#1-1-线程安全" class="headerlink" title="1.1 线程安全"></a>1.1 线程安全</h3><p>当一个线程访问数据的时候，其他的线程不能对其进行访问，直到该线程访问完毕。</p>
<p>换句话说就是在同一时刻，对同一个数据操作的线程只有一个。</p>
<p>而线程不安全，则是在同一时刻可以有多个线程对该数据进行访问，从而得不到预期的结果</p>
<h3 id="1-2-检测安全"><a href="#1-2-检测安全" class="headerlink" title="1.2 检测安全"></a>1.2 检测安全</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120252280.png"></p>
<h3 id="1-3-锁的作用"><a href="#1-3-锁的作用" class="headerlink" title="1.3 锁的作用"></a>1.3 锁的作用</h3><p><code>锁</code>作为一种非强制的机制，被用来保证线程安全。每一个线程在访问数据或者资源前，要先获取（<code>Acquire</code>）锁，并在访问结束之后释放（<code>Release</code>）锁。如果锁已经被占用，其它试图获取锁的线程会等待，直到锁重新可用</p>
<h3 id="1-4-锁的分类"><a href="#1-4-锁的分类" class="headerlink" title="1.4 锁的分类"></a>1.4 锁的分类</h3><p>在iOS中锁的基本种类只有两种：<code>自旋锁</code>、<code>互斥锁</code>，其他的比如<code>条件锁</code>、<code>递归锁</code>、<code>信号量</code>都是上层的封装和实现</p>
<h3 id="1-5-自旋锁"><a href="#1-5-自旋锁" class="headerlink" title="1.5 自旋锁"></a>1.5 自旋锁</h3><p><code>自旋锁</code>：线程==反复检查==锁变量是否可⽤。⼀旦获取了⾃旋锁，线程会⼀直保持该锁，直⾄显式释放⾃旋锁</p>
<h3 id="1-6-互斥锁"><a href="#1-6-互斥锁" class="headerlink" title="1.6 互斥锁"></a>1.6 互斥锁</h3><p><code>互斥锁</code>(Mutual exclusion，缩写<code>Mutex</code>)防止两条线程同时对同一公共资源(比如全局变量)进行读写的机制。当获取锁操作失败时，线程会进入==睡眠==，等待锁释放时被唤醒</p>
<p><code>互斥锁</code>又分为：</p>
<ul>
<li><code>递归锁</code>：可重入，同一个线程在锁释放前可再次获取锁，即可以递归调用</li>
<li><code>非递归锁</code>：不可重入，必须等锁释放后才能再次获取锁</li>
</ul>
<h3 id="1-7-自旋锁和互斥锁的区别"><a href="#1-7-自旋锁和互斥锁的区别" class="headerlink" title="1.7 自旋锁和互斥锁的区别"></a>1.7 自旋锁和互斥锁的区别</h3><ul>
<li><code>自旋锁</code>在线程获取锁但没有获取到时，线程则会一直处于等待状态（忙等待），不会进入休眠</li>
</ul>
<ul>
<li><code>互斥锁</code>在线程获取锁但没有获取到时，线程会进入休眠状态，等锁被释放时线程会被唤醒</li>
</ul>
<h2 id="二、自旋锁"><a href="#二、自旋锁" class="headerlink" title="二、自旋锁"></a>二、自旋锁</h2><h3 id="2-1-OSSpinLock（废弃）"><a href="#2-1-OSSpinLock（废弃）" class="headerlink" title="2.1 OSSpinLock（废弃）"></a>2.1 OSSpinLock（废弃）</h3><p>自从<code>OSSpinLock</code>出现了安全问题之后就废弃了。</p>
<h3 id="2-2-atomic"><a href="#2-2-atomic" class="headerlink" title="2.2 atomic"></a>2.2 atomic</h3><h4 id="2-2-1-atomic原理"><a href="#2-2-1-atomic原理" class="headerlink" title="2.2.1 atomic原理"></a>2.2.1 atomic原理</h4><p>在<a target="_blank" rel="noopener" href="https://www.evilimo.com/2021/03/23/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/13-KVC%E5%8E%9F%E7%90%86/#more">13-KVC原理</a>中提到自动生成的 setter 方法会根据修饰符不同调用不同方法，最后统一调用<code>reallySetProperty</code>方法，其中就有一段关于<code>atomic</code>修饰词的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        object_setClass(self, newValue);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id oldValue;</span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">        newValue = [newValue copyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">        newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">        newValue = objc_retain(newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!atomic) &#123;	<span class="comment">// nonatomic 修饰的属性不会加锁，直接赋值</span></span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// atomic 修饰的属性会加锁</span></span><br><span class="line">        <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">        slotlock.lock();</span><br><span class="line">        oldValue = *slot;</span><br><span class="line">        *slot = newValue;        </span><br><span class="line">        slotlock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比对一下<code>atomic</code>的逻辑分支：</p>
<ul>
<li>原子性修饰的属性进行了<code>spinlock</code>加锁处理</li>
<li>非原子性的属性除了没加锁，其他逻辑与<code>atomic</code>一般无二</li>
</ul>
<p><code>getter</code>方法亦是如此：对 atomic 修饰的属性进行加锁处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="keyword">ptrdiff_t</span> offset, BOOL atomic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain release world</span></span><br><span class="line">    id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line">    <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Atomic retain release world</span></span><br><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    id value = objc_retain(*slot);</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">    <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-atomic修饰的属性绝对安全吗？"><a href="#2-2-2-atomic修饰的属性绝对安全吗？" class="headerlink" title="2.2.2 atomic修饰的属性绝对安全吗？"></a>2.2.2 atomic修饰的属性绝对安全吗？</h4><p><code>atomic</code>只能保证 setter、getter 方法的线程安全，并不能保证数据安全。例：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120313833.png"></p>
<p>如上图所示，被<code>atomic</code>修饰的<code>index变量</code>分别在两次并发异步for循环<code>10000次</code>后输出的结果并不等于<code>20000</code>，出现了线程不安全的情况。</p>
<p>所以：</p>
<ul>
<li><code>atomic</code>保证变量 setter、getter 方法的线程安全</li>
<li>但不能保证<code>self.index+1</code>也是线程安全的</li>
<li>使用时还是要非常小心的，不要天真的以为属性加了<code>atomic</code>后就安全的不行了</li>
</ul>
<h3 id="2-3-读写锁"><a href="#2-3-读写锁" class="headerlink" title="2.3 读写锁"></a>2.3 读写锁</h3><p><code>读写锁</code>实际是一种特殊的<code>自旋锁</code>，它把对共享资源的访问者划分成<code>读者</code>和<code>写者</code>。</p>
<p><code>读者</code>只对共享资源进行读访问，<code>写者</code>则需要对共享资源进行写操作。</p>
<p>一次只有一个线程可以占有写模式，但是可以有多个线程同时占有读模式的读写锁，也就是我们常说的<strong>多读单写。</strong>即读者之间是并发的，写者与其他写者、读者之间是互斥的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)readDataForKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">    __block <span class="keyword">id</span> result;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(_concurrentQueue, ^&#123;</span><br><span class="line">        result = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeData:(<span class="keyword">id</span>)data forKey:(<span class="built_in">NSString</span>*)key &#123;</span><br><span class="line">    dispatch_barrier_async(_concurrentQueue, ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> setValue:data forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>读：<code>并发同步</code>获取到值后返回给读者<ul>
<li>若使用<code>并发异步</code>则会先返回空的<code>result 0x0</code>，再通过getter方法获取到值</li>
</ul>
</li>
<li>写：写的那个时间段，不能有任何读者+其他写者<ul>
<li><code>dispatch_barrier_async</code>满足：等队列中前面的读写任务都执行完了再来执行当前任务</li>
</ul>
</li>
</ul>
<h2 id="三、互斥锁"><a href="#三、互斥锁" class="headerlink" title="三、互斥锁"></a>三、互斥锁</h2><h3 id="3-1-pthread-mutex"><a href="#3-1-pthread-mutex" class="headerlink" title="3.1 pthread_mutex"></a>3.1 pthread_mutex</h3><p>当锁被占用，而其他线程申请锁时，不是使用忙等，而是阻塞线程并睡眠。</p>
<p>使用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入头文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局声明互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> _lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line">pthread_mutex_init(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">pthread_mutex_lock(&amp;_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里做需要线程安全操作</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁 </span></span><br><span class="line">pthread_mutex_unlock(&amp;_lock);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">pthread_mutex_destroy(&amp;_lock);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit/blob/3869686e0e560db0b27a7140188fad771e271508/YYKit/Cache/YYMemoryCache.m">YYKit的YYMemoryCach</a>有使用到<code>pthread_mutex</code></p>
<h3 id="3-2-synchronized"><a href="#3-2-synchronized" class="headerlink" title="3.2 @synchronized"></a>3.2 @synchronized</h3><p><code>@synchronized</code>可能是日常开发中用的比较多的一种互斥锁，因为它的使用比较简单，但并不是在任意场景下都能使用<code>@synchronized</code>，且它的性能较低</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (obj) &#123;</span><br><span class="line">	<span class="comment">// 这里做需要线程安全的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来就通过源码探索来看一下<code>@synchronized</code>在使用中的注意事项</p>
<ul>
<li>通过<strong>汇编</strong>能能定位到<code>objc_sync_enter</code>和<code>objc_sync_exit</code>两个方法</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210704093016811.png"></p>
<h4 id="3-2-1-源码分析"><a href="#3-2-1-源码分析" class="headerlink" title="3.2.1 源码分析"></a>3.2.1 源码分析</h4><p>在<code>objc源码</code>中找到<code>objc_sync_enter</code>和<code>objc_sync_exit</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Allocates recursive mutex associated with &#x27;obj&#x27; if needed.</span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE);</span><br><span class="line">        assert(data);</span><br><span class="line">        data-&gt;mutex.lock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// End synchronizing on &#x27;obj&#x27;. </span></span><br><span class="line"><span class="comment">// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); </span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock();</span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先从它的注释中<code>recursive mutex</code>可以得出<code>@synchronized</code>是递归锁</p>
</li>
<li><p>如果锁的对象<code>obj</code>不存在时分别会走<code>objc_sync_nil()</code>和<code>不做任何操作</code></p>
<p>这也是<code>@synchronized</code>作为递归锁但能防止死锁的原因所在：在不断递归的过程中如果对象不存在了就会停止递归从而防止死锁</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BREAKPOINT_FUNCTION(</span><br><span class="line">    <span class="keyword">void</span> objc_sync_nil(<span class="keyword">void</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<p>正常情况下（obj 存在）会通过<code>id2data</code>方法生成一个<code>SyncData</code>对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> struct <span class="title">alignas</span><span class="params">(CacheLineSize)</span> SyncData </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span>  <span class="comment">// 链表中下一个 SyncData</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object;   <span class="comment">// 当前加锁的对象</span></span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">//  使用该对象进行加锁的线程数</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex;    <span class="comment">// 对象所关联的锁</span></span><br><span class="line">&#125; SyncData;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-id2data方法准备SyncData"><a href="#3-2-2-id2data方法准备SyncData" class="headerlink" title="3.2.2 id2data方法准备SyncData"></a>3.2.2 <code>id2data</code>方法准备SyncData</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">spinlock_t</span> *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class="line">    SyncData* result = <span class="literal">NULL</span>;	<span class="comment">// 准备数据，后续进行填充</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>id2data</code>先将返回对象<code>SyncData类型的result</code>准备好，后续进行数据填充。</p>
<p>看一下这个方法开头的两个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SyncList</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="keyword">spinlock_t</span> lock;</span><br><span class="line"></span><br><span class="line">    constexpr SyncList() : data(nil), lock(fork_unsafe_lock) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中通过两个宏定义去取得<code>SyncList</code>中的<code>data</code>和<code>lock</code>。</p>
<p>既然<code>@synchronized</code>能在任意地方（VC、View、Model等）使用，那么底层必然维护着一张全局的表（类似于 weak 表）。而从<code>SyncList</code>和<code>SyncData</code>的结构可以证实系统确实在底层维护着一张哈希表，里面存储着<code>SyncList结构</code>的数据。<code>sDataLists</code>表结构：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120353100.png"></p>
<h4 id="3-2-3-使用快速缓存"><a href="#3-2-3-使用快速缓存" class="headerlink" title="3.2.3 使用快速缓存"></a>3.2.3 使用快速缓存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    <span class="comment">// Check per-thread single-entry fast cache for matching object</span></span><br><span class="line">    <span class="comment">// 检查每线程单项快速缓存中是否有匹配的对象</span></span><br><span class="line">    <span class="keyword">bool</span> fastCacheOccupied = NO;</span><br><span class="line">    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        fastCacheOccupied = YES;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data-&gt;object == object) &#123;</span><br><span class="line">            <span class="comment">// Found a match in fast cache.</span></span><br><span class="line">            <span class="keyword">uintptr_t</span> lockCount;</span><br><span class="line"></span><br><span class="line">            result = data;</span><br><span class="line">            lockCount = (<span class="keyword">uintptr_t</span>)tls_get_direct(SYNC_COUNT_DIRECT_KEY);</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;id2data fastcache is buggy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE: &#123;</span><br><span class="line">                lockCount++;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                lockCount--;</span><br><span class="line">                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)lockCount);</span><br><span class="line">                <span class="keyword">if</span> (lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from fast cache</span></span><br><span class="line">                    tls_set_direct(SYNC_DATA_DIRECT_KEY, <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个重要的知识点——<code>TLS</code>：<code>TLS</code>全称为<code>Thread Local Storage</code>，每个线程都拥有自己的<code>TLS</code>，负责保存本线程的一些变量， 且<code>TLS</code>无需锁保护</p>
<blockquote>
<p>快速缓存的含义为：定义两个变量<code>SYNC_DATA_DIRECT_KEY</code>/<code>SYNC_COUNT_DIRECT_KEY</code>，与<code>tsl_get_direct</code>/<code>ls_set_direct</code>配合可以从线程局部缓存中快速取得<code>SyncCacheItem.data</code>和<code>SyncCacheItem.lockCount</code></p>
</blockquote>
<p>如果在缓存中找到当前对象，就拿出当前被锁的次数<code>lockCount</code>，再根据传入参数类型(获取、释放、查看)对<code>lockCount</code>分别进行操作</p>
<ul>
<li>获取资源<code>ACQUIRE</code>：<code>lockCount++</code>并根据<code>key</code>值存入被锁次数</li>
<li>释放资源<code>RELEASE</code>：<code>lockCount--</code>并根据<code>key</code>值存入被锁次数。如果次数变为0，此时锁也不复存在，需要从快速缓存移除并清空线程数<code>threadCount</code></li>
<li>查看资源<code>check</code>：不操作</li>
</ul>
<blockquote>
<p>lockCount 表示被锁的次数，意味着能多次进入，从侧面表现出了@synchronized的递归性</p>
</blockquote>
<h4 id="3-2-4-获取该线程下的-SyncCache"><a href="#3-2-4-获取该线程下的-SyncCache" class="headerlink" title="3.2.4 获取该线程下的 SyncCache"></a>3.2.4 获取该线程下的 SyncCache</h4><p>这个逻辑分支是找不到确切的线程标记只能==遍历所有的缓存==</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    SyncCache *cache = fetch_cache(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cache-&gt;used; i++) &#123;</span><br><span class="line">            SyncCacheItem *item = &amp;cache-&gt;<span class="built_in">list</span>[i];</span><br><span class="line">            <span class="keyword">if</span> (item-&gt;data-&gt;object != object) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            result = item-&gt;data;</span><br><span class="line">            <span class="keyword">if</span> (result-&gt;threadCount &lt;= <span class="number">0</span>  ||  item-&gt;lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;id2data cache is buggy&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">switch</span>(why) &#123;</span><br><span class="line">            <span class="keyword">case</span> ACQUIRE:</span><br><span class="line">                item-&gt;lockCount++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RELEASE:</span><br><span class="line">                item-&gt;lockCount--;</span><br><span class="line">                <span class="keyword">if</span> (item-&gt;lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    cache-&gt;<span class="built_in">list</span>[i] = cache-&gt;<span class="built_in">list</span>[--cache-&gt;used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里介绍一下<code>SyncCache</code>和<code>SyncCacheItem</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SyncData *data;             <span class="comment">// 该缓存条目对应的SyncData</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lockCount;     <span class="comment">// 该对象在该线程中被加锁的次数</span></span><br><span class="line">&#125; SyncCacheItem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> allocated;     <span class="comment">// 该缓存此时对应的缓存大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;          <span class="comment">// 该缓存此时对应的已使用缓存大小</span></span><br><span class="line">    SyncCacheItem <span class="built_in">list</span>[<span class="number">0</span>];      <span class="comment">// SyncCacheItem数组</span></span><br><span class="line">&#125; SyncCache;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>SyncCacheItem</code>用来记录某个<code>SyncData</code>在某个线程中被加锁的记录，一个<code>SyncData</code>可以被多个<code>SyncCacheItem</code>持有</li>
<li><code>SyncCache</code>用来记录某个线程中所有<code>SyncCacheItem</code>，并且记录了缓存大小以及已使用缓存大小</li>
</ul>
<h4 id="3-2-5-全局哈希表查找"><a href="#3-2-5-全局哈希表查找" class="headerlink" title="3.2.5 全局哈希表查找"></a>3.2.5 全局哈希表查找</h4><p>快速、慢速流程都没找到缓存就会来到这步——在系统保存的哈希表进行链式查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    lockp-&gt;lock();</span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">for</span> (p = *listp; p != <span class="literal">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ( (firstUnused == <span class="literal">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            result-&gt;object = (objc_object *)object;</span><br><span class="line">            result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.<code>lockp-&gt;lock()</code>并不是在底层对锁进行了封装，而是在查找过程前后进行了加锁操作</p>
<p>2.for循环遍历链表，如果有符合的就 goto done</p>
<p>3.如果是<code>RELEASE</code>或<code>CHECK</code>直接<code>goto done</code></p>
<p>4.如果第二步中有发现第一次使用的的对象就将<code>threadCount</code>标记为1且<code>goto done</code></p>
<h4 id="3-2-6-生成新数据并写入缓存"><a href="#3-2-6-生成新数据并写入缓存" class="headerlink" title="3.2.6 生成新数据并写入缓存"></a>3.2.6 生成新数据并写入缓存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> SyncData* <span class="title">id2data</span><span class="params">(id object, <span class="keyword">enum</span> usage why)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    posix_memalign((<span class="keyword">void</span> **)&amp;result, <span class="keyword">alignof</span>(SyncData), <span class="keyword">sizeof</span>(SyncData));</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> (&amp;result-&gt;mutex) <span class="keyword">recursive_mutex_t</span>(fork_unsafe_lock);</span><br><span class="line">    result-&gt;nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">    lockp-&gt;unlock();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (result-&gt;object != object) _objc_fatal(<span class="string">&quot;id2data is buggy&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">        <span class="keyword">if</span> (!fastCacheOccupied) &#123;</span><br><span class="line">            <span class="comment">// Save in fast thread cache</span></span><br><span class="line">            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);</span><br><span class="line">            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (<span class="keyword">void</span>*)<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">#endif</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].data = result;</span><br><span class="line">            cache-&gt;<span class="built_in">list</span>[cache-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line">            cache-&gt;used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.前三步情况均不满足（即链表不存在——对象对于全部线程来说是第一次加锁）就会创建<code>SyncData</code>并存在<code>result</code>里，方便下次进行存储</p>
<p>2.done分析：</p>
<ul>
<li>先将前面的 lock 锁解开</li>
<li>如果是<code>RELEASE</code>类型直接返回 nil</li>
<li>对<code>ACQUIRE</code>类型和对象的断言判断</li>
<li><code>!fastCacheOccupied</code>分支表示支持快速缓存且快速缓存被占用了，将该<code>SyncCacheItem</code>数据写入快速缓存中</li>
<li>否则将该<code>SyncCacheItem</code>存入该线程对应的<code>SyncCache</code>中</li>
</ul>
<h4 id="3-2-7-疑难解答"><a href="#3-2-7-疑难解答" class="headerlink" title="3.2.7 疑难解答"></a>3.2.7 疑难解答</h4><ol>
<li><p>不能使用<code>非OC对象</code>作为加锁条件——<code>id2data</code>中接收参数为id类型</p>
</li>
<li><p>多次锁同一个对象会有什么后果吗——不会出问题，因为会从高速缓存中拿到 data，所以只会锁一次对象</p>
</li>
<li><p>都说<code>@synchronized</code>性能低——是因为在底层<code>增删改查</code>消耗了大量性能</p>
</li>
<li><p>加锁对象不能为nil，否则加锁无效，就不能保证线程安全了。所以要小心避免加锁对象在代码执行过程中为 nil 的情况。</p>
</li>
<li><p>看一个坑点：</p>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    _testArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.testArray) &#123;</span><br><span class="line">                <span class="keyword">self</span>.testArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码一运行就会崩溃，原因是因为在某一瞬间<code>testArray</code>释放了为nil，所以导致<code>@synchronized</code>加锁失效，线程不安全了，然后就会出现多个线程同时释放 self.testArray 和给 self.testArray 赋值的情况，那么就会有一个瞬间：两个线程同时给 self.testArray 进行释放，因为当前对象已经释放过了，再次释放就会导致崩溃了。</p>
<p>解决方案：</p>
<ul>
<li>对<code>self</code>进行同步锁，这个似乎太臃肿了</li>
<li>使用<code>NSLock</code></li>
</ul>
<h3 id="3-3-NSLock"><a href="#3-3-NSLock" class="headerlink" title="3.3 NSLock"></a>3.3 NSLock</h3><h4 id="3-3-1-使用"><a href="#3-3-1-使用" class="headerlink" title="3.3.1 使用"></a>3.3.1 使用</h4><p><code>NSLock</code>是对<code>互斥锁</code>的简单封装，使用如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="keyword">self</span>.testArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="keyword">self</span>.testArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NSLock</code>在<a target="_blank" rel="noopener" href="https://github.com/AFNetworking/AFNetworking/blob/master/AFNetworking/AFURLSessionManager.m">AFNetworking的AFURLSessionManager.m</a>中有使用到</p>
<p>想要了解一下<code>NSLock</code>的底层原理，但发现其是在未开源的 OC <code>Foundation</code>源码下面的，但是 Swift 对<code>Foundation</code>却开源了，可以在<a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-foundation">swift-corelibs-foundation</a>下载到源码来一探究竟</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120409673.png"></p>
<p>从源码来看就是对互斥锁的简单封装</p>
<h4 id="3-3-2-注意事项"><a href="#3-3-2-注意事项" class="headerlink" title="3.3.2 注意事项"></a>3.3.2 注意事项</h4><p>使用互斥锁<code>NSLock</code>异步并发调用 block 块，block 块内部递归调用自己，问打印什么？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> (^block)(<span class="keyword">int</span>);</span><br><span class="line">        </span><br><span class="line">        block = ^(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;加锁前&quot;</span>);</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;加锁后&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;value——%d&quot;</span>, value);</span><br><span class="line">                block(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        block(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果并没有按照我们想象的去走：递归到最后进行解锁然后从内到外依次解锁，而是只打印了一次value值之后就卡住了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">加锁前</span><br><span class="line">加锁后</span><br><span class="line">value——10</span><br><span class="line">加锁前		&#x2F;&#x2F; 卡在这</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong> 互斥锁在递归调用时会造成堵塞，并非死锁——这里的问题是后面的代码无法执行下去</p>
<ul>
<li>第一次加完锁之后还没出锁就进行递归调用</li>
<li>第二次加锁就堵塞了线程（因为不会查询缓存）</li>
</ul>
<p><strong>解决方案：</strong> 使用递归锁<code>NSRecursiveLock</code>替换<code>NSLock</code></p>
<blockquote>
<p>堵塞：由于资源不足引起的排队等待现象</p>
<p>死锁：互相等待</p>
</blockquote>
<h3 id="3-4-NSRecursiveLock"><a href="#3-4-NSRecursiveLock" class="headerlink" title="3.4 NSRecursiveLock"></a>3.4 NSRecursiveLock</h3><h4 id="3-4-1-使用"><a href="#3-4-1-使用" class="headerlink" title="3.4.1 使用"></a>3.4.1 使用</h4><p><code>NSRecursiveLock</code>使用和<code>NSLock</code>类似，如下代码就能解决上个问题</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSRecursiveLock</span> *lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">void</span> (^block)(<span class="keyword">int</span>);</span><br><span class="line">        </span><br><span class="line">        block = ^(<span class="keyword">int</span> value) &#123;</span><br><span class="line">            [lock lock];</span><br><span class="line">            <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;value——%d&quot;</span>, value);</span><br><span class="line">                block(value - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            [lock unlock];</span><br><span class="line">        &#125;;</span><br><span class="line">        block(<span class="number">10</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NSRecursiveLock</code>在<a target="_blank" rel="noopener" href="https://github.com/ibireme/YYKit/blob/4e1bd1cfcdb3331244b219cbd37cc9b1ccb62b7a/YYKit/Image/YYWebImageOperation.m">YYKit中YYWebImageOperation.m</a>中有用到</p>
<h4 id="3-4-2-注意事项"><a href="#3-4-2-注意事项" class="headerlink" title="3.4.2 注意事项"></a>3.4.2 注意事项</h4><p>递归锁在使用时需要注意==死锁==问题——前后代码相互等待便会产生死锁</p>
<p>上述代码在外层加个<code>for循环</code>，问输出结果？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test &#123;</span><br><span class="line">    <span class="built_in">NSRecursiveLock</span> *lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">void</span> (^block)(<span class="keyword">int</span>);</span><br><span class="line">            </span><br><span class="line">            block = ^(<span class="keyword">int</span> value) &#123;</span><br><span class="line">                [lock lock];</span><br><span class="line">                <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;value——%d&quot;</span>, value);</span><br><span class="line">                    block(value - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                [lock unlock];</span><br><span class="line">            &#125;;</span><br><span class="line">            block(<span class="number">10</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码会崩溃，并会提示<code>野指针</code>错误</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120425194.png"></p>
<p><strong>原因：</strong> for 循环在 block 内部对同一个对象进行了多次锁操作，直到这个资源身上挂着N把锁，最后大家都无法一次性解锁——找不到解锁的出口</p>
<p>即 线程1中加锁1、同时线程2中加锁2-&gt; 解锁1等待解锁2 -&gt; 解锁2等待解锁1 -&gt; 无法结束解锁——形成死锁</p>
<p><strong>解决：</strong> 可以采用使用缓存的<code>@synchronized</code>，因为它对对象进行锁操作，会先从缓存查找是否有锁<code>syncData</code>存在。如果有，直接返回而不加锁，保证锁的唯一性</p>
<h3 id="3-5-dispatch-semaphore"><a href="#3-5-dispatch-semaphore" class="headerlink" title="3.5 dispatch_semaphore"></a>3.5 dispatch_semaphore</h3><p>在<a target="_blank" rel="noopener" href="https://www.evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/#more">17-多线程之GCD应用</a>已经对信号量进行过讲解。严格来说，信号量不是一种锁，但是可以实现锁的效果。</p>
<h3 id="3-6-NSCondition"><a href="#3-6-NSCondition" class="headerlink" title="3.6 NSCondition"></a>3.6 NSCondition</h3><p><code>NSCondition</code>是一个条件锁，可能平时用的不多，但与信号量相似：线程1需要等到条件1满足才会往下走，否则就会堵塞等待，直至条件满足。</p>
<p>同样的能在<code>Swift源码</code>中找到关于<code>NSCondition</code>部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">NSCondition</span>:</span> NSObject, NSLocking &#123;</span><br><span class="line">    internal var mutex = _MutexPointer.allocate(capacity: <span class="number">1</span>)</span><br><span class="line">    internal var cond = _ConditionVariablePointer.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> init() &#123;</span><br><span class="line">        pthread_mutex_init(mutex, nil)</span><br><span class="line">        pthread_cond_init(cond, nil)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        pthread_mutex_destroy(mutex)</span><br><span class="line">        pthread_cond_destroy(cond)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func lock() &#123;</span><br><span class="line">        pthread_mutex_lock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func unlock() &#123;</span><br><span class="line">        pthread_mutex_unlock(mutex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func wait() &#123;</span><br><span class="line">        pthread_cond_wait(cond, mutex)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func wait(until limit: Date) -&gt; Bool &#123;</span><br><span class="line">        guard var timeout = timeSpecFrom(date: limit) <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pthread_cond_timedwait(cond, mutex, &amp;timeout) == <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func signal() &#123;</span><br><span class="line">        pthread_cond_signal(cond)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func broadcast() &#123;</span><br><span class="line">        pthread_cond_broadcast(cond) <span class="comment">// wait  signal</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述精简后的代码可以得出以下几点：</p>
<ul>
<li><code>NSCondition</code>是对<code>mutex</code>和<code>cond</code>的一种封装（<code>cond</code>就是用于访问和操作特定类型数据的指针）</li>
<li><code>wait</code>操作会阻塞线程，使其进入休眠状态，直至超时</li>
<li><code>signal</code>操作是唤醒一个正在休眠等待的线程</li>
<li><code>broadcast</code>会唤醒所有正在等待的线程</li>
</ul>
<h3 id="3-7-NSConditionLock"><a href="#3-7-NSConditionLock" class="headerlink" title="3.7 NSConditionLock"></a>3.7 NSConditionLock</h3><p>顾名思义，就是<code>NSCondition</code> + <code>Lock</code></p>
<p>那么和<code>NSCondition</code>的区别在于哪里呢？接下来看一下<code>NSConditionLock</code>源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">open <span class="class"><span class="keyword">class</span> <span class="title">NSConditionLock</span> :</span> NSObject, NSLocking &#123;</span><br><span class="line">    internal var _cond = NSCondition()</span><br><span class="line">    internal var _value: Int</span><br><span class="line">    internal var _thread: _swift_CFThreadRef?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> convenience <span class="keyword">override</span> init() &#123;</span><br><span class="line">        self.init(condition: <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> init(condition: Int) &#123;</span><br><span class="line">        _value = condition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock() &#123;</span><br><span class="line">        let _ = lock(before: Date.distantFuture)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func unlock() &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        _thread = nil</span><br><span class="line">        _cond.broadcast()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var condition: Int &#123;</span><br><span class="line">        <span class="keyword">return</span> _value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock(whenCondition condition: Int) &#123;</span><br><span class="line">        let _ = lock(whenCondition: condition, before: Date.distantFuture)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func `<span class="keyword">try</span>`() -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lock(before: Date.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func tryLock(whenCondition condition: Int) -&gt; Bool &#123;</span><br><span class="line">        <span class="keyword">return</span> lock(whenCondition: condition, before: Date.distantPast)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func unlock(withCondition condition: Int) &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        _thread = nil</span><br><span class="line">        _value = condition</span><br><span class="line">        _cond.broadcast()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    open func lock(before limit: Date) -&gt; Bool &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        <span class="keyword">while</span> _thread != nil &#123;</span><br><span class="line">            <span class="keyword">if</span> !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open func lock(whenCondition condition: Int, before limit: Date) -&gt; Bool &#123;</span><br><span class="line">        _cond.lock()</span><br><span class="line">        <span class="keyword">while</span> _thread != nil || _value != condition &#123;</span><br><span class="line">            <span class="keyword">if</span> !_cond.wait(until: limit) &#123;</span><br><span class="line">                _cond.unlock()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _thread = pthread_self()</span><br><span class="line">        _cond.unlock()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    open var name: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以得出以下几点：</p>
<ul>
<li><code>NSConditionLock</code>是<code>NSCondition</code>加线程数的封装</li>
<li><code>NSConditionLock</code>可以设置锁条件，而<code>NSCondition</code>只是无脑的通知信号</li>
</ul>
<h3 id="3-8-os-unfair-lock"><a href="#3-8-os-unfair-lock" class="headerlink" title="3.8 os_unfair_lock"></a>3.8 os_unfair_lock</h3><p>由于<code>OSSpinLock</code>自旋锁的bug，替代方案是内部封装了<code>os_unfair_lock</code>，而<code>os_unfair_lock</code>在加锁时会处于休眠状态，而不是自旋锁的忙等状态</p>
<h3 id="3-9-互斥锁性能对比"><a href="#3-9-互斥锁性能对比" class="headerlink" title="3.9 互斥锁性能对比"></a>3.9 互斥锁性能对比</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210704120438866.png"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul>
<li><code>OSSpinLock</code>不再安全，底层用<code>os_unfair_lock</code>替代</li>
<li>属性的<code>atomic</code>修饰符只能保证<code>setter</code>、<code>getter</code>方法的线程安全，不能保证其他操作的线程安全，所以更多的使用<code>nonatomic</code>来修饰</li>
<li><code>读写锁</code>更多使用栅栏函数来实现</li>
<li><code>@synchronized</code>在底层维护了一个哈希链表进行<code>data</code>的存储，使用<code>recursive_mutex_t</code>进行加锁</li>
<li>互斥锁分为<code>递归锁</code>和<code>非递归锁</code>。<ul>
<li><code>递归锁</code>：<code>NSRecursiveLock</code>；对象锁<code>@synchronized</code>。</li>
<li><code>非递归锁</code>：<code>pthread_mutex</code>；<code>NSLock</code>；条件锁<code>NSCondition</code>、<code>NSConditionLock</code>。</li>
</ul>
</li>
<li><code>NSLock</code>、<code>NSRecursiveLock</code>、<code>NSCondition</code>和<code>NSConditionLock</code>底层都是对<code>pthread_mutex</code>的封装</li>
<li><code>NSCondition</code>和<code>NSConditionLock</code>是条件锁，当满足某一个条件时才能进行操作，和信号量<code>dispatch_semaphore</code>类似</li>
</ul>
<p>使用时：</p>
<ul>
<li>普通场景下涉及到线程安全，可以用<code>NSLock</code></li>
<li>循环调用时用<code>NSRecursiveLock</code></li>
<li>循环调用且有线程影响时，请注意死锁，如果有死锁问题的话使用<code>@synchronized</code>解决</li>
</ul>
<p>日常开发中若需要使用线程锁来保证线程安全，请多考虑一下再选择使用哪个锁，<code>@synchronized</code>并不是最优的选择。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2">objc 源码</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-foundation">Swift Foundation 源码</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904167010467854#heading-9">iOS探索 细数iOS中的那些锁</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904087004119048#heading-3">iOS -锁</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/TuGeLe/article/details/88399115">synchronized实现原理及缺陷分析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904149889318925">iOS底层学习 - 多线程之中的锁</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b1edc6b0937a">iOS开发中的11种锁以及性能对比</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/06/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/20-Block%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%8E%9F%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">20-Block的使用及原理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-item">《乌合之众》读书笔记</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、锁"><span class="level-left"><span class="level-item">一、锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-线程安全"><span class="level-left"><span class="level-item">1.1 线程安全</span></span></a></li><li><a class="level is-mobile" href="#1-2-检测安全"><span class="level-left"><span class="level-item">1.2 检测安全</span></span></a></li><li><a class="level is-mobile" href="#1-3-锁的作用"><span class="level-left"><span class="level-item">1.3 锁的作用</span></span></a></li><li><a class="level is-mobile" href="#1-4-锁的分类"><span class="level-left"><span class="level-item">1.4 锁的分类</span></span></a></li><li><a class="level is-mobile" href="#1-5-自旋锁"><span class="level-left"><span class="level-item">1.5 自旋锁</span></span></a></li><li><a class="level is-mobile" href="#1-6-互斥锁"><span class="level-left"><span class="level-item">1.6 互斥锁</span></span></a></li><li><a class="level is-mobile" href="#1-7-自旋锁和互斥锁的区别"><span class="level-left"><span class="level-item">1.7 自旋锁和互斥锁的区别</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、自旋锁"><span class="level-left"><span class="level-item">二、自旋锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-OSSpinLock（废弃）"><span class="level-left"><span class="level-item">2.1 OSSpinLock（废弃）</span></span></a></li><li><a class="level is-mobile" href="#2-2-atomic"><span class="level-left"><span class="level-item">2.2 atomic</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-2-1-atomic原理"><span class="level-left"><span class="level-item">2.2.1 atomic原理</span></span></a></li><li><a class="level is-mobile" href="#2-2-2-atomic修饰的属性绝对安全吗？"><span class="level-left"><span class="level-item">2.2.2 atomic修饰的属性绝对安全吗？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-3-读写锁"><span class="level-left"><span class="level-item">2.3 读写锁</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、互斥锁"><span class="level-left"><span class="level-item">三、互斥锁</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-pthread-mutex"><span class="level-left"><span class="level-item">3.1 pthread_mutex</span></span></a></li><li><a class="level is-mobile" href="#3-2-synchronized"><span class="level-left"><span class="level-item">3.2 @synchronized</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-源码分析"><span class="level-left"><span class="level-item">3.2.1 源码分析</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-id2data方法准备SyncData"><span class="level-left"><span class="level-item">3.2.2 id2data方法准备SyncData</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-使用快速缓存"><span class="level-left"><span class="level-item">3.2.3 使用快速缓存</span></span></a></li><li><a class="level is-mobile" href="#3-2-4-获取该线程下的-SyncCache"><span class="level-left"><span class="level-item">3.2.4 获取该线程下的 SyncCache</span></span></a></li><li><a class="level is-mobile" href="#3-2-5-全局哈希表查找"><span class="level-left"><span class="level-item">3.2.5 全局哈希表查找</span></span></a></li><li><a class="level is-mobile" href="#3-2-6-生成新数据并写入缓存"><span class="level-left"><span class="level-item">3.2.6 生成新数据并写入缓存</span></span></a></li><li><a class="level is-mobile" href="#3-2-7-疑难解答"><span class="level-left"><span class="level-item">3.2.7 疑难解答</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-NSLock"><span class="level-left"><span class="level-item">3.3 NSLock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-使用"><span class="level-left"><span class="level-item">3.3.1 使用</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-注意事项"><span class="level-left"><span class="level-item">3.3.2 注意事项</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-4-NSRecursiveLock"><span class="level-left"><span class="level-item">3.4 NSRecursiveLock</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-4-1-使用"><span class="level-left"><span class="level-item">3.4.1 使用</span></span></a></li><li><a class="level is-mobile" href="#3-4-2-注意事项"><span class="level-left"><span class="level-item">3.4.2 注意事项</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-5-dispatch-semaphore"><span class="level-left"><span class="level-item">3.5 dispatch_semaphore</span></span></a></li><li><a class="level is-mobile" href="#3-6-NSCondition"><span class="level-left"><span class="level-item">3.6 NSCondition</span></span></a></li><li><a class="level is-mobile" href="#3-7-NSConditionLock"><span class="level-left"><span class="level-item">3.7 NSConditionLock</span></span></a></li><li><a class="level is-mobile" href="#3-8-os-unfair-lock"><span class="level-left"><span class="level-item">3.8 os_unfair_lock</span></span></a></li><li><a class="level is-mobile" href="#3-9-互斥锁性能对比"><span class="level-left"><span class="level-item">3.9 互斥锁性能对比</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、总结"><span class="level-left"><span class="level-item">四、总结</span></span></a></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考资料"><span class="level-left"><span class="level-item">参考资料</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>