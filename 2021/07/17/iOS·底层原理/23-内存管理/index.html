<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>23-内存管理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="23-内存管理"><meta property="og:url" content="http://evilimo.com/2021/07/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/23-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215005843"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215021292"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215033295"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215041375"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215056694"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717161422635.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215117727"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215124999"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717201907488.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/dfb7c5c894bd4c77ae35ac6839352e78%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/6a27ade070af45f2be2d7e5992821374%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/433090ab7b4447c1bd35bbfd1e61fba0%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/32264ad20da9489dbeff9f2d71e9f79b%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/38becd19aefd4773b639204c7732800d%7Etplv-k3u1fbpfcp-zoom-1.image"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717212129833.png"><meta property="article:published_time" content="2021-07-17T06:03:37.456Z"><meta property="article:modified_time" content="2021-07-19T06:23:27.336Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215005843"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/07/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/23-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717161422635.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717201907488.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717212129833.png"],"datePublished":"2021-07-17T06:03:37.456Z","dateModified":"2021-07-19T06:23:27.336Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/07/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/23-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-07-17T06:03:37.456Z" title="2021-07-17T06:03:37.456Z">2021-07-17</time>发表</span><span class="level-item"><time dateTime="2021-07-19T06:23:27.336Z" title="2021-07-19T06:23:27.336Z">2021-07-19</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">23-内存管理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、内存布局"><a href="#一、内存布局" class="headerlink" title="一、内存布局"></a>一、内存布局</h2><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215005843"></p>
<h3 id="1-1-五大区"><a href="#1-1-五大区" class="headerlink" title="1.1 五大区"></a>1.1 五大区</h3><p>从高地址到低地址依次为：</p>
<p><strong>栈区</strong>：编译器自动分配，由系统管理，在不需要的时候自动清除。局部变量、函数参数存储在这里。栈区的内存地址一般是0x7开头。</p>
<p><strong>堆区</strong>：那些由<code>new</code>，<code>alloc</code>、<code>block copy</code>创建的对象存储在这里，是由开发者管理的，需要告诉系统什么时候释放内存。ARC下编译器会自动在合适的时候释放内存，而在MRC下需要开发者手动释放。堆区的内存地址一般是0x6开头。</p>
<p><strong>BSS段</strong>：BSS段又称静态区，未初始化的全局变量，静态变量存放在这里。程序运行过程中内存中的数据一直存在，程序结束后由系统释放。</p>
<p><strong>数据段</strong>：数据段又称常量区，专门存放常量，程序结束后由系统释放。</p>
<p><strong>代码段</strong>：用于存放程序运行时的代码，代码会被编译成二进制存进内存的程序代码区。</p>
<p>除了<code>五大区</code>之外，内存中还有<code>保留字段</code>和<code>内核区</code></p>
<ul>
<li>内核区：在4gb内存中只用到了3gb，还有1gb给内核区处理</li>
<li>保留字段：保留一定的区域给保留字段，进行一些存储</li>
</ul>
<p>接下来就用LLDB来打印一下堆区和栈区中的一些内容 </p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215021292"></p>
<h3 id="1-2-内存布局面试题"><a href="#1-2-内存布局面试题" class="headerlink" title="1.2 内存布局面试题"></a>1.2 内存布局面试题</h3><p><strong>1.全局变量和局部变量在内存中是否有区别？</strong></p>
<ul>
<li>全局变量存放在相应的全局储存区，而局部变量存放在栈区</li>
<li>两者访问的权限不一样</li>
</ul>
<p><strong>2.block是否可以修改全局变量</strong></p>
<p>可以，因为全局变量的作用域很大（可以理解为公共区域），block可以访问到</p>
<p><strong>3.关于全局静态变量</strong></p>
<ul>
<li>全局静态变量是可变的，是 static 不是 const</li>
<li>全局静态变量的值只针对当前文件而言，不同文件中的全局静态变量的内存地址是不一样的，所以值也不一样<ul>
<li>假设有个全局静态变量 num=10</li>
<li>vc中修改<code>num=20</code>并在vc中打印会输出<code>20</code></li>
<li>view中修改<code>num=num+1</code>并在view中会输出<code>11</code></li>
<li>model中修改<code>num=0</code>并在model中会输出<code>0</code></li>
<li>在model的分类中修改<code>num=1000</code>并在model分类中会输出<code>1000</code></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215033295"></p>
<p><strong>总结：</strong> 全局静态变量只针对文件而言，无论别的文件怎么修改，本文件使用时都拿原有值/本文件修改后的值</p>
<h2 id="二、内存管理方案"><a href="#二、内存管理方案" class="headerlink" title="二、内存管理方案"></a>二、内存管理方案</h2><h3 id="2-1-taggedPointer-简介"><a href="#2-1-taggedPointer-简介" class="headerlink" title="2.1 taggedPointer 简介"></a>2.1 taggedPointer 简介</h3><p>在 2013 年 9 月，苹果推出了 <code>iPhone5s</code>，与此同时，iPhone5s 配备了首个采用 64 位架构的 <code>A7 双核处理器</code>，为了节省内存和提高执行效率，苹果提出了<code>Tagged Pointer</code>。</p>
<ul>
<li><p><code>Tagged Pointer</code>是专⻔⽤来存储⼩的对象，例如<code>NSNumber</code>，<code>NSString</code>，<code>NSDate</code>等。</p>
</li>
<li><p><code>Tagged Pointer</code>指针的值不再是地址了，⽽是真正的值。所以，实际上它不再是⼀个对象了，它只是⼀个披着对象⽪的普通变量⽽已。所以，它的内存并不存储在堆中，也不需要<code>malloc</code>和<code>free</code>。</p>
</li>
<li><p>在内存读取上有着3倍的效率，创建时⽐以前快106倍。</p>
</li>
</ul>
<p>那么<code>Tagged Ponter</code>对于内存优化的点在哪里呢？</p>
<p>正常情况下，一个 NSInteger的普通变量，那么它在32位CPU下占 4 个字节，在 64 位CPU下占 8 个字节的。而NSNumber对象还有一个<code>isa</code>指针，它在32位CPU下为4个字节，在 64 位 CPU 下是 8 个字节。所以从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种 NSNumber、NSDate 一类的对象所占用的内存会翻倍。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215041375"></p>
<p>而实际上一个NSNumber、NSDate这一类的变量的值需要的内存空间常常不需要8个字节，那么如上述来进行数据的存储，内存空间的浪费是很大的。<code>Tagged Ponter</code>解决了这个问题。 <code>Tagged Ponter</code>将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。所以，引入了Tagged Pointer对象之后，64位CPU下 NSNumber 的内存图变成了以下这样：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215056694"></p>
<h3 id="2-2-taggedPointer-底层探索"><a href="#2-2-taggedPointer-底层探索" class="headerlink" title="2.2 taggedPointer 底层探索"></a>2.2 taggedPointer 底层探索</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">initializeTaggedPointerObfuscator(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sdkIsOlderThan(<span class="number">10</span>_14, <span class="number">12</span>_0, <span class="number">12</span>_0, <span class="number">5</span>_0, <span class="number">3</span>_0) ||</span><br><span class="line">        <span class="comment">// Set the obfuscator to zero for apps linked against older SDKs,</span></span><br><span class="line">        <span class="comment">// in case they&#x27;re relying on the tagged pointer representation.</span></span><br><span class="line">        DisableTaggedPointerObfuscation) &#123;</span><br><span class="line">        objc_debug_taggedpointer_obfuscator = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Pull random data into the variable, then shift away all non-payload bits.</span></span><br><span class="line">        arc4random_buf(&amp;objc_debug_taggedpointer_obfuscator,</span><br><span class="line">                       <span class="keyword">sizeof</span>(objc_debug_taggedpointer_obfuscator));</span><br><span class="line">        objc_debug_taggedpointer_obfuscator &amp;= ~_OBJC_TAG_MASK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>底层也做了对<code>objc_debug_taggedpointer_obfuscator</code>进行异或的操作。我们都知道将a和b异或操作得到c再和a进行异或操作便可以重新得到a的值，通常可以使用这个方式来实现不用中间变量实现两个值的交换，<code>Tagged Pointer</code>正是使用了这种原理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">uintptr_t</span> objc_debug_taggedpointer_obfuscator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> * _Nonnull</span><br><span class="line">_objc_encodeTaggedPointer(<span class="keyword">uintptr_t</span> ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)(objc_debug_taggedpointer_obfuscator ^ ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">_objc_decodeTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> * _Nullable ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以通过类似的方法对<code>taggedPointer</code>进行解码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uintptr_t objc_debug_taggedpointer_obfuscator;</span><br><span class="line"></span><br><span class="line">uintptr_t</span><br><span class="line">_objc_decodeTaggedPointer_(<span class="keyword">id</span> ptr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (uintptr_t)ptr ^ objc_debug_taggedpointer_obfuscator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *str1 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;a&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ab&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str3 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abc&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str4 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcd&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str5 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcde&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str6 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdef&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str7 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdefg&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str8 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdefgh&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str9 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdefghi&quot;</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *str10 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;abcdefghij&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str1, str1, _objc_decodeTaggedPointer_(str1));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str2, str2, _objc_decodeTaggedPointer_(str2));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str3, str3, _objc_decodeTaggedPointer_(str3));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str4, str4, _objc_decodeTaggedPointer_(str4));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str5, str5, _objc_decodeTaggedPointer_(str5));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str6, str6, _objc_decodeTaggedPointer_(str6));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str7, str7, _objc_decodeTaggedPointer_(str7));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str8, str8, _objc_decodeTaggedPointer_(str8));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str9, str9, _objc_decodeTaggedPointer_(str9));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@  %p  0x%lx&quot;</span>, str10, str10, _objc_decodeTaggedPointer_(str10));</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717161422635.png"></p>
<p>结果就是：</p>
<ul>
<li><p><code>NSString</code>不超过9个字符是<code>NSTaggedPointerString</code>类型，超过9个字符是<code>__NSCFString</code>类型</p>
</li>
<li><p><code>NSString</code>用字面量初始化会是<code>__NSCFConstantString</code>类型而不是<code>NSTaggedPointerString</code>类型</p>
</li>
</ul>
<h3 id="2-3-taggedPointer-总结"><a href="#2-3-taggedPointer-总结" class="headerlink" title="2.3 taggedPointer 总结"></a>2.3 taggedPointer 总结</h3><ul>
<li><p><code>taggedPointer</code>专门用来存储小的对象，例如<code>NSNumber</code>、<code>NSStirng</code>、<code>NSDate</code></p>
</li>
<li><p><code>taggedPointer</code>指针的值不再是地址了，而是真正的值。所以他不再是一个对象了，他只是一个”披着对象外皮”的普通变量而已——它的内存并不在堆中，也不需要<code>malloc</code>和<code>free</code></p>
</li>
<li><p><code>taggedPointer</code>不像地址指针一样，直接从指针中拿到值——编译读取的时候更加直接了</p>
</li>
</ul>
<h2 id="三、NONPOINTER-ISA"><a href="#三、NONPOINTER-ISA" class="headerlink" title="三、NONPOINTER_ISA"></a>三、NONPOINTER_ISA</h2><p><code>NONPOINTER_ISA</code>同样是苹果公司对于内存优化的一种方案。<code>isa</code>是个8字节（64位）的指针，仅用来<code>isa</code>指向比较浪费，所以<code>isa</code>中就掺杂了一些其他数据来节省内存。<code>isa</code> 指针第一位为 1 即表示使用优化的 isa 指针：<code>NONPOINTER_ISA</code></p>
<p>arm64 架构下 isa 指针的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(ISA_BITFIELD)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; </span><br><span class="line">      <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;                                       </span><br><span class="line">      <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215117727"></p>
<h2 id="四、SideTable"><a href="#四、SideTable" class="headerlink" title="四、SideTable"></a>四、SideTable</h2><p><code>SideTable</code>在OC中扮演这一个很重要的角色。在runtime中，通过<code>SideTable</code>来管理对象的==引用计数==以及==weak引用==。同时，系统中维护了一个全局的<code>SideTables</code>，这是一个<code>SideTable</code>的集合。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210717215124999"></p>
<p>来看看SideTable的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SideTable的定义很清晰，有三个成员:</p>
<blockquote>
<ul>
<li><strong>spinlock_t slock</strong>：自旋锁，用于上锁/解锁 SideTable。</li>
<li><strong>RefcountMap refcnts</strong>：用来存储OC对象的引用计数的 <code>hash表</code>(仅在未开启isa优化或在isa优化情况下isa_t的引用计数溢出时才会用到)。</li>
<li><strong>weak_table_t weak_table</strong>：存储对象弱引用指针的hash表。是OC中weak功能实现的核心数据结构。</li>
</ul>
</blockquote>
<h2 id="五、ARC-amp-MRC"><a href="#五、ARC-amp-MRC" class="headerlink" title="五、ARC &amp; MRC"></a>五、ARC &amp; MRC</h2><ul>
<li><code>ARC</code>是<code>LLVM</code>和<code>Runtime</code>配合的结果</li>
<li><code>ARC</code>中禁止手动调用<code>retain/release/retainCount/dealloc</code></li>
<li><code>ARC</code>新加了<code>weak</code>、<code>strong</code>关键字</li>
</ul>
<h3 id="5-1-alloc"><a href="#5-1-alloc" class="headerlink" title="5.1 alloc"></a>5.1 alloc</h3><p>之前已经对<a target="_blank" rel="noopener" href="https://www.evilimo.com/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/#more">alloc流程</a>有了一个详细的介绍。总结一句话就是<code>alloc</code>创建了对象并且申请了一块不少于16字节的内存空间。</p>
<h3 id="5-2-retain"><a href="#5-2-retain" class="headerlink" title="5.2 retain"></a>5.2 retain</h3><p>使用<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">我的objc4-756.2源码</a>进行源码追踪：</p>
<p>入口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">objc_retain(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span> obj; <span class="comment">//TaggedPointer对象不做引用计数处理</span></span><br><span class="line">    <span class="keyword">return</span> obj-&gt;retain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> id </span><br><span class="line">objc_object::retain()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!isTaggedPointer());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!ISA()-&gt;hasCustomRR())) &#123;</span><br><span class="line">        <span class="keyword">return</span> rootRetain();    <span class="comment">// 大概率走这里</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ((id(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_retain);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>retain</code>方法内部其实很简单，就是一个判断，然后调用<code>rootRetain</code>方法。其中<code>fastpath</code>是大概率发生的意思。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">objc_object::rootRetain(<span class="keyword">bool</span> tryRetain, <span class="keyword">bool</span> handleOverflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        transcribeToSideTable = <span class="literal">false</span>;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123; <span class="comment">//如果不是 nonpointer isa，直接操作散列表sidetable</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">if</span> (tryRetain) <span class="keyword">return</span> sidetable_tryRetain() ? (id)<span class="keyword">this</span> : nil;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> sidetable_retain(); <span class="comment">//引用计数存储于SideTable中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="comment">// 检查对象是否正在释放，如果正在释放，则执行dealloc流程</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(tryRetain &amp;&amp; newisa.deallocating)) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> nil;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是nonpointer_isa，大概率事件</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> carry;    <span class="comment">// 记录引用计数是否超负荷</span></span><br><span class="line">        <span class="comment">// isa的bits中的extra_rc进行加1</span></span><br><span class="line">        newisa.bits = addc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc++</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果bits的extra_rc已经存满了，则extra_rc置空一半的数值</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;  <span class="comment">// 小概率发生</span></span><br><span class="line">            <span class="comment">// newisa.extra_rc++ overflowed</span></span><br><span class="line">            <span class="keyword">if</span> (!handleOverflow) &#123;</span><br><span class="line">                ClearExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">return</span> rootRetain_overflow(tryRetain);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Leave half of the retain counts inline and </span></span><br><span class="line">            <span class="comment">// prepare to copy the other half to the side table.</span></span><br><span class="line">            <span class="keyword">if</span> (!tryRetain &amp;&amp; !sideTableLocked) sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            transcribeToSideTable = <span class="literal">true</span>;</span><br><span class="line">            newisa.extra_rc = RC_HALF;  <span class="comment">// extra_rc置空一半的数值</span></span><br><span class="line">            newisa.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(transcribeToSideTable)) &#123;</span><br><span class="line">        <span class="comment">// Copy the other half of the retain counts to the side table.</span></span><br><span class="line">        <span class="comment">// 如果bits的extra_rc已经存满了，将另外的一半引用计数存储到sidetable中</span></span><br><span class="line">        sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(!tryRetain &amp;&amp; sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>【第一步】判断是否为<code>Nonpointer_isa</code></p>
<p>【第二步】操作引用计数</p>
<ul>
<li>1.如果不是<code>Nonpointer_isa</code>，则直接操作<code>SideTables</code>散列表，此时的散列表并不是只有一张，而是有很多张</li>
<li>2.判断<code>是否正在释放</code>，如果正在释放，则执行dealloc流程</li>
<li>3.执行<code>extra_rc+1</code>，即引用计数+1操作，并给一个引用计数的<code>状态标识carry</code>，用于表示<code>extra_rc</code>是否满了</li>
<li>4.如果<code>carray</code>的状态表示<code>extra_rc的引用计数满</code>了，此时需要操作<code>散列表</code>，将满状态的一半拿出来存到<code>extra_rc</code>，另一半存在 散列表的<code>rc_half</code>。这么做的原因是因为如果都存储在散列表，每次对散列表操作都需要开解锁，操作耗时，消耗性能大，这么<code>对半分</code>操作的目的在于<code>提高性能</code></li>
</ul>
<p><strong>总结：retain 完整回答</strong></p>
<ul>
<li><code>retain</code>在底层首先会<code>判断是否是 Nonpointer isa</code>，如果<code>不是，则直接操作散列表 进行+1操作</code></li>
<li>如果<code>是Nonpointer isa</code>，还需要<code>判断是否正在释放</code>，如果正在<code>释放，则执行dealloc流程</code>，释放弱引用表和引用技术表，最后free释放对象内存</li>
<li>如果<code>不是正在释放，则对Nonpointer isa进行常规的引用计数+1.</code>这里需要注意一点的是，<code>extra_rc</code>在真机上只有<code>8位用于存储引用计数的值</code>，当存储<code>满了</code>时，需要<code>借助散列表</code>用于存储。需要将满了的<code>extra_rc</code>对半分，一半（即2^7）存储在<code>散列表</code>中。另一半还是存储在<code>extra_rc</code>中，用于常规的引用计数的+1或者-1操作，然后再返回</li>
</ul>
<h3 id="5-3-release"><a href="#5-3-release" class="headerlink" title="5.3 release"></a>5.3 release</h3><p>通过<code>setProperty -&gt; reallySetProperty -&gt; objc_release -&gt; release -&gt; rootRelease -&gt; rootRelease</code>顺序，进入<code>rootRelease</code>源码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">objc_object::rootRelease(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 判断是否是TaggedPointer</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">isa_t</span> oldisa;</span><br><span class="line">    <span class="keyword">isa_t</span> newisa;</span><br><span class="line"></span><br><span class="line"> retry:</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        newisa = oldisa;</span><br><span class="line">        <span class="comment">// 判断是否是Nonpointer isa</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(!newisa.nonpointer)) &#123;</span><br><span class="line">            <span class="comment">// 如果不是，则直接操作散列表-1</span></span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> sidetable_release(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果是NONPOINTER_ISA</span></span><br><span class="line">        <span class="comment">// don&#x27;t check newisa.fast_rr; we already called any RR overrides</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">        <span class="comment">// isa的bits的extra_rc减1</span></span><br><span class="line">        newisa.bits = subc(newisa.bits, RC_ONE, <span class="number">0</span>, &amp;carry);  <span class="comment">// extra_rc--</span></span><br><span class="line">        <span class="comment">// 如果此时extra_rc的值为0了，则走到underflow</span></span><br><span class="line">        <span class="keyword">if</span> (slowpath(carry)) &#123;</span><br><span class="line">            <span class="comment">// don&#x27;t ClearExclusive()</span></span><br><span class="line">            <span class="keyword">goto</span> underflow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slowpath(!StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                             oldisa.bits, newisa.bits)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"> underflow:</span><br><span class="line">    <span class="comment">// newisa.extra_rc-- underflowed: borrow from side table or deallocate</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// abandon newisa to undo the decrement</span></span><br><span class="line">    newisa = oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断isa是否有辅助的引用计数散列表</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!handleUnderflow) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            <span class="keyword">return</span> rootRelease_underflow(performDealloc);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Transfer retain count from side table to inline storage.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!sideTableLocked) &#123;</span><br><span class="line">            ClearExclusive(&amp;isa.bits);</span><br><span class="line">            sidetable_lock();</span><br><span class="line">            sideTableLocked = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Need to start over to avoid a race against </span></span><br><span class="line">            <span class="comment">// the nonpointer -&gt; raw pointer transition.</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try to remove some retain counts from the side table.</span></span><br><span class="line">        <span class="comment">//从散列表中取出存储的一半引用计数</span></span><br><span class="line">        <span class="keyword">size_t</span> borrowed = sidetable_subExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To avoid races, has_sidetable_rc must remain set </span></span><br><span class="line">        <span class="comment">// even if the side table count is now zero.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (borrowed &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Side table retain count decreased.</span></span><br><span class="line">            <span class="comment">// Try to add them to the inline count.</span></span><br><span class="line">            <span class="comment">//进行-1操作，然后存储到extra_rc中</span></span><br><span class="line">            newisa.extra_rc = borrowed - <span class="number">1</span>;  <span class="comment">// redo the original decrement too</span></span><br><span class="line">            <span class="keyword">bool</span> stored = StoreReleaseExclusive(&amp;isa.bits, </span><br><span class="line">                                                oldisa.bits, newisa.bits);</span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed. </span></span><br><span class="line">                <span class="comment">// Try it again right now. This prevents livelock on LL/SC </span></span><br><span class="line">                <span class="comment">// architectures where the side table access itself may have </span></span><br><span class="line">                <span class="comment">// dropped the reservation.</span></span><br><span class="line">                <span class="keyword">isa_t</span> oldisa2 = LoadExclusive(&amp;isa.bits);</span><br><span class="line">                <span class="keyword">isa_t</span> newisa2 = oldisa2;</span><br><span class="line">                <span class="keyword">if</span> (newisa2.nonpointer) &#123;</span><br><span class="line">                    <span class="keyword">uintptr_t</span> overflow;</span><br><span class="line">                    newisa2.bits = </span><br><span class="line">                        addc(newisa2.bits, RC_ONE * (borrowed<span class="number">-1</span>), <span class="number">0</span>, &amp;overflow);</span><br><span class="line">                    <span class="keyword">if</span> (!overflow) &#123;</span><br><span class="line">                        stored = StoreReleaseExclusive(&amp;isa.bits, oldisa2.bits, </span><br><span class="line">                                                       newisa2.bits);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!stored) &#123;</span><br><span class="line">                <span class="comment">// Inline update failed.</span></span><br><span class="line">                <span class="comment">// Put the retains back in the side table.</span></span><br><span class="line">                sidetable_addExtraRC_nolock(borrowed);</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Decrement successful after borrowing from side table.</span></span><br><span class="line">            <span class="comment">// This decrement cannot be the deallocating decrement - the side </span></span><br><span class="line">            <span class="comment">// table lock and has_sidetable_rc bit ensure that if everyone </span></span><br><span class="line">            <span class="comment">// else tried to -release while we worked, the last one would block.</span></span><br><span class="line">            sidetable_unlock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Side table is empty after all. Fall-through to the dealloc path.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//此时extra_rc中值为0，散列表中也是空的，则直接进行析构，即自动触发dealloc流程</span></span><br><span class="line">    <span class="comment">// Really deallocate.</span></span><br><span class="line">    <span class="comment">//触发dealloc的时机</span></span><br><span class="line">    <span class="keyword">if</span> (slowpath(newisa.deallocating)) &#123;</span><br><span class="line">        ClearExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">if</span> (sideTableLocked) sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">        <span class="comment">// does not actually return</span></span><br><span class="line">    &#125;</span><br><span class="line">    newisa.deallocating = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) <span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slowpath(sideTableLocked)) sidetable_unlock();</span><br><span class="line"></span><br><span class="line">    __sync_synchronize();</span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        <span class="comment">//发送一个dealloc消息</span></span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>【第一步】判断是否是<code>Nonpointer isa</code>，如果不是，则<code>直接对散列表进行-1操作</code></p>
<p>【第二步】如果是<code>Nonpointer isa</code>，则对<code>extra_rc</code>中的引用计数值进行<code>-1</code>操作，并存储此时的extra_rc状态到<code>carry</code>中</p>
<ul>
<li><p>如果此时的状态<code>carray</code>为0，则走到<code>underflow</code>流程</p>
<p><code>underflow</code>流程有以下几步：</p>
<ul>
<li>判断<code>散列表</code>中<code>是否存储了一半的引用计数</code></li>
<li>如果是，则从<code>散列表</code>中<code>取出</code>存储的一半引用计数，进行<code>-1操作</code>，然后存储到<code>extra_rc</code>中</li>
<li>如果此时<code>extra_rc</code>没有值，散列表中也是空的，则直接进行析构，即<code>dealloc</code>操作，属于自动触发</li>
</ul>
</li>
</ul>
<h3 id="5-4-retainCount"><a href="#5-4-retainCount" class="headerlink" title="5.4 retainCount"></a>5.4 retainCount</h3><p>前面说了这么多引用计数，那么我们来看看<code>retainCount</code>和引用计数有什么关系呢？</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *objc = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%ld&quot;</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)objc));</span><br></pre></td></tr></table></figure>

<p>上述代码会输出<code>1</code>，然而在alloc流程中并没有看到任何与<code>retainCount</code>相关的内容，这又是怎么一回事呢？接下来就来看看<code>retainCount</code>的底层实现</p>
<p><code>retainCount</code>-&gt;<code>rootRetainCount</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;	<span class="comment">// 这里就是1+0=1</span></span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先判断是否为<code>isTaggedPointer</code></li>
<li>再判断是否为 nonpointer，如果是的话，当前引用计数=1+extrac_rc<ul>
<li>这行代码就能说明<code>alloc</code>出来的对象引用计数为<code>0</code>，是苹果人员为了不给开发人员造成引用计数为<code>0</code>时就销毁造成错觉才默认加一</li>
</ul>
</li>
<li>接着判断 has_sidetable_rc 是否有额外的散列表<ul>
<li>有的话引用计数再加上引用计数表中的数量</li>
</ul>
</li>
<li>所以<code>引用计数</code>=<code>1 + extrac_rc + sidetable_getExtraRC_nolock</code></li>
</ul>
<h3 id="5-5-dealloc"><a href="#5-5-dealloc" class="headerlink" title="5.5 dealloc"></a>5.5 dealloc</h3><p>第3小节已经提到了<code>dealloc</code>——在<code>release</code>底层会判断当前<code>extra_rc</code>和<code>引用计数表</code>是否都为0，如果满足条件就会通过消息发送调用<code>dealloc</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717201907488.png"></p>
<p>进入 dealloc -&gt; _objc_rootDealloc -&gt; rootDealloc：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ✅如果是Tagged Pointer，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ✅如果同时满足</span></span><br><span class="line"><span class="comment">     1. 是优化过的isa、</span></span><br><span class="line"><span class="comment">     2. 没有被weak指针引用过、</span></span><br><span class="line"><span class="comment">     3. 没有关联对象、</span></span><br><span class="line"><span class="comment">     4. 没有C++析构函数、</span></span><br><span class="line"><span class="comment">     5. 没有sideTable引用计数</span></span><br><span class="line"><span class="comment">     就可以直接释放内存free()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//否则的话就需要通过下面的函数处理</span></span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先判断对象是否是<code>Tagged Pointer</code>，如果是则直接返回。</li>
<li>如果对象是采用了优化的isa计数方式，且同时满足：对象没有被weak引用<code>!isa.weakly_referenced</code>、没有关联对象<code>!isa.has_assoc</code>、没有自定义的C++析构方法<code>!isa.has_cxx_dtor</code>、没有用到SideTable来引用计数<code>!isa.has_sidetable_rc</code>，则直接快速释放。</li>
<li>如果不能满足上面的条件，则会调用<code>object_dispose</code>方法。</li>
</ul>
<p>object_dispose -&gt; objc_destructInstance：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="comment">// 如果有C++析构函数，则运行相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="comment">// 如果有关联对象，则移除所有的关联对象，并将其自身从Association Manager的map中移除</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 清除对象的相关引用</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果有自定义的C++析构方法，则调用C++析构函数。如果有关联对象，则移除关联对象并将其自身从<code>AssociationManager</code>的map中移除。调用<code>clearDeallocating</code>方法清除对象的相关引用。</p>
<p>clearDeallocating:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="comment">// 如果要释放的对象没有采用了优化过的isa引用计数，则清理对象存储在SideTable中的引用计数</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="comment">// ✅ 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数（现在一般都是优化过的 isa）</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断对象是否采用了优化isa引用计数，如果没有的话则需要清理对象存储在<code>SideTable</code>中的引用计数数据。</li>
<li>如果对象采用了优化isa引用计数，则判断是都有使用<code>SideTable</code>的辅助引用计数(<code>isa.has_sidetable_rc</code>)或者有weak引用(<code>isa.weakly_referenced</code>)，符合这两种情况中一种的，调用<code>clearDeallocating_slow</code>方法。</li>
</ul>
<p>clearDeallocating_slow:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局的SideTables中，以this指针(要释放的对象)为key，找到对应的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="comment">// ✅ 要释放的对象被弱引用了，通过weak_clear_no_lock函数将指向该对象的弱引用指针置为nil</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用了sideTable的辅助引用计数,直接在SideTable中擦除该对象的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果对象被弱引用，则调用<code>weak_clear_no_lock</code>函数将指向该对象的弱引用指针置为nil</li>
<li>如果采用了<code>SideTable</code>做引用计数，则在 <code>SideTable</code>的引用计数中移除对象的引用计数</li>
</ul>
<h2 id="六、NSTimer-循环引用"><a href="#六、NSTimer-循环引用" class="headerlink" title="六、NSTimer 循环引用"></a>六、NSTimer 循环引用</h2><h3 id="6-1-原因"><a href="#6-1-原因" class="headerlink" title="6.1 原因"></a>6.1 原因</h3><p>一个常出现的循环引用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TimerViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TimerViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(fireHome) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireHome &#123;</span><br><span class="line">    num++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;current - %d&quot;</span>,num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">		[<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">    <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码运行起来所发生的问题就是<code>当前VC</code>pop到前一页时不会触发<code>dealloc函数</code>，那么就是产生了循环引用。</p>
<p>查看苹果 API 说明：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/dfb7c5c894bd4c77ae35ac6839352e78%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>timer 会对他的 target 进行强持有，所以造成了如下现象：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/6a27ade070af45f2be2d7e5992821374%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>这个 API 说明同时提到，在 timer 不用的时候需要 invalidate。</p>
<p>那么能不能像<code>block</code>一样使用弱引用来解决循环引用呢？答案是不能的！</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们尝试解决：</span></span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> target:weakSelf selector:<span class="keyword">@selector</span>(fireHome) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/433090ab7b4447c1bd35bbfd1e61fba0%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>由于 weakSelf 和 self 都指向同一个对象 vc，所以本质上是一个东西，只是指针的地址不一样，那么就会造成：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/32264ad20da9489dbeff9f2d71e9f79b%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<p>结果还是循环引用。</p>
<p>那么为什么可以使用<code>__weak typeof(self) weakSelf = self;</code>解决 block 的循环引用呢？</p>
<p>看block源码：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/38becd19aefd4773b639204c7732800d%7Etplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li><code>block</code>持有的是<code>weakSelf</code>的<strong>指针地址</strong>。</li>
<li><code>timer</code>持有的是<code>weakSelf</code>的<strong>指针指向的对象</strong>，这里间接持有了<code>self</code>，所以仍然存在循环引用导致释放不掉</li>
</ul>
<h3 id="6-2-解决方案"><a href="#6-2-解决方案" class="headerlink" title="6.2 解决方案"></a>6.2 解决方案</h3><h4 id="方案一：提前-invalidate【推荐】"><a href="#方案一：提前-invalidate【推荐】" class="headerlink" title="方案一：提前 invalidate【推荐】"></a>方案一：提前 invalidate【推荐】</h4><ul>
<li>既然dealloc不能来，就在dealloc函数调用前解决掉这层强引用</li>
<li>可以在<code>viewWillDisappear</code>、<code>viewDidDisappear</code>中处理<code>NSTimer</code>，但这样处理效果并不好，因为跳转到下一页定时器也会停止工作，与业务不符</li>
<li>使用<code>didMoveToParentViewController</code>可以很好地解决这层强引用</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法在当前控制器 push 和 pop 的时候都会调用</span></span><br><span class="line">- (<span class="keyword">void</span>)didMoveToParentViewController:(<span class="built_in">UIViewController</span> *)parent &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">        <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方案二：中介者模式"><a href="#方案二：中介者模式" class="headerlink" title="方案二：中介者模式"></a>方案二：中介者模式</h4><p>原理：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210717212129833.png"></p>
<ul>
<li>使用中介者解除循环引用</li>
<li>同时在调用 proxy 的 timerTest 方法时，使用消息转发，转发到让 self 去调用他自己的 timerTest 方法，保证了功能的正常实现。</li>
</ul>
<p>JYProxy.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JYProxy</span> : <span class="title">NSObject</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>JYProxy.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JYProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JYProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    JYProxy *proxy = [[JYProxy alloc] init];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发，即让谁去调用方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>ViewController.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JYProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">		<span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[JYProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">		[<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>运行，timer 功能一切正常，并且没有循环引用。</p>
<h4 id="方案三：使用-NSProxy【推荐】"><a href="#方案三：使用-NSProxy【推荐】" class="headerlink" title="方案三：使用 NSProxy【推荐】"></a>方案三：使用 NSProxy【推荐】</h4><p>原理跟中介者模式一样，只不过这个 NSProxy 类更专业，只用来做中介，效率更高。</p>
<ul>
<li>上一节提到的中介者只是一个普通的 NSObject，调用他的 timerTest 方法时会走正常的消息发送流程，包括缓存查找、遍历父类进行查找、消息转发等，流程多。</li>
<li>NSProxy 只用来做消息转发，没有复杂的流程，效率高，做中介者就找他</li>
</ul>
<p>MJProxy.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MJProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">id</span> target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>MJProxy.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MJProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span></span><br><span class="line">    MJProxy *proxy = [MJProxy alloc];</span><br><span class="line">    proxy.target = target;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 NSObject 做消息转发要实现一个方法不同，这里要实现下面这两个方法</span></span><br><span class="line"><span class="comment">// 返回方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发，即让谁去调用方法</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>ViewController.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;MJProxy1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:[MJProxy proxyWithTarget:<span class="keyword">self</span>] selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)timerTest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>, __func__);</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>运行，一切正常。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">我的objc4-756.2源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="http://blog.devtang.com/2014/05/30/understand-tagged-pointer/">深入理解Tagged Pointer</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904104163016718#heading-22">iOS内存管理一：Tagged Pointer&amp;引用计数</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6949590957083852807#heading-9">iOS-底层原理 33：内存管理（一）</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6857758064658153486#heading-21">iOS探索 内存管理篇</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/24-AutoReleasePool%20&amp;%20NSRunLoop/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">24-AutoReleasePool &amp; NSRunLoop</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/07/13/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/22-iOS%20App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"><span class="level-item">22-iOS App 启动优化</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、内存布局"><span class="level-left"><span class="level-item">一、内存布局</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-五大区"><span class="level-left"><span class="level-item">1.1 五大区</span></span></a></li><li><a class="level is-mobile" href="#1-2-内存布局面试题"><span class="level-left"><span class="level-item">1.2 内存布局面试题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、内存管理方案"><span class="level-left"><span class="level-item">二、内存管理方案</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-taggedPointer-简介"><span class="level-left"><span class="level-item">2.1 taggedPointer 简介</span></span></a></li><li><a class="level is-mobile" href="#2-2-taggedPointer-底层探索"><span class="level-left"><span class="level-item">2.2 taggedPointer 底层探索</span></span></a></li><li><a class="level is-mobile" href="#2-3-taggedPointer-总结"><span class="level-left"><span class="level-item">2.3 taggedPointer 总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、NONPOINTER-ISA"><span class="level-left"><span class="level-item">三、NONPOINTER_ISA</span></span></a></li><li><a class="level is-mobile" href="#四、SideTable"><span class="level-left"><span class="level-item">四、SideTable</span></span></a></li><li><a class="level is-mobile" href="#五、ARC-amp-MRC"><span class="level-left"><span class="level-item">五、ARC &amp; MRC</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-alloc"><span class="level-left"><span class="level-item">5.1 alloc</span></span></a></li><li><a class="level is-mobile" href="#5-2-retain"><span class="level-left"><span class="level-item">5.2 retain</span></span></a></li><li><a class="level is-mobile" href="#5-3-release"><span class="level-left"><span class="level-item">5.3 release</span></span></a></li><li><a class="level is-mobile" href="#5-4-retainCount"><span class="level-left"><span class="level-item">5.4 retainCount</span></span></a></li><li><a class="level is-mobile" href="#5-5-dealloc"><span class="level-left"><span class="level-item">5.5 dealloc</span></span></a></li></ul></li><li><a class="level is-mobile" href="#六、NSTimer-循环引用"><span class="level-left"><span class="level-item">六、NSTimer 循环引用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-原因"><span class="level-left"><span class="level-item">6.1 原因</span></span></a></li><li><a class="level is-mobile" href="#6-2-解决方案"><span class="level-left"><span class="level-item">6.2 解决方案</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#方案一：提前-invalidate【推荐】"><span class="level-left"><span class="level-item">方案一：提前 invalidate【推荐】</span></span></a></li><li><a class="level is-mobile" href="#方案二：中介者模式"><span class="level-left"><span class="level-item">方案二：中介者模式</span></span></a></li><li><a class="level is-mobile" href="#方案三：使用-NSProxy【推荐】"><span class="level-left"><span class="level-item">方案三：使用 NSProxy【推荐】</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>