<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>16-GCD底层原理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="16-GCD底层原理"><meta property="og:url" content="http://evilimo.com/2021/04/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-GCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"><meta property="article:published_time" content="2021-04-15T03:00:24.968Z"><meta property="article:modified_time" content="2021-04-15T03:20:44.826Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/04/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-GCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png","https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png","https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"],"datePublished":"2021-04-15T03:00:24.968Z","dateModified":"2021-04-15T03:20:44.826Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/04/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-GCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-15T03:00:24.968Z" title="2021-04-15T03:00:24.968Z">2021-04-15</time>发表</span><span class="level-item"><time dateTime="2021-04-15T03:20:44.826Z" title="2021-04-15T03:20:44.826Z">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">16-GCD底层原理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="如何定位源码"><a href="#如何定位源码" class="headerlink" title="如何定位源码"></a>如何定位源码</h2><p>已知要研究<code>GCD</code>，所以有以下几种选择源码的方法：</p>
<ul>
<li><p>Baidu/Google</p>
</li>
<li><p>下符号断点<code>dispatch_queue_create</code></p>
<p>首先写下测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> aaqueue = dispatch_queue_create(<span class="string">&quot;aa&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>然后添加符号断点：</p>
<img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png" alt="" style="zoom:50%;" />
</li>
<li><p>仅使用<code>Debug-&gt;Debug Workflow-&gt;Always show Disassembly</code>，断点到上面的测试代码，查看汇编也能看到定位在<code>libdispatch.dylib</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png"></p>
</li>
</ul>
<p>苹果官网的：<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="一、开始研究-GCD"><a href="#一、开始研究-GCD" class="headerlink" title="一、开始研究 GCD"></a>一、开始研究 GCD</h2><p>首先创建两个常见的队列，串行队列和并发队列，然后分别 <code>po</code> 一下，再顺便把主队列和全局队列分别一起给看了。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<ul>
<li><p>发现主队列的 <code>width</code> 和串行队列的 <code>width</code> 是一样的，其他的也有很多相同的，难怪说主队列是特殊的串行队列。</p>
</li>
<li><p>但是并发队列和全局队列的 <code>width</code> 却相差 1，有点奇怪。接下来我们就到源码中一探究竟吧。</p>
</li>
</ul>
<h2 id="二、创建队列在底层是怎样实现的"><a href="#二、创建队列在底层是怎样实现的" class="headerlink" title="二、创建队列在底层是怎样实现的"></a>二、创建队列在底层是怎样实现的</h2><p>先上结论：</p>
<ul>
<li>自定义并发队列和串行队列，是从<strong>根队列数组</strong>中取出模板属性，然后经过了一系列的开辟空间、构造、赋值等操作创建出来的。</li>
<li><strong>根队列数组</strong>是在<code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的。</li>
</ul>
<h3 id="2-1-自定义队列的创建"><a href="#2-1-自定义队列的创建" class="headerlink" title="2.1 自定义队列的创建"></a>2.1 自定义队列的创建</h3><p>根据我们的调用：<code>dispatch_queue_create(&quot;aa&quot;, NULL);</code>，全局搜索<code>dispatch_queue_create</code>。但是会出现搜索结果巨多的情况（66 results in 17 files），此时我们应该修改搜索条件：</p>
<ul>
<li>由于创建队列代码为<code>dispatch_queue_create(&quot;&quot;, NULL)</code>，所以搜索<code>dispatch_queue_create(</code>——将筛选结果降至（21 results in 6 files）</li>
<li>由于第一个参数为字符串，在c语言中用<code>const</code>修饰，所以搜索<code>dispatch_queue_create(const</code>——将筛选结果降至（2 results in 2 files），由此找到了我们需要看的底层代码</li>
</ul>
<h4 id="2-1-1-dispatch-queue-create"><a href="#2-1-1-dispatch-queue-create" class="headerlink" title="2.1.1 dispatch_queue_create"></a>2.1.1 dispatch_queue_create</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现去调用了 <code>_dispatch_lane_create_with_target</code>方法，常规的接口隔离操作。</p>
<h4 id="2-1-2-dispatch-lane-create-with-target"><a href="#2-1-2-dispatch-lane-create-with-target" class="headerlink" title="2.1.2 _dispatch_lane_create_with_target"></a>2.1.2 _dispatch_lane_create_with_target</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ✅2.3</span></span><br><span class="line">	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	dispatch_qos_t qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	_dispatch_queue_attr_overcommit_t overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify both overcommit and &quot;</span></span><br><span class="line">					<span class="string">&quot;a non-global target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				<span class="comment">// 并发队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 串行队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify an overcommit attribute &quot;</span></span><br><span class="line">					<span class="string">&quot;and use this kind of target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;	<span class="comment">// 并发是...disable，串行是...enable</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// ✅一定会走这里</span></span><br><span class="line">		<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.4 开辟内存 - 生成相应的对象 queue</span></span><br><span class="line">	dispatch_lane_t dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2.5 构造方法</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 标签</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ✅2.6</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法较长，我们拆开重点代码进行分析。</p>
<h4 id="2-1-3-dispatch-queue-attr-to-info"><a href="#2-1-3-dispatch-queue-attr-to-info" class="headerlink" title="2.1.3 _dispatch_queue_attr_to_info"></a>2.1.3 _dispatch_queue_attr_to_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br></pre></td></tr></table></figure>

<p>其中传入这个方法的参数<code>dqa</code>为<code>dispatch_queue_attr_t</code>类型的，串行队列传入的是<code>NULL</code>，并发传入的是<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<p>将<code>dqa</code>参数传入后，生成了<code>dispatch_queue_attr_info_t</code>对象<code>dqai</code>。</p>
<blockquote>
<p>我们可以发现<code>dispatch_queue_attr_info_t</code>是一个结构体位域的形式，里面包含了一些<code>dispatch_qos_t</code>等优先级的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_info_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> dqai_qos : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span>      dqai_relpri : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_overcommit:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_autorelease_frequency:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_concurrent:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_inactive:<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">dispatch_queue_attr_info_t</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>进入方法查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span></span><br><span class="line">_dispatch_queue_attr_to_info(<span class="keyword">dispatch_queue_attr_t</span> dqa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 串行队列直接返回空结构体。后续代码都是对并发队列进行的操作</span></span><br><span class="line">	<span class="keyword">if</span> (!dqa) <span class="keyword">return</span> dqai;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_VARIANT_STATIC</span></span><br><span class="line">	<span class="keyword">if</span> (dqa == &amp;_dispatch_queue_attr_concurrent) &#123;</span><br><span class="line">		dqai.dqai_concurrent = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> dqai;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dqa &lt; _dispatch_queue_attrs ||</span><br><span class="line">			dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 苹果的算法</span></span><br><span class="line">	<span class="keyword">size_t</span> idx = (<span class="keyword">size_t</span>)(dqa - _dispatch_queue_attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发队列结构体位域的默认配置和赋值</span></span><br><span class="line">	dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发数。✅重点关注。只有并发队列才有这个值</span></span><br><span class="line">	dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_relpri = -(<span class="keyword">int</span>)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_autorelease_frequency =</span><br><span class="line">			idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dqai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当为串行队列的时候，传入的参数为<code>NULL</code>，直接返回一个空结构体。所以代码后续对<code>dqai</code>的操作都是基于并发队列的，并通过此来<strong>进行判断取值</strong>。</p>
<p>那么对于并发队列，会根据传入的宏定义参数，通过位运算，来给<code>dqai</code>进行赋值，比较主要的有并发数（<code>dqai_concurrent</code>），优先级（<code>dqai_qos</code>）等。</p>
<h4 id="2-1-4-dispatch-object-alloc"><a href="#2-1-4-dispatch-object-alloc" class="headerlink" title="2.1.4 _dispatch_object_alloc"></a>2.1.4 _dispatch_object_alloc</h4><p>虽然在上一步获取到了<code>dispatch_queue_attr_info_t</code>相关的值，但是它并不是最终返回的线程，只是我们用来获取一些配置的临时变量而已。</p>
<p>看<code>_dispatch_lane_create_with_target</code>方法最后一行，发现最终返回的是一个<code>dispatch_lane_t</code>类型的<code>dq</code>的对象，所以<code>dispatch_lane_t</code>应该是最终生成的队列，我们可以发现它是由<code>_dispatch_object_alloc</code>方法创建出来的。</p>
<p>但是<code>_dispatch_object_alloc</code>方法并没有开源，所以我们不知道里面是如何实现的。</p>
<p>不过<code>_dispatch_object</code>很像OC中的<code>NSObject</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br></pre></td></tr></table></figure>



<p><strong>dispatch_object_t</strong></p>
<p>通过搜索<code>dispatch_object</code>，发现并找不到我们需要的多线程抽象类，不过我们发现，一般多线程的对象后面都有<code>_t</code>，所以我们找到了<code>dispatch_object_t</code>这个多线程的抽象类。</p>
<p>我们可以发现其是一个联合体，和我们<code>isa</code>的结果极其类似，里面包含了我们常用的很多信息。因为联合体互斥，这样做有利于内存的优化，和更好的实现多态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span>	       <span class="comment">// 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>	       <span class="comment">// 队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>	   <span class="comment">// 参数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>	       <span class="comment">// 组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_s</span> *_<span class="title">dch</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>   <span class="comment">// 信号量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-dispatch-queue-init"><a href="#2-1-5-dispatch-queue-init" class="headerlink" title="2.1.5 _dispatch_queue_init"></a>2.1.5 _dispatch_queue_init</h4><p>当我们创建出<code>dispatch_lane_t</code>对象<code>dq</code>后，紧接着就执行<code>_dispatch_queue_init</code>构造方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>



<p>查看方法内部实现，发现通过<code>dispatch_queue_t dq = dqu._dq;</code>取出队列后，对队列又进行了一系列的赋值，然后又返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> width, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line">	<span class="comment">// 取出队列</span></span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行了一系列赋值</span></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(width);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="comment">// 又返回了</span></span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>关注一下这个方法中的第三个参数，是一个判断：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>判断了<code>dqai.dqai_concurrent</code>，我们知道串行是没有<code>dqai_concurrent</code>的，所以串行队列的这个属性为1，就表示串行队列的并发数为1。</p>
<p>那么并发队列的这个属性就为：<code>DISPATCH_QUEUE_WIDTH_MAX</code>。</p>
<p>查看<code>DISPATCH_QUEUE_WIDTH_MAX</code>宏定义，我们发现它的值为<code>DISPATCH_QUEUE_WIDTH_FULL-2</code>，即<code>0xFFE</code>，所以并发队列的最大并发数为<code>0xFFE</code>。</p>
<p>至于<code>-2</code>则是因为<code>-1</code>是为了不饱和，再<code>-1</code>是因为<code>DISPATCH_QUEUE_WIDTH_POOL</code>为创建全局队列时候所使用的，避免相同。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png"></p>
<h4 id="2-1-6-dq-gt-do-targetq-tq"><a href="#2-1-6-dq-gt-do-targetq-tq" class="headerlink" title="2.1.6 dq-&gt;do_targetq = tq;"></a>2.1.6 dq-&gt;do_targetq = tq;</h4><p>执行完构造函数之后，接着又对<code>dq</code>进行了一些列赋值。</p>
<p>但是如果每次创建线程，所有的属性都要重新赋值的话，是比较耗性能的。所以苹果设计了基于“模板”的队列创建方式，这个”模板”就是我们的<code>do_targetq</code>属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签</span></span><br><span class="line">dq-&gt;dq_label = label;</span><br><span class="line"><span class="comment">// 优先级</span></span><br><span class="line">dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">		dqai.dqai_relpri);</span><br><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">	dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">	_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_retain(tq);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅2.6</span></span><br><span class="line">dq-&gt;do_targetq = tq;</span><br><span class="line"></span><br><span class="line">_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br></pre></td></tr></table></figure>

<p>在方法中寻找，我们可以发现<code>tq</code>的创建是通过<code>_dispatch_get_root_queue</code>方法，即在根队列的基础上创建，然后赋值了优先级<code>qos</code>和<code>overcommit</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">	<span class="comment">// ✅一定会走这里</span></span><br><span class="line">	<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">	tq = _dispatch_get_root_queue(</span><br><span class="line">			qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">			overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看<code>qos</code>的值，我们发现<code>DISPATCH_QOS_UNSPECIFIED</code>为0，且之前我们并没有赋值，所以一般情况下即执行<code>DISPATCH_QOS_DEFAULT</code>，为4，所以<code>qos</code>没指定的情况下为4。</p>
<p>接着看<code>overcommit</code>的值，根据上面<code>dqai</code>可以判断出，串行为1，并发为0</p>
<h4 id="2-1-7-dispatch-get-root-queue"><a href="#2-1-7-dispatch-get-root-queue" class="headerlink" title="2.1.7 _dispatch_get_root_queue"></a>2.1.7 _dispatch_get_root_queue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_global_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4 - 1 = 3</span></span><br><span class="line">	<span class="comment">// 2 * 3 + 0/1 = 6/7</span></span><br><span class="line">	<span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，最终就是从==根队列数组==里通过下标来取出队列。</p>
<p>根据入参可以知道，下标为6或者7。也就是说从<strong>根队列数组</strong>中取出第六个和第七个队列。</p>
<h4 id="2-1-8-dispatch-root-queues"><a href="#2-1-8-dispatch-root-queues" class="headerlink" title="2.1.8 _dispatch_root_queues[]"></a>2.1.8 _dispatch_root_queues[]</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">		((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = _dispatch_root_queue_ctxt(_DISPATCH_ROOT_QUEUE_IDX(n, flags)), \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = flags | ((flags &amp; DISPATCH_PRIORITY_FLAG_FALLBACK) ? \</span><br><span class="line">				_dispatch_priority_make_fallback(DISPATCH_QOS_##n) : \</span><br><span class="line">				_dispatch_priority_make(DISPATCH_QOS_##n, <span class="number">0</span>)), \</span><br><span class="line">		__VA_ARGS__ \</span><br><span class="line">	&#125;</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,  		<span class="comment">// 自定义串行队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">10</span>,			<span class="comment">// 自定义并发队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">			DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">11</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">12</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">13</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">14</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">15</span>,</span><br><span class="line">	),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<strong>下标</strong>，我们可以得出如下结论。</p>
<ul>
<li>自定义并发队列<code>target</code>队列为<code>com.apple.root.default-qos</code></li>
<li>自定义串行队列<code>target</code>队列为<code>com.apple.root.default-qos.overcommit</code></li>
</ul>
<blockquote>
<p>至此，我们自定义的一个串行或者并发队列就已经根据模板创建完成了</p>
</blockquote>
<h4 id="2-1-9-验证"><a href="#2-1-9-验证" class="headerlink" title="2.1.9 验证"></a>2.1.9 验证</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<p>回看我们开头打印的一些关于各种队列的信息，可以看到：</p>
<ul>
<li>串行队列、并发队列的<code>target</code>确实对应模板中的值</li>
<li>串行队列、并发队列、主队列、全局队列的<code>width</code>（<code>width</code>表示队列中的最大并发数）都与我们的分析一致，即：<ul>
<li>串行队列和主队列的<code>width</code>为1</li>
<li>自定义并发队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_MAX</code>，是满值-2</li>
<li>全局队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_POOL</code>，是满值-1</li>
</ul>
</li>
</ul>
<blockquote>
<p>由此可见，我们对于底层的分析是正确的。</p>
</blockquote>
<h3 id="2-2-根队列数组的初始化"><a href="#2-2-根队列数组的初始化" class="headerlink" title="2.2 根队列数组的初始化"></a>2.2 根队列数组的初始化</h3><p>除了<code>dispatch_get_main_queue</code>，其他队列都是通过<code>_dispatch_root_queues</code>创建的，那么 <code>_dispatch_root_queues</code> 又是在哪创建的呢？</p>
<p>结论：</p>
<p><code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"></p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>我用的<a target="_blank" rel="noopener" href="https://github.com/speam/libdispatch.git">libdispatch源码</a></p>
<p>苹果官网的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099201155079#heading-3">iOS GCD源码浅析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904097871577102#heading-3">iOS底层学习 - 多线程之GCD队列原理篇</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/08/Mac/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Mac应用程序无法打开或文件损坏的解决办法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/04/08/iOS%C2%B7%E7%BB%9F%E8%AE%A1/%E5%9F%8B%E7%82%B9%20SDK%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><span class="level-item">埋点 SDK 使用指南</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#如何定位源码"><span class="level-left"><span class="level-item">如何定位源码</span></span></a></li><li><a class="level is-mobile" href="#一、开始研究-GCD"><span class="level-left"><span class="level-item">一、开始研究 GCD</span></span></a></li><li><a class="level is-mobile" href="#二、创建队列在底层是怎样实现的"><span class="level-left"><span class="level-item">二、创建队列在底层是怎样实现的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-自定义队列的创建"><span class="level-left"><span class="level-item">2.1 自定义队列的创建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-dispatch-queue-create"><span class="level-left"><span class="level-item">2.1.1 dispatch_queue_create</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-dispatch-lane-create-with-target"><span class="level-left"><span class="level-item">2.1.2 _dispatch_lane_create_with_target</span></span></a></li><li><a class="level is-mobile" href="#2-1-3-dispatch-queue-attr-to-info"><span class="level-left"><span class="level-item">2.1.3 _dispatch_queue_attr_to_info</span></span></a></li><li><a class="level is-mobile" href="#2-1-4-dispatch-object-alloc"><span class="level-left"><span class="level-item">2.1.4 _dispatch_object_alloc</span></span></a></li><li><a class="level is-mobile" href="#2-1-5-dispatch-queue-init"><span class="level-left"><span class="level-item">2.1.5 _dispatch_queue_init</span></span></a></li><li><a class="level is-mobile" href="#2-1-6-dq-gt-do-targetq-tq"><span class="level-left"><span class="level-item">2.1.6 dq-&gt;do_targetq = tq;</span></span></a></li><li><a class="level is-mobile" href="#2-1-7-dispatch-get-root-queue"><span class="level-left"><span class="level-item">2.1.7 _dispatch_get_root_queue</span></span></a></li><li><a class="level is-mobile" href="#2-1-8-dispatch-root-queues"><span class="level-left"><span class="level-item">2.1.8 _dispatch_root_queues[]</span></span></a></li><li><a class="level is-mobile" href="#2-1-9-验证"><span class="level-left"><span class="level-item">2.1.9 验证</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-根队列数组的初始化"><span class="level-left"><span class="level-item">2.2 根队列数组的初始化</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>