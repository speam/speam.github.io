<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>14-KVO原理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="14-KVO原理"><meta property="og:url" content="http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png"><meta property="article:published_time" content="2021-03-26T03:09:32.152Z"><meta property="article:modified_time" content="2021-03-26T07:51:39.178Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png"],"datePublished":"2021-03-26T03:09:32.152Z","dateModified":"2021-03-26T07:51:39.178Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-26T03:09:32.152Z" title="2021-03-26T03:09:32.152Z">2021-03-26</time>发表</span><span class="level-item"><time dateTime="2021-03-26T07:51:39.178Z" title="2021-03-26T07:51:39.178Z">2021-03-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">14-KVO原理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、KVO简述"><a href="#一、KVO简述" class="headerlink" title="一、KVO简述"></a>一、KVO简述</h2><p><code>KVO（Key-Value Observing）</code>是苹果提供的一套事件通知机制，开发者可以使用它来检测对象属性的变化、快速做出响应。</p>
<p>在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">Documentation Archieve</a>中提到一句想要理解<code>KVO</code>，必须先理解<code>KVC</code>，因为<code>键值观察</code>是建立在<code>键值编码</code>的基础上。</p>
<blockquote>
<p>而<code>KVO</code>和<code>NSNotificatioCenter</code>都是iOS观察者模式的一种实现，两者的区别在于：</p>
<ul>
<li>相对于被观察者和观察者之间的关系，<code>KVO</code>是一对一的，<code>NSNotificatioCenter</code>是一对多的</li>
<li><code>KVO</code>对被监听对象无侵入性，不需要修改其内部代码即可实现监听</li>
</ul>
</blockquote>
<h2 id="二、KVO使用及注意点"><a href="#二、KVO使用及注意点" class="headerlink" title="二、KVO使用及注意点"></a>二、KVO使用及注意点</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>KVO使用三部曲：</p>
<ul>
<li>注册观察者</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>实现回调</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@&quot;name&quot;</span>]) <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除观察者</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-context-说明"><a href="#2-context-说明" class="headerlink" title="2.context 说明"></a>2.context 说明</h3><p>如果父类中有个<code>name</code>属性，子类中也有个<code>name</code>属性，两者都注册对<code>name</code>的观察，那么仅通过<code>keyPath</code>已经区分不了是哪个<code>name</code>发生变化了，现有两个解决办法：</p>
<ul>
<li>多加一层判断：判断<code>object</code>，但是会出现很多 if…else…</li>
<li>使用<code>context</code>传递信息，更安全、更可扩展</li>
</ul>
<p><strong><code>context</code>使用总结:</strong></p>
<ul>
<li>不使用context作为观察值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context是 void * 类型，应该填 NULL 而不是 nil</span></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>使用context传递信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *ChildNameContext = &amp;ChildNameContext;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:PersonNameContext];</span><br><span class="line">[<span class="keyword">self</span>.child addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:ChildNameContext];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == PersonNameContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == ChildNameContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-移除观察的必要性"><a href="#3-移除观察的必要性" class="headerlink" title="3.移除观察的必要性"></a>3.移除观察的必要性</h3><p>不移除会带来潜在的隐患：</p>
<p>如果观察者对象 dealloc 的时候没有移除对目标属性的观察，当目标属性改变的时候，还是会通知该观察者，但是该观察者此时已经释放了，就会出现野指针的情况。</p>
<p>例如：<code>LGPerson</code>是一个单例对象，它有个属性<code>name</code>。然后在<code>FirstViewController</code>和<code>SecondViewController</code>中都对<code>LGPerson</code>对象的<code>name</code>属性进行了KVO观察。</p>
<p>操作顺序是从<code>FirstViewController</code>push到<code>SecondViewController</code>，然后从<code>SecondViewController</code>pop 到<code>FirstViewController</code>。</p>
<p>假如<code>SecondViewController</code>在 dealloc 的时候没有移除观察者，但是这个<code>LGPerson</code>对象由于是单例所以没有销毁。然后在<code>FirstViewController</code>中<code>name</code>属性被改变了。此时就会通知它的观察者即<code>SecondViewController</code>，但是<code>SecondViewController</code>这个观察者已经释放了，再次访问它就会造成访问野指针的情况。</p>
<p><strong>所以说，该移除观察的时候就要移除。</strong></p>
<blockquote>
<p>苹果官方推荐的方式是——在<code>init</code>的时候进行<code>addObserver</code>，在<code>dealloc</code>时<code>removeObserver</code>，这样可以保证<code>add</code>和<code>remove</code>是成对出现的，这是一种比较理想的使用方式</p>
</blockquote>
<h3 id="4-手动触发键值观察"><a href="#4-手动触发键值观察" class="headerlink" title="4.手动触发键值观察"></a>4.手动触发键值观察</h3><p>有时候业务需求需要观察某个属性值，一会儿要观察了，一会又不要观察了…如果把<code>KVO三部曲</code>整体去掉、再整体添上，必然又是一顿繁琐而又不必要的工作，好在KVO中有两种办法可以手动触发键值观察：</p>
<ul>
<li>将被观察者的<code>automaticallyNotifiesObserversForKey</code>返回NO（可以只对某个属性设置），这样就不会自动观察属性的变化了，而是通过手动通知的方式去观察。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;name&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>重写被观察者的属性的<code>setter</code>方法</p>
<p>这两个方法用于通知系统该 key 的属性值即将和已经变更了</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">    _name = name;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式使用的排列组合如下，可以自由组合如何使用</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>回调次数</th>
</tr>
</thead>
<tbody><tr>
<td>正常情况</td>
<td>1</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为NO</td>
<td>0</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为NO且添加willChangeValueForKey、didChangeValueForKey</td>
<td>1</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为YES且添加willChangeValueForKey、didChangeValueForKey</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>最近发现[self willChangeValueForKey:name]和[self willChangeValueForKey:”name”]两种写法是不同的结果：重写setter方法取属性值操作不会额外发送通知；而使用“name”会额外发送一次通知</p>
</blockquote>
<h3 id="5-Key-依赖情况"><a href="#5-Key-依赖情况" class="headerlink" title="5.Key 依赖情况"></a>5.Key 依赖情况</h3><p>比如有一个下载任务的需求，根据<code>总下载量Total</code>和<code>当前已下载量Current</code>来得到<code>当前下载进度progress</code>，这个需求就有两种实现：</p>
<ul>
<li>分别观察<code>总下载量Total</code>和<code>当前已下载量Current</code>两个属性，其中一个属性发生变化时计算求值<code>当前下载进度Process</code>【太麻烦了】</li>
<li>实现<code>keyPathsForValuesAffectingValueForKey</code>方法，并观察<code>progress</code>属性【采用】</li>
</ul>
<p><code>progress</code>属性受到<code>current</code>和<code>total</code>属性变化的影响，如果我们想只监听<code>progress</code>，又保证<code>current</code>和<code>total</code>变化时能收到<code>KVO</code>中的回调告诉我们<code>progress</code>变化了，我们需要实现<code>+keyPathsForValuesAffectingValueForKey:</code>方法来关联两个属性到<code>progress</code>上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;progress&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@&quot;current&quot;</span>, <span class="string">@&quot;total&quot;</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person 类中<code>progess</code>受到两个属性变化的影响</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)progress &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.current / <span class="keyword">self</span>.total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加监听：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person = p;</span><br><span class="line">p.current = <span class="number">0</span>;</span><br><span class="line">p.total = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;progress&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<p>监听回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>current</code>和<code>total</code>变化时，就能监听到<code>progress</code>的变化了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.current += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.person.total += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-可变数组"><a href="#6-可变数组" class="headerlink" title="6.可变数组"></a>6.可变数组</h3><p>首先添加对<code>dataArray</code>这个可变数组的观察：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;dateArray&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<p>然后调用下面代码，对<code>dateArray</code>数组添加元素</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person.dateArray addObject:<span class="string">@&quot;hello&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>这样会不会触发KVO通知呢？答案是不会的，因为KVO是给予set方法的，这样不会触发set方法，所以就不会触发KVO通知。正确的做法应该是下面这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.person mutableArrayValueForKey:<span class="string">@&quot;dateArray&quot;</span>] addObject:<span class="string">@&quot;hello&quot;</span>];</span><br></pre></td></tr></table></figure>

<h2 id="三、KVO-底层原理—isa-swizzling"><a href="#三、KVO-底层原理—isa-swizzling" class="headerlink" title="三、KVO 底层原理—isa-swizzling"></a>三、KVO 底层原理—isa-swizzling</h2><h3 id="1-官方解释"><a href="#1-官方解释" class="headerlink" title="1.官方解释"></a>1.官方解释</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png" alt="img"></p>
<p><code>Key-Value Observing Programming Guide</code>中有一段底层实现原理的叙述</p>
<ul>
<li>KVO是使用<code>isa-swizzling</code>技术实现的</li>
<li>isa指针指向对象的类</li>
<li>在为对象的属性注册观察者时，将修改观察对象的<code>isa</code>指针，指向中间类而不是真实类。所以<code>isa</code>指针的值不一定反映对象的实际类。</li>
<li>您永远不应依靠<code>isa</code>指针来确定类成员身份。相反，您应该使用<code>class</code>方法来确定对象实例的类</li>
</ul>
<h3 id="2-代码探索"><a href="#2-代码探索" class="headerlink" title="2.代码探索"></a>2.代码探索</h3><ul>
<li><p>注册观察者之前：类对象为</p>
<p><code>FXPerson</code>，实例对象isa指向<code>FXPerson</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png" alt="img"></p>
</li>
<li><p>注册观察者之后：类对象为</p>
<p><code>FXPerson</code>，实例对象<code>isa</code>指向<code>NSKVONotifying_FXPerson</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png" alt="img"></p>
</li>
</ul>
<p>从这两图中可以得出一个结论：观察者注册前后<code>FXPerson类</code>没发生变化，但实例对象的<code>isa</code>指向发生了变化</p>
<p>那么这个动态生成的中间类<code>NSKVONotifying_FXPerson</code>和<code>FXPerson</code>是什么关系呢？</p>
<p>在注册观察者前后分别打印子类——发现<code>NSKVONotifying_FXPerson</code>是<code>FXPerson</code>的子类</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png" alt="img"></p>
<h3 id="3-动态子类探索"><a href="#3-动态子类探索" class="headerlink" title="3.动态子类探索"></a>3.动态子类探索</h3><p>①首先得明白动态子类观察的是什么？下面观察<code>属性变量name</code>和<code>成员变量nickname</code>来找区别</p>
<p>两个变量同时发生变化，但只有<code>属性变量</code>监听到回调——说明动态子类观察的是<code>setter</code>方法</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png" alt="img"></p>
<p>②通过<code>runtime-API</code>打印一下动态子类和观察类的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClassAllMethod:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@-%p&quot;</span>,<span class="built_in">NSStringFromSelector</span>(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png" alt="img"></p>
<p>通过打印可以看出：</p>
<ul>
<li><code>FXPerson类</code>中的方法没有改变（imp实现地址没有变化）</li>
<li><code>NSKVONotifying_FXPerson类</code>中重写了父类<code>FXPerson</code>的<code>dealloc</code>方法</li>
<li><code>NSKVONotifying_FXPerson</code>类中重写了基类<code>NSObject</code>的<code>class</code>方法和<code>_isKVOA</code>方法<ul>
<li>重写的<code>class</code>方法可以指回<code>FXPerson类</code></li>
</ul>
</li>
<li><code>NSKVONotifying_FXPerson</code>类中重写了父类<code>FXPerson</code>的<code>setName</code>方法<ul>
<li>因为子类只继承、不重写是不会有方法imp的，调用方法时会问父类要方法实现</li>
<li>且两个<code>setName</code>的地址指针不一样</li>
<li>每观察一个<code>属性变量</code>就重写一个<code>setter</code>方法（可自行论证）</li>
</ul>
</li>
</ul>
<p>③<code>dealloc</code>之后<code>isa</code>指向谁？——指回原类</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png" alt="img"></p>
<p>④<code>dealloc</code>之后动态子类会销毁吗？——不会</p>
<p>页面pop后再次push进来打印<code>FXPerson类</code>的子类，子类<code>NSKVONotifying_FXPerson类</code>依旧存在</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png" alt="img"></p>
<p>⑤<code>automaticallyNotifiesObserversForKey</code>是否会影响动态子类生成——会</p>
<p>动态子类会根据观察属性的<code>automaticallyNotifiesObserversForKey</code>的布尔值来决定是否生成</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><ol>
<li><code>automaticallyNotifiesObserversForKey</code>为<code>YES</code>时注册观察属性会生成动态子类<code>NSKVONotifying_XXX</code></li>
<li>动态子类观察的是<code>setter</code>方法</li>
<li>动态子类重写了观察属性的<code>setter</code>方法、<code>dealloc</code>、<code>class</code>、<code>_isKVOA</code>方法<ul>
<li><code>setter</code>方法用于观察键值</li>
<li><code>dealloc</code>方法用于释放时对<code>isa</code>指向进行操作</li>
<li><code>class</code>方法用于指回动态子类的父类</li>
<li><code>_isKVOA</code>用来标识是否是在观察者状态的一个标志位</li>
</ul>
</li>
<li><code>dealloc</code>之后<code>isa</code>指向元类</li>
<li><code>dealloc</code>之后动态子类不会销毁</li>
</ol>
<h2 id="四、自定义KVO"><a href="#四、自定义KVO" class="headerlink" title="四、自定义KVO"></a>四、自定义KVO</h2><blockquote>
<p>根据KVO的官方文档和上述结论，我们将自定义KVO——下面的自定义会有runtime-API的使用和接口设计思路的讲解，最终的自定义KVO能满足基本使用的需求但仍不完善。系统的KVO回调和自动移除观察者都与注册逻辑分层，自定义的KVO将使用block回调和自动释放来优化这一点不足</p>
</blockquote>
<p>新建一个<code>NSObject+FXKVO</code>的分类，开放注册观察者方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)fx_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(FXKVOBlock)block;</span><br></pre></td></tr></table></figure>

<h3 id="1-注册观察者"><a href="#1-注册观察者" class="headerlink" title="1.注册观察者"></a>1.注册观察者</h3><p>1.判断<code>当前观察值keypath</code>是否存在/setter方法是否存在</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (keyPath == <span class="literal">nil</span> || keyPath.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (![<span class="keyword">self</span> isContainSetterMethodFromKeyPath:keyPath]) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断setter方法</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isContainSetterMethodFromKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    Class superClass    = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    SEL setterSeletor   = <span class="built_in">NSSelectorFromString</span>(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod(superClass, setterSeletor);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;没找到该属性的setter方法%@&quot;</span>, keyPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.判断观察属性的<code>automaticallyNotifiesObserversForKey</code>方法返回的布尔值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isAutomatically = [<span class="keyword">self</span> fx_performSelectorWithMethodName:<span class="string">@&quot;automaticallyNotifiesObserversForKey:&quot;</span> keyPath:keyPath];</span><br><span class="line"><span class="keyword">if</span> (!isAutomatically) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态调用类方法</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)fx_performSelectorWithMethodName:(<span class="built_in">NSString</span> *)methodName keyPath:(<span class="keyword">id</span>)keyPath &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([[<span class="keyword">self</span> <span class="keyword">class</span>] respondsToSelector:<span class="built_in">NSSelectorFromString</span>(methodName)]) &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-performSelector-leaks&quot;</span></span></span><br><span class="line">        <span class="built_in">BOOL</span> i = [[<span class="keyword">self</span> <span class="keyword">class</span>] performSelector:<span class="built_in">NSSelectorFromString</span>(methodName) withObject:keyPath];</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.动态生成子类，添加<code>class</code>方法指向原先的类</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态生成子类</span></span><br><span class="line">Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br><span class="line"></span><br><span class="line">- (Class)createChildClassWithKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@&quot;</span>, kFXKVOPrefix, oldClassName];</span><br><span class="line">    Class newClass = <span class="built_in">NSClassFromString</span>(newClassName);</span><br><span class="line">    <span class="comment">// 防止重复创建生成新类</span></span><br><span class="line">    <span class="keyword">if</span> (newClass) <span class="keyword">return</span> newClass;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 申请类</span></span><br><span class="line">    newClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注册类</span></span><br><span class="line">    objc_registerClassPair(newClass);</span><br><span class="line">    <span class="comment">// class的指向是FXPerson</span></span><br><span class="line">    SEL classSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;class&quot;</span>);</span><br><span class="line">    Method classMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], classSEL);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">    class_addMethod(newClass, classSEL, (IMP)fx_class, classTypes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>isa重指向——使对象的<code>isa</code>的值指向动态子类</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object_setClass(self, newClass);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ol>
<li>保存信息</li>
</ol>
<p>由于可能会观察多个属性值，所以以<code>属性值-模型</code>的形式一一保存在数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">typedef void(^FXKVOBlock)(id observer,NSString *keyPath,id oldValue,id newValue);</span><br><span class="line"></span><br><span class="line">@interface FXKVOInfo : NSObject</span><br><span class="line">@property (nonatomic, weak) NSObject *observer;</span><br><span class="line">@property (nonatomic, copy) NSString *keyPath;</span><br><span class="line">@property (nonatomic, copy) FXKVOBlock handleBlock;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation FXKVOInfo</span><br><span class="line"></span><br><span class="line">- (instancetype)initWitObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath handleBlock:(FXKVOBlock)block &#123;</span><br><span class="line">    if (self&#x3D;[super init]) &#123;</span><br><span class="line">        _observer &#x3D; observer;</span><br><span class="line">        _keyPath  &#x3D; keyPath;</span><br><span class="line">        _handleBlock &#x3D; block;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 保存信息</span><br><span class="line">FXKVOInfo *info &#x3D; [[FXKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line">NSMutableArray *mArray &#x3D; objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kFXKVOAssiociateKey));</span><br><span class="line">if (!mArray) &#123;</span><br><span class="line">    mArray &#x3D; [NSMutableArray arrayWithCapacity:1];</span><br><span class="line">    objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kFXKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">[mArray addObject:info];</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="2-添加setter方法并回调"><a href="#2-添加setter方法并回调" class="headerlink" title="2.添加setter方法并回调"></a>2.添加setter方法并回调</h3><p>往动态子类添加<code>setter</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (Class)createChildClassWithKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 添加setter</span><br><span class="line">    SEL setterSEL &#x3D; NSSelectorFromString(setterForGetter(keyPath));</span><br><span class="line">    Method setterMethod &#x3D; class_getInstanceMethod([self class], setterSEL);</span><br><span class="line">    const char *setterTypes &#x3D; method_getTypeEncoding(setterMethod);</span><br><span class="line">    class_addMethod(newClass, setterSEL, (IMP)fx_setter, setterTypes);</span><br><span class="line">    </span><br><span class="line">    return newClass;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>setter方法的具体实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static void fx_setter(id self,SEL _cmd,id newValue) &#123;</span><br><span class="line">    NSString *keyPath &#x3D; getterForSetter(NSStringFromSelector(_cmd));</span><br><span class="line">    id oldValue &#x3D; [self valueForKey:keyPath];</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 改变父类的值 --- 可以强制类型转换</span><br><span class="line">    void (*lg_msgSendSuper)(void *,SEL , id) &#x3D; (void *)objc_msgSendSuper;</span><br><span class="line">    struct objc_super superStruct &#x3D; &#123;</span><br><span class="line">        .receiver &#x3D; self,</span><br><span class="line">        .super_class &#x3D; class_getSuperclass(object_getClass(self)),</span><br><span class="line">    &#125;;</span><br><span class="line">    lg_msgSendSuper(&amp;superStruct,_cmd,newValue);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 信息数据回调</span><br><span class="line">    NSMutableArray *mArray &#x3D; objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kFXKVOAssiociateKey));</span><br><span class="line">    </span><br><span class="line">    for (FXKVOInfo *info in mArray) &#123;</span><br><span class="line">        if ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">            info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="3-销毁观察者"><a href="#3-销毁观察者" class="headerlink" title="3.销毁观察者"></a>3.销毁观察者</h3><p>往动态子类添加<code>dealloc</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (Class)createChildClassWithKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 添加dealloc</span><br><span class="line">    SEL deallocSEL &#x3D; NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">    Method deallocMethod &#x3D; class_getInstanceMethod([self class], deallocSEL);</span><br><span class="line">    const char *deallocTypes &#x3D; method_getTypeEncoding(deallocMethod);</span><br><span class="line">    class_addMethod(newClass, deallocSEL, (IMP)fx_dealloc, deallocTypes);</span><br><span class="line">    </span><br><span class="line">    return newClass;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>由于页面释放时会释放持有的对象，对象释放时会调用dealloc，现在往动态子类的dealloc方法名中添加实现将isa指回去，从而在释放时就不会去找父类要方法实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void fx_dealloc(id self, SEL _cmd) &#123;</span><br><span class="line">    Class superClass &#x3D; [self class];</span><br><span class="line">    object_setClass(self, superClass);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>但仅仅是这样还是不够的，只把isa指回去，但对象不会调用真正的dealloc方法，对象不会释放</p>
<p>出于这种情况，根据<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904079957688328#heading-23">iOS探索 runtime面试题分析</a>讲过的方法交换进行一波操作</p>
<ul>
<li>取出基类<code>NSObject</code>的dealloc实现与<code>fx_dealloc</code>进行方法交换</li>
<li>isa指回去之后继续调用真正的<code>dealloc</code>进行释放</li>
<li>之所以不在<code>+load</code>方法中进行交换，一是因为效率低，二是因为会影响到所有类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (Class)createChildClassWithKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x2F;&#x2F; 添加dealloc</span><br><span class="line">&#x2F;&#x2F;    SEL deallocSEL &#x3D; NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">&#x2F;&#x2F;    Method deallocMethod &#x3D; class_getInstanceMethod([self class], deallocSEL);</span><br><span class="line">&#x2F;&#x2F;    const char *deallocTypes &#x3D; method_getTypeEncoding(deallocMethod);</span><br><span class="line">&#x2F;&#x2F;    class_addMethod(newClass, deallocSEL, (IMP)fx_dealloc, deallocTypes);</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        [self FXMethodSwizzlingWithClass:[self class] oriSEL:NSSelectorFromString(@&quot;dealloc&quot;) swizzledSEL:@selector(fx_dealloc)];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return newClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)fx_dealloc &#123;</span><br><span class="line">    Class superClass &#x3D; [self class];</span><br><span class="line">    object_setClass(self, superClass);</span><br><span class="line">    [self fx_dealloc];</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>就这样自定义KVO将KVO三部曲用block形式合成一步</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904090569277447">iOS探索 KVO原理及自定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bf99c6dbfc03">KVO原理分析</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《指数基金投资指南》读书笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/23/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/13-KVC%E5%8E%9F%E7%90%86/"><span class="level-item">13-KVC原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、KVO简述"><span class="level-left"><span class="level-item">一、KVO简述</span></span></a></li><li><a class="level is-mobile" href="#二、KVO使用及注意点"><span class="level-left"><span class="level-item">二、KVO使用及注意点</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-基本使用"><span class="level-left"><span class="level-item">1.基本使用</span></span></a></li><li><a class="level is-mobile" href="#2-context-说明"><span class="level-left"><span class="level-item">2.context 说明</span></span></a></li><li><a class="level is-mobile" href="#3-移除观察的必要性"><span class="level-left"><span class="level-item">3.移除观察的必要性</span></span></a></li><li><a class="level is-mobile" href="#4-手动触发键值观察"><span class="level-left"><span class="level-item">4.手动触发键值观察</span></span></a></li><li><a class="level is-mobile" href="#5-Key-依赖情况"><span class="level-left"><span class="level-item">5.Key 依赖情况</span></span></a></li><li><a class="level is-mobile" href="#6-可变数组"><span class="level-left"><span class="level-item">6.可变数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、KVO-底层原理—isa-swizzling"><span class="level-left"><span class="level-item">三、KVO 底层原理—isa-swizzling</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-官方解释"><span class="level-left"><span class="level-item">1.官方解释</span></span></a></li><li><a class="level is-mobile" href="#2-代码探索"><span class="level-left"><span class="level-item">2.代码探索</span></span></a></li><li><a class="level is-mobile" href="#3-动态子类探索"><span class="level-left"><span class="level-item">3.动态子类探索</span></span></a></li><li><a class="level is-mobile" href="#4-总结"><span class="level-left"><span class="level-item">4.总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、自定义KVO"><span class="level-left"><span class="level-item">四、自定义KVO</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-注册观察者"><span class="level-left"><span class="level-item">1.注册观察者</span></span></a></li><li><a class="level is-mobile" href="#2-添加setter方法并回调"><span class="level-left"><span class="level-item">2.添加setter方法并回调</span></span></a></li><li><a class="level is-mobile" href="#3-销毁观察者"><span class="level-left"><span class="level-item">3.销毁观察者</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>