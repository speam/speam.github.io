<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>14-KVO原理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="14-KVO原理"><meta property="og:url" content="http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329174500156.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329175903523.png"><meta property="article:published_time" content="2021-03-26T03:09:32.152Z"><meta property="article:modified_time" content="2021-03-30T07:10:28.287Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329174500156.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329175903523.png"],"datePublished":"2021-03-26T03:09:32.152Z","dateModified":"2021-03-30T07:10:28.287Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-26T03:09:32.152Z" title="2021-03-26T03:09:32.152Z">2021-03-26</time>发表</span><span class="level-item"><time dateTime="2021-03-30T07:10:28.287Z" title="2021-03-30T07:10:28.287Z">2021-03-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">14-KVO原理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、KVO简述"><a href="#一、KVO简述" class="headerlink" title="一、KVO简述"></a>一、KVO简述</h2><p><code>KVO（Key-Value Observing）</code>是一套事件观察 &amp; 通知机制，开发者可以使用它来监测对象属性的变化并做出响应。</p>
<p>在<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">Documentation Archieve</a>中提到一句想要理解<code>KVO</code>，必须先理解<code>KVC</code>，因为<code>键值观察</code>是建立在<code>键值编码</code>的基础上。</p>
<blockquote>
<p>而<code>KVO</code>和<code>NSNotificatioCenter</code>都是 iOS 观察者模式的一种实现，两者的区别在于：</p>
<ul>
<li>相对于被观察者和观察者之间的关系，<code>KVO</code>是一对一的，<code>NSNotificatioCenter</code>是一对多的</li>
<li><code>KVO</code>对被监听对象无侵入性，不需要修改其内部代码即可实现监听</li>
</ul>
</blockquote>
<h2 id="二、KVO使用及注意点"><a href="#二、KVO使用及注意点" class="headerlink" title="二、KVO使用及注意点"></a>二、KVO使用及注意点</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p>KVO使用三部曲：</p>
<ul>
<li>注册观察者</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>实现回调</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:<span class="string">@&quot;name&quot;</span>]) <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>移除观察者</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-context-说明"><a href="#2-2-context-说明" class="headerlink" title="2.2 context 说明"></a>2.2 context 说明</h3><p>如果父类中有个<code>name</code>属性，子类中也有个<code>name</code>属性，两者都注册对<code>name</code>的观察，那么仅通过<code>keyPath</code>已经区分不了是哪个<code>name</code>发生变化了，现有两个解决办法：</p>
<ul>
<li>多加一层判断：判断<code>object</code>，但是会出现很多 if…else…</li>
<li>使用<code>context</code>传递信息，更安全、更可扩展</li>
</ul>
<p><strong><code>context</code>使用总结:</strong></p>
<ul>
<li>不使用context作为观察值</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context是 void * 类型，应该填 NULL 而不是 nil</span></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>使用context传递信息</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *PersonNameContext = &amp;PersonNameContext;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *ChildNameContext = &amp;ChildNameContext;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:PersonNameContext];</span><br><span class="line">[<span class="keyword">self</span>.child addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:ChildNameContext];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == PersonNameContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context == ChildNameContext) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-移除观察的必要性"><a href="#2-3-移除观察的必要性" class="headerlink" title="2.3 移除观察的必要性"></a>2.3 移除观察的必要性</h3><p>不移除会带来潜在的隐患：</p>
<p>如果观察者对象 dealloc 的时候没有移除对目标属性的观察，当目标属性改变的时候，还是会通知该观察者，但是该观察者此时已经释放了，就会出现野指针的情况。</p>
<p>例如：<code>LGPerson</code>是一个单例对象，它有个属性<code>name</code>。然后在<code>FirstViewController</code>和<code>SecondViewController</code>中都对<code>LGPerson</code>对象的<code>name</code>属性进行了KVO观察。</p>
<p>操作顺序是从<code>FirstViewController</code>push到<code>SecondViewController</code>，然后从<code>SecondViewController</code>pop 到<code>FirstViewController</code>。</p>
<p>假如<code>SecondViewController</code>在 dealloc 的时候没有移除观察者，但是这个<code>LGPerson</code>对象由于是单例所以没有销毁。然后在<code>FirstViewController</code>中<code>name</code>属性被改变了。此时就会通知它的观察者即<code>SecondViewController</code>，但是<code>SecondViewController</code>这个观察者已经释放了，再次访问它就会造成访问野指针的情况。</p>
<p><strong>所以说，该移除观察的时候就要移除。</strong></p>
<blockquote>
<p>苹果官方推荐的方式是——在<code>init</code>的时候进行<code>addObserver</code>，在<code>dealloc</code>时<code>removeObserver</code>，这样可以保证<code>add</code>和<code>remove</code>是成对出现的，这是一种比较理想的使用方式</p>
</blockquote>
<h3 id="2-4-手动触发键值观察"><a href="#2-4-手动触发键值观察" class="headerlink" title="2.4 手动触发键值观察"></a>2.4 手动触发键值观察</h3><p>有时候业务需求需要观察某个属性值，一会儿要观察了，一会又不要观察了…如果把<code>KVO三部曲</code>整体去掉、再整体添上，必然又是一顿繁琐而又不必要的工作，好在KVO中有两种办法可以手动触发键值观察：</p>
<ul>
<li>将被观察者的<code>automaticallyNotifiesObserversForKey</code>返回NO（可以只对某个属性设置），这样就不会自动观察属性的变化了，而是通过手动通知的方式去观察。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)automaticallyNotifiesObserversForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;name&quot;</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> automaticallyNotifiesObserversForKey:key];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>使用<code>willChangeValueForKey</code>、<code>didChangeValueForKey</code>重写被观察者的属性的<code>setter</code>方法</p>
<p>这两个方法用于通知系统该 key 的属性值即将和已经变更了</p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">    _name = name;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;name&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两种方式使用的排列组合如下，可以自由组合如何使用</p>
<table>
<thead>
<tr>
<th>情况</th>
<th>回调次数</th>
</tr>
</thead>
<tbody><tr>
<td>正常情况</td>
<td>1</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为NO</td>
<td>0</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为NO且添加willChangeValueForKey、didChangeValueForKey</td>
<td>1</td>
</tr>
<tr>
<td>automaticallyNotifiesObserversForKey为YES且添加willChangeValueForKey、didChangeValueForKey</td>
<td>2</td>
</tr>
</tbody></table>
<blockquote>
<p>最近发现[self willChangeValueForKey:name]和[self willChangeValueForKey:”name”]两种写法是不同的结果：重写setter方法取属性值操作不会额外发送通知；而使用“name”会额外发送一次通知</p>
</blockquote>
<h3 id="2-5-Key-依赖情况"><a href="#2-5-Key-依赖情况" class="headerlink" title="2.5 Key 依赖情况"></a>2.5 Key 依赖情况</h3><p>比如有一个下载任务的需求，根据<code>总下载量Total</code>和<code>当前已下载量Current</code>来得到<code>当前下载进度progress</code>，这个需求就有两种实现：</p>
<ul>
<li>分别观察<code>总下载量Total</code>和<code>当前已下载量Current</code>两个属性，其中一个属性发生变化时计算求值<code>当前下载进度Process</code>【太麻烦了】</li>
<li>实现<code>keyPathsForValuesAffectingValueForKey</code>方法，并观察<code>progress</code>属性【采用】</li>
</ul>
<p><code>progress</code>属性受到<code>current</code>和<code>total</code>属性变化的影响，如果我们想只监听<code>progress</code>，又保证<code>current</code>和<code>total</code>变化时能收到<code>KVO</code>中的回调告诉我们<code>progress</code>变化了，我们需要实现<code>+keyPathsForValuesAffectingValueForKey:</code>方法来关联两个属性到<code>progress</code>上：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSSet</span>&lt;<span class="built_in">NSString</span> *&gt; *)keyPathsForValuesAffectingValueForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="built_in">NSSet</span> *keyPaths = [<span class="keyword">super</span> keyPathsForValuesAffectingValueForKey:key];</span><br><span class="line">    <span class="keyword">if</span> ([key isEqualToString:<span class="string">@&quot;progress&quot;</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *affectingKeys = @[<span class="string">@&quot;current&quot;</span>, <span class="string">@&quot;total&quot;</span>];</span><br><span class="line">        keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person 类中<code>progess</code>受到两个属性变化的影响</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)progress &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.current / <span class="keyword">self</span>.total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加监听：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person = p;</span><br><span class="line">p.current = <span class="number">0</span>;</span><br><span class="line">p.total = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;progress&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<p>监听回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，<code>current</code>和<code>total</code>变化时，就能监听到<code>progress</code>的变化了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.current += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">self</span>.person.total += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-可变数组"><a href="#2-6-可变数组" class="headerlink" title="2.6 可变数组"></a>2.6 可变数组</h3><p>首先添加对<code>dataArray</code>这个可变数组的观察：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;dateArray&quot;</span> options:(<span class="built_in">NSKeyValueObservingOptionNew</span>) context:<span class="literal">NULL</span>];</span><br></pre></td></tr></table></figure>

<p>然后调用下面代码，对<code>dateArray</code>数组添加元素</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.person.dateArray addObject:<span class="string">@&quot;hello&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>这样会不会触发KVO通知呢？答案是不会的，因为KVO是给予set方法的，这样不会触发set方法，所以就不会触发KVO通知。正确的做法应该是下面这样</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">self</span>.person mutableArrayValueForKey:<span class="string">@&quot;dateArray&quot;</span>] addObject:<span class="string">@&quot;hello&quot;</span>];</span><br></pre></td></tr></table></figure>

<h2 id="三、KVO-底层原理—isa-swizzling"><a href="#三、KVO-底层原理—isa-swizzling" class="headerlink" title="三、KVO 底层原理—isa-swizzling"></a>三、KVO 底层原理—isa-swizzling</h2><h3 id="3-1-官方解释"><a href="#3-1-官方解释" class="headerlink" title="3.1 官方解释"></a>3.1 官方解释</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326110016951.png" alt="img"></p>
<p><code>Key-Value Observing Programming Guide</code>中有一段底层实现原理的叙述</p>
<blockquote>
<ul>
<li>KVO是使用<code>isa-swizzling</code>技术实现的</li>
<li><code>isa</code>指针指向对象的类</li>
<li>在为对象的属性注册观察者时，将修改观察对象的<code>isa</code>指针，指向中间类而不是真实类。所以<code>isa</code>指针的值不一定反映对象的实际类。</li>
<li>您永远不应依靠<code>isa</code>指针来确定类成员身份。相反，您应该使用<code>class</code>方法来确定对象实例的类</li>
</ul>
</blockquote>
<h3 id="3-2-代码探索"><a href="#3-2-代码探索" class="headerlink" title="3.2 代码探索"></a>3.2 代码探索</h3><ul>
<li><p>注册观察者之前：类对象为</p>
<p><code>FXPerson</code>，实例对象isa指向<code>FXPerson</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111146603.png" alt="img"></p>
</li>
<li><p>注册观察者之后：类对象为</p>
<p><code>FXPerson</code>，实例对象<code>isa</code>指向<code>NSKVONotifying_FXPerson</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111216225.png" alt="img"></p>
</li>
</ul>
<p>从这两图中可以得出一个结论：观察者注册前后<code>FXPerson类</code>没发生变化，但实例对象的<code>isa</code>指向发生了变化</p>
<p>那么这个动态生成的中间类<code>NSKVONotifying_FXPerson</code>和<code>FXPerson</code>是什么关系呢？</p>
<p>在注册观察者前后分别打印子类——发现<code>NSKVONotifying_FXPerson</code>是<code>FXPerson</code>的子类</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111516736.png" alt="img"></p>
<h3 id="3-3-动态子类探索"><a href="#3-3-动态子类探索" class="headerlink" title="3.3 动态子类探索"></a>3.3 动态子类探索</h3><p>①首先得明白动态子类观察的是什么？</p>
<p>下面观察<code>属性变量name</code>和<code>成员变量nickname</code>来找区别：两个变量同时发生变化，但只有<code>属性变量</code>监听到回调——说明动态子类观察的是<code>setter</code>方法</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326111634225.png" alt="img"></p>
<p>②通过<code>runtime-API</code>打印一下动态子类和观察类的方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)printClassAllMethod:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Method *methodList = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL sel = method_getName(method);</span><br><span class="line">        IMP imp = class_getMethodImplementation(cls, sel);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%@-%p&quot;</span>,<span class="built_in">NSStringFromSelector</span>(sel),imp);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326112140165.png" alt="img"></p>
<p>通过打印可以看出：</p>
<ul>
<li><code>FXPerson类</code>中的方法没有改变（imp实现地址没有变化）</li>
<li><code>NSKVONotifying_FXPerson类</code>中重写了父类<code>FXPerson</code>的<code>dealloc</code>方法</li>
<li><code>NSKVONotifying_FXPerson类</code>中重写了基类<code>NSObject</code>的<code>class</code>方法和<code>_isKVOA</code>方法<ul>
<li>重写的<code>class</code>方法可以指回<code>FXPerson类</code></li>
</ul>
</li>
<li><code>NSKVONotifying_FXPerson</code>类中重写了父类<code>FXPerson</code>的<code>setName</code>方法<ul>
<li>因为子类只继承、不重写是不会有方法imp的（那么调用方法时会问父类要方法实现）</li>
<li>且两个<code>setName</code>的地址指针不一样</li>
<li>每观察一个<code>属性变量</code>就重写一个<code>setter</code>方法（可自行论证）</li>
</ul>
</li>
</ul>
<p>③<code>dealloc</code>之后<code>isa</code>指向谁？——指回原类</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113052837.png" alt="img"></p>
<p>④<code>dealloc</code>之后动态子类会销毁吗？——不会</p>
<p>页面pop后再次push进来打印<code>FXPerson类</code>的子类，子类<code>NSKVONotifying_FXPerson类</code>依旧存在</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210326113218384.png" alt="img"></p>
<p>⑤<code>automaticallyNotifiesObserversForKey</code>是否会影响动态子类生成——会</p>
<p>动态子类会根据观察属性的<code>automaticallyNotifiesObserversForKey</code>的布尔值来决定是否生成</p>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><ol>
<li><code>automaticallyNotifiesObserversForKey</code>为<code>YES</code>时注册观察属性会生成动态子类<code>NSKVONotifying_XXX</code></li>
<li>动态子类观察的是<code>setter</code>方法</li>
<li>动态子类重写了观察属性的<code>setter</code>方法、<code>dealloc</code>、<code>class</code>、<code>_isKVOA</code>方法<ul>
<li><code>setter</code>方法用于观察键值</li>
<li><code>dealloc</code>方法用于释放时将<code>isa</code>指向原来的类</li>
<li><code>class</code>方法用于指回动态子类的父类</li>
<li><code>_isKVOA</code>用来标识是否是在观察者状态的一个标志位</li>
</ul>
</li>
<li><code>dealloc</code>之后<code>isa</code>指向原来的类</li>
<li><code>dealloc</code>之后动态子类不会销毁</li>
</ol>
<h3 id="3-5-原理图"><a href="#3-5-原理图" class="headerlink" title="3.5 原理图"></a>3.5 原理图</h3><p>假设我们要观察的是 Person 实例对象的 age 属性。</p>
<h4 id="添加观察者之前"><a href="#添加观察者之前" class="headerlink" title="添加观察者之前"></a>添加观察者之前</h4><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329174500156.png" alt="image-20210329174500156" style="zoom:50%;" />

<h4 id="添加观察者之后"><a href="#添加观察者之后" class="headerlink" title="添加观察者之后"></a>添加观察者之后</h4><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210329175903523.png" alt="image-20210329175903523" style="zoom: 50%;" />

<h2 id="四、自己实现KVO"><a href="#四、自己实现KVO" class="headerlink" title="四、自己实现KVO"></a>四、自己实现KVO</h2><p>我的完整代码已放到 GitHub：<a target="_blank" rel="noopener" href="https://github.com/speam/ExploreKVO.git">Link🔗</a></p>
<h3 id="4-1-前言"><a href="#4-1-前言" class="headerlink" title="4.1 前言"></a>4.1 前言</h3><p>下面我们根据系统 KVO 的原理，简单实现一下 KVO。</p>
<ul>
<li><p>此过程中会有 runtime-API 的使用和接口设计思路的讲解，最终的自定义 KVO 能满足基本使用的需求但仍不完善，但此过程中最重要的是了解并模仿系统实现原理，以及加深对 runtime 的理解。</p>
</li>
<li><p>系统的 KVO 注册、回调、自动移除观察者在写法上都是分离的，使用起来稍显不简洁，所以我们自定义的 KVO 将使用 block 回调和自动释放来优化这一点不足。</p>
</li>
<li><p>自定义 KVO 的优化其实是参考了 <a target="_blank" rel="noopener" href="https://github.com/facebookarchive/KVOController">FBKVOController</a> 的实现，但 FBKVOController 是通过中间层对相应属性进行观察，然后回调到观察者，其在内存管理上更加安全；我们的自定义 KVO 是直接进行观察，逻辑上更简单易懂。</p>
</li>
</ul>
<p>首先回顾系统 KVO 的逻辑：</p>
<p>1.<code>automaticallyNotifiesObserversForKey</code>为<code>YES</code>时，注册观察属性会生成动态子类<code>NSKVONotifying_XXX</code></p>
<p>2.动态子类观察的是对应属性的<code>setter</code>方法</p>
<p>3.动态子类重写了观察属性的<code>setter</code>方法、<code>dealloc</code>、<code>class</code>、<code>_isKVOA</code>方法</p>
<ul>
<li><code>setter</code>方法用于观察键值</li>
<li><code>dealloc</code>方法用于释放时将<code>isa</code>指向原来的类</li>
<li><code>class</code>方法用于指回动态子类的父类</li>
<li><code>_isKVOA</code>用来标识是否是在观察者状态的一个标志位【这个没实现】</li>
</ul>
<p>4.<code>dealloc</code>之后<code>isa</code>指向原来的类</p>
<p>5.<code>dealloc</code>之后动态子类不会销毁</p>
<h3 id="4-2-初始化"><a href="#4-2-初始化" class="headerlink" title="4.2 初始化"></a>4.2 初始化</h3><p>创建NSObject的分类：NSObject+JYKVO，提供添加观察者的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^JYKVOBlock)(<span class="keyword">id</span> observer, <span class="built_in">NSString</span> *keyPath, <span class="keyword">id</span> oldValue,<span class="keyword">id</span> newValue);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">JYKVO</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 对属性添加观察</span></span><br><span class="line"><span class="comment">/// @param observer 观察者</span></span><br><span class="line"><span class="comment">/// @param keyPath 观察的属性</span></span><br><span class="line"><span class="comment">/// @param block 属性改变后的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)jy_addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath block:(JYKVOBlock)block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p>下面开始实现<code>jy_addObserver:forKeyPath:block:</code>方法：</p>
<h3 id="4-3-验证是否存在setter方法，只观察属性"><a href="#4-3-验证是否存在setter方法，只观察属性" class="headerlink" title="4.3 验证是否存在setter方法，只观察属性"></a>4.3 验证是否存在setter方法，只观察属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否有对应的 setter</span></span><br><span class="line">  <span class="keyword">if</span> (![<span class="keyword">self</span> isContainSetterMethodFromKeyPath:keyPath]) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p><code>isContainSetterMethodFromKeyPath:</code>方法的实现如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 判断是否存在对应的 setter</span></span><br><span class="line"><span class="comment">/// @param keyPath 属性名</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isContainSetterMethodFromKeyPath:(<span class="built_in">NSString</span> *)keyPath &#123;</span><br><span class="line">    Class <span class="keyword">class</span>         = object_getClass(<span class="keyword">self</span>);</span><br><span class="line">    SEL setterSeletor   = <span class="built_in">NSSelectorFromString</span>(setterForKeyPath(keyPath));</span><br><span class="line">    Method setterMethod = class_getInstanceMethod(<span class="keyword">class</span>, setterSeletor);</span><br><span class="line">    <span class="keyword">if</span> (!setterMethod) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;没找到属性:%@的setter方法&quot;</span>, keyPath);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-判断automaticallyNotifiesObserversForKey方法返回的布尔值"><a href="#4-4-判断automaticallyNotifiesObserversForKey方法返回的布尔值" class="headerlink" title="4.4 判断automaticallyNotifiesObserversForKey方法返回的布尔值"></a>4.4 判断automaticallyNotifiesObserversForKey方法返回的布尔值</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isAutomatically = [<span class="keyword">self</span> jy_performSelectorWithMethodName:<span class="string">@&quot;automaticallyNotifiesObserversForKey:&quot;</span> keyPath:keyPath];</span><br><span class="line"><span class="keyword">if</span> (!isAutomatically) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>为<code>YES</code>时才会继续</p>
<h3 id="4-5-动态生成子类"><a href="#4-5-动态生成子类" class="headerlink" title="4.5 动态生成子类"></a>4.5 动态生成子类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态生成子类</span></span><br><span class="line">Class newClass = [<span class="keyword">self</span> createChildClassWithKeyPath:keyPath];</span><br></pre></td></tr></table></figure>

<p><code>createChildClassWithKeyPath:</code>方法是我们的核心方法，分步来看：</p>
<p>⑴ 根据 keyPath 拼接中间类的名称，然后如果不存在中间类的话，就创建，如果已经存在，不需要重复创建</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取新类的类名</span></span><br><span class="line">    <span class="built_in">NSString</span> *oldClassName = <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSString</span> *newClassName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@%@&quot;</span>, kJYKVOPrefix, oldClassName];</span><br><span class="line">    Class newClass = <span class="built_in">NSClassFromString</span>(newClassName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防止重复创建新类</span></span><br><span class="line">    <span class="keyword">if</span> (newClass) <span class="keyword">return</span> newClass;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 申请类</span></span><br><span class="line"><span class="comment">     * 如果内存中不存在, 创建生成</span></span><br><span class="line"><span class="comment">     * 参数一: 父类</span></span><br><span class="line"><span class="comment">     * 参数二: 新类的名字</span></span><br><span class="line"><span class="comment">     * 参数三: 新类的开辟的额外空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    newClass = objc_allocateClassPair([<span class="keyword">self</span> <span class="keyword">class</span>], newClassName.UTF8String, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 注册类</span></span><br><span class="line">    objc_registerClassPair(newClass);</span><br></pre></td></tr></table></figure>

<p>⑵ 添加<code>+class</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 +class 方法</span></span><br><span class="line">SEL classSEL = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;class&quot;</span>);</span><br><span class="line">Method classMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], classSEL);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *classTypes = method_getTypeEncoding(classMethod);</span><br><span class="line">class_addMethod(newClass, classSEL, (IMP)jy_class, classTypes);</span><br></pre></td></tr></table></figure>

<p>⑶ 添加对应属性的<code>setter</code>方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 setter</span></span><br><span class="line">SEL setterSEL = <span class="built_in">NSSelectorFromString</span>(setterForKeyPath(keyPath));</span><br><span class="line">Method setterMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], setterSEL);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *setterTypes = method_getTypeEncoding(setterMethod);</span><br><span class="line">class_addMethod(newClass, setterSEL, (IMP)jy_setter, setterTypes);</span><br></pre></td></tr></table></figure>

<p>其中<code>jy_setter</code>是我们自己对<code>setter</code>方法的实现，思路如下：</p>
<p>① 因为我们使用KVO时候，是对操作的类(例如 LGPerson)的属性赋值，这里因为将 isa 指向了新创建的中间子类(NSKVONotifying_LGPerson)，所以这里需要调用父类(LGPerson)的setter 方法进行属性赋值。我们这里通过<code>objc_msgSendSuper</code>发送消息来实现。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1️⃣转发给父类，改变父类的值</span></span><br><span class="line"><span class="keyword">void</span> (*jy_msgSendSuper)(<span class="keyword">void</span> *, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</span><br><span class="line"><span class="keyword">struct</span> objc_super superStruct = &#123;</span><br><span class="line">    .receiver = <span class="keyword">self</span>,</span><br><span class="line">    .super_class = class_getSuperclass(object_getClass(<span class="keyword">self</span>)),</span><br><span class="line">&#125;;</span><br><span class="line">jy_msgSendSuper(&amp;superStruct, _cmd, newValue);</span><br></pre></td></tr></table></figure>

<p>② 取原来的值，用于回调</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2️⃣取旧值</span></span><br><span class="line"><span class="built_in">NSString</span> *keyPath = getterForSetter(<span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line"><span class="keyword">id</span> oldValue = [<span class="keyword">self</span> valueForKey:keyPath];</span><br></pre></td></tr></table></figure>

<p>③ 属性改变后我们还需要通过 block 的方式回调到添加观察的地方</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3️⃣通知观察者</span></span><br><span class="line"><span class="comment">// 1.拿到观察者，在添加观察者的时候通过关联对象将 observer 存储了起来。</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJYKVOAssiociateKey));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.消息发送给观察者</span></span><br><span class="line"><span class="keyword">for</span> (JYKVOInfo *info <span class="keyword">in</span> mArray) &#123;</span><br><span class="line">    <span class="keyword">if</span> ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) &#123;</span><br><span class="line">        info.handleBlock(info.observer, keyPath, oldValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>⑷ 然后为了实现自动移除观察者，我们还要交换一下 dealloc 方法的实现，在里面做一些事情</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交换 dealloc 实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> JYMethodSwizzlingWithClass:[<span class="keyword">self</span> <span class="keyword">class</span>] oriSEL:<span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;dealloc&quot;</span>) swizzledSEL:<span class="keyword">@selector</span>(jy_dealloc)];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当对象销毁的时候会调用 dealloc，在该方法中将 isa 指针重新指向原来的类</span></span><br><span class="line">- (<span class="keyword">void</span>)jy_dealloc &#123;</span><br><span class="line">    Class superClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">    object_setClass(<span class="keyword">self</span>, superClass);</span><br><span class="line">    [<span class="keyword">self</span> jy_dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-将isa指向创建好的动态子类"><a href="#4-6-将isa指向创建好的动态子类" class="headerlink" title="4.6 将isa指向创建好的动态子类"></a>4.6 将isa指向创建好的动态子类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isa指向修改-&gt;指向动态子类</span></span><br><span class="line">object_setClass(<span class="keyword">self</span>, newClass);</span><br></pre></td></tr></table></figure>

<h3 id="4-7-保存observer信息，在setter方法中通知observer的时候需要用到该信息"><a href="#4-7-保存observer信息，在setter方法中通知observer的时候需要用到该信息" class="headerlink" title="4.7 保存observer信息，在setter方法中通知observer的时候需要用到该信息"></a>4.7 保存observer信息，在setter方法中通知observer的时候需要用到该信息</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存信息</span></span><br><span class="line">JYKVOInfo *info = [[JYKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *mArray = objc_getAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJYKVOAssiociateKey));</span><br><span class="line"><span class="keyword">if</span> (!mArray) &#123;</span><br><span class="line">    mArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">1</span>];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> * _Nonnull)(kJYKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">[mArray addObject:info];</span><br></pre></td></tr></table></figure>

<p>其中使用<code>JYKVOInfo</code>这个<code>model</code>来存储<code>observer</code>信息，因为可能会还有多个<code>observer</code>，所以使用数组的形式进行存储。</p>
<p>现在可以给一个属性添加观察测试一下了。</p>
<h3 id="4-8-测试"><a href="#4-8-测试" class="headerlink" title="4.8 测试"></a>4.8 测试</h3><p>依旧是<code>Person</code>类，有一个简单的<code>name</code>成员属性。</p>
<p>下面在控制器中添加对<code>name</code>属性的观察：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.person = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person.name = <span class="string">@&quot;旧名字&quot;</span>;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.person jy_addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;name&quot;</span> block:^(<span class="keyword">id</span>  _Nonnull observer, <span class="built_in">NSString</span> * _Nonnull keyPath, <span class="keyword">id</span>  _Nonnull oldValue, <span class="keyword">id</span>  _Nonnull newValue) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;旧值：%@&quot;</span>, oldValue);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;新值：%@&quot;</span>, newValue);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;path：%@&quot;</span>, keyPath);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>点击屏幕的时候去改变这个对象的<code>name</code>的值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">self</span>.person.name = <span class="string">@&quot;新名字&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>然后将 demo 运行，点击这个控制器，查看打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2021-03-30 14:48:14.483797+0800 OCTest[13317:272742] 旧值：旧名字</span><br><span class="line">2021-03-30 14:48:14.483927+0800 OCTest[13317:272742] 新值：新名字</span><br><span class="line">2021-03-30 14:48:14.483983+0800 OCTest[13317:272742] path：name</span><br></pre></td></tr></table></figure>



<p>至此就完成了 KVO 的简单实现。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">苹果开发文档- KVO 原理的介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebookarchive/KVOController">FBKVOController</a> </p>
<p><a target="_blank" rel="noopener" href="https://github.com/speam/ExploreKVO.git">我的完整代码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://github.com/facebookarchive">facebookarchive</a>/<a target="_blank" rel="noopener" href="https://github.com/facebookarchive/KVOController">KVOController</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bf99c6dbfc03">KVO原理分析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904090569277447">iOS探索 KVO原理及自定义</a></p>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/365cshitou/ontheroad/customkvo">自定义KVO</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《指数基金投资指南》读书笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/03/23/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/13-KVC%E5%8E%9F%E7%90%86/"><span class="level-item">13-KVC原理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、KVO简述"><span class="level-left"><span class="level-item">一、KVO简述</span></span></a></li><li><a class="level is-mobile" href="#二、KVO使用及注意点"><span class="level-left"><span class="level-item">二、KVO使用及注意点</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-基本使用"><span class="level-left"><span class="level-item">2.1 基本使用</span></span></a></li><li><a class="level is-mobile" href="#2-2-context-说明"><span class="level-left"><span class="level-item">2.2 context 说明</span></span></a></li><li><a class="level is-mobile" href="#2-3-移除观察的必要性"><span class="level-left"><span class="level-item">2.3 移除观察的必要性</span></span></a></li><li><a class="level is-mobile" href="#2-4-手动触发键值观察"><span class="level-left"><span class="level-item">2.4 手动触发键值观察</span></span></a></li><li><a class="level is-mobile" href="#2-5-Key-依赖情况"><span class="level-left"><span class="level-item">2.5 Key 依赖情况</span></span></a></li><li><a class="level is-mobile" href="#2-6-可变数组"><span class="level-left"><span class="level-item">2.6 可变数组</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、KVO-底层原理—isa-swizzling"><span class="level-left"><span class="level-item">三、KVO 底层原理—isa-swizzling</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-官方解释"><span class="level-left"><span class="level-item">3.1 官方解释</span></span></a></li><li><a class="level is-mobile" href="#3-2-代码探索"><span class="level-left"><span class="level-item">3.2 代码探索</span></span></a></li><li><a class="level is-mobile" href="#3-3-动态子类探索"><span class="level-left"><span class="level-item">3.3 动态子类探索</span></span></a></li><li><a class="level is-mobile" href="#3-4-总结"><span class="level-left"><span class="level-item">3.4 总结</span></span></a></li><li><a class="level is-mobile" href="#3-5-原理图"><span class="level-left"><span class="level-item">3.5 原理图</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#添加观察者之前"><span class="level-left"><span class="level-item">添加观察者之前</span></span></a></li><li><a class="level is-mobile" href="#添加观察者之后"><span class="level-left"><span class="level-item">添加观察者之后</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、自己实现KVO"><span class="level-left"><span class="level-item">四、自己实现KVO</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-前言"><span class="level-left"><span class="level-item">4.1 前言</span></span></a></li><li><a class="level is-mobile" href="#4-2-初始化"><span class="level-left"><span class="level-item">4.2 初始化</span></span></a></li><li><a class="level is-mobile" href="#4-3-验证是否存在setter方法，只观察属性"><span class="level-left"><span class="level-item">4.3 验证是否存在setter方法，只观察属性</span></span></a></li><li><a class="level is-mobile" href="#4-4-判断automaticallyNotifiesObserversForKey方法返回的布尔值"><span class="level-left"><span class="level-item">4.4 判断automaticallyNotifiesObserversForKey方法返回的布尔值</span></span></a></li><li><a class="level is-mobile" href="#4-5-动态生成子类"><span class="level-left"><span class="level-item">4.5 动态生成子类</span></span></a></li><li><a class="level is-mobile" href="#4-6-将isa指向创建好的动态子类"><span class="level-left"><span class="level-item">4.6 将isa指向创建好的动态子类</span></span></a></li><li><a class="level is-mobile" href="#4-7-保存observer信息，在setter方法中通知observer的时候需要用到该信息"><span class="level-left"><span class="level-item">4.7 保存observer信息，在setter方法中通知observer的时候需要用到该信息</span></span></a></li><li><a class="level is-mobile" href="#4-8-测试"><span class="level-left"><span class="level-item">4.8 测试</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>