<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>18-多线程之GCD底层原理 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="18-多线程之GCD底层原理"><meta property="og:url" content="http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/%E7%BB%98%E5%9B%BE.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519091109342.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519100004403.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/wer324fdsg15.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210519170358277.png"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210524090119763.png"><meta property="article:published_time" content="2021-05-18T00:50:11.112Z"><meta property="article:modified_time" content="2021-05-24T06:37:01.305Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png","https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png","https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png","https://raw.githubusercontent.com/speam/blogImgs/main/%E7%BB%98%E5%9B%BE.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519091109342.png","https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519100004403.png","https://raw.githubusercontent.com/speam/blogImgs/main/wer324fdsg15.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210519170358277.png","https://raw.githubusercontent.com/speam/blogImgs/main/1-20210524090119763.png"],"datePublished":"2021-05-18T00:50:11.112Z","dateModified":"2021-05-24T06:37:01.305Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T00:50:11.112Z" title="2021-05-18T00:50:11.112Z">2021-05-18</time>发表</span><span class="level-item"><time dateTime="2021-05-24T06:37:01.305Z" title="2021-05-24T06:37:01.305Z">2021-05-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">18-多线程之GCD底层原理</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="如何定位源码"><a href="#如何定位源码" class="headerlink" title="如何定位源码"></a>如何定位源码</h2><p>已知要研究<code>GCD</code>，所以有以下几种选择源码的方法：</p>
<ul>
<li><p>Baidu/Google</p>
</li>
<li><p>下符号断点<code>dispatch_queue_create</code></p>
<p>首先写下测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> aaqueue = dispatch_queue_create(<span class="string">&quot;aa&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>然后添加符号断点：</p>
<img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png" alt="" style="zoom:50%;" />
</li>
<li><p>仅使用<code>Debug-&gt;Debug Workflow-&gt;Always show Disassembly</code>，断点到上面的测试代码，查看汇编也能看到定位在<code>libdispatch.dylib</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png"></p>
</li>
</ul>
<p>苹果官网的：<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="一、开始研究-GCD"><a href="#一、开始研究-GCD" class="headerlink" title="一、开始研究 GCD"></a>一、开始研究 GCD</h2><p>首先创建两个常见的队列，串行队列和并发队列，然后分别 <code>po</code> 一下，再顺便把主队列和全局队列分别一起给看了。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<ul>
<li><p>发现主队列的 <code>width</code> 和串行队列的 <code>width</code> 是一样的，其他的也有很多相同的，难怪说主队列是特殊的串行队列。</p>
</li>
<li><p>但是并发队列和全局队列的 <code>width</code> 却相差 1，有点奇怪。接下来我们就到源码中一探究竟吧。</p>
</li>
</ul>
<h2 id="二、创建队列在底层是怎样实现的"><a href="#二、创建队列在底层是怎样实现的" class="headerlink" title="二、创建队列在底层是怎样实现的"></a>二、创建队列在底层是怎样实现的</h2><p>先上结论：</p>
<ul>
<li>自定义并发队列和串行队列，是从<strong>根队列数组</strong>中取出模板属性，然后经过了一系列的开辟空间、构造、赋值等操作创建出来的。</li>
<li><strong>根队列数组</strong>是在<code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的。</li>
</ul>
<h3 id="2-1-自定义队列的创建"><a href="#2-1-自定义队列的创建" class="headerlink" title="2.1 自定义队列的创建"></a>2.1 自定义队列的创建</h3><p>根据我们的调用：<code>dispatch_queue_create(&quot;aa&quot;, NULL);</code>，全局搜索<code>dispatch_queue_create</code>。但是会出现搜索结果巨多的情况（66 results in 17 files），此时我们应该修改搜索条件：</p>
<ul>
<li>由于创建队列代码为<code>dispatch_queue_create(&quot;&quot;, NULL)</code>，所以搜索<code>dispatch_queue_create(</code>——将筛选结果降至（21 results in 6 files）</li>
<li>由于第一个参数为字符串，在c语言中用<code>const</code>修饰，所以搜索<code>dispatch_queue_create(const</code>——将筛选结果降至（2 results in 2 files），由此找到了我们需要看的底层代码</li>
</ul>
<h4 id="2-1-1-dispatch-queue-create"><a href="#2-1-1-dispatch-queue-create" class="headerlink" title="2.1.1 dispatch_queue_create"></a>2.1.1 dispatch_queue_create</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现去调用了 <code>_dispatch_lane_create_with_target</code>方法，常规的接口隔离操作。</p>
<h4 id="2-1-2-dispatch-lane-create-with-target"><a href="#2-1-2-dispatch-lane-create-with-target" class="headerlink" title="2.1.2 _dispatch_lane_create_with_target"></a>2.1.2 _dispatch_lane_create_with_target</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ✅2.3</span></span><br><span class="line">	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	dispatch_qos_t qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	_dispatch_queue_attr_overcommit_t overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify both overcommit and &quot;</span></span><br><span class="line">					<span class="string">&quot;a non-global target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				<span class="comment">// 并发队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 串行队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify an overcommit attribute &quot;</span></span><br><span class="line">					<span class="string">&quot;and use this kind of target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;	<span class="comment">// 并发是...disable，串行是...enable</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// ✅一定会走这里</span></span><br><span class="line">		<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.4 开辟内存 - 生成相应的对象 queue</span></span><br><span class="line">	dispatch_lane_t dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2.5 构造方法</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 标签</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ✅2.6</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法较长，我们拆开重点代码进行分析。</p>
<h4 id="2-1-3-dispatch-queue-attr-to-info"><a href="#2-1-3-dispatch-queue-attr-to-info" class="headerlink" title="2.1.3 _dispatch_queue_attr_to_info"></a>2.1.3 _dispatch_queue_attr_to_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br></pre></td></tr></table></figure>

<p>其中传入这个方法的参数<code>dqa</code>为<code>dispatch_queue_attr_t</code>类型的，串行队列传入的是<code>NULL</code>，并发传入的是<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<p>将<code>dqa</code>参数传入后，生成了<code>dispatch_queue_attr_info_t</code>对象<code>dqai</code>。</p>
<blockquote>
<p>我们可以发现<code>dispatch_queue_attr_info_t</code>是一个结构体位域的形式，里面包含了一些<code>dispatch_qos_t</code>等优先级的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_info_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> dqai_qos : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span>      dqai_relpri : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_overcommit:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_autorelease_frequency:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_concurrent:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_inactive:<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">dispatch_queue_attr_info_t</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>进入方法查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span></span><br><span class="line">_dispatch_queue_attr_to_info(<span class="keyword">dispatch_queue_attr_t</span> dqa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 串行队列直接返回空结构体。后续代码都是对并发队列进行的操作</span></span><br><span class="line">	<span class="keyword">if</span> (!dqa) <span class="keyword">return</span> dqai;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_VARIANT_STATIC</span></span><br><span class="line">	<span class="keyword">if</span> (dqa == &amp;_dispatch_queue_attr_concurrent) &#123;</span><br><span class="line">		dqai.dqai_concurrent = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> dqai;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dqa &lt; _dispatch_queue_attrs ||</span><br><span class="line">			dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 苹果的算法</span></span><br><span class="line">	<span class="keyword">size_t</span> idx = (<span class="keyword">size_t</span>)(dqa - _dispatch_queue_attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发队列结构体位域的默认配置和赋值</span></span><br><span class="line">	dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发数。✅重点关注。只有并发队列才有这个值</span></span><br><span class="line">	dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_relpri = -(<span class="keyword">int</span>)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_autorelease_frequency =</span><br><span class="line">			idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dqai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当为串行队列的时候，传入的参数为<code>NULL</code>，直接返回一个空结构体。所以代码后续对<code>dqai</code>的操作都是基于并发队列的，并通过此来<strong>进行判断取值</strong>。</p>
<p>那么对于并发队列，会根据传入的宏定义参数，通过位运算，来给<code>dqai</code>进行赋值，比较主要的有并发数（<code>dqai_concurrent</code>），优先级（<code>dqai_qos</code>）等。</p>
<h4 id="2-1-4-dispatch-object-alloc"><a href="#2-1-4-dispatch-object-alloc" class="headerlink" title="2.1.4 _dispatch_object_alloc"></a>2.1.4 _dispatch_object_alloc</h4><p>虽然在上一步获取到了<code>dispatch_queue_attr_info_t</code>相关的值，但是它并不是最终返回的线程，只是我们用来获取一些配置的临时变量而已。</p>
<p>看<code>_dispatch_lane_create_with_target</code>方法最后一行，发现最终返回的是一个<code>dispatch_lane_t</code>类型的<code>dq</code>的对象，所以<code>dispatch_lane_t</code>应该是最终生成的队列，我们可以发现它是由<code>_dispatch_object_alloc</code>方法创建出来的。</p>
<p>但是<code>_dispatch_object_alloc</code>方法并没有开源，所以我们不知道里面是如何实现的。</p>
<p>不过<code>_dispatch_object</code>很像OC中的<code>NSObject</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br></pre></td></tr></table></figure>



<p><strong>dispatch_object_t</strong></p>
<p>通过搜索<code>dispatch_object</code>，发现并找不到我们需要的多线程抽象类，不过我们发现，一般多线程的对象后面都有<code>_t</code>，所以我们找到了<code>dispatch_object_t</code>这个多线程的抽象类。</p>
<p>我们可以发现其是一个联合体，和我们<code>isa</code>的结果极其类似，里面包含了我们常用的很多信息。因为联合体互斥，这样做有利于内存的优化，和更好的实现多态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span>	       <span class="comment">// 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>	       <span class="comment">// 队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>	   <span class="comment">// 参数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>	       <span class="comment">// 组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_s</span> *_<span class="title">dch</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>   <span class="comment">// 信号量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-dispatch-queue-init"><a href="#2-1-5-dispatch-queue-init" class="headerlink" title="2.1.5 _dispatch_queue_init"></a>2.1.5 _dispatch_queue_init</h4><p>当我们创建出<code>dispatch_lane_t</code>对象<code>dq</code>后，紧接着就执行<code>_dispatch_queue_init</code>构造方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>



<p>查看方法内部实现，发现通过<code>dispatch_queue_t dq = dqu._dq;</code>取出a队列后，对队列又进行了一系列的赋值，然后又返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> width, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line">	<span class="comment">// 取出队列</span></span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行了一系列赋值</span></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(width);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="comment">// 又返回了</span></span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>关注一下这个方法中的第三个参数，是一个判断：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>判断了<code>dqai.dqai_concurrent</code>，我们知道串行是没有<code>dqai_concurrent</code>的，所以串行队列的这个属性为1，就表示串行队列的并发数为1。</p>
<p>那么并发队列的这个属性就为：<code>DISPATCH_QUEUE_WIDTH_MAX</code>。</p>
<p>查看<code>DISPATCH_QUEUE_WIDTH_MAX</code>宏定义，我们发现它的值为<code>DISPATCH_QUEUE_WIDTH_FULL-2</code>，即<code>0xFFE</code>，所以并发队列的最大并发数为<code>0xFFE</code>(4094)。</p>
<p>至于<code>-2</code>则是因为<code>-1</code>是为了不饱和，再<code>-1</code>是因为<code>DISPATCH_QUEUE_WIDTH_POOL</code>为创建全局队列时候所使用的，避免相同。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png"></p>
<h4 id="2-1-6-dq-gt-do-targetq-tq"><a href="#2-1-6-dq-gt-do-targetq-tq" class="headerlink" title="2.1.6 dq-&gt;do_targetq = tq;"></a>2.1.6 dq-&gt;do_targetq = tq;</h4><p>执行完构造函数之后，接着又对<code>dq</code>进行了一些列赋值。</p>
<p>但是如果每次创建线程，所有的属性都要重新赋值的话，是比较耗性能的。所以苹果设计了基于“模板”的队列创建方式，这个”模板”就是我们的<code>do_targetq</code>属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签</span></span><br><span class="line">dq-&gt;dq_label = label;</span><br><span class="line"><span class="comment">// 优先级</span></span><br><span class="line">dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">		dqai.dqai_relpri);</span><br><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">	dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">	_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_retain(tq);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅2.6</span></span><br><span class="line">dq-&gt;do_targetq = tq;</span><br><span class="line"></span><br><span class="line">_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br></pre></td></tr></table></figure>

<p>在方法中寻找，我们可以发现<code>tq</code>的创建是通过<code>_dispatch_get_root_queue</code>方法，即在根队列的基础上创建，然后赋值了优先级<code>qos</code>和<code>overcommit</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">	<span class="comment">// ✅一定会走这里</span></span><br><span class="line">	<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">	tq = _dispatch_get_root_queue(</span><br><span class="line">			qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">			overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看<code>qos</code>的值，我们发现<code>DISPATCH_QOS_UNSPECIFIED</code>为0，且之前我们并没有赋值，所以一般情况下即执行<code>DISPATCH_QOS_DEFAULT</code>，为4，所以<code>qos</code>没指定的情况下为4。</p>
<p>接着看<code>overcommit</code>的值，根据上面<code>dqai</code>可以判断出，串行为1，并发为0</p>
<h4 id="2-1-7-dispatch-get-root-queue"><a href="#2-1-7-dispatch-get-root-queue" class="headerlink" title="2.1.7 _dispatch_get_root_queue"></a>2.1.7 _dispatch_get_root_queue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_global_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4 - 1 = 3</span></span><br><span class="line">	<span class="comment">// 2 * 3 + 0/1 = 6/7</span></span><br><span class="line">	<span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，最终就是从==根队列数组==里通过下标来取出队列。</p>
<p>根据入参可以知道，下标为6或者7。也就是说从<strong>根队列数组</strong>中取出第六个和第七个队列。</p>
<h4 id="2-1-8-dispatch-root-queues"><a href="#2-1-8-dispatch-root-queues" class="headerlink" title="2.1.8 _dispatch_root_queues[]"></a>2.1.8 _dispatch_root_queues[]</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">		((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = _dispatch_root_queue_ctxt(_DISPATCH_ROOT_QUEUE_IDX(n, flags)), \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = flags | ((flags &amp; DISPATCH_PRIORITY_FLAG_FALLBACK) ? \</span><br><span class="line">				_dispatch_priority_make_fallback(DISPATCH_QOS_##n) : \</span><br><span class="line">				_dispatch_priority_make(DISPATCH_QOS_##n, <span class="number">0</span>)), \</span><br><span class="line">		__VA_ARGS__ \</span><br><span class="line">	&#125;</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,  		<span class="comment">// 自定义串行队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">10</span>,			<span class="comment">// 自定义并发队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">			DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">11</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">12</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">13</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">14</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">15</span>,</span><br><span class="line">	),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<strong>下标</strong>，我们可以得出如下结论。</p>
<ul>
<li>自定义并发队列<code>target</code>队列为<code>com.apple.root.default-qos</code></li>
<li>自定义串行队列<code>target</code>队列为<code>com.apple.root.default-qos.overcommit</code></li>
</ul>
<blockquote>
<p>至此，我们自定义的一个串行或者并发队列就已经根据模板创建完成了</p>
</blockquote>
<h4 id="2-1-9-验证"><a href="#2-1-9-验证" class="headerlink" title="2.1.9 验证"></a>2.1.9 验证</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<p>回看我们开头打印的一些关于各种队列的信息，可以看到：</p>
<ul>
<li>串行队列、并发队列的<code>target</code>确实对应模板中的值</li>
<li>串行队列、并发队列、主队列、全局队列的<code>width</code>（<code>width</code>表示队列中的最大并发数）都与我们的分析一致，即：<ul>
<li>串行队列和主队列的<code>width</code>为1</li>
<li>自定义并发队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_MAX</code>，是满值-2，0xffe（4094）</li>
<li>全局队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_POOL</code>，是满值-1</li>
</ul>
</li>
</ul>
<blockquote>
<p>由此可见，我们对于底层的分析是正确的。</p>
</blockquote>
<h3 id="2-2-根队列数组的初始化"><a href="#2-2-根队列数组的初始化" class="headerlink" title="2.2 根队列数组的初始化"></a>2.2 根队列数组的初始化</h3><p>除了<code>dispatch_get_main_queue</code>，其他队列都是通过<code>_dispatch_root_queues</code>创建的，那么 <code>_dispatch_root_queues</code> 又是在哪创建的呢？</p>
<p>结论：</p>
<p><code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"></p>
<h3 id="2-3-一张图总结自定义队列的创建过程"><a href="#2-3-一张图总结自定义队列的创建过程" class="headerlink" title="2.3 一张图总结自定义队列的创建过程"></a>2.3 一张图总结自定义队列的创建过程</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/%E7%BB%98%E5%9B%BE.png"></p>
<h2 id="三、同步执行-dispatch-sync"><a href="#三、同步执行-dispatch-sync" class="headerlink" title="三、同步执行 dispatch_sync"></a>三、同步执行 dispatch_sync</h2><h3 id="3-1-死锁的产生"><a href="#3-1-死锁的产生" class="headerlink" title="3.1 死锁的产生"></a>3.1 死锁的产生</h3><p>死锁的产生是由于任务的相互等待，那么底层又是怎么实现死锁的？或者说底层是怎么判断产生了死锁？</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519091109342.png" alt="同步函数+主队列产生的死锁"></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210519100004403.png" alt="死锁崩溃时的堆栈信息"></p>
<p>这部分底层代码要跳转10层以上，抓住主线思维，理解起来就不算难。</p>
<h4 id="3-1-1-dispatch-sync"><a href="#3-1-1-dispatch-sync" class="headerlink" title="3.1.1 dispatch_sync"></a>3.1.1 dispatch_sync</h4><p>全局搜索<code>dispatch_sync(dispatch</code>，忽略<code>unlikely</code>小概率事件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ✅</span></span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __BLOCKS__</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-1-2-dispatch-sync-f"><a href="#3-1-2-dispatch-sync-f" class="headerlink" title="3.1.2  _dispatch_sync_f"></a>3.1.2  _dispatch_sync_f</h4><p>还是常规的中间层封装：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-3-dispatch-sync-f-inline"><a href="#3-1-3-dispatch-sync-f-inline" class="headerlink" title="3.1.3 _dispatch_sync_f_inline"></a>3.1.3 _dispatch_sync_f_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;Queue type doesn&#x27;t support dispatch_sync&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, <span class="number">0</span>, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>已知串行队列的<code>width</code>是1，所以串行队列满足<code>dq-&gt;dq_width == 1</code>，那么串型队列会走：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br></pre></td></tr></table></figure>

<p><code>并发队列</code>会继续往下走。</p>
<h4 id="3-1-4-dispatch-barrier-sync-f"><a href="#3-1-4-dispatch-barrier-sync-f" class="headerlink" title="3.1.4 _dispatch_barrier_sync_f"></a>3.1.4 _dispatch_barrier_sync_f</h4><p>因为死锁产生在串型队列，所以看串型队列走的分支，<code>串行队列</code>和<code>栅栏函数</code>的比较相似，所以跳转到这里，还是中间层封装</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-5-dispatch-barrier-sync-f-inline"><a href="#3-1-5-dispatch-barrier-sync-f-inline" class="headerlink" title="3.1.5 _dispatch_barrier_sync_f_inline"></a>3.1.5 _dispatch_barrier_sync_f_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid = _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dx_metatype(dq) != _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(<span class="number">0</span>, <span class="string">&quot;Queue type doesn&#x27;t support dispatch_sync&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">dispatch_lane_t</span> dl = upcast(dq)._dl;</span><br><span class="line">	<span class="comment">// The more correct thing to do would be to merge the qos of the thread</span></span><br><span class="line">	<span class="comment">// that just acquired the barrier lock into the queue state.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// However this is too expensive for the fast path, so skip doing it.</span></span><br><span class="line">	<span class="comment">// The chosen tradeoff is that if an enqueue on a lower priority thread</span></span><br><span class="line">	<span class="comment">// contends with this fast path, this thread may receive a useless override.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Global concurrent queues and queues bound to non-dispatch threads</span></span><br><span class="line">	<span class="comment">// always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 死锁会产生的位置</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-1-dispatch-tid-self"><a href="#3-1-5-1-dispatch-tid-self" class="headerlink" title="3.1.5.1 _dispatch_tid_self"></a>3.1.5.1 _dispatch_tid_self</h5><p><code>_dispatch_tid_self</code>是个宏定义，最终调用<code>_dispatch_thread_getspecific</code>来获取当前线程id（线程是以<code>key-value</code>的形式存在的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_tid_self()		((dispatch_tid)_dispatch_thread_port())</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() ((mach_port_t)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> !DISPATCH_USE_THREAD_LOCAL_STORAGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_DIRECT_TSD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() ((mach_port_t)(uintptr_t)\</span></span><br><span class="line">		_dispatch_thread_getspecific(_PTHREAD_TSD_SLOT_MACH_THREAD_SELF))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_thread_port() pthread_mach_thread_np(_dispatch_thread_self())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来就是死锁的核心分析！</p>
</blockquote>
<h5 id="3-1-5-2-dispatch-queue-try-acquire-barrier-sync"><a href="#3-1-5-2-dispatch-queue-try-acquire-barrier-sync" class="headerlink" title="3.1.5.2 _dispatch_queue_try_acquire_barrier_sync"></a>3.1.5.2 _dispatch_queue_try_acquire_barrier_sync</h5><p><code>_dispatch_queue_try_acquire_barrier_sync</code>会从os底层获取到一个状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">uint32_t</span> tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_queue_try_acquire_barrier_sync_and_suspend(dq._dl, tid, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(<span class="keyword">dispatch_lane_t</span> dq,</span><br><span class="line">		<span class="keyword">uint32_t</span> tid, <span class="keyword">uint64_t</span> suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> init  = DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line">	<span class="keyword">uint64_t</span> value = DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">			_dispatch_lock_value_from_tid(tid) |</span><br><span class="line">			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);</span><br><span class="line">	<span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">	<span class="comment">// 从底层获取信息 -- 状态信息 - 当前队列 - 线程</span></span><br><span class="line">	<span class="keyword">return</span> os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, &#123;</span><br><span class="line">		<span class="keyword">uint64_t</span> role = old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">		<span class="keyword">if</span> (old_state != (init | role)) &#123;</span><br><span class="line">			os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		new_state = value | role;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-3-dispatch-sync-f-slow"><a href="#3-1-5-3-dispatch-sync-f-slow" class="headerlink" title="3.1.5.3  _dispatch_sync_f_slow"></a>3.1.5.3  _dispatch_sync_f_slow</h5><p>上一步获取到<code>new_state</code>后就会来到这里（死锁崩溃时的调用栈中就出现过这个函数）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_slow(<span class="keyword">dispatch_queue_class_t</span> top_dqu, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> top_dc_flags,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> top_dq = top_dqu._dq;</span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = _dispatch_get_priority();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_sync_context_s</span> <span class="title">dsc</span> = &#123;</span></span><br><span class="line">		.dc_flags    = DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     = _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     = &amp;dsc,</span><br><span class="line">		.dc_other    = top_dq,</span><br><span class="line">		.dc_priority = pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  = _voucher_get(),</span><br><span class="line">		.dsc_func    = func,</span><br><span class="line">		.dsc_ctxt    = ctxt,</span><br><span class="line">		.dsc_waiter  = _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 压栈操作</span></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	<span class="comment">// 崩溃栈中出现的最后一个函数</span></span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dsc.dsc_func == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">dispatch_queue_t</span> stop_dq = dsc.dc_other;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_dispatch_trace_item_push</code>压栈操作，将执行任务push到队列中，按照<code>FIFO</code>执行</li>
<li><code>__DISPATCH_WAIT_FOR_QUEUE__</code>是崩溃栈的最后一个函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(<span class="keyword">dispatch_sync_context_t</span> dsc, <span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 获取队列的状态，看是否是处于等待状态</span></span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = _dispatch_wait_prepare(dq);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">		<span class="comment">// 死锁报错</span></span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)dq_state,</span><br><span class="line">				<span class="string">&quot;dispatch_sync called on queue &quot;</span></span><br><span class="line">				<span class="string">&quot;already owned by current thread&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-1-5-4-dq-state-drain-locked-by"><a href="#3-1-5-4-dq-state-drain-locked-by" class="headerlink" title="3.1.5.4 _dq_state_drain_locked_by"></a>3.1.5.4 _dq_state_drain_locked_by</h5><p>判断队列和线程的等待状态，如果两者都在等待，那么就会返回<code>YES</code>，从而造成死锁的崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dq_state_drain_locked_by(<span class="keyword">uint64_t</span> dq_state, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lock_is_locked_by((dispatch_lock)dq_state, tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// equivalent to _dispatch_lock_owner(lock_value) == tid</span></span><br><span class="line">	<span class="comment">// ^ (异或运算法) 两个相同就会出现 0 否则为1</span></span><br><span class="line">	<span class="keyword">return</span> ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-6-一图总结死锁过程"><a href="#3-1-6-一图总结死锁过程" class="headerlink" title="3.1.6 一图总结死锁过程"></a>3.1.6 一图总结死锁过程</h4><ol>
<li><code>_dispatch_sync</code>首先获取当前线程的<code>tid</code></li>
<li>获取到系统底层返回的<code>status</code></li>
<li>获取到队列的等待状态和tid比较，如果相同，则表示正在死锁，从而崩溃</li>
</ol>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/wer324fdsg15.png"></p>
<h3 id="3-2-block-任务的执行"><a href="#3-2-block-任务的执行" class="headerlink" title="3.2 block 任务的执行"></a>3.2 block 任务的执行</h3><p>在<code>dispatch_block</code>处打下断点，LLDB 调试打印出函数调用栈</p>
<p>![image-20210519113421454](../../../../Library/Application Support/typora-user-images/image-20210519113421454.png)</p>
<p>可以看到两个重要的函数：</p>
<ul>
<li><strong>_dispatch_lane_barrier_sync_invoke_and_complete</strong></li>
<li><strong>_dispatch_client_callout</strong></li>
</ul>
<p>接下来进行源码跟踪：</p>
<h4 id="3-2-1-dispatch-sync"><a href="#3-2-1-dispatch-sync" class="headerlink" title="3.2.1 dispatch_sync"></a>3.2.1 dispatch_sync</h4><p>对于同步任务<code>block</code>的执行，同样是从<code>dispatch_sync</code>开始跟进：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_sync(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_BLOCK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ✅</span></span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// __BLOCKS__</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-dispatch-sync-f"><a href="#3-2-2-dispatch-sync-f" class="headerlink" title="3.2.2 _dispatch_sync_f"></a>3.2.2 _dispatch_sync_f</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func,</span><br><span class="line">		<span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-dispatch-sync-f-inline"><a href="#3-2-3-dispatch-sync-f-inline" class="headerlink" title="3.2.3 _dispatch_sync_f_inline"></a>3.2.3 _dispatch_sync_f_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (likely(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="comment">// 串行队列走这里</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-dispatch-barrier-sync-f"><a href="#3-2-4-dispatch-barrier-sync-f" class="headerlink" title="3.2.4 _dispatch_barrier_sync_f"></a>3.2.4 _dispatch_barrier_sync_f</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-dispatch-barrier-sync-f-inline"><a href="#3-2-5-dispatch-barrier-sync-f-inline" class="headerlink" title="3.2.5 _dispatch_barrier_sync_f_inline"></a>3.2.5 _dispatch_barrier_sync_f_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_barrier_sync_f_inline(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-6-dispatch-lane-barrier-sync-invoke-and-complete"><a href="#3-2-6-dispatch-lane-barrier-sync-invoke-and-complete" class="headerlink" title="3.2.6 _dispatch_lane_barrier_sync_invoke_and_complete"></a>3.2.6 _dispatch_lane_barrier_sync_invoke_and_complete</h4><blockquote>
<p>这个函数出现在打印中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_lane_barrier_sync_invoke_and_complete(<span class="keyword">dispatch_lane_t</span> dq,</span><br><span class="line">		<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func DISPATCH_TRACE_ARG(<span class="keyword">void</span> *dc))</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_function_invoke_inline(dq, ctxt, func);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-7-dispatch-sync-function-invoke-inline"><a href="#3-2-7-dispatch-sync-function-invoke-inline" class="headerlink" title="3.2.7 _dispatch_sync_function_invoke_inline"></a>3.2.7 _dispatch_sync_function_invoke_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_sync_function_invoke_inline(<span class="keyword">dispatch_queue_class_t</span> dq, <span class="keyword">void</span> *ctxt,</span><br><span class="line">		<span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_thread_frame_s dtf;</span><br><span class="line">	_dispatch_thread_frame_push(&amp;dtf, dq);</span><br><span class="line">	_dispatch_client_callout(ctxt, func);</span><br><span class="line">	_dispatch_perfmon_workitem_inc();</span><br><span class="line">	_dispatch_thread_frame_pop(&amp;dtf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-8-dispatch-client-callout"><a href="#3-2-8-dispatch-client-callout" class="headerlink" title="3.2.8 _dispatch_client_callout"></a>3.2.8 _dispatch_client_callout</h4><blockquote>
<p> 这个函数出现在打印中</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_client_callout(<span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_get_tsd_base();</span><br><span class="line">	<span class="keyword">void</span> *u = _dispatch_get_unwind_tsd();</span><br><span class="line">	<span class="keyword">if</span> (likely(!u)) <span class="keyword">return</span> f(ctxt);</span><br><span class="line">	_dispatch_set_unwind_tsd(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// ✅</span></span><br><span class="line">	f(ctxt);</span><br><span class="line">	_dispatch_free_unwind_tsd();</span><br><span class="line">	_dispatch_set_unwind_tsd(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f(ctxt);</code>就是回调函数的调用，至此同步函数的<code>block</code>调用完成。</p>
<h4 id="3-2-9-总结同步函数block任务的执行"><a href="#3-2-9-总结同步函数block任务的执行" class="headerlink" title="3.2.9 总结同步函数block任务的执行"></a>3.2.9 总结同步函数block任务的执行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync</span><br><span class="line">└──_dispatch_sync_f</span><br><span class="line">   └──_dispatch_sync_f_inline</span><br><span class="line">      └──_dispatch_barrier_sync_f</span><br><span class="line">         └──_dispatch_barrier_sync_f_inline</span><br><span class="line">            └──_dispatch_lane_barrier_sync_invoke_and_complete</span><br><span class="line">               └──_dispatch_sync_function_invoke_inline</span><br><span class="line">                  └──_dispatch_client_callout</span><br></pre></td></tr></table></figure>

<h2 id="四、异步执行-dispatch-async"><a href="#四、异步执行-dispatch-async" class="headerlink" title="四、异步执行 dispatch_async"></a>四、异步执行 dispatch_async</h2><h3 id="4-1-任务的保存"><a href="#4-1-任务的保存" class="headerlink" title="4.1 任务的保存"></a>4.1 任务的保存</h3><p>还是一样的思路，跟到<code>dispatch_async</code>的源码中</p>
<h4 id="4-1-1-dispatch-async"><a href="#4-1-1-dispatch-async" class="headerlink" title="4.1.1 dispatch_async"></a>4.1.1 dispatch_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME;</span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line"></span><br><span class="line">	qos = _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-1-2-dispatch-continuation-init"><a href="#4-1-2-dispatch-continuation-init" class="headerlink" title="4.1.2 _dispatch_continuation_init"></a>4.1.2 _dispatch_continuation_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_block_t</span> work,</span><br><span class="line">		<span class="keyword">dispatch_block_flags_t</span> flags, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *ctxt = _dispatch_Block_copy(work);</span><br><span class="line"></span><br><span class="line">	dc_flags |= DC_FLAG_BLOCK | DC_FLAG_ALLOCATED;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		dc-&gt;dc_flags = dc_flags;</span><br><span class="line">		dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">		<span class="comment">// will initialize all fields but requires dc_flags &amp; dc_ctxt to be set</span></span><br><span class="line">		<span class="keyword">return</span> _dispatch_continuation_init_slow(dc, dqu, flags);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将任务进行统一格式化</span></span><br><span class="line">	<span class="keyword">dispatch_function_t</span> func = _dispatch_Block_invoke(work);</span><br><span class="line">	<span class="keyword">if</span> (dc_flags &amp; DC_FLAG_CONSUME) &#123;</span><br><span class="line">		func = _dispatch_call_block_and_release;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_continuation_init_f(dc, dqu, ctxt, func, flags, dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_Block_invoke</code>将任务进行统一格式化</p>
<h4 id="4-1-3-dispatch-continuation-init-f"><a href="#4-1-3-dispatch-continuation-init-f" class="headerlink" title="4.1.3  _dispatch_continuation_init_f"></a>4.1.3  _dispatch_continuation_init_f</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_qos_t</span></span><br><span class="line">_dispatch_continuation_init_f(<span class="keyword">dispatch_continuation_t</span> dc,</span><br><span class="line">		<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> f,</span><br><span class="line">		<span class="keyword">dispatch_block_flags_t</span> flags, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">pthread_priority_t</span> pp = <span class="number">0</span>;</span><br><span class="line">	dc-&gt;dc_flags = dc_flags | DC_FLAG_ALLOCATED;</span><br><span class="line">	dc-&gt;dc_func = f;</span><br><span class="line">	dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">	<span class="comment">// in this context DISPATCH_BLOCK_HAS_PRIORITY means that the priority</span></span><br><span class="line">	<span class="comment">// should not be propagated, only taken from the handler if it has one</span></span><br><span class="line">	<span class="keyword">if</span> (!(flags &amp; DISPATCH_BLOCK_HAS_PRIORITY)) &#123;</span><br><span class="line">		pp = _dispatch_priority_propagate();</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_continuation_voucher_set(dc, flags);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_continuation_priority_set(dc, dqu, pp, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dc-&gt;dc_func = f</code>将block任务 保存下来</p>
<blockquote>
<p>异步函数的任务保存找到了，那它的任务又是何时执行的呢？以及线程是何时创建的？</p>
</blockquote>
<h3 id="4-2-线程的创建"><a href="#4-2-线程的创建" class="headerlink" title="4.2 线程的创建"></a>4.2 线程的创建</h3><h4 id="4-2-1-dispatch-async"><a href="#4-2-1-dispatch-async" class="headerlink" title="4.2.1 dispatch_async"></a>4.2.1 dispatch_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_async(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_block_t</span> work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">	<span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME;</span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line"></span><br><span class="line">	qos = _dispatch_continuation_init(dc, dq, work, <span class="number">0</span>, dc_flags);</span><br><span class="line">	_dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-dispatch-continuation-async"><a href="#4-2-2-dispatch-continuation-async" class="headerlink" title="4.2.2 _dispatch_continuation_async"></a>4.2.2 _dispatch_continuation_async</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_async(<span class="keyword">dispatch_queue_class_t</span> dqu,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">uintptr_t</span> dc_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">	<span class="keyword">if</span> (!(dc_flags &amp; DC_FLAG_NO_INTROSPECTION)) &#123;</span><br><span class="line">		_dispatch_trace_item_push(dqu, dc);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)dc_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">return</span> dx_push(dqu._dq, dc, qos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-dx-push"><a href="#4-2-3-dx-push" class="headerlink" title="4.2.3 dx_push"></a>4.2.3 dx_push</h4><p>查看其代码，发现为宏定义，执行了<code>dq_push</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_push(x, y, z) dx_vtable(x)-&gt;dq_push(x, y, z)</span></span><br></pre></td></tr></table></figure>

<p>那么<code>dq_push</code>又是怎么赋值的呢，由于其是一个属性，所以我们可以搜索<code>.dq_pus</code>来查看其赋值。我们发现其赋值的地方非常多，但是大体的意思我们可以理解，就是主要在根队列，自定义队列，主队列等等进行<code>push</code>操作的时候调用。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210519170358277.png"></p>
<p>我们知道线程的创建一般都是在根队列上进行创建的，所以我们直接找根队列的<code>dq_push</code>赋值，即<code>_dispatch_root_queue_push</code>，因为它最基本，省去了旁枝末节。</p>
<p>那么接下来的流程就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_root_queue_push</span><br><span class="line">-&gt; _dispatch_root_queue_poke </span><br><span class="line">-&gt; _dispatch_root_queue_poke_slow</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-dispatch-root-queue-push"><a href="#4-2-4-dispatch-root-queue-push" class="headerlink" title="4.2.4 _dispatch_root_queue_push"></a>4.2.4 _dispatch_root_queue_push</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_root_queue_push(<span class="keyword">dispatch_queue_global_t</span> rq, <span class="keyword">dispatch_object_t</span> dou,</span><br><span class="line">		<span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_KEVENT_WORKQUEUE</span></span><br><span class="line">	<span class="keyword">dispatch_deferred_items_t</span> ddi = _dispatch_deferred_items_get();</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ddi &amp;&amp; ddi-&gt;ddi_can_stash)) &#123;</span><br><span class="line">		<span class="keyword">dispatch_object_t</span> old_dou = ddi-&gt;ddi_stashed_dou;</span><br><span class="line">		<span class="keyword">dispatch_priority_t</span> rq_overcommit;</span><br><span class="line">		rq_overcommit = rq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!old_dou._do || rq_overcommit)) &#123;</span><br><span class="line">			<span class="keyword">dispatch_queue_global_t</span> old_rq = ddi-&gt;ddi_stashed_rq;</span><br><span class="line">			<span class="keyword">dispatch_qos_t</span> old_qos = ddi-&gt;ddi_stashed_qos;</span><br><span class="line">			ddi-&gt;ddi_stashed_rq = rq;</span><br><span class="line">			ddi-&gt;ddi_stashed_dou = dou;</span><br><span class="line">			ddi-&gt;ddi_stashed_qos = qos;</span><br><span class="line">			_dispatch_debug(<span class="string">&quot;deferring item %p, rq %p, qos %d&quot;</span>,</span><br><span class="line">					dou._do, rq, qos);</span><br><span class="line">			<span class="keyword">if</span> (rq_overcommit) &#123;</span><br><span class="line">				ddi-&gt;ddi_can_stash = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (likely(!old_dou._do)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// push the previously stashed item</span></span><br><span class="line">			qos = old_qos;</span><br><span class="line">			rq = old_rq;</span><br><span class="line">			dou = old_dou;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (_dispatch_root_queue_push_needs_override(rq, qos)) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_root_queue_push_override(rq, dou, qos);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	_dispatch_root_queue_push_inline(rq, dou, dou, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-5-dispatch-root-queue-push-inline"><a href="#4-2-5-dispatch-root-queue-push-inline" class="headerlink" title="4.2.5 _dispatch_root_queue_push_inline"></a>4.2.5 _dispatch_root_queue_push_inline</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_root_queue_push_inline(<span class="keyword">dispatch_queue_global_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_object_t</span> _head, <span class="keyword">dispatch_object_t</span> _tail, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">hd</span> = _<span class="title">head</span>._<span class="title">do</span>, *<span class="title">tl</span> = _<span class="title">tail</span>._<span class="title">do</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(os_mpsc_push_list(os_mpsc(dq, dq_items), hd, tl, do_next))) &#123;</span><br><span class="line">		<span class="keyword">return</span> _dispatch_root_queue_poke(dq, n, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-6-dispatch-root-queue-poke"><a href="#4-2-6-dispatch-root-queue-poke" class="headerlink" title="4.2.6 _dispatch_root_queue_poke"></a>4.2.6 _dispatch_root_queue_poke</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">_dispatch_root_queue_poke(<span class="keyword">dispatch_queue_global_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!_dispatch_queue_class_probe(dq)) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">	<span class="keyword">if</span> (likely(dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!os_atomic_cmpxchg2o(dq, dgq_pending, <span class="number">0</span>, n, relaxed))) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending &quot;</span></span><br><span class="line">					<span class="string">&quot;for global queue: %p&quot;</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line">	<span class="keyword">return</span> _dispatch_root_queue_poke_slow(dq, n, <span class="built_in">floor</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-dispatch-root-queue-poke-slow"><a href="#4-2-7-dispatch-root-queue-poke-slow" class="headerlink" title="4.2.7 _dispatch_root_queue_poke_slow"></a>4.2.7 _dispatch_root_queue_poke_slow</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_root_queue_poke_slow(<span class="keyword">dispatch_queue_global_t</span> dq, <span class="keyword">int</span> n, <span class="keyword">int</span> <span class="built_in">floor</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> remaining = n;</span><br><span class="line">	<span class="keyword">int</span> r = ENOSYS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ✅队列初始化，runtime强转等操作，防止类型无法匹配等情况</span></span><br><span class="line">	_dispatch_root_queues_init();</span><br><span class="line">	_dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">	_dispatch_trace_runtime_event(worker_request, dq, (<span class="keyword">uint64_t</span>)n);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (dx_type(dq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#123;</span><br><span class="line">		_dispatch_root_queue_debug(<span class="string">&quot;requesting new worker thread for global &quot;</span></span><br><span class="line">				<span class="string">&quot;queue: %p&quot;</span>, dq);</span><br><span class="line">		r = _pthread_workqueue_addthreads(remaining,</span><br><span class="line">				_dispatch_priority_to_pp_prefer_fallback(dq-&gt;dq_priority));</span><br><span class="line">		(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !DISPATCH_USE_INTERNAL_WORKQUEUE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">	<span class="keyword">dispatch_pthread_root_queue_context_t</span> pqc = dq-&gt;do_ctxt;</span><br><span class="line">	<span class="keyword">if</span> (likely(pqc-&gt;dpq_thread_mediator.do_vtable)) &#123;</span><br><span class="line">		<span class="keyword">while</span> (dispatch_semaphore_signal(&amp;pqc-&gt;dpq_thread_mediator)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">&quot;signaled sleeping worker for &quot;</span></span><br><span class="line">					<span class="string">&quot;global queue: %p&quot;</span>, dq);</span><br><span class="line">			<span class="keyword">if</span> (!--remaining) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> overcommit = dq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	<span class="keyword">if</span> (overcommit) &#123;</span><br><span class="line">		os_atomic_add2o(dq, dgq_pending, remaining, relaxed);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!os_atomic_cmpxchg2o(dq, dgq_pending, <span class="number">0</span>, remaining, relaxed)) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">&quot;worker thread request still pending for &quot;</span></span><br><span class="line">					<span class="string">&quot;global queue: %p&quot;</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> can_request, t_count;</span><br><span class="line">	<span class="comment">// seq_cst with atomic store to tail &lt;rdar://problem/16932833&gt;</span></span><br><span class="line">	<span class="comment">// ✅获取线程池的大小</span></span><br><span class="line">	t_count = os_atomic_load2o(dq, dgq_thread_pool_size, ordered);</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="comment">// ✅计算可以请求的数量</span></span><br><span class="line">		can_request = t_count &lt; <span class="built_in">floor</span> ? <span class="number">0</span> : t_count - <span class="built_in">floor</span>;</span><br><span class="line">		<span class="keyword">if</span> (remaining &gt; can_request) &#123;</span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">&quot;pthread pool reducing request from %d to %d&quot;</span>,</span><br><span class="line">					remaining, can_request);</span><br><span class="line">			os_atomic_sub2o(dq, dgq_pending, remaining - can_request, relaxed);</span><br><span class="line">			remaining = can_request;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (remaining == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">// 线程池无可用将会报错</span></span><br><span class="line">			_dispatch_root_queue_debug(<span class="string">&quot;pthread pool is full for root queue: &quot;</span></span><br><span class="line">					<span class="string">&quot;%p&quot;</span>, dq);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!os_atomic_cmpxchgvw2o(dq, dgq_thread_pool_size, t_count,</span><br><span class="line">			t_count - remaining, &amp;t_count, acquire));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_WIN32)</span></span><br><span class="line">	<span class="keyword">pthread_attr_t</span> *attr = &amp;pqc-&gt;dpq_thread_attr;</span><br><span class="line">	<span class="keyword">pthread_t</span> tid, *pthr = &amp;tid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_USE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq == &amp;_dispatch_mgr_root_queue)) &#123;</span><br><span class="line">		pthr = _dispatch_mgr_root_queue_init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_retain(dq); <span class="comment">// released in _dispatch_worker_thread</span></span><br><span class="line">		<span class="comment">// ✅开辟线程✅</span></span><br><span class="line">		<span class="keyword">while</span> ((r = pthread_create(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">				(<span class="keyword">void</span>)dispatch_assume_zero(r);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (--remaining);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_MGR_THREAD &amp;&amp; DISPATCH_USE_PTHREAD_ROOT_QUEUES</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(dq == &amp;_dispatch_mgr_root_queue)) &#123;</span><br><span class="line">		_dispatch_mgr_root_queue_init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		_dispatch_retain(dq); <span class="comment">// released in _dispatch_worker_thread</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">		<span class="keyword">unsigned</span> dwStackSize = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">unsigned</span> dwStackSize = <span class="number">64</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="keyword">uintptr_t</span> hThread = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (!(hThread = _beginthreadex(<span class="literal">NULL</span>, dwStackSize, _dispatch_worker_thread_thunk, dq, STACK_SIZE_PARAM_IS_A_RESERVATION, <span class="literal">NULL</span>))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">				(<span class="keyword">void</span>)dispatch_assume(hThread);</span><br><span class="line">			&#125;</span><br><span class="line">			_dispatch_temporary_resource_shortage();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (_dispatch_mgr_sched.prio &gt; _dispatch_mgr_sched.default_prio) &#123;</span><br><span class="line">			(<span class="keyword">void</span>)dispatch_assume_zero(SetThreadPriority((HANDLE)hThread, _dispatch_mgr_sched.prio) == TRUE);</span><br><span class="line">		&#125;</span><br><span class="line">		CloseHandle((HANDLE)hThread);</span><br><span class="line">	&#125; <span class="keyword">while</span> (--remaining);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// defined(_WIN32)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	(<span class="keyword">void</span>)<span class="built_in">floor</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_USE_PTHREAD_POOL</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个<code>do-while</code>是对核心线程数的判断、操作等等</li>
<li>第二个<code>do-while</code>调用<code>pthread_create</code>创建线程（底层还是用了<code>pthread</code>）</li>
</ul>
<h3 id="4-3-任务的执行"><a href="#4-3-任务的执行" class="headerlink" title="4.3 任务的执行"></a>4.3 任务的执行</h3><p><code>_dispatch_root_queue_poke_slow</code>中调用了<code>_dispatch_root_queues_init();</code></p>
<p><strong>_dispatch_root_queues_init</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_STATIC_GLOBAL(<span class="keyword">dispatch_once_t</span> _dispatch_root_queues_pred);</span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_root_queues_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_once_f(&amp;_dispatch_root_queues_pred, <span class="literal">NULL</span>,</span><br><span class="line">			_dispatch_root_queues_init_once);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>任务的执行其实刚才已经讲过了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;dispatch_once_f-&gt;_dispatch_once_callout-&gt;_dispatch_client_callout</span><br></pre></td></tr></table></figure>

<p>只不过任务在等待线程的状态，而线程怎么执行任务就不得而知了</p>
<h3 id="4-4-一图总结异步函数执行流程"><a href="#4-4-一图总结异步函数执行流程" class="headerlink" title="4.4 一图总结异步函数执行流程"></a>4.4 一图总结异步函数执行流程</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210524090119763.png"></p>
<h2 id="五、信号量的原理"><a href="#五、信号量的原理" class="headerlink" title="五、信号量的原理"></a>五、信号量的原理</h2><p>信号量的基本使用是这样的，底层又是怎么个原理呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(M);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(sem);</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>

<h3 id="5-1-dispatch-semaphore-create"><a href="#5-1-dispatch-semaphore-create" class="headerlink" title="5.1 dispatch_semaphore_create"></a>5.1 dispatch_semaphore_create</h3><p>只是初始化<code>dispatch_semaphore_t</code>，内部进行传值保存（value必须大于0）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span></span><br><span class="line">dispatch_semaphore_create(<span class="keyword">long</span> value)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the internal value is negative, then the absolute of the value is</span></span><br><span class="line">	<span class="comment">// equal to the number of waiting threads. Therefore it is bogus to</span></span><br><span class="line">	<span class="comment">// initialize the semaphore with a negative value.</span></span><br><span class="line">	<span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dsema = _dispatch_object_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">	dsema-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dsema-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	dsema-&gt;dsema_value = value;</span><br><span class="line">	_dispatch_sema4_init(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	dsema-&gt;dsema_orig = value;</span><br><span class="line">	<span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-dispatch-semaphore-signal"><a href="#5-2-dispatch-semaphore-signal" class="headerlink" title="5.2 dispatch_semaphore_signal"></a>5.2 dispatch_semaphore_signal</h3><p>类似<code>KVC</code>形式从底层取得当前信号量的<code>value</code>值，并且这个函数是有返回值的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_signal(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(value == LONG_MIN)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(value,</span><br><span class="line">				<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">long</span></span><br><span class="line">_dispatch_semaphore_signal_slow(<span class="keyword">dispatch_semaphore_t</span> dsema)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	_dispatch_sema4_signal(&amp;dsema-&gt;dsema_sema, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实最核心的点在于<code>os_atomic_inc2o</code>进行了<code>++操作</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_inc2o(p, f, m) \</span></span><br><span class="line">		os_atomic_add2o(p, f, <span class="number">1</span>, m)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_add2o(p, f, v, m) \</span></span><br><span class="line">		os_atomic_add(&amp;(p)-&gt;f, (v), m)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_add(p, v, m) \</span></span><br><span class="line">		_os_atomic_c11_op((p), (v), m, add, +)</span><br></pre></td></tr></table></figure>

<h3 id="5-3-dispatch-semaphore-wait"><a href="#5-3-dispatch-semaphore-wait" class="headerlink" title="5.3 dispatch_semaphore_wait"></a>5.3 dispatch_semaphore_wait</h3><p>同理<code>dispatch_semaphore_wait</code>也是取value值，并返回对应结果</p>
<ul>
<li><code>value&gt;=0</code>就立刻返回</li>
<li><code>value&lt;0</code>根据等待时间<code>timeout</code>作出不同操作<ul>
<li><code>DISPATCH_TIME_NOW</code>将<code>value</code>加一(也就是变为0)——为了抵消 wait 函数一开始的减一操作，并返回<code>KERN_OPERATION_TIMED_OUT</code>表示由于等待时间超时</li>
<li><code>DISPATCH_TIME_FOREVER</code>调用系统的<code>semaphore_wait</code>方法继续等待，直到收到<code>signal</code>调用</li>
<li><code>默认情况</code>与<code>DISPATCH_TIME_FOREVER</code>类似，不过需要指定一个等待时间</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_semaphore_wait(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> value = os_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">	<span class="keyword">if</span> (likely(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span></span><br><span class="line">_dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema,</span><br><span class="line">		<span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">long</span> orig;</span><br><span class="line"></span><br><span class="line">	_dispatch_sema4_create(&amp;dsema-&gt;dsema_sema, _DSEMA4_POLICY_FIFO);</span><br><span class="line">	<span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">if</span> (!_dispatch_sema4_timedwait(&amp;dsema-&gt;dsema_sema, timeout)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Fall through and try to undo what the fast path did to</span></span><br><span class="line">		<span class="comment">// dsema-&gt;dsema_value</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">		orig = dsema-&gt;dsema_value;</span><br><span class="line">		<span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (os_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>,</span><br><span class="line">					&amp;orig, relaxed)) &#123;</span><br><span class="line">				<span class="keyword">return</span> _DSEMA4_TIMEOUT();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Another thread called semaphore_signal().</span></span><br><span class="line">		<span class="comment">// Fall through and drain the wakeup.</span></span><br><span class="line">	<span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">		_dispatch_sema4_wait(&amp;dsema-&gt;dsema_sema);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os_atomic_dec2o`进行了`--操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_dec2o(p, f, m) \</span></span><br><span class="line">		os_atomic_sub2o(p, f, <span class="number">1</span>, m)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_sub2o(p, f, v, m) \</span></span><br><span class="line">		os_atomic_sub(&amp;(p)-&gt;f, (v), m)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> os_atomic_sub(p, v, m) \</span></span><br><span class="line">		_os_atomic_c11_op((p), (v), m, sub, -)</span><br></pre></td></tr></table></figure>

<h2 id="六、调度组的原理"><a href="#六、调度组的原理" class="headerlink" title="六、调度组的原理"></a>六、调度组的原理</h2><p>调度组的基本使用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span> group = dispatch_group_create();</span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line">dispatch_group_leave(group);</span><br><span class="line">dispatch_group_async(group, <span class="built_in">queue</span>, ^&#123;&#125;);</span><br><span class="line">dispatch_group_notify(group, <span class="built_in">queue</span>, ^&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="6-1-dispatch-group-create"><a href="#6-1-dispatch-group-create" class="headerlink" title="6.1 dispatch_group_create"></a>6.1 dispatch_group_create</h3><p>跟其他GCD对象一样使用<code>_dispatch_object_alloc</code>生成<code>dispatch_group_t</code>，这个方法就是开辟了内存空间。</p>
<p>从<code>os_atomic_store2o</code>可以看出<code>group</code>底层也维护了一个<code>value</code>值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_group_t</span></span><br><span class="line">dispatch_group_create(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_group_create_with_count(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_group_t</span></span><br><span class="line">_dispatch_group_create_with_count(<span class="keyword">uint32_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">dispatch_group_t</span> dg = _dispatch_object_alloc(DISPATCH_VTABLE(group),</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_group_s));</span><br><span class="line">	dg-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dg-&gt;do_targetq = _dispatch_get_default_queue(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">if</span> (n) &#123;</span><br><span class="line">		os_atomic_store2o(dg, dg_bits,</span><br><span class="line">				-n * DISPATCH_GROUP_VALUE_INTERVAL, relaxed);</span><br><span class="line">		os_atomic_store2o(dg, do_ref_cnt, <span class="number">1</span>, relaxed); <span class="comment">// &lt;rdar://22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-dispatch-group-enter-amp-dispatch-group-leave"><a href="#6-2-dispatch-group-enter-amp-dispatch-group-leave" class="headerlink" title="6.2 dispatch_group_enter &amp; dispatch_group_leave"></a>6.2 dispatch_group_enter &amp; dispatch_group_leave</h3><p>这两个<code>API</code>与信号量的使用大同异，<code>os_atomic_sub_orig2o</code>、<code>os_atomic_add_orig2o</code>负责<code>--</code>、<code>++</code>操作，如果不成对使用则会出错</p>
<ul>
<li><code>dispatch_group_leave</code>出组会对<code>state</code>进行更新</li>
<li>全部出组了会调用<code>_dispatch_group_wake</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ✅-- 操作</span></span><br><span class="line">	<span class="keyword">uint32_t</span> old_bits = os_atomic_sub_orig2o(dg, dg_bits,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, acquire);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = old_bits &amp; DISPATCH_GROUP_VALUE_MASK;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		_dispatch_retain(dg); <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(old_bits,</span><br><span class="line">				<span class="string">&quot;Too many nested calls to dispatch_group_enter()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> dg)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ✅++ 操作</span></span><br><span class="line">	<span class="keyword">uint64_t</span> new_state, old_state = os_atomic_add_orig2o(dg, dg_state,</span><br><span class="line">			DISPATCH_GROUP_VALUE_INTERVAL, release);</span><br><span class="line">	<span class="keyword">uint32_t</span> old_value = (<span class="keyword">uint32_t</span>)(old_state &amp; DISPATCH_GROUP_VALUE_MASK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == DISPATCH_GROUP_VALUE_1)) &#123;</span><br><span class="line">		old_state += DISPATCH_GROUP_VALUE_INTERVAL;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			new_state = old_state;</span><br><span class="line">			<span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// If the group was entered again since the atomic_add above,</span></span><br><span class="line">				<span class="comment">// we can&#x27;t clear the waiters bit anymore as we don&#x27;t know for</span></span><br><span class="line">				<span class="comment">// which generation the waiters are for</span></span><br><span class="line">				new_state &amp;= ~DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (old_state == new_state) <span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">while</span> (unlikely(!os_atomic_cmpxchgv2o(dg, dg_state,</span><br><span class="line">				old_state, new_state, &amp;old_state, relaxed)));</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> _dispatch_group_wake(dg, old_state, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(old_value == <span class="number">0</span>)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH((<span class="keyword">uintptr_t</span>)old_value,</span><br><span class="line">				<span class="string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-dispatch-group-async"><a href="#6-3-dispatch-group-async" class="headerlink" title="6.3 dispatch_group_async"></a>6.3 dispatch_group_async</h3><p><code>dispatch_group_async</code> 就是对 <code>enter</code> 和 <code>leave</code> 的封装，当 <code>block</code> 调用完成之后进行 <code>callout</code> 之后就出组了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_block_t</span> db)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="keyword">uintptr_t</span> dc_flags = DC_FLAG_CONSUME | DC_FLAG_GROUP_ASYNC;</span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos;</span><br><span class="line">    <span class="comment">// 保存任务 </span></span><br><span class="line">    qos = _dispatch_continuation_init(dc, dq, db, <span class="number">0</span>, dc_flags);</span><br><span class="line">    _dispatch_continuation_group_async(dg, dq, dc, qos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_group_async(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dc, <span class="keyword">dispatch_qos_t</span> qos)</span><br><span class="line">&#123;   <span class="comment">// 进组</span></span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    _dispatch_continuation_async(dq, dc, qos, dc-&gt;dc_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_continuation_with_group_invoke(<span class="keyword">dispatch_continuation_t</span> dc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dou</span> = <span class="title">dc</span>-&gt;<span class="title">dc_data</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> type = dx_type(dou);</span><br><span class="line">    <span class="keyword">if</span> (type == DISPATCH_GROUP_TYPE) &#123;</span><br><span class="line">    	_dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    	_dispatch_trace_item_complete(dc);</span><br><span class="line">    	<span class="comment">// 出组</span></span><br><span class="line">    	dispatch_group_leave((<span class="keyword">dispatch_group_t</span>)dou);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	DISPATCH_INTERNAL_CRASH(dx_type(dou), <span class="string">&quot;Unexpected object type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4-dispatch-group-wait"><a href="#6-4-dispatch-group-wait" class="headerlink" title="6.4 dispatch_group_wait"></a>6.4 dispatch_group_wait</h3><p>这个方法用于等待 <code>group</code> 中所有任务执行完成，可以理解为信号量 <code>wait</code> 的封装:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span></span><br><span class="line">dispatch_group_wait(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">    </span><br><span class="line">    os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, relaxed, &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((old_state &amp; DISPATCH_GROUP_VALUE_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">    		os_atomic_rmw_loop_give_up_with_fence(acquire, <span class="keyword">return</span> <span class="number">0</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">if</span> (unlikely(timeout == <span class="number">0</span>)) &#123;</span><br><span class="line">    		os_atomic_rmw_loop_give_up(<span class="keyword">return</span> _DSEMA4_TIMEOUT());</span><br><span class="line">    	&#125;</span><br><span class="line">    	new_state = old_state | DISPATCH_GROUP_HAS_WAITERS;</span><br><span class="line">    	<span class="keyword">if</span> (unlikely(old_state &amp; DISPATCH_GROUP_HAS_WAITERS)) &#123;</span><br><span class="line">    		os_atomic_rmw_loop_give_up(<span class="keyword">break</span>);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_wait_slow(dg, _dg_state_gen(new_state), timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前 <code>value</code> 和原始 <code>value</code> 相同，表明任务已经全部完成，直接返回 0，如果 <code>timeout</code> 为 0 也会立刻返回，否则调用 <code>_dispatch_group_wait_slow</code>。 在 <code>_dispatch_group_wait_slow</code> 会一直等到任务完成返回 0 ，当然如果一直没有完成就会返回 <code>timeout</code>。</p>
<h3 id="6-5-dispatch-group-notify"><a href="#6-5-dispatch-group-notify" class="headerlink" title="6.5 dispatch_group_notify"></a>6.5 dispatch_group_notify</h3><p>等待<code>_dispatch_group_wake</code>回调（全部出组会调用）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_notify(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">		<span class="keyword">dispatch_continuation_t</span> dsn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> old_state, new_state;</span><br><span class="line">	<span class="keyword">dispatch_continuation_t</span> prev;</span><br><span class="line"></span><br><span class="line">	dsn-&gt;dc_data = dq;</span><br><span class="line">	_dispatch_retain(dq);</span><br><span class="line"></span><br><span class="line">	prev = os_mpsc_push_update_tail(os_mpsc(dg, dg_notify), dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) _dispatch_retain(dg);</span><br><span class="line">	os_mpsc_push_update_prev(os_mpsc(dg, dg_notify), prev, dsn, do_next);</span><br><span class="line">	<span class="keyword">if</span> (os_mpsc_push_was_empty(prev)) &#123;</span><br><span class="line">		os_atomic_rmw_loop2o(dg, dg_state, old_state, new_state, release, &#123;</span><br><span class="line">			new_state = old_state | DISPATCH_GROUP_HAS_NOTIFS;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)old_state == <span class="number">0</span>) &#123;</span><br><span class="line">				os_atomic_rmw_loop_give_up(&#123;</span><br><span class="line">          <span class="comment">// ✅</span></span><br><span class="line">					<span class="keyword">return</span> _dispatch_group_wake(dg, new_state, <span class="literal">false</span>);</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-6-dispatch-group-wake"><a href="#6-6-dispatch-group-wake" class="headerlink" title="6.6 dispatch_group_wake"></a>6.6 dispatch_group_wake</h3><p>这个函数主要做的就是循环调用 <code>dispatch_async_f</code> 异步执行在 <code>notify</code> 函数中注册的回调。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_dispatch_group_wake(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">uint64_t</span> dg_state, <span class="keyword">bool</span> needs_release)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> refs = needs_release ? <span class="number">1</span> : <span class="number">0</span>; <span class="comment">// &lt;rdar://problem/22318411&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dg_state &amp; DISPATCH_GROUP_HAS_NOTIFS) &#123;</span><br><span class="line">    	<span class="keyword">dispatch_continuation_t</span> dc, next_dc, tail;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// Snapshot before anything is notified/woken</span></span><br><span class="line">    	dc = os_mpsc_capture_snapshot(os_mpsc(dg, dg_notify), &amp;tail);</span><br><span class="line">    	<span class="keyword">do</span> &#123;</span><br><span class="line">    		<span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)dc-&gt;dc_data;</span><br><span class="line">    		next_dc = os_mpsc_pop_snapshot_head(dc, tail, do_next);</span><br><span class="line">    		_dispatch_continuation_async(dsn_queue, dc,</span><br><span class="line">    				_dispatch_qos_from_pp(dc-&gt;dc_priority), dc-&gt;dc_flags);</span><br><span class="line">    		_dispatch_release(dsn_queue);</span><br><span class="line">    	&#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    </span><br><span class="line">    	refs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dg_state &amp; DISPATCH_GROUP_HAS_WAITERS) &#123;</span><br><span class="line">    	_dispatch_wake_by_address(&amp;dg-&gt;dg_gen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (refs) _dispatch_release_n(dg, refs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、单例的原理"><a href="#七、单例的原理" class="headerlink" title="七、单例的原理"></a>七、单例的原理</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLOCK_ONCE_UNLOCKED	((uintptr_t)0)</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_once_f(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果你来过一次 -- 下次就不来</span></span><br><span class="line">    <span class="keyword">dispatch_once_gate_t</span> l = (<span class="keyword">dispatch_once_gate_t</span>)val;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !DISPATCH_ONCE_INLINE_FASTPATH || DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> v = os_atomic_load(&amp;l-&gt;dgo_once, acquire);</span><br><span class="line">    <span class="keyword">if</span> (likely(v == DLOCK_ONCE_DONE)) &#123;</span><br><span class="line">    	<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> DISPATCH_ONCE_USE_QUIESCENT_COUNTER</span></span><br><span class="line">    <span class="keyword">if</span> (likely(DISPATCH_ONCE_IS_GEN(v))) &#123;</span><br><span class="line">    	<span class="keyword">return</span> _dispatch_once_mark_done_if_quiesced(l, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (_dispatch_once_gate_tryenter(l)) &#123;</span><br><span class="line">    	<span class="keyword">return</span> _dispatch_once_callout(l, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_once_wait(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span></span><br><span class="line">_dispatch_once_gate_tryenter(<span class="keyword">dispatch_once_gate_t</span> l)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_atomic_cmpxchg(&amp;l-&gt;dgo_once, DLOCK_ONCE_UNLOCKED,</span><br><span class="line">			(<span class="keyword">uintptr_t</span>)_dispatch_lock_value_for_self(), relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>第一次调用时外部传进来的<code>onceToken</code>为空，所以<code>val</code>为<code>NULL</code><ul>
<li><code>_dispatch_once_gate_tryenter(l)</code>判断<code>l-&gt;dgo_once</code>是否标记为<code>DLOCK_ONCE_UNLOCKED</code>（是否存储过）</li>
<li><code>DLOCK_ONCE_UNLOCKED=0</code>，所以if 判断是成立的，就会进行<code>block</code>回调</li>
<li>再通过<code>_dispatch_once_gate_broadcast</code>将<code>l-&gt;dgo_once</code>标记为<code>DLOCK_ONCE_DONE</code></li>
</ul>
</li>
<li>第二次进来就会直接返回，保证代码只执行一次</li>
</ul>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本文主要整理了 <code>GCD</code> 中常见的 <code>API</code> 以及底层的实现原理。</p>
<ul>
<li><code>dispatch_sync</code> 将任务 <code>block</code> 通过 <code>push</code> 到队列中，然后按照 <code>FIFO</code> 去执行。</li>
<li><code>dispatch_async</code> 会把任务包装并保存，之后就会开辟相应线程去执行已保存的任务。</li>
<li><code>semaphore</code> 主要使用 <code>signal</code> 和 <code>wait</code> 这两个接口，底层分别调用了内核提供的方法。在调用 <code>signal</code> 方法后，先将 <code>value</code> 减一，如果大于零立刻返回，否则陷入等待。<code>signal</code> 方法将信号量加一，如果 <code>value</code> 大于零立刻返回，否则说明唤醒了某一个等待线程，此时由系统决定哪个线程的等待方法可以返回。</li>
<li><code>dispatch_group</code> 底层也是维护了一个 <code>value</code> 的值，等待 <code>group</code> 完成实际上就是等待 <code>value</code> 恢复初始值。而 <code>notify</code> 的作用是将所有注册的回调组装成一个链表，在 <code>dispatch_async</code> 完成时判断 <code>value</code> 是不是恢复初始值，如果是则调用 <code>dispatch_async</code> 异步执行所有注册的回调。</li>
<li><code>dispatch_once</code> 通过一个静态变量来标记 <code>block</code> 是否已被执行，同时使用加锁确保只有一个线程能执行，执行完 <code>block</code> 后会唤醒其他所有等待的线程。</li>
</ul>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>我用的<a target="_blank" rel="noopener" href="https://github.com/speam/libdispatch.git">libdispatch源码</a></p>
<p>苹果官网的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099201155079#heading-3">iOS GCD源码浅析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904097871577102#heading-3">iOS底层学习 - 多线程之GCD队列原理篇</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/07/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E4%B9%8C%E5%90%88%E4%B9%8B%E4%BC%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">《乌合之众》读书笔记</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/"><span class="level-item">17-多线程之GCD应用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#如何定位源码"><span class="level-left"><span class="level-item">如何定位源码</span></span></a></li><li><a class="level is-mobile" href="#一、开始研究-GCD"><span class="level-left"><span class="level-item">一、开始研究 GCD</span></span></a></li><li><a class="level is-mobile" href="#二、创建队列在底层是怎样实现的"><span class="level-left"><span class="level-item">二、创建队列在底层是怎样实现的</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-自定义队列的创建"><span class="level-left"><span class="level-item">2.1 自定义队列的创建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-1-dispatch-queue-create"><span class="level-left"><span class="level-item">2.1.1 dispatch_queue_create</span></span></a></li><li><a class="level is-mobile" href="#2-1-2-dispatch-lane-create-with-target"><span class="level-left"><span class="level-item">2.1.2 _dispatch_lane_create_with_target</span></span></a></li><li><a class="level is-mobile" href="#2-1-3-dispatch-queue-attr-to-info"><span class="level-left"><span class="level-item">2.1.3 _dispatch_queue_attr_to_info</span></span></a></li><li><a class="level is-mobile" href="#2-1-4-dispatch-object-alloc"><span class="level-left"><span class="level-item">2.1.4 _dispatch_object_alloc</span></span></a></li><li><a class="level is-mobile" href="#2-1-5-dispatch-queue-init"><span class="level-left"><span class="level-item">2.1.5 _dispatch_queue_init</span></span></a></li><li><a class="level is-mobile" href="#2-1-6-dq-gt-do-targetq-tq"><span class="level-left"><span class="level-item">2.1.6 dq-&gt;do_targetq = tq;</span></span></a></li><li><a class="level is-mobile" href="#2-1-7-dispatch-get-root-queue"><span class="level-left"><span class="level-item">2.1.7 _dispatch_get_root_queue</span></span></a></li><li><a class="level is-mobile" href="#2-1-8-dispatch-root-queues"><span class="level-left"><span class="level-item">2.1.8 _dispatch_root_queues[]</span></span></a></li><li><a class="level is-mobile" href="#2-1-9-验证"><span class="level-left"><span class="level-item">2.1.9 验证</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-2-根队列数组的初始化"><span class="level-left"><span class="level-item">2.2 根队列数组的初始化</span></span></a></li><li><a class="level is-mobile" href="#2-3-一张图总结自定义队列的创建过程"><span class="level-left"><span class="level-item">2.3 一张图总结自定义队列的创建过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、同步执行-dispatch-sync"><span class="level-left"><span class="level-item">三、同步执行 dispatch_sync</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-死锁的产生"><span class="level-left"><span class="level-item">3.1 死锁的产生</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-dispatch-sync"><span class="level-left"><span class="level-item">3.1.1 dispatch_sync</span></span></a></li><li><a class="level is-mobile" href="#3-1-2-dispatch-sync-f"><span class="level-left"><span class="level-item">3.1.2  _dispatch_sync_f</span></span></a></li><li><a class="level is-mobile" href="#3-1-3-dispatch-sync-f-inline"><span class="level-left"><span class="level-item">3.1.3 _dispatch_sync_f_inline</span></span></a></li><li><a class="level is-mobile" href="#3-1-4-dispatch-barrier-sync-f"><span class="level-left"><span class="level-item">3.1.4 _dispatch_barrier_sync_f</span></span></a></li><li><a class="level is-mobile" href="#3-1-5-dispatch-barrier-sync-f-inline"><span class="level-left"><span class="level-item">3.1.5 _dispatch_barrier_sync_f_inline</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-5-1-dispatch-tid-self"><span class="level-left"><span class="level-item">3.1.5.1 _dispatch_tid_self</span></span></a></li><li><a class="level is-mobile" href="#3-1-5-2-dispatch-queue-try-acquire-barrier-sync"><span class="level-left"><span class="level-item">3.1.5.2 _dispatch_queue_try_acquire_barrier_sync</span></span></a></li><li><a class="level is-mobile" href="#3-1-5-3-dispatch-sync-f-slow"><span class="level-left"><span class="level-item">3.1.5.3  _dispatch_sync_f_slow</span></span></a></li><li><a class="level is-mobile" href="#3-1-5-4-dq-state-drain-locked-by"><span class="level-left"><span class="level-item">3.1.5.4 _dq_state_drain_locked_by</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-1-6-一图总结死锁过程"><span class="level-left"><span class="level-item">3.1.6 一图总结死锁过程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-block-任务的执行"><span class="level-left"><span class="level-item">3.2 block 任务的执行</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-dispatch-sync"><span class="level-left"><span class="level-item">3.2.1 dispatch_sync</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-dispatch-sync-f"><span class="level-left"><span class="level-item">3.2.2 _dispatch_sync_f</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-dispatch-sync-f-inline"><span class="level-left"><span class="level-item">3.2.3 _dispatch_sync_f_inline</span></span></a></li><li><a class="level is-mobile" href="#3-2-4-dispatch-barrier-sync-f"><span class="level-left"><span class="level-item">3.2.4 _dispatch_barrier_sync_f</span></span></a></li><li><a class="level is-mobile" href="#3-2-5-dispatch-barrier-sync-f-inline"><span class="level-left"><span class="level-item">3.2.5 _dispatch_barrier_sync_f_inline</span></span></a></li><li><a class="level is-mobile" href="#3-2-6-dispatch-lane-barrier-sync-invoke-and-complete"><span class="level-left"><span class="level-item">3.2.6 _dispatch_lane_barrier_sync_invoke_and_complete</span></span></a></li><li><a class="level is-mobile" href="#3-2-7-dispatch-sync-function-invoke-inline"><span class="level-left"><span class="level-item">3.2.7 _dispatch_sync_function_invoke_inline</span></span></a></li><li><a class="level is-mobile" href="#3-2-8-dispatch-client-callout"><span class="level-left"><span class="level-item">3.2.8 _dispatch_client_callout</span></span></a></li><li><a class="level is-mobile" href="#3-2-9-总结同步函数block任务的执行"><span class="level-left"><span class="level-item">3.2.9 总结同步函数block任务的执行</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、异步执行-dispatch-async"><span class="level-left"><span class="level-item">四、异步执行 dispatch_async</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-任务的保存"><span class="level-left"><span class="level-item">4.1 任务的保存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-1-dispatch-async"><span class="level-left"><span class="level-item">4.1.1 dispatch_async</span></span></a></li><li><a class="level is-mobile" href="#4-1-2-dispatch-continuation-init"><span class="level-left"><span class="level-item">4.1.2 _dispatch_continuation_init</span></span></a></li><li><a class="level is-mobile" href="#4-1-3-dispatch-continuation-init-f"><span class="level-left"><span class="level-item">4.1.3  _dispatch_continuation_init_f</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-2-线程的创建"><span class="level-left"><span class="level-item">4.2 线程的创建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-2-1-dispatch-async"><span class="level-left"><span class="level-item">4.2.1 dispatch_async</span></span></a></li><li><a class="level is-mobile" href="#4-2-2-dispatch-continuation-async"><span class="level-left"><span class="level-item">4.2.2 _dispatch_continuation_async</span></span></a></li><li><a class="level is-mobile" href="#4-2-3-dx-push"><span class="level-left"><span class="level-item">4.2.3 dx_push</span></span></a></li><li><a class="level is-mobile" href="#4-2-4-dispatch-root-queue-push"><span class="level-left"><span class="level-item">4.2.4 _dispatch_root_queue_push</span></span></a></li><li><a class="level is-mobile" href="#4-2-5-dispatch-root-queue-push-inline"><span class="level-left"><span class="level-item">4.2.5 _dispatch_root_queue_push_inline</span></span></a></li><li><a class="level is-mobile" href="#4-2-6-dispatch-root-queue-poke"><span class="level-left"><span class="level-item">4.2.6 _dispatch_root_queue_poke</span></span></a></li><li><a class="level is-mobile" href="#4-2-7-dispatch-root-queue-poke-slow"><span class="level-left"><span class="level-item">4.2.7 _dispatch_root_queue_poke_slow</span></span></a></li></ul></li><li><a class="level is-mobile" href="#4-3-任务的执行"><span class="level-left"><span class="level-item">4.3 任务的执行</span></span></a></li><li><a class="level is-mobile" href="#4-4-一图总结异步函数执行流程"><span class="level-left"><span class="level-item">4.4 一图总结异步函数执行流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、信号量的原理"><span class="level-left"><span class="level-item">五、信号量的原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-dispatch-semaphore-create"><span class="level-left"><span class="level-item">5.1 dispatch_semaphore_create</span></span></a></li><li><a class="level is-mobile" href="#5-2-dispatch-semaphore-signal"><span class="level-left"><span class="level-item">5.2 dispatch_semaphore_signal</span></span></a></li><li><a class="level is-mobile" href="#5-3-dispatch-semaphore-wait"><span class="level-left"><span class="level-item">5.3 dispatch_semaphore_wait</span></span></a></li></ul></li><li><a class="level is-mobile" href="#六、调度组的原理"><span class="level-left"><span class="level-item">六、调度组的原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#6-1-dispatch-group-create"><span class="level-left"><span class="level-item">6.1 dispatch_group_create</span></span></a></li><li><a class="level is-mobile" href="#6-2-dispatch-group-enter-amp-dispatch-group-leave"><span class="level-left"><span class="level-item">6.2 dispatch_group_enter &amp; dispatch_group_leave</span></span></a></li><li><a class="level is-mobile" href="#6-3-dispatch-group-async"><span class="level-left"><span class="level-item">6.3 dispatch_group_async</span></span></a></li><li><a class="level is-mobile" href="#6-4-dispatch-group-wait"><span class="level-left"><span class="level-item">6.4 dispatch_group_wait</span></span></a></li><li><a class="level is-mobile" href="#6-5-dispatch-group-notify"><span class="level-left"><span class="level-item">6.5 dispatch_group_notify</span></span></a></li><li><a class="level is-mobile" href="#6-6-dispatch-group-wake"><span class="level-left"><span class="level-item">6.6 dispatch_group_wake</span></span></a></li></ul></li><li><a class="level is-mobile" href="#七、单例的原理"><span class="level-left"><span class="level-item">七、单例的原理</span></span></a></li><li><a class="level is-mobile" href="#八、总结"><span class="level-left"><span class="level-item">八、总结</span></span></a></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>