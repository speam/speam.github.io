<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>17-多线程之GCD应用 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="17-多线程之GCD应用"><meta property="og:url" content="http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210512160426466.png"><meta property="article:published_time" content="2021-05-18T00:46:16.810Z"><meta property="article:modified_time" content="2021-05-24T06:05:44.734Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210512160426466.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/"},"headline":"IMO's Blog","image":["https://raw.githubusercontent.com/speam/blogImgs/main/1-20210512160426466.png"],"datePublished":"2021-05-18T00:46:16.810Z","dateModified":"2021-05-24T06:05:44.734Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T00:46:16.810Z" title="2021-05-18T00:46:16.810Z">2021-05-18</time>发表</span><span class="level-item"><time dateTime="2021-05-24T06:05:44.734Z" title="2021-05-24T06:05:44.734Z">2021-05-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">17-多线程之GCD应用</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><code>GCD</code>除了基本的<code>dispatch_sync</code>和<code>dispatch_async</code>用法外，还有信号量，调度组，延时执行等等。</p>
<h2 id="二、信号量-dispatch-semaphore"><a href="#二、信号量-dispatch-semaphore" class="headerlink" title="二、信号量 dispatch_semaphore"></a>二、信号量 dispatch_semaphore</h2><h3 id="2-1-引言"><a href="#2-1-引言" class="headerlink" title="2.1 引言"></a>2.1 引言</h3><p>看下题，问：外面 a 的值为多少？里面 a 的值又为多少？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;里面a的值：%d -- %@&quot;</span>, a, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            a++;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;外面a的值：%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>分析：</strong></p>
<p>主队列中有<code>while</code>任务和<code>NSLog</code>任务，串型执行，所以一定是执行完<code>while</code>之后再执行<code>NSLog</code>，所以外面打印的 a 的值一定是5。</p>
<p>但是我们知道<code>dispatch_async</code>是异步执行的并发队列，所以会开辟子线程进行<code>a++</code>操作，且这些线程操作的都是 a 的同一片内存空间，也就表示当一个线程执行完毕后，此时只在执行的线程上的 a 值都会变化，所以里面的 a 一定是大于5的。</p>
<p><strong>打印验证：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.253962</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187541</span>] 里面a的值：<span class="number">0</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f80</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.253989</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187540</span>] 里面a的值：<span class="number">0</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023be2c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.253996</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187516</span>] 里面a的值：<span class="number">0</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f40</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254001</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187541</span>] 里面a的值：<span class="number">1</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f80</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254020</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187540</span>] 里面a的值：<span class="number">2</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023be2c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254049</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187541</span>] 里面a的值：<span class="number">5</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f80</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254050</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187084</span>] 外面a的值：<span class="number">5</span></span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254055</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187560</span>] 里面a的值：<span class="number">5</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002381600</span>&gt;&#123;number = <span class="number">6</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254074</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187541</span>] 里面a的值：<span class="number">6</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f80</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254073</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187561</span>] 里面a的值：<span class="number">5</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023a19c0</span>&gt;&#123;number = <span class="number">7</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254080</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187516</span>] 里面a的值：<span class="number">6</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x600002380f40</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254095</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187517</span>] 里面a的值：<span class="number">6</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023dc000</span>&gt;&#123;number = <span class="number">8</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254110</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187540</span>] 里面a的值：<span class="number">6</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023be2c0</span>&gt;&#123;number = <span class="number">4</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254166</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187563</span>] 里\<span class="number">3512021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.254258</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187567</span>] 里面a的值：<span class="number">8</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023a2280</span>&gt;&#123;number = <span class="number">14</span>, name = (null)&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.260581</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187578</span>] 里面a的值：<span class="number">55</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x6000023a3240</span>&gt;&#123;number = <span class="number">25</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">14</span>:<span class="number">58</span>:<span class="number">14.391239</span>+<span class="number">0800</span> Test03[<span class="number">10963</span>:<span class="number">187084</span>] [Lifecycle] Scene state change error: the scene is no longer connected. (<span class="built_in">NSMenuBarScene_0BD7D9C8</span>-B162<span class="number">-41</span>DB-AB90-B4B866250478)</span><br></pre></td></tr></table></figure>



<p>这样的写法必然是浪费线程资源的，非常不合理，通常我们进行<code>I/O</code>操作时，都是需要加锁来保证线程安全的，这样数据才不会出错。</p>
<p>这里可以采用信号量进行处理。</p>
<h3 id="2-2-用途"><a href="#2-2-用途" class="headerlink" title="2.2 用途"></a>2.2 用途</h3><p>信号量是用于多线程同步的，跟一般的锁不一样的是，信号量不是锁定某一个资源，而是锁定流程。比如：有 A，B 两个线程，B 线程要等 A 线程完成某一任务以后再进行自己下面的步骤，这就是锁定流程。</p>
<p>锁定资源指的是被锁住的资源无法被其余的线程访问，从而阻塞线程而实现线程同步。</p>
<h3 id="2-3-相关API"><a href="#2-3-相关API" class="headerlink" title="2.3 相关API"></a>2.3 相关API</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_create(M)</span><br></pre></td></tr></table></figure>

<p>创建一个值为 M 的信号量，如果用于加锁，此时 M= 0。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_wait(信号量，等待时间)</span><br></pre></td></tr></table></figure>

<p>如果该信号量的值大于0，则使其信号量的值-1，然后继续执行后面的代码。</p>
<p>如果小于等于0，则阻塞线程直到该信号量的值大于0或者达到等待时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_signal(信号量)</span><br></pre></td></tr></table></figure>

<p>释放信号量，使得该信号量的值加1。</p>
<h3 id="2-4-使用场景"><a href="#2-4-使用场景" class="headerlink" title="2.4 使用场景"></a>2.4 使用场景</h3><h4 id="2-4-1-限制线程的最大并发数"><a href="#2-4-1-限制线程的最大并发数" class="headerlink" title="2.4.1 限制线程的最大并发数"></a>2.4.1 限制线程的最大并发数</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t sema = dispatch_semaphore_create(M);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>;i&lt;N;i++） &#123;</span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER); </span><br><span class="line">        <span class="comment">// 耗时操作</span></span><br><span class="line">        dispatch_semaphore_signal(sema);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如上述代码可知，总共异步执行N个任务，但是由于我们设置了值为 M 的信号量，每一次执行任务的时候都会导致信号量的减1，而在任务结束后使信号量加1，当信号量减到0的时候，说明正在执行的任务有 M 个，这个时候其它任务就会阻塞，直到有任务被完成时，这些任务才会执行。</p>
<h4 id="2-4-2-阻塞发请求的线程"><a href="#2-4-2-阻塞发请求的线程" class="headerlink" title="2.4.2 阻塞发请求的线程"></a>2.4.2 阻塞发请求的线程</h4><p>有些时候，我们需要==阻塞==发送请求的线程，比如在多个请求回调后统一操作的需求，而这些请求之间并没有顺序关系，且这些接口都会另开线程进行网络请求的。一般地，这种多线程完成后进行统一操作的需求都会使用队列组(dispatch_group_t)来完成，但是由于是异步请求，没等其异步回调之后，请求的线程就结束了，为此，就需要使用信号量来阻塞住发请求的线程。实现代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(<span class="built_in">queue</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> sema = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    [网络请求:^&#123;</span><br><span class="line">        <span class="comment">//请求回调</span></span><br><span class="line">        dispatch_semaphore_signal(sema);  </span><br><span class="line">    &#125;];</span><br><span class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样，请求的线程就可以等到回调结束后再结束了，再配合队列组就能完成上述的需求。这种技巧可用于以下场景：</p>
<ul>
<li>多个请求结束后统一操作</li>
<li>多个请求顺序执行</li>
</ul>
<h3 id="2-5-对于引言中例子的处理"><a href="#2-5-对于引言中例子的处理" class="headerlink" title="2.5 对于引言中例子的处理"></a>2.5 对于引言中例子的处理</h3><p>了解了信号量如何使用后，我们就可以对引言中的例子进行下面的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    dispatch_semaphore_t sem = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;里面a的值：%d -- %@&quot;</span>, a, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">            a++;</span><br><span class="line">            <span class="comment">// 任务执行完了才+1</span></span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 锁住</span></span><br><span class="line">        dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;外面a的值：%d&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用的是阻塞当前线程的方式，如果任务不执行完，就不会执行下次的循环，从而达到了<code>a++</code>跟随<code>while</code>循环执行5次的效果。</p>
<p>打印验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677802</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">214126</span>] 里面a的值：<span class="number">0</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000368a780</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677857</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">214126</span>] 里面a的值：<span class="number">1</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000368a780</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677898</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">214126</span>] 里面a的值：<span class="number">2</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000368a780</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677938</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">214126</span>] 里面a的值：<span class="number">3</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000368a780</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677970</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">214126</span>] 里面a的值：<span class="number">4</span> -- &lt;<span class="built_in">NSThread</span>: <span class="number">0x60000368a780</span>&gt;&#123;number = <span class="number">5</span>, name = (null)&#125;</span><br><span class="line"><span class="number">2021</span><span class="number">-05</span><span class="number">-12</span> <span class="number">15</span>:<span class="number">40</span>:<span class="number">26.677994</span>+<span class="number">0800</span> Test03[<span class="number">11206</span>:<span class="number">213710</span>] 外面a的值：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="三、栅栏函数dispatch-barrier"><a href="#三、栅栏函数dispatch-barrier" class="headerlink" title="三、栅栏函数dispatch_barrier"></a>三、栅栏函数dispatch_barrier</h2><h3 id="3-1-用途"><a href="#3-1-用途" class="headerlink" title="3.1 用途"></a>3.1 用途</h3><p>使用栅栏函数可以让<code>两组异步任务</code>有先后顺序的执行。</p>
<h3 id="3-2-相关API"><a href="#3-2-相关API" class="headerlink" title="3.2 相关API"></a>3.2 相关API</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_async</span><br></pre></td></tr></table></figure>

<p>不会阻塞当前线程</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_barrier_sync</span><br></pre></td></tr></table></figure>

<p>会阻塞当前线程</p>
<p>简单来说<code>dispatch_barrier_async</code>或<code>dispatch_barrier_sync</code>将异步任务分成了两组，执行完第一组后，再执行自己，然后执行队列中剩余的任务。</p>
<p>示意图：</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210512160426466.png"></p>
<h3 id="3-3-使用场景"><a href="#3-3-使用场景" class="headerlink" title="3.3 使用场景"></a>3.3 使用场景</h3><p>通过例子来看一下栅栏函数的使用。通过打印结果过我们可以看到，栅栏函数并没有阻塞主线程的调用，但是异步任务2的执行完毕是在异步任务1后面的。说明栅栏并没有阻塞线程，而只是阻塞了队列的执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">&quot;com.imo.barrier1&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务1-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栅栏</span></span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;--------------栅栏---------------&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;中止&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务2-%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;结束&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">中止</span><br><span class="line">结束</span><br><span class="line">任务1-&lt;NSThread: 0x6000022d0a00&gt;&#123;number = 4, name = (null)&#125;</span><br><span class="line">--------------栅栏---------------</span><br><span class="line">任务2-&lt;NSThread: 0x6000022d0a00&gt;&#123;number = 4, name = (null)&#125;</span><br></pre></td></tr></table></figure>



<p>如果将例子中的<code>dispatch_barrier_async</code>换成<code>dispatch_barrier_sync</code>。通过下面的打印结果过可以看出，<code>dispatch_barrier_sync</code>不仅阻塞了线程的执行，也阻塞了队列的执行。整个任务都按照顺序来执行了（阻塞主线程的操作还是要尽量避免）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始</span><br><span class="line">任务1-&lt;NSThread: 0x600001e96d00&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">--------------栅栏---------------</span><br><span class="line">中止</span><br><span class="line">结束</span><br><span class="line">任务2-&lt;NSThread: 0x600001e96d00&gt;&#123;number = 5, name = (null)&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意事项⚠️：</strong></p>
<ol>
<li>栅栏函数最直接的作用: 控制任务执行顺序，同步</li>
<li><code>dispatch_barrier_async</code> 前面的任务执行完毕才会来到这里</li>
<li><code>dispatch_barrier_sync</code> 作用相同，但是这个会堵塞线程，影响后面任务的执行</li>
<li><strong>栅栏函数只能控制同一并发队列</strong></li>
</ol>
<h2 id="四、调度组-队列组dispatch-group"><a href="#四、调度组-队列组dispatch-group" class="headerlink" title="四、调度组/队列组dispatch_group"></a>四、调度组/队列组<code>dispatch_group</code></h2><h3 id="4-1-用途"><a href="#4-1-用途" class="headerlink" title="4.1 用途"></a>4.1 用途</h3><p>也是为了解决多线程中多个异步任务顺序执行的问题。</p>
<h3 id="4-2-相关API"><a href="#4-2-相关API" class="headerlink" title="4.2 相关API"></a>4.2 相关API</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_create</span><br></pre></td></tr></table></figure>

<p>用来创建一个调度组</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_async</span><br></pre></td></tr></table></figure>

<p>先把任务添加到队列中，然后将队列放到调度组中</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_enter</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_leave</span><br></pre></td></tr></table></figure>

<p>进组和出组，必须<strong>成对使用</strong>，和<code>dispatch_group_async</code>作用相同</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait</span><br></pre></td></tr></table></figure>

<p>进组任务执行等待</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_notify</span><br></pre></td></tr></table></figure>

<p>执行调度组结束后接下来的任务</p>
<h3 id="4-3-常见用法"><a href="#4-3-常见用法" class="headerlink" title="4.3 常见用法"></a>4.3 常见用法</h3><h4 id="4-3-1-使用-dispatch-group-async【推荐】"><a href="#4-3-1-使用-dispatch-group-async【推荐】" class="headerlink" title="4.3.1 使用 dispatch_group_async【推荐】"></a>4.3.1 使用 <code>dispatch_group_async</code>【推荐】</h4><p>在所有任务执行完毕之后，调用<code>dispatch_group_notify</code>方法通知到我们。一般在此方法中获取到<code>dispatch_get_main_queue</code>主线程，用来刷新UI等操作。具体使用的代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//创建调度组</span></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line"><span class="comment">// 全局并发队列</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 自己创建的并发队列</span></span><br><span class="line">  <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;com.imo.group&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;任务一&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_async(group, queue1, ^&#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;任务二&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;任务执行完成&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任务一</span><br><span class="line">任务二</span><br><span class="line">任务执行完成</span><br></pre></td></tr></table></figure>

<h4 id="4-3-2-使用进组出组"><a href="#4-3-2-使用进组出组" class="headerlink" title="4.3.2 使用进组出组"></a>4.3.2 使用进组出组</h4><p>使用进出组的方式和<code>dispatch_group_async</code>效果相同，只不过是有了进出组的代码，逻辑更加清晰明了，但是写法较麻烦，推荐使用上一种方式。</p>
<p><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>是<strong>成对使用的，必须先进组再出组，缺一不可</strong>，否则会报错。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 全局并发队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 队列组</span></span><br><span class="line">  dispatch_group_t group = dispatch_group_create();</span><br><span class="line">  </span><br><span class="line">  dispatch_group_enter(group);</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">      sleep(<span class="number">2</span>);</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;任务一&quot;</span>);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_enter(group);</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;任务二&quot;</span>);</span><br><span class="line">      dispatch_group_leave(group);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@&quot;所有任务完成,可以更新UI&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">任务二</span><br><span class="line">任务一</span><br><span class="line">所有任务完成,可以更新UI</span><br></pre></td></tr></table></figure>

<h4 id="4-3-3-使用-dispatch-group-wait"><a href="#4-3-3-使用-dispatch-group-wait" class="headerlink" title="4.3.3 使用 dispatch_group_wait"></a>4.3.3 使用 <code>dispatch_group_wait</code></h4><p>可以理解为一种栅栏。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_wait(调度组, 等待时间)</span><br></pre></td></tr></table></figure>



<p>等待时间：</p>
<ul>
<li><p><code>DISPATCH_TIME_FOREVER</code>：永久等待</p>
</li>
<li><p><code>DISPATCH_TIME_NOW</code>：不等待，立刻判定<code>Dispatch Group</code>的处理是否全部执行结束</p>
</li>
</ul>
<p>函数返回值：</p>
<ul>
<li><p>返回值为<code>0</code>，就意味着<code>Dispatch Group</code>中的操作全部执行完毕</p>
</li>
<li><p>返回值不为<code>0</code>，就意味着虽然经过了指定的时间，但<code>Dispatch Group</code>中的操作并未全部执行完毕</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务一&quot;</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> timeout = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_FOREVER, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;回来了&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;等待中&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dispatch_group_enter(group);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;任务二&quot;</span>);</span><br><span class="line">    dispatch_group_leave(group);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;所有任务完成,可以更新UI&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">任务一</span><br><span class="line">回来了</span><br><span class="line">任务二</span><br><span class="line">所有任务完成,可以更新UI</span><br></pre></td></tr></table></figure>



<p>如果我们把超时时间设置的短一点，比如1秒，<code>long timeout = dispatch_group_wait(group, dispatch_time(DISPATCH_TIME_NOW,1 * NSEC_PER_SEC));</code>可以发现打印结果不同，和没有进行<code>wait</code>时的打印结果是相同的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">等待中</span><br><span class="line">任务二</span><br><span class="line">任务一</span><br><span class="line">所有任务完成,可以更新UI</span><br></pre></td></tr></table></figure>



<p><strong>注意事项⚠️：</strong></p>
<ol>
<li><code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>是<strong>成对使用的，必须先进组再出组，缺一不可</strong></li>
<li><code>dispatch_group_wait</code>可以设置等待时间，用来区分异步任务执行</li>
<li><code>dispatch_group_notify</code>为组任务全部完成后执行的回调，一般在处理主线程逻辑</li>
</ol>
<h2 id="五、延迟函数dispatch-after"><a href="#五、延迟函数dispatch-after" class="headerlink" title="五、延迟函数dispatch_after"></a>五、延迟函数<code>dispatch_after</code></h2><p>需要注意的是：<code>dispatch_after</code>方法并不是在指定时间之后才开始执行处理，而是在<strong>指定时间之后将任务追加到主队列中</strong>。</p>
<p>严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，<code>dispatch_after</code> 方法还是很方便的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)afterTask&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;开始&quot;</span>);</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3.0</span>*<span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;执行---%@&quot;</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、单次函数dispatch-once"><a href="#六、单次函数dispatch-once" class="headerlink" title="六、单次函数dispatch_once"></a>六、单次函数<code>dispatch_once</code></h2><p><code>dispatch_once</code>方法可以保证一段代码在程序运行过程中只被调用一次，而且在多线程环境下可以保证线程安全。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)shareInstance&#123;</span><br><span class="line">    <span class="keyword">static</span> JYManager *instance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [JYManager alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、事件源dispatch-source"><a href="#七、事件源dispatch-source" class="headerlink" title="七、事件源dispatch_source"></a>七、事件源<code>dispatch_source</code></h2><h3 id="7-1-用途"><a href="#7-1-用途" class="headerlink" title="7.1 用途"></a>7.1 用途</h3><p>可以用来监听一些底层的系统事件。在日常的开发中，我们经常使用它来创建一个基于<code>GCD</code>的<code>Timer</code>。但是它还有很多其他的监听类型，通过查看<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/GCDWorkQueues/GCDWorkQueues.html#//apple_ref/doc/uid/TP40008091-CH103-SW1">官方文档</a>我们可得以下监听：</p>
<ul>
<li><code>Timer Dispatch Source</code>：定时调度源。</li>
<li><code>Signal Dispatch Source</code>：监听UNIX信号调度源，比如监听代表挂起指令的SIGSTOP信号。</li>
<li><code>Descriptor Dispatch Source</code>：监听文件相关操作和<code>Socket</code>相关操作的调度源。</li>
<li><code>Process Dispatch Source</code>：监听进程相关状态的调度源。</li>
<li><code>Mach port Dispatch Source</code>：监听Mach相关事件的调度源。</li>
<li><code>Custom Dispatch Source</code>：监听自定义事件的调度源</li>
</ul>
<h3 id="7-2-相关API"><a href="#7-2-相关API" class="headerlink" title="7.2 相关API"></a>7.2 相关API</h3><ul>
<li><code>dispatch_source_create</code>: 创建事件源</li>
<li><code>dispatch_source_set_event_handler</code>: 设置数据源回调</li>
<li><code>dispatch_source_merge_data</code>: 设置事件源数据</li>
<li><code>dispatch_source_get_data</code>：获取事件源数据</li>
<li><code>dispatch_resume</code>: 继续</li>
<li><code>dispatch_suspend</code>: 挂起</li>
<li><code>dispatch_cancle</code>: 取消</li>
</ul>
<h3 id="7-3-使用"><a href="#7-3-使用" class="headerlink" title="7.3 使用"></a>7.3 使用</h3><p><strong>如何使用：</strong></p>
<p>①指定一个希望监听的系统事件类型</p>
<p>②指定一个捕获到事件后进行逻辑处理的回调函数</p>
<p>③再指定一个该回调函数执行的队列即可</p>
<p>然后当监听到事件后就会触发指定队列中的回调。</p>
<p>这里与通常的手动添加任务的模式不同，一旦<code>dispatch_source</code>与队列关联后，只要监听到系统事件，<code>dispatch_source</code>就会自动将任务（回调函数）添加到关联的队列中，直到我们调用函数取消监听。</p>
<p>为了保证监听到事件后回调函数能够都到执行，已关联的队列会被<code>dispatch_source</code>强引用。</p>
<h3 id="7-4-应用—自定义GCDTimer"><a href="#7-4-应用—自定义GCDTimer" class="headerlink" title="7.4 应用—自定义GCDTimer"></a>7.4 应用—自定义GCDTimer</h3><p>在iOS开发中一般使用<code>NSTimer</code>来处理定时逻辑，但<code>NSTimer</code>是依赖<code>Runloop</code>的，而<code>Runloop</code>可以运行在不同的模式下。如果<code>NSTimer</code>添加在一种模式下，当Runloop运行在其他模式下的时候，定时器就挂机了；又如果<code>Runloop</code>在阻塞状态，<code>NSTimer</code>触发时间就会推迟到下一个<code>Runloop</code>周期。因此<code>NSTimer</code>在计时上会有误差，并不是特别精确，而GCD定时器不依赖<code>Runloop</code>，计时精度要高很多</p>
<p>下面我们通过代码，使用<code>dispatch_source</code>来封装一个<code>GCDTimer</code>：</p>
<p>Demo地址：<a target="_blank" rel="noopener" href="https://github.com/speam/GCDTimer.git">Link</a></p>
<p><code>JYTimer.h</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^JYTimerBlock)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JYTimer</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 创建一个基于 GCD 的定时器，默认挂起，需要手动开启</span></span><br><span class="line"><span class="comment">/// @param interval 重复时间间隔</span></span><br><span class="line"><span class="comment">/// @param repeat 是否重复</span></span><br><span class="line"><span class="comment">/// @param completion 事件回调</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)timerWithInterval:(<span class="built_in">NSTimeInterval</span>)interval</span><br><span class="line">                           repeat:(<span class="built_in">BOOL</span>)repeat</span><br><span class="line">                       completion:(JYTimerBlock)completion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 开始和继续定时器</span></span><br><span class="line">- (<span class="keyword">void</span>)resumeTimer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 终止定时器</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidTimer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 暂停定时器</span></span><br><span class="line">- (<span class="keyword">void</span>)pauseTimer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p><code>JYTimer.m</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;JYTimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JYTimer</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GCDTimer 需要强持有，否则出了作用域立即释放，也就没有了事件回调</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) dispatch_source_t timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isRuning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JYTimer</span></span></span><br><span class="line"></span><br><span class="line">+ (JYTimer *)timerWithInterval:(<span class="built_in">NSTimeInterval</span>)interval repeat:(<span class="built_in">BOOL</span>)repeat completion:(JYTimerBlock)completion &#123;</span><br><span class="line">    JYTimer *timer = [[JYTimer alloc] initWithInterval:interval repeat:repeat completion:completion];</span><br><span class="line">    <span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInterval:(<span class="built_in">NSTimeInterval</span>)interval repeat:(<span class="built_in">BOOL</span>)repeat completion:(JYTimerBlock)completion &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.isRuning = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 timer</span></span><br><span class="line">        <span class="keyword">self</span>.timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 timer 的首次执行时间，间隔，精确度</span></span><br><span class="line">        dispatch_source_set_timer(<span class="keyword">self</span>.timer, DISPATCH_TIME_NOW, interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 timer 事件回调</span></span><br><span class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        dispatch_source_set_event_handler(<span class="keyword">self</span>.timer, ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                completion();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!repeat) &#123;</span><br><span class="line">                dispatch_source_cancel(weakSelf.timer);</span><br><span class="line">                weakSelf.isRuning = <span class="literal">NO</span>;</span><br><span class="line">                weakSelf.timer = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)resumeTimer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer &amp;&amp; !<span class="keyword">self</span>.isRuning) &#123;</span><br><span class="line">        dispatch_resume(<span class="keyword">self</span>.timer);</span><br><span class="line">        <span class="keyword">self</span>.isRuning = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalidTimer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer) &#123;</span><br><span class="line">        dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br><span class="line">        <span class="keyword">self</span>.isRuning = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">self</span>.timer = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pauseTimer &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.timer &amp;&amp; <span class="keyword">self</span>.isRuning) &#123;</span><br><span class="line">        dispatch_suspend(<span class="keyword">self</span>.timer);</span><br><span class="line">        <span class="keyword">self</span>.isRuning = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>测试代码：</p>
<p><code>ViewController.m</code></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;ViewController.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;JYTimer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) JYTimer *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    JYTimer *timer = [JYTimer timerWithInterval:<span class="number">1.0</span> repeat:<span class="literal">YES</span> completion:^&#123;</span><br><span class="line">        a++;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;%d&quot;</span>, a);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.timer = timer;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> setupUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setupUI &#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> new];</span><br><span class="line">    [btn setTitle:<span class="string">@&quot;开始&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">90</span>, <span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">    btn.backgroundColor = [<span class="built_in">UIColor</span> systemBlueColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(start:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIButton</span> *btn1 = [<span class="built_in">UIButton</span> new];</span><br><span class="line">    [btn1 setTitle:<span class="string">@&quot;终止&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    btn1.frame = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">190</span>, <span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">    btn1.backgroundColor = [<span class="built_in">UIColor</span> systemBlueColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn1];</span><br><span class="line">    [btn1 addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(invalid:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIButton</span> *btn2 = [<span class="built_in">UIButton</span> new];</span><br><span class="line">    [btn2 setTitle:<span class="string">@&quot;暂停&quot;</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    btn2.frame = <span class="built_in">CGRectMake</span>(<span class="number">10</span>, <span class="number">290</span>, <span class="number">100</span>, <span class="number">80</span>);</span><br><span class="line">    btn2.backgroundColor = [<span class="built_in">UIColor</span> systemBlueColor];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn2];</span><br><span class="line">    [btn2 addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pause:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Event</span></span><br><span class="line">- (<span class="keyword">void</span>)start:(<span class="built_in">UIButton</span> *)btn &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer resumeTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)invalid:(<span class="built_in">UIButton</span> *)btn &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer invalidTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pause:(<span class="built_in">UIButton</span> *)btn &#123;</span><br><span class="line">    [<span class="keyword">self</span>.timer pauseTimer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>使用<code>dispatch_source</code>自定义定时器注意点：</p>
<ul>
<li><code>GCDTimer</code>需要<code>强持有</code>，否则出了作用域立即释放，也就没有了事件回调</li>
<li><code>GCDTimer</code>默认是挂起状态，需要手动激活</li>
<li><code>GCDTimer</code>没有<code>repeat</code>，需要封装来增加标志位控制</li>
<li><code>GCDTimer</code>如果存在循环引用，使用<code>weak+strong</code>或者提前调用<code>dispatch_source_cancel</code>取消timer</li>
<li><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡</li>
<li><code>source</code>在<code>挂起状态</code>下，如果直接设置<code>source = nil</code>或者重新创建<code>source</code>都会造成crash。正确的方式是在<code>激活状态</code>下调用<code>dispatch_source_cancel(source)</code>释放当前的<code>source</code></li>
</ul>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p><a target="_blank" rel="noopener" href="https://github.com/speam/GCDTimer.git">我封装的GCDTimer</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2f0225b67f6c">IOS GCD中的信号量</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904122068500487#heading-28">iOS探索 多线程之GCD应用</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">18-多线程之GCD底层原理</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%88%9D%E6%8E%A2/"><span class="level-item">16-多线程之GCD初探</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、前言"><span class="level-left"><span class="level-item">一、前言</span></span></a></li><li><a class="level is-mobile" href="#二、信号量-dispatch-semaphore"><span class="level-left"><span class="level-item">二、信号量 dispatch_semaphore</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-引言"><span class="level-left"><span class="level-item">2.1 引言</span></span></a></li><li><a class="level is-mobile" href="#2-2-用途"><span class="level-left"><span class="level-item">2.2 用途</span></span></a></li><li><a class="level is-mobile" href="#2-3-相关API"><span class="level-left"><span class="level-item">2.3 相关API</span></span></a></li><li><a class="level is-mobile" href="#2-4-使用场景"><span class="level-left"><span class="level-item">2.4 使用场景</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-4-1-限制线程的最大并发数"><span class="level-left"><span class="level-item">2.4.1 限制线程的最大并发数</span></span></a></li><li><a class="level is-mobile" href="#2-4-2-阻塞发请求的线程"><span class="level-left"><span class="level-item">2.4.2 阻塞发请求的线程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-5-对于引言中例子的处理"><span class="level-left"><span class="level-item">2.5 对于引言中例子的处理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、栅栏函数dispatch-barrier"><span class="level-left"><span class="level-item">三、栅栏函数dispatch_barrier</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-用途"><span class="level-left"><span class="level-item">3.1 用途</span></span></a></li><li><a class="level is-mobile" href="#3-2-相关API"><span class="level-left"><span class="level-item">3.2 相关API</span></span></a></li><li><a class="level is-mobile" href="#3-3-使用场景"><span class="level-left"><span class="level-item">3.3 使用场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、调度组-队列组dispatch-group"><span class="level-left"><span class="level-item">四、调度组/队列组dispatch_group</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-用途"><span class="level-left"><span class="level-item">4.1 用途</span></span></a></li><li><a class="level is-mobile" href="#4-2-相关API"><span class="level-left"><span class="level-item">4.2 相关API</span></span></a></li><li><a class="level is-mobile" href="#4-3-常见用法"><span class="level-left"><span class="level-item">4.3 常见用法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-3-1-使用-dispatch-group-async【推荐】"><span class="level-left"><span class="level-item">4.3.1 使用 dispatch_group_async【推荐】</span></span></a></li><li><a class="level is-mobile" href="#4-3-2-使用进组出组"><span class="level-left"><span class="level-item">4.3.2 使用进组出组</span></span></a></li><li><a class="level is-mobile" href="#4-3-3-使用-dispatch-group-wait"><span class="level-left"><span class="level-item">4.3.3 使用 dispatch_group_wait</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#五、延迟函数dispatch-after"><span class="level-left"><span class="level-item">五、延迟函数dispatch_after</span></span></a></li><li><a class="level is-mobile" href="#六、单次函数dispatch-once"><span class="level-left"><span class="level-item">六、单次函数dispatch_once</span></span></a></li><li><a class="level is-mobile" href="#七、事件源dispatch-source"><span class="level-left"><span class="level-item">七、事件源dispatch_source</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-用途"><span class="level-left"><span class="level-item">7.1 用途</span></span></a></li><li><a class="level is-mobile" href="#7-2-相关API"><span class="level-left"><span class="level-item">7.2 相关API</span></span></a></li><li><a class="level is-mobile" href="#7-3-使用"><span class="level-left"><span class="level-item">7.3 使用</span></span></a></li><li><a class="level is-mobile" href="#7-4-应用—自定义GCDTimer"><span class="level-left"><span class="level-item">7.4 应用—自定义GCDTimer</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>