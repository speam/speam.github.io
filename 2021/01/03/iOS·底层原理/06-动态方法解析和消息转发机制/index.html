<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>06-动态方法解析和消息转发机制 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="06-动态方法解析和消息转发机制"><meta property="og:url" content="http://evilimo.com/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103121818905.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103134024269.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103141027089.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103180554720.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103163647082.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103164253950.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103165252524.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103165657854.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103170902583.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103171442810.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103172353701.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210105094058668.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17178c89c46895dc.png"><meta property="article:published_time" content="2021-01-03T04:02:52.736Z"><meta property="article:modified_time" content="2021-01-07T10:20:00.313Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103121818905.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103121818905.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103134024269.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103141027089.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103180554720.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103163647082.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103164253950.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103165252524.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103165657854.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103170902583.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103171442810.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103172353701.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210105094058668.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17178c89c46895dc.png"],"datePublished":"2021-01-03T04:02:52.736Z","dateModified":"2021-01-07T10:20:00.313Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-03T04:02:52.736Z" title="2021-01-03T04:02:52.736Z">2021-01-03</time>发表</span><span class="level-item"><time dateTime="2021-01-07T10:20:00.313Z" title="2021-01-07T10:20:00.313Z">2021-01-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">06-动态方法解析和消息转发机制</h1><div class="content"><hr>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>OC</code>中方法的调用是通过<code>objc_msgSend</code>（或<code>objc_msgSendSuper</code>，或<code>objc_msgSend_stret</code>，或<code>objc_msgSendSuper_stret</code>）函数，向调用者发送名为<code>SEL</code>的消息，找到具体的函数地址<code>IMP</code>，进而执行该函数。</p>
<p>找<code>IMP</code>时先<strong>快速查找</strong>，然后<strong>慢速查找</strong>。如果<strong>慢速查找</strong>后找不到<code>IMP</code>，会进行方法的解析，这相当于提供一次容错处理；方法解析之后，如果依然找不到<code>IMP</code>，还有最后一次机会，那就是消息的转发。</p>
<blockquote>
<p>我用的源码是 <a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2">objc4-756.2</a></p>
</blockquote>
<h1 id="一、消息查找流程"><a href="#一、消息查找流程" class="headerlink" title="一、消息查找流程"></a>一、消息查找流程</h1><p><code>消息查找流程</code>部分不再展开详述，消息慢速查找主要经过以下流程：</p>
<ul>
<li>先查找本类缓存，再找本类方法列表</li>
<li>遍历父类：查找父类缓存，再找父类方法列表</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103121818905.png"></p>
<p>遍历父类无果后就来到动态方法解析。</p>
<h1 id="二、动态方法解析"><a href="#二、动态方法解析" class="headerlink" title="二、动态方法解析"></a>二、动态方法解析</h1><p>动态方法解析，即<code>method resolver</code>（又名消息的解析，也叫方法决议），方法查找失败之后就会进行，源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在【类...根类】的【缓存+方法列表】中都没找到IMP，进行方法解析</span></span><br><span class="line"><span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">    runtimeLock.unlock();</span><br><span class="line">    resolveMethod(cls, sel, inst);</span><br><span class="line">    runtimeLock.lock();</span><br><span class="line">    <span class="comment">// Don&#x27;t cache the result; we don&#x27;t hold the lock so it may have </span></span><br><span class="line">    <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">    triedResolver = YES;</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它主要是调用了<code>resolveMethod</code>函数。<code>resolveMethod</code>函数处理完毕之后，还要重新执行一次<code>retry</code>（再走一遍方法的查找流程）。其中，<code>triedResolver</code>这个变量使得消息的解析只进行一次。</p>
<h2 id="2-1-resolveMethod-入口"><a href="#2-1-resolveMethod-入口" class="headerlink" title="2.1 resolveMethod 入口"></a>2.1 resolveMethod 入口</h2><p>源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前是否是元类</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// 类，尝试找实例方法</span></span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是元类，先找类方法</span></span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个分支：</p>
<ul>
<li><code>非元类</code>的话说明是类，调用实例方法，走<code>_class_resolveInstanceMethod</code></li>
</ul>
<ul>
<li>cls是<code>元类</code>的话说明调用类方法，走<code>_class_resolveClassMethod</code></li>
</ul>
<h2 id="2-2-实例方法解析"><a href="#2-2-实例方法解析" class="headerlink" title="2.2 实例方法解析"></a>2.2 实例方法解析</h2><p><code>resolveInstanceMethod</code>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveInstanceMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去 cls 找是否实现了 resolveInstanceMethod 方法</span></span><br><span class="line">    <span class="comment">// 如果没有实现，则直接返回，就不会给 cls 发送 resolveInstanceMethod 消息，就不会报找不到 resolveInstanceMethod</span></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="comment">// NSObject中默认有实现，所以一般不会走这里。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本类实现了类方法 resolveInstanceMethod</span></span><br><span class="line">    <span class="comment">// 当对象找不到需要调用的方法时，系统就会主动响应 resolveInstanceMethod 方法，可以在 resolveInstanceMethod 进行自定义处理</span></span><br><span class="line">    <span class="comment">// 向本类发送SEL_resolveInstanceMethod消息，即调用这个方法</span></span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveInstanceMethod adds to self a.k.a. cls</span></span><br><span class="line">    <span class="comment">// 再次去查找方法，找到就缓存并且返回，找不到就直接返回</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些报错信息代码</span></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>流程分析：</p>
<p>①调用<code>lookUpImpOrNil</code>方法检查cls中是否有<code>SEL_resolveInstanceMethod(resolveInstanceMethod)</code>方法。<code>NSObject</code>类中有实现这个类方法，所以一般会接着往下走。</p>
<p><code>lookUpImpOrNil</code>函数源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrNil</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><code>NSObject</code>类中实现了<code>resolveInstanceMethod</code>方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体搜索 NSObject.mm</span></span><br><span class="line">+ (BOOL)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>②向本类发送<code>SEL_resolveInstanceMethod</code>消息，即调用这个方法。<code>resolveInstanceMethod</code> 是系统给我们的一次机会，让我们可以针对没有实现的 <code>sel</code> 进行自定义操作。</p>
<p>③<code>lookUpImpOrNil</code>再次查找当前实例方法<code>IMP</code>，找到就缓存并返回，找不到就直接返回。</p>
<blockquote>
<p> 假如你在<code>+(BOOL)resolveInstanceMethod:(SEL)sel</code>中添加了<code>sel</code>的函数地址<code>IMP</code>，此时再次去查找这个<code>IMP</code>就能找到。</p>
</blockquote>
<blockquote>
<p>注意到两次调用<code>lookUpImpOrNil</code>中，<code>resolver</code>都是<code>NO</code>，因此在其调用<code>lookUpImpOrForward</code>时不会触发 <strong>动态方法解析</strong>，仅仅是从“类、父类、…、根类”的缓存中和方法列表中找<code>IMP</code>。</p>
</blockquote>
<p>④结束<code>动态方法解析</code>，回到<code>lookUpImpOrForward</code>方法将<code>triedResolver</code>置YES并<code>goto retry</code>重新查找缓存和方法列表</p>
<p><strong>实例方法解析流程图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103134024269.png"></p>
<h2 id="2-3-类方法解析"><a href="#2-3-类方法解析" class="headerlink" title="2.3 类方法解析"></a>2.3 类方法解析</h2><p><code>resolveClassMethod</code> 和 <code>resolveInstanceMethod</code> 逻辑差不多，只不过类方法是去元类里处理，源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的cls是元类，因为类方法存储在元类</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveClassMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    assert(cls-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, </span><br><span class="line">                         NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Resolver not implemented.</span></span><br><span class="line">        <span class="comment">// 如果你没有实现类方法 +(BOOL)resolveClassMethod:(SEL)sel，</span></span><br><span class="line">        <span class="comment">// NSObject中也有实现，所以一般不会走这里</span></span><br><span class="line">        <span class="comment">// 注意这里的第一个参数是cls，是元类</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class nonmeta;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">        <span class="comment">// 获取 元类的对象，即类。</span></span><br><span class="line">        nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst);</span><br><span class="line">        <span class="comment">// +initialize path should have realized nonmeta already</span></span><br><span class="line">        <span class="keyword">if</span> (!nonmeta-&gt;isRealized()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;nonmeta class %s (%p) unexpectedly not realized&quot;</span>,</span><br><span class="line">                        nonmeta-&gt;nameForLogging(), nonmeta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend;</span><br><span class="line">    <span class="comment">// 调用类方法： +(BOOL)resolveClassMethod:(SEL)sel</span></span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(nonmeta, SEL_resolveClassMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache the result (good or bad) so the resolver doesn&#x27;t fire next time.</span></span><br><span class="line">    <span class="comment">// +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls</span></span><br><span class="line">    <span class="comment">// 再找一次imp</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一些打印</span></span><br><span class="line">    <span class="keyword">if</span> (resolved  &amp;&amp;  PrintResolving) &#123;</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: method %c[%s %s] &quot;</span></span><br><span class="line">                         <span class="string">&quot;dynamically resolved to %p&quot;</span>, </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), imp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Method resolver didn&#x27;t add anything?</span></span><br><span class="line">            _objc_inform(<span class="string">&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot;</span></span><br><span class="line">                         <span class="string">&quot;, but no new implementation of %c[%s %s] was found&quot;</span>,</span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel), </span><br><span class="line">                         cls-&gt;isMetaClass() ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), sel_getName(sel));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>流程如下：</p>
<p>①<code>lookUpImpOrNil</code>查找<code>SEL_resolveClassMethod(resolveClassMethod)</code>是否实现</p>
<p>②调用类方法： <code>+(BOOL)resolveClassMethod:(SEL)sel</code></p>
<p>③<code>lookUpImpOrNil</code>再次查找当前实例方法imp，找到就填充缓存并返回，找不到就直接返回</p>
<p>④结束<code>resolveClassMethod</code>，返回到<code>resolveMethod</code>方法。此时<code>lookUpImpOrNil</code>再次查找<code>sel</code>的<code>imp</code>，若有<code>imp</code>则退出动态方法解析，若无则进入<code>_class_resolveInstanceMethod</code>开始实例方法解析，跟之前的流程一样。</p>
<blockquote>
<p>⑤ 检查cls中是否有<code>SEL_resolveInstanceMethod(resolveInstanceMethod)</code>方法</p>
<p>⑥向本类发送<code>SEL_resolveInstanceMethod</code>消息</p>
<p>⑦<code>lookUpImpOrNil</code>再次查找当前实例方法<code>IMP</code>，找到就缓存并返回，找不到就直接返回。</p>
<p>⑧结束<code>动态方法解析</code>，回到<code>lookUpImpOrForward</code>方法将<code>triedResolver</code>置否并<code>goto retry</code>重新查找缓存和方法列表</p>
</blockquote>
<p><strong>类方法解析流程图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103141027089.png"></p>
<h2 id="2-4-动态方法决议"><a href="#2-4-动态方法决议" class="headerlink" title="2.4 动态方法决议"></a>2.4 动态方法决议</h2><p><code>resolveMethod</code>中进行类方法解析之后还要在进行一次实例方法解析，这是为什么呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">resolveMethod</span><span class="params">(Class cls, SEL sel, id inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前是否是元类</span></span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// 类，尝试找实例方法</span></span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 是元类，先找类方法</span></span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            NO<span class="comment">/*initialize*/</span>, YES<span class="comment">/*cache*/</span>, NO<span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 为什么这里还要查找一次呢？</span></span><br><span class="line">            resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然上面的对象方法决议和类方法解析都会走 <code>_class_resolveInstanceMethod</code>，而最终都会找到父类 <code>NSObject</code>里面去，那我们不就可以在 <code>NSObject</code> 分类里面重写 <code>resolveInstanceMethod</code> 方法，在这个方法里面对没有实现的方法(不管是类方法还是对象方法)进行动态添加 <code>imp</code>，然后就可以进行自定义处理，比如弹个框说网络不佳，或者做bug收集等。</p>
<p>这其实就是Objective-C提供了一种名为<code>动态方法决议</code>的手段，使得我们可以在运行时动态地为一个<code>selector</code> 提供实现。</p>
<p><strong>举个例子看看：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod1;</span><br><span class="line">- (<span class="keyword">void</span>)personInstanceMethod1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>一个简单的<code>Person</code>类，里面分别有一个类方法和一个实例方法，但是都没有实现。</p>
<p>接着添加对这两个方法的解析：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)unimplementedMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;没实现？没关系，绝不崩溃&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;动态实例方法解析：%@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(personInstanceMethod1)) &#123;</span><br><span class="line">        IMP methodIMP = class_getMethodImplementation(<span class="keyword">self</span>, <span class="keyword">@selector</span>(unimplementedMethod:));</span><br><span class="line">        Method method = class_getInstanceMethod(Person.class, <span class="keyword">@selector</span>(unimplementedMethod:));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *methodType = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(Person.class, sel, methodIMP, methodType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;动态类方法解析：%@&quot;</span>, <span class="built_in">NSStringFromSelector</span>(sel));</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(personClassMethod1)) &#123;</span><br><span class="line">        IMP methodIMP = class_getMethodImplementation(<span class="keyword">self</span>, <span class="keyword">@selector</span>(unimplementedMethod:));</span><br><span class="line">        Method method = class_getInstanceMethod(Person.class, <span class="keyword">@selector</span>(unimplementedMethod:));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *methodType = method_getTypeEncoding(method);</span><br><span class="line">        <span class="keyword">return</span> class_addMethod(objc_getMetaClass(<span class="string">&quot;Person&quot;</span>), sel, methodIMP, methodType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用并打印：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103180554720.png"></p>
<p><strong>动态方法决议总结：</strong></p>
<ul>
<li><code>实例方法</code>可以重写<code>resolveInstanceMethod</code>添加<code>imp</code></li>
<li><code>类方法</code>可以在本类重写<code>resolveClassMethod</code>往元类添加<code>imp</code>，或者在<code>NSObject分类</code>重写<code>resolveInstanceMethod</code>添加<code>imp</code></li>
<li><code>动态方法解析</code>只要在任意一步<code>lookUpImpOrNil</code>查找到<code>imp</code>就不会查找下去——即<code>本类</code>做了动态方法决议，不会走到<code>NSObjct分类</code>的动态方法决议</li>
<li>所有方法都可以通过在<code>NSObject分类</code>重写<code>resolveInstanceMethod</code>添加<code>imp</code>解决崩溃</li>
</ul>
<p>那么把所有崩溃都在<code>NSObjct分类</code>中处理，加以前缀区分业务逻辑，岂不是美滋滋？错！</p>
<ul>
<li>统一处理起来耦合度高</li>
<li>逻辑判断多</li>
<li>可能在<code>NSObjct分类</code>动态方法决议之前已经做了处理</li>
<li>SDK封装的时候需要给一个容错空间</li>
</ul>
<p>这也不行，那也不行，那该怎么办？放心，苹果已经给我们准备好后路了！</p>
<h1 id="三、消息转发"><a href="#三、消息转发" class="headerlink" title="三、消息转发"></a>三、消息转发</h1><p>方法的调用经过了查找、解析，如果还是没有找到<code>IMP</code>，就会来到消息转发流程。它的入口在<code>lookUpImpOrForward</code>函数靠后的位置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// No implementation found, and method resolver didn&#x27;t help. </span></span><br><span class="line"><span class="comment">// Use forwarding.</span></span><br><span class="line"><span class="comment">// 开始消息转发</span></span><br><span class="line">imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">cache_fill(cls, sel, imp, inst);</span><br></pre></td></tr></table></figure>



<p>继续跟进，来到<code>objc-msg-arm64.s</code>文件中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103163647082.png"></p>
<p><code>__objc_msgForward_impcache</code>方法中调用<code>__objc_msgForward</code>，最后会来到c++中<code>_objc_forward_handler</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br><span class="line"></span><br><span class="line">objc_defaultForwardHandler(id self, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;</span></span><br><span class="line">                <span class="string">&quot;(no message forward handler is installed)&quot;</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(self)) ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>, </span><br><span class="line">                object_getClassName(self), sel_getName(sel), self);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用一个没实现的方法时，报的错就是<code>unrecognized selector sent to ...</code></p>
<p>但是到这里并没有结束，我们创造一个崩溃，然后看打印信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103164253950.png"></p>
<p>崩溃之前底层还调用了<code>___forwarding___</code>和<code>_CF_forwarding_prep_0</code>等方法，但是<code>CoreFoundation库</code>不开源，在无从下手之际，只能根据前辈们的经验开始着手——然后在<code>logMessageSend</code>方法中找到了探索方向(<code>lookUpImpOrForward</code>-&gt;<code>log_and_fill_cache</code>-&gt;<code>logMessageSend</code>)</p>
<p>通过<code>logMessageSend</code>方法我们可以看到，日志会记录在<code>/tmp/msgSends</code>目录下，并且通过<code>objcMsgLogEnabled</code>变量来控制是否存储日志：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">logMessageSend</span><span class="params">(<span class="keyword">bool</span> isClassMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *objectsClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">const</span> <span class="keyword">char</span> *implementingClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                    SEL selector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>	buf[ <span class="number">1024</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create/open the log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD == (<span class="number">-1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 日志会记录在/tmp/msgSends目录下</span></span><br><span class="line">        <span class="built_in">snprintf</span> (buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;/tmp/msgSends-%d&quot;</span>, (<span class="keyword">int</span>) getpid ());</span><br><span class="line">        objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid());</span><br><span class="line">        <span class="keyword">if</span> (objcMsgLogFD &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// no log file - disable logging</span></span><br><span class="line">            <span class="comment">// 通过objcMsgLogEnabled变量来控制是否存储日志</span></span><br><span class="line">            objcMsgLogEnabled = <span class="literal">false</span>;</span><br><span class="line">            objcMsgLogFD = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make the log entry</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%c %s %s %s\n&quot;</span>,</span><br><span class="line">            isClassMethod ? <span class="string">&#x27;+&#x27;</span> : <span class="string">&#x27;-&#x27;</span>,</span><br><span class="line">            objectsClass,</span><br><span class="line">            implementingClass,</span><br><span class="line">            sel_getName(selector));</span><br><span class="line"></span><br><span class="line">    objcMsgLogLock.lock();</span><br><span class="line">    write (objcMsgLogFD, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    objcMsgLogLock.unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell caller to not cache the method</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>紧接着他下面的<code>instrumentObjcMessageSends</code>方法可以改变<code>objcMsgLogEnabled</code>的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">instrumentObjcMessageSends</span><span class="params">(BOOL flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> enable = flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcut NOP</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogEnabled == enable)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If enabling, flush all method caches so we get some traces</span></span><br><span class="line">    <span class="keyword">if</span> (enable)</span><br><span class="line">        _objc_flush_caches(Nil);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sync our log file</span></span><br><span class="line">    <span class="keyword">if</span> (objcMsgLogFD != <span class="number">-1</span>)</span><br><span class="line">        fsync (objcMsgLogFD);</span><br><span class="line"></span><br><span class="line">    objcMsgLogEnabled = enable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>所以，虽然我们到这里就不能查看<code>CoreFoundation库</code>的源代码了，但是我们可以根据以下代码来记录并查看崩溃日志（仿佛不能在源码工程中操作）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> instrumentObjcMessageSends(<span class="built_in">BOOL</span> flag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        FXSon *son = [[FXSon alloc] init];</span><br><span class="line">        </span><br><span class="line">        instrumentObjcMessageSends(<span class="literal">true</span>);</span><br><span class="line">        [son doInstanceNoImplementation];	<span class="comment">// 调用一个声明了但是没实现的方法</span></span><br><span class="line">        instrumentObjcMessageSends(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>崩溃后，在访达中<code>command+shift+G</code>前往<code>/tmp/msgSends</code>，找到最新的一份日志文件（数字最大）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103165252524.png"></p>
<p>打开查看后发现，在<code>动态方法解析</code>和<code>doesNotRecognizeSelector崩溃</code>之间，就是<code>消息转发流程</code>，分为：</p>
<ul>
<li><p>快速转发<code>forwardingTargetForSelector</code></p>
</li>
<li><p>慢速转发<code>methodSignatureForSelector</code></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210103165657854.png"></p>
<h2 id="3-1-消息的快速转发"><a href="#3-1-消息的快速转发" class="headerlink" title="3.1 消息的快速转发"></a>3.1 消息的快速转发</h2><p><code>forwardingTargetForSelector:</code>对应的就是消息的快速转发流程，它在源码中只是简单的返回<code>nil</code>（可在子类或分类中重写）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过我们可以在开发文档中找到说明（<code>cmd + shift + 0</code>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103170902583.png"></p>
<p>概括地说，<code>forwardingTargetForSelector:</code>主要是返回一个新的<code>receiver</code>，去处理<code>sel</code>这个当前类无法处理的消息，如果处理不了，会转到效率低下的<code>forwardInvocation:</code>。</p>
<p>在效率方面，<code>forwardingTargetForSelector:</code>领先<code>forwardInvocation:</code>一个数量级，因此，最好不要用后者的方式处理消息的转发逻辑。</p>
<p>关于<code>forwardingTargetForSelector:</code>返回的新的<code>receiver</code>，需要注意一下几点：</p>
<ul>
<li>绝对不能返回<code>self</code>，否则会陷入无限循环；</li>
<li>不处理的话，可以返回<code>nil</code>，或者<code>[super forwardingTargetForSelector:sel]</code>（非根类的情况），此时会走<code>methodSignatureForSelector:</code>慢速转发流程；</li>
<li>如果有这个<code>receiver</code>，此时相当于执行<code>objc_msgSend(newReceiver, sel, ...)</code>，那么它必须拥有和被调用的方法相同方法签名的方法（方法名、参数列表、返回值类型都必须一致）。</li>
</ul>
<p><strong>举例说明：</strong></p>
<p><code>Person</code>类中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod1;</span><br><span class="line">- (<span class="keyword">void</span>)personInstanceMethod1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;实例方法开始转发&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> [ForwardObject alloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法开始转发&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> [ForwardObject <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>ForwardObject</code>类中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ForwardObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ForwardObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法转发给%@，执行%s&quot;</span>, [<span class="keyword">self</span> className], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)personInstanceMethod1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;实例方法转发给%@，执行%s&quot;</span>, [<span class="keyword">self</span> className], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>显然，<code>ForwardObject</code>作为消息转发后的处理类，拥有<code>Person</code>类的同名类方法和实例方法。现在开始验证，结果如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103171442810.png"></p>
<p>事实证明确实有效！接下来看消息的慢速转发流程。</p>
<h2 id="3-2-消息的慢速转发"><a href="#3-2-消息的慢速转发" class="headerlink" title="3.2 消息的慢速转发"></a>3.2 消息的慢速转发</h2><p>如果<code>forwardingTargetForSelector:</code>没有处理消息（如返回<code>nil</code>），就会启动<code>慢速转发流程</code>，也就是<code>methodSignatureForSelector:</code>方法，同样需要在子类或分类中重写</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;+[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replaced by CF (returns an NSMethodSignature)</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    _objc_fatal(<span class="string">&quot;-[NSObject methodSignatureForSelector:] &quot;</span></span><br><span class="line">                <span class="string">&quot;not available without CoreFoundation&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读官方文档，我们得出以下结论：</p>
<ul>
<li><code>methodSignatureForSelector:</code>方法是跟<code>forwardInvocation:</code>方法搭配使用的，前者需要我们根据<code>sel</code>返回一个方法签名，后者会把这个方法签名封装成一个<code>NSInvocation</code>对象，并将其作为形参。</li>
<li>如果有目标对象能处理<code>Invocation</code>中的<code>sel</code>，<code>Invocation</code>可以指派这个对象处理；否则不处理。<ul>
<li><code>Invocation</code>可以指派多个对象处理</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：消息的慢速转发流程性能较低，如果可以的话，你应该尽可能早地处理掉消息（如在方法解析时，或在消息的快速转发流程时，除非有特殊需求）。</p>
</blockquote>
<p><strong>举例说明:</strong></p>
<p>这里把快速转发例子中的<code>Person</code>类修改一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: 慢速转发--类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法慢速转发：%s, sel：%@&quot;</span>, __FUNCTION__, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personClassMethod1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法慢速转发：%s, sel：%@&quot;</span>, __FUNCTION__, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">id</span> target = [ForwardObject <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">if</span> ([target respondsToSelector:aSelector]) &#123;</span><br><span class="line">      [anInvocation invokeWithTarget:target];</span><br><span class="line">    &#125; &#123;</span><br><span class="line">      <span class="keyword">else</span> [<span class="keyword">super</span> forwardInvocation:anInvocation]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: 慢速转发--实例方法</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;实例方法慢速转发：%s, sel：%@&quot;</span>, __FUNCTION__, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(personInstanceMethod1)) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">&quot;v@:&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">    SEL aSelector = [anInvocation selector];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;实例方法慢速转发：%s, sel：%@&quot;</span>, __FUNCTION__, <span class="built_in">NSStringFromSelector</span>(aSelector));</span><br><span class="line">    ForwardObject *obj = [ForwardObject alloc];</span><br><span class="line">    <span class="keyword">if</span> ([obj respondsToSelector:aSelector]) &#123;</span><br><span class="line">      [anInvocation invokeWithTarget:obj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>ForwardObject</code>类中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ForwardObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ForwardObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)personClassMethod1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;类方法转发给%@，执行%s&quot;</span>, [<span class="keyword">self</span> className], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)personInstanceMethod1 &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;实例方法转发给%@，执行%s&quot;</span>, [<span class="keyword">self</span> className], __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>其结果如下图所示，显然也没有崩溃:</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210103172353701.png"></p>
<blockquote>
<p>对方法签名类型编码不熟悉的可以查看 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100">苹果官方的类型编码介绍</a></p>
</blockquote>
<h2 id="3-3-消息转发的应用-NSProxy"><a href="#3-3-消息转发的应用-NSProxy" class="headerlink" title="3.3 消息转发的应用 - NSProxy"></a>3.3 消息转发的应用 - NSProxy</h2><h3 id="3-3-1-模拟实现多继承【学习使用】"><a href="#3-3-1-模拟实现多继承【学习使用】" class="headerlink" title="3.3.1 模拟实现多继承【学习使用】"></a>3.3.1 模拟实现多继承【学习使用】</h3><p><code>TestProxy</code>继承自<code>NSProxy</code>，<code>TestProxy.h</code>文件：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestProxy</span> : <span class="title">NSProxy</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)transformToObject:(<span class="keyword">id</span>)object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>



<p><code>TestProxy.m</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;TestProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TestProxy</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为这个对象转发消息</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TestProxy</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObject:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">self</span>.object = object;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)transformToObject:(<span class="keyword">id</span>)object &#123;</span><br><span class="line">    <span class="keyword">self</span>.object = object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写-methodSignatureForSelector:方法获得方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.object &amp;&amp; [<span class="keyword">self</span>.object respondsToSelector:sel]) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.object methodSignatureForSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写-forwardInvocation:为调用设置目标</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    SEL sel = [invocation selector];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.object &amp;&amp; [<span class="keyword">self</span>.object respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>.object];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">super</span> forwardInvocation:invocation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p><code>ClassA</code>类中有<code>funcA</code>方法，<code>ClassB</code>类中有<code>funcB</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassA</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)funcA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ClassA.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassA</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)funcA &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用了funcA*************&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassB</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)funcB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;ClassB.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassB</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)funcB &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;调用了funcB*************&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>使用一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test2 &#123;</span><br><span class="line">    <span class="comment">// 变为clsA的代理，即proxy把消息转发给了clsA</span></span><br><span class="line">    ClassA *clsA = [ClassA new];</span><br><span class="line"><span class="comment">//    TestProxy *proxy = [[TestProxy alloc] initWithObject:clsA];</span></span><br><span class="line"><span class="comment">//    [proxy performSelector:@selector(funcA)];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变为clsB的代理，即proxy1把消息转发给了clsB</span></span><br><span class="line">    ClassB *clsB = [ClassB new];</span><br><span class="line">    TestProxy *proxy1 = [[TestProxy alloc] initWithObject:clsB];</span><br><span class="line">    [proxy1 performSelector:<span class="keyword">@selector</span>(funcB)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 又把消息转发给了clsA</span></span><br><span class="line">    [proxy1 transformToObject:clsA];</span><br><span class="line">    [proxy1 performSelector:<span class="keyword">@selector</span>(funcA)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">33.533056</span>+<span class="number">0800</span> Demo[<span class="number">62114</span>:<span class="number">6062041</span>] 调用了funcB*************</span><br><span class="line"><span class="number">2021</span><span class="number">-01</span><span class="number">-04</span> <span class="number">17</span>:<span class="number">51</span>:<span class="number">33.533094</span>+<span class="number">0800</span> Demo[<span class="number">62114</span>:<span class="number">6062041</span>] 调用了funcA*************</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<ul>
<li><p>就是<code>proxy1</code>这个对象既能调用<code>ClassA</code>中的方法，又能调用<code>ClassB</code>中的方法，看起来就像是继承自这两个类一样。</p>
</li>
<li><p>但实际上<code>proxy1</code>只是消息转发的中间站，实际上还是<code>ClassA</code>和<code>ClassB</code>的实例去调用各自的方法。</p>
</li>
</ul>
<h3 id="3-3-2-拦截方法的调用，从中实现一些我们自己需要的功能"><a href="#3-3-2-拦截方法的调用，从中实现一些我们自己需要的功能" class="headerlink" title="3.3.2 拦截方法的调用，从中实现一些我们自己需要的功能"></a>3.3.2 拦截方法的调用，从中实现一些我们自己需要的功能</h3><p>比如埋点SDK中需要实现的<code>UITableView</code>点击事件全埋点，就可以把<code>NSProxy</code>类作为<code>UITableView</code>的中间代理，以实现在中间拦截代理方法并在其中添加埋点事件的功能。</p>
<p>这里我们使用慢速消息转发，原因是苹果在官方文档中写道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Discussion</span><br><span class="line">This method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature.</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该方法用于协议的实现。在必须创建NSInvocation对象的情况下，例如在消息转发期间，也可以使用此方法。如果对象管理代理或能够处理它没有直接实现的消息，则应重写此方法以返回适当的方法签名。</span><br></pre></td></tr></table></figure>

<p>我们在这里需要管理代理，所以使用慢速消息转发。</p>
<p><strong>步骤：</strong></p>
<p>1.自定一个<code>XWTrackingAnalyticsDelegateProxy</code>类，继承自<code>NSProxy</code>，并在其中进行拦截和消息转发。</p>
<p><code>XWTrackingAnalyticsDelegateProxy.h</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XWTrackingAnalyticsDelegateProxy</span> : <span class="title">NSProxy</span> &lt;<span class="title">UITableViewDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTableViewDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_END</span></span><br></pre></td></tr></table></figure>

<p><code>XWTrackingAnalyticsDelegateProxy.m</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;XWTrackingAnalyticsDelegateProxy.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;XWTrackingAnalysisSDK.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XWTrackingAnalyticsDelegateProxy</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XWTrackingAnalyticsDelegateProxy</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTableViewDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)delegate &#123;</span><br><span class="line">    XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy alloc];</span><br><span class="line">    proxy.delegate = delegate;</span><br><span class="line">    <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">    <span class="comment">// 返回 delegate 对象中对应的方法签名</span></span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">NSObject</span> *)<span class="keyword">self</span>.delegate methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="comment">// 先执行 delegate 对象中的方法</span></span><br><span class="line">    [invocation invokeWithTarget:<span class="keyword">self</span>.delegate];</span><br><span class="line">    <span class="comment">// 判断是否是 cell 的点击事件的代理方法</span></span><br><span class="line">    <span class="keyword">if</span> (invocation.selector == <span class="keyword">@selector</span>(tableView:didSelectRowAtIndexPath:)) &#123;</span><br><span class="line">        <span class="comment">// 将方法修改为进行数据采集的方法</span></span><br><span class="line">        invocation.selector = <span class="built_in">NSSelectorFromString</span>(<span class="string">@&quot;xwtracking_tableView:didSelectRowAtIndexPath:&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行数据采集相关的方法</span></span><br><span class="line">        [invocation invokeWithTarget:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)xwtracking_tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="comment">// 数据采集相关</span></span><br><span class="line">    [XWTrackingAnalysisSDK.shareInstance trackAppClickWithTableView:tableView didSelectRowAtIndexPath:indexPath properties:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>



<p>2.使用方法交换把代理设置为<code>proxy</code></p>
<p><code>UITableView+XWTracking.m</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;UITableView+XWTracking.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;NSObject+XWSwizzler.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;XWTrackingAnalysisSDK.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;XWTrackingAnalyticsDelegateProxy.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;UIScrollView+XWTracking.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableView</span> (<span class="title">XWTracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="built_in">UITableView</span> xwtracking_swizzleMethod:<span class="keyword">@selector</span>(setDelegate:) withMethod:<span class="keyword">@selector</span>(xwtracking_setDelegate:)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)xwtracking_setDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">UITableViewDelegate</span>&gt;)delegate &#123;</span><br><span class="line"><span class="comment">//    [self xwtracking_setDelegate:delegate];</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//    // 方案一：交换方法</span></span><br><span class="line"><span class="comment">//    // 交换 delegate 中的 tableView:didSelectRowAtIndexPath: 方法</span></span><br><span class="line"><span class="comment">//    [self xwtracking_swizzleDidSelectRowAtIndexPathMethodWithDelegate:delegate];</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方案三：NSProxy 消息转发</span></span><br><span class="line">    <span class="comment">// 销毁保存的委托对象</span></span><br><span class="line">    <span class="keyword">self</span>.xwtracking_delegateProxy = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy proxyWithTableViewDelegate:delegate];</span><br><span class="line">        <span class="comment">// 保存委托对象</span></span><br><span class="line">        <span class="keyword">self</span>.xwtracking_delegateProxy = proxy;</span><br><span class="line">        <span class="comment">// 调用原始方法，将代理设置为委托对象</span></span><br><span class="line">        [<span class="keyword">self</span> xwtracking_setDelegate:proxy];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用原始方法，将代理设置为nil</span></span><br><span class="line">        [<span class="keyword">self</span> xwtracking_setDelegate:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>3.为了解决<code>proxy</code>这个局部变量出代码块被释放，然后<code>proxy</code>这个中间代理不存在的情况下还去调用代理方法时的崩溃，需要加一个对这个委托对象加一个强引用。</p>
<p>为了可以同时支持<code>UICollectionView</code>控件，直接在<code>UIScrollView</code>中扩展<code>xwtracking_delegateProxy</code>这个属性：</p>
<p><code>UIScrollView+XWTracking.h</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;XWTrackingAnalyticsDelegateProxy.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIScrollView</span> (<span class="title">XWTracking</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) XWTrackingAnalyticsDelegateProxy *xwtracking_delegateProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><code>UIScrollView+XWTracking.m</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;UIScrollView+XWTracking.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIScrollView</span> (<span class="title">XWTracking</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setXwtracking_delegateProxy:(XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(setXwtracking_delegateProxy:), xwtracking_delegateProxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(xwtracking_delegateProxy));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>至此就已经能够拦截到<code>tableView:didSelectRowAtIndexPath:</code>方法并且在其中埋点了。</p>
<h4 id="原理图："><a href="#原理图：" class="headerlink" title="原理图："></a>原理图：</h4><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210105094058668.png"></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>综上所述，当我们调用方法时：</p>
<p>①首先进行方法的查找</p>
<p>②如果查找失败，会进行<strong>动态方法解析</strong>，此时<code>OC</code>会给我们一次对<code>sel</code>的处理机会，你可以在<code>resolveInstanceMethod:</code>（类方法对应<code>resolveClassMethod:</code>）中添加一个<code>IMP</code></p>
<p>③如果你没把握住这次机会，也就是解析失败时，会来到<strong>消息转发阶段</strong>，这个阶段有两个机会去处理<code>sel</code>，分别是快速转发的<code>forwardingTargetForSelector:</code>，以及慢速转发的<code>methodSignatureForSelector:</code>。</p>
<ul>
<li>消息快速转发阶段<code>forwardingTargedForSelector</code>，有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。</li>
<li>消息慢速转发阶段<code>methodSignatureForSelector</code>，进行方法签名，把方法丢出去，<code>forwardInvocation</code>来对消息处理。</li>
</ul>
<p>④当然，如果这些机会你都放弃了，那<code>OC</code>只好让程序崩溃，就进入到了<code>doesNotRecognizeSelector</code>报错。</p>
<p>下面用一副图总结方法的解析和转发流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/17178c89c46895dc.png"></p>
<h1 id="五、问题讨论"><a href="#五、问题讨论" class="headerlink" title="五、问题讨论"></a>五、问题讨论</h1><h2 id="为什么引入消息转发机制？"><a href="#为什么引入消息转发机制？" class="headerlink" title="为什么引入消息转发机制？"></a>为什么引入消息转发机制？</h2><p>在一个方法被调用之前，我们是没办法确定它的实现地址的，直到运行时，这个方法被调用的时候，我们才能真正知道它是否有实现，以及其具体的实现地址。这也就是所谓的“动态绑定”。</p>
<p>在<code>编译期</code>，如果编译器发现方法不存在，会直接报错；同样，在<code>运行时</code>，也有<code>doesNotRecognizeSelector</code>的处理。</p>
<p>在抛出<code>doesNotRecognizeSelector</code>这个异常信息之前，<code>OC</code>利用其动态绑定的特性，引入了消息转发机制，给予了我们额外的机会处理消息（解析 or 转发），这样的做法显然更加周全合理。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904126887772173#heading-9">OC源码分析之方法的解析与转发原理-红酒牛排</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904063524405255#heading-7">iOS探索 动态方法解析和消息转发机制-我是好宝宝</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904037997887502#heading-5">iOS 底层探索篇 —— 方法的转发流程-Eating</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904057962758152#heading-5">iOS 带你走进消息转发流程及防崩溃处理-流年匆匆i</a></p>
<p>《iOS全埋点解决方案》</p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-Mach-O%E6%96%87%E4%BB%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">07上-通用二进制文件和Mach-O文件</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/"><span class="level-item">05-方法的本质和消息查找流程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#一、消息查找流程"><span class="level-left"><span class="level-item">一、消息查找流程</span></span></a></li><li><a class="level is-mobile" href="#二、动态方法解析"><span class="level-left"><span class="level-item">二、动态方法解析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-resolveMethod-入口"><span class="level-left"><span class="level-item">2.1 resolveMethod 入口</span></span></a></li><li><a class="level is-mobile" href="#2-2-实例方法解析"><span class="level-left"><span class="level-item">2.2 实例方法解析</span></span></a></li><li><a class="level is-mobile" href="#2-3-类方法解析"><span class="level-left"><span class="level-item">2.3 类方法解析</span></span></a></li><li><a class="level is-mobile" href="#2-4-动态方法决议"><span class="level-left"><span class="level-item">2.4 动态方法决议</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、消息转发"><span class="level-left"><span class="level-item">三、消息转发</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-消息的快速转发"><span class="level-left"><span class="level-item">3.1 消息的快速转发</span></span></a></li><li><a class="level is-mobile" href="#3-2-消息的慢速转发"><span class="level-left"><span class="level-item">3.2 消息的慢速转发</span></span></a></li><li><a class="level is-mobile" href="#3-3-消息转发的应用-NSProxy"><span class="level-left"><span class="level-item">3.3 消息转发的应用 - NSProxy</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-3-1-模拟实现多继承【学习使用】"><span class="level-left"><span class="level-item">3.3.1 模拟实现多继承【学习使用】</span></span></a></li><li><a class="level is-mobile" href="#3-3-2-拦截方法的调用，从中实现一些我们自己需要的功能"><span class="level-left"><span class="level-item">3.3.2 拦截方法的调用，从中实现一些我们自己需要的功能</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#原理图："><span class="level-left"><span class="level-item">原理图：</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、总结"><span class="level-left"><span class="level-item">四、总结</span></span></a></li><li><a class="level is-mobile" href="#五、问题讨论"><span class="level-left"><span class="level-item">五、问题讨论</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么引入消息转发机制？"><span class="level-left"><span class="level-item">为什么引入消息转发机制？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>