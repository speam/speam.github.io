<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>07上-通用二进制文件和Mach-O文件 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="07上-通用二进制文件和Mach-O文件"><meta property="og:url" content="http://evilimo.com/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-Mach-O%E6%96%87%E4%BB%B6/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210115114138229.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-5b1d71c9ddec02bf03421dbbcb0329b7_1440w.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-e34102eb91dd801500f7a68b31044b5f_1440w.png"><meta property="og:image" content="https://pic2.zhimg.com/80/v2-6c684f20d0c9b9bc02d482a42045e2b5_1440w.png"><meta property="article:published_time" content="2021-01-15T03:53:40.206Z"><meta property="article:modified_time" content="2021-01-15T08:14:06.417Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210115114138229.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-Mach-O%E6%96%87%E4%BB%B6/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210115114138229.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-5b1d71c9ddec02bf03421dbbcb0329b7_1440w.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-e34102eb91dd801500f7a68b31044b5f_1440w.png","https://pic2.zhimg.com/80/v2-6c684f20d0c9b9bc02d482a42045e2b5_1440w.png"],"datePublished":"2021-01-15T03:53:40.206Z","dateModified":"2021-01-15T08:14:06.417Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-Mach-O%E6%96%87%E4%BB%B6/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-15T03:53:40.206Z" title="2021-01-15T03:53:40.206Z">2021-01-15</time>发表</span><span class="level-item"><time dateTime="2021-01-15T08:14:06.417Z" title="2021-01-15T08:14:06.417Z">2021-01-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">07上-通用二进制文件和Mach-O文件</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要研究<code>dyld</code>的加载流程，首先要了解<code>通用二进制文件</code>和<code>Mach-O文件</code>。</p>
<h2 id="一、通用二进制文件"><a href="#一、通用二进制文件" class="headerlink" title="一、通用二进制文件"></a>一、通用二进制文件</h2><h3 id="1-1-通用二进制文件简介"><a href="#1-1-通用二进制文件简介" class="headerlink" title="1.1 通用二进制文件简介"></a>1.1 通用二进制文件简介</h3><p>为了解决软件在多个硬件平台上的兼容性问题(就是arm和x86)，苹果开发了一个<code>Universal Binary</code>(<code>通用的二进制文件</code>)，又称<code>Fat Binary</code>(胖二进制)。</p>
<p><code>Universal Binary</code>将支持不同架构的<code>Mach-O</code>打包在一起，再在文件起始位置加上<code>Fat Header</code>来说明所包含的<code>Mach-O</code>文件支持的架构和偏移地址信息。系统在加载运行该程序时，会根据<code>Universal Binary</code>中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。</p>
<h3 id="1-2-通用二进制的种类"><a href="#1-2-通用二进制的种类" class="headerlink" title="1.2 通用二进制的种类"></a>1.2 通用二进制的种类</h3><p>通用二进制的”通用”不止针对可以直接运行的可执行程序。包含以下几种：</p>
<ul>
<li><code>Mach-O Object</code> 目标文件 .o</li>
<li><code>Mach-O ececutable</code>可执行文件</li>
<li><code>Mach-O dynamically</code> 动态库文件<ul>
<li>.a</li>
<li>.dylib</li>
</ul>
</li>
<li>库文件<ul>
<li>Framework</li>
</ul>
</li>
<li><code>Mach-O dynamic linker</code> 动态链接器文件 dyld</li>
<li><code>Mach-O dSYM companion</code> 符号表文件.dsym，等</li>
</ul>
<h3 id="1-3-操作通用二进制文件"><a href="#1-3-操作通用二进制文件" class="headerlink" title="1.3 操作通用二进制文件"></a>1.3 操作通用二进制文件</h3><h4 id="1-3-1-查看"><a href="#1-3-1-查看" class="headerlink" title="1.3.1 查看"></a>1.3.1 查看</h4><p>苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行<code>file</code>命令可以查看它的信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> file /usr/bin/python</span></span><br><span class="line">/usr/bin/python: Mach-O universal binary with 2 architectures</span><br><span class="line">/usr/bin/python (for architecture x86_64):    Mach-O 64-bit executable x86_64</span><br><span class="line">/usr/bin/python (for architecture i386):    Mach-O executable i386</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-提取"><a href="#1-3-2-提取" class="headerlink" title="1.3.2 提取"></a>1.3.2 提取</h4><p>系统提供了一个命令行工具<code>lipo</code>来操作通用二进制文件。可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。</p>
<p>例如提取python中x86_64版本的二进制文件可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-删除"><a href="#1-3-3-删除" class="headerlink" title="1.3.3 删除"></a>1.3.3 删除</h4><p>删除x86版本的二进制文件可以执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-4-瘦身"><a href="#1-3-4-瘦身" class="headerlink" title="1.3.4 瘦身"></a>1.3.4 瘦身</h4><p>或者直接瘦身为x86_64版本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-通用二进制文件结构"><a href="#1-4-通用二进制文件结构" class="headerlink" title="1.4 通用二进制文件结构"></a>1.4 通用二进制文件结构</h3><p>下载**<a target="_blank" rel="noopener" href="https://github.com/gdbinit/MachOView"> MachOView</a>**，搜索<code>fat.h</code>，查看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/machine.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;architecture/byte_order.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_MAGIC   0xcafebabe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAT_CIGAM   0xbebafeca  <span class="comment">/* NXSwapLong(FAT_MAGIC) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_header</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    magic;      <span class="comment">/* FAT_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nfat_arch;  <span class="comment">/* number of structs that follow */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fat_arch</span> &#123;</span></span><br><span class="line">    <span class="keyword">cpu_type_t</span>  cputype;    <span class="comment">/* cpu specifier (int) */</span></span><br><span class="line">    <span class="keyword">cpu_subtype_t</span>   cpusubtype; <span class="comment">/* machine specifier (int) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;     <span class="comment">/* file offset to this object file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    size;       <span class="comment">/* size of this object file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;      <span class="comment">/* alignment as a power of 2 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fat_header</code>结构体中：</p>
<ul>
<li><code>magic</code>字段就是我们常说的魔数（例如通常判断png文件格式，还有快速求平方根的[0x5f3759df），加载器通过这个魔数值来判断这是什么样的文件，胖二进制文件的魔数值是定值0xcafebabe</li>
<li><code>nfat_arch</code>字段是指当前的胖二进制文件包含了多少个不同架构的<code>Mach-O文件</code>。<code>fat_header</code>后会跟着一个或多个连续的<code>fat_arch</code>，有多少个不同架构的<code>Mach-O</code>文件，就有多少个<code>fat_arch</code>。</li>
</ul>
<p><code>fat_arch</code>结构体中：</p>
<ul>
<li><code>cputype</code>指定了具体的cpu类型，它的类型是cpu_type_t，定义位于<code>mach/machine.h</code>中。cpu的常用类型主要有如下几种：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_X86        ((cpu_type_t) 7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386        CPU_TYPE_X86        </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    CPU_TYPE_X86_64        (CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_MC98000    ((cpu_type_t) 10)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_HPPA           ((cpu_type_t) 11)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM        ((cpu_type_t) 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_MC88000    ((cpu_type_t) 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_SPARC        ((cpu_type_t) 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I860        ((cpu_type_t) 15)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_POWERPC        ((cpu_type_t) 18)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_POWERPC64        (CPU_TYPE_POWERPC | CPU_ARCH_ABI64</span></span><br></pre></td></tr></table></figure>

<p>macOS平台上的CPU类型一般为<code>CPU_TYPE_X86_64</code>。</p>
<ul>
<li><code>cpusubtype</code>指定了cpu的子类型。它的类型是cpu_subtype_t。cpu子类型主要有如下几种：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_SUBTYPE_MASK    0xff000000</span><br><span class="line">#define CPU_SUBTYPE_LIB64    0x80000000</span><br><span class="line">#define CPU_SUBTYPE_X86_ALL        ((cpu_subtype_t)3)</span><br><span class="line">#define CPU_SUBTYPE_X86_64_ALL        ((cpu_subtype_t)3)</span><br><span class="line">#define CPU_SUBTYPE_X86_ARCH1        ((cpu_subtype_t)4)</span><br><span class="line">#define CPU_SUBTYPE_X86_64_H        ((cpu_subtype_t)8)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>cpu子类型一般CPU_SUBTYPE_LIB64与CPU_SUBTYPE_X86_64_ALL比较常见。</p>
<ul>
<li><p><code>offset</code>字段指明了当前cpu架构数据相对于当前文件开头的偏移值。</p>
</li>
<li><p><code>size</code>字段指明了数据的大小。</p>
</li>
<li><p><code>align</code>字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。</p>
</li>
</ul>
<p>可以使用otool工具打印本机安装的python程序的fat_header信息。如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ otool -f -V /usr/bin/python</span><br><span class="line">Fat headers</span><br><span class="line">fat_magic FAT_MAGIC</span><br><span class="line">nfat_arch 2</span><br><span class="line">architecture i386</span><br><span class="line">    cputype CPU_TYPE_I386</span><br><span class="line">    cpusubtype CPU_SUBTYPE_I386_ALL</span><br><span class="line">    capabilities 0x0</span><br><span class="line">    offset 4096</span><br><span class="line">    size 29632</span><br><span class="line">    align 2^12 (4096)</span><br><span class="line">architecture x86_64</span><br><span class="line">    cputype CPU_TYPE_X86_64</span><br><span class="line">    cpusubtype CPU_SUBTYPE_X86_64_ALL</span><br><span class="line">    capabilities CPU_SUBTYPE_LIB64</span><br><span class="line">    offset 36864</span><br><span class="line">    size 29872</span><br><span class="line">    align 2^12 (4096)</span><br></pre></td></tr></table></figure>



<p><strong>在fat_arch结构体往下就是具体的<code>Mach-O</code>文件格式了，它的内容复杂得多，将在下一小节进行讨论。</strong></p>
<h2 id="二、Mach-O文件"><a href="#二、Mach-O文件" class="headerlink" title="二、Mach-O文件"></a>二、Mach-O文件</h2><h3 id="2-1-Mach-O文件格式简介"><a href="#2-1-Mach-O文件格式简介" class="headerlink" title="2.1 Mach-O文件格式简介"></a>2.1 Mach-O文件格式简介</h3><p><code>Mach-O</code>（Mach Object File Format）描述了macOS系统上可执行文件的格式。熟悉Mach-O文件格式，有助于了解苹果底层软件运行机制，更好的掌握dyld加载Mach-O的步骤，为自己动手开发Mach-O相关的加解密工具打下基础。</p>
<p>一个典型的<code>Mach-O</code>文件格式如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210115114138229.png"></p>
<p>通过上图，可以看出<code>Mach-O</code>主要由以下三部分组成：</p>
<ul>
<li><p><code>Header</code> </p>
<p>描述了<code>Mach-O</code>的cpu架构、文件类型以及加载命令等信息</p>
</li>
<li><p><code>Load commands</code> </p>
<p>描述了文件中数据的具体组织结构，不同的数据类型使用不同的加载命令表示。</p>
</li>
<li><p><code>Data</code> </p>
<p>通常是对象文件中最大的部分。<code>Data</code>中每个段（segment）的数据都保存在这里，段的概念与ELF文件中段的概念类似。每个段都有一个或多个<code>Section</code>，它们存放了具体的数据与代码。</p>
</li>
</ul>
<h3 id="2-2-Header"><a href="#2-2-Header" class="headerlink" title="2.2 Header"></a>2.2 Header</h3><p>**<a target="_blank" rel="noopener" href="https://github.com/gdbinit/MachOView"> MachOView</a>**源码中搜索<code>loader.h</code>并查看：</p>
<p>32位对应<code>mach_header</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>64位对应<code>mach_header_64</code>结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	magic;		<span class="comment">/* mach magic number identifier */</span></span><br><span class="line">	<span class="keyword">cpu_type_t</span>	cputype;	<span class="comment">/* cpu specifier */</span></span><br><span class="line">	<span class="keyword">cpu_subtype_t</span>	cpusubtype;	<span class="comment">/* machine specifier */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	filetype;	<span class="comment">/* type of file */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	ncmds;		<span class="comment">/* number of load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	sizeofcmds;	<span class="comment">/* the size of all the load commands */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	flags;		<span class="comment">/* flags */</span></span><br><span class="line">	<span class="keyword">uint32_t</span>	reserved;	<span class="comment">/* reserved */</span>    <span class="comment">// 比32位多的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>magic</code>字段与<code>fat_header</code>结构体中的<code>magic</code>字段一样，表示<code>Mach-O</code>文件的魔数值，对于32位架构的程序来说，它的取值是MH_MAGIC，固定为0xfeedface。</li>
<li><code>cputype</code>与<code>cpusubtype</code>字段与<code>fat_header</code>结构体中的含义完全相同。</li>
<li><code>filetype</code>字段表示<code>Mach-O</code>的具体文件类型。它的取值有：</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define    MH_OBJECT    0x1        /* relocatable object file */</span><br><span class="line">#define    MH_EXECUTE    0x2        /* demand paged executable file */</span><br><span class="line">#define    MH_FVMLIB    0x3        /* fixed VM shared library file */</span><br><span class="line">#define    MH_CORE        0x4        /* core file */</span><br><span class="line">#define    MH_PRELOAD    0x5        /* preloaded executable file */</span><br><span class="line">#define    MH_DYLIB    0x6        /* dynamically bound shared library */</span><br><span class="line">#define    MH_DYLINKER    0x7        /* dynamic link editor */</span><br><span class="line">#define    MH_BUNDLE    0x8        /* dynamically bound bundle file */</span><br><span class="line">#define    MH_DYLIB_STUB    0x9        /* shared library stub for static */</span><br><span class="line">                    /*  linking only, no section contents */</span><br><span class="line">#define    MH_DSYM        0xa        /* companion file with only debug sections */</span><br><span class="line">#define    MH_KEXT_BUNDLE    0xb        /* x86_64 kexts */</span><br></pre></td></tr></table></figure>

<p>这里主要关注<code>MH_EXECUTE</code>、<code>MH_DYLIB</code>与<code>MH_DYLIB</code>这3个文件格式。</p>
<ul>
<li><p><code>ncmds</code>指明了<code>Mach-O</code>文件中加载命令（load commands）的数量。</p>
</li>
<li><p><code>sizeofcmds</code>字段指明了<code>Mach-O</code>文件加载命令（load commands）所占的总字节大小。</p>
</li>
<li><p><code>flags</code>字段表示文件标志，它是一个含有一组位标志的整数，指明了Mach-O文件的一些标志信息。可用的值有：</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define    MH_NOUNDEFS    0x1</span><br><span class="line">#define    MH_INCRLINK    0x2</span><br><span class="line">#define MH_DYLDLINK    0x4</span><br><span class="line">#define MH_LAZY_INIT 0x40</span><br><span class="line">#define MH_TWOLEVEL    0x80</span><br><span class="line">#define MH_PIE 0x200000</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<ul>
<li><code>mach_header_64</code>结构体中的<code>reserved</code>字段，目前它的取值由系统保留。</li>
</ul>
<h3 id="2-3-Load-commands"><a href="#2-3-Load-commands" class="headerlink" title="2.3 Load commands"></a>2.3 Load commands</h3><p>在<code>mach_header</code>之后的是<code>Load Command</code>加载命令，这些加载命令在<code>Mach-O</code>文件加载解析时，被内核加载器或者动态链接器调用，基本的加载命令的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;        <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;    <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>cmd</code>字段代表当前加载命令的类型</p>
</li>
<li><p><code>cmdsize</code>字段代表当前加载命令的大小</p>
</li>
</ul>
<p><code>cmd</code>的类型不同，所代表的加载命令的类型就不同，它的结构体也会有所不一样，对于不同类型的加载命令，它们都会在<code>load_command</code>结构体后面加上一个或多个字段来表示自己特定的结构体信息。</p>
<p>macOS系统在进化的过程中，加载命令算是比较频繁被更新的一个数据结构体，截止到macOS 10.12系统，加载命令的类型<code>cmd</code>的取值共有48种。它们的部分定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_SEGMENT    0x1    <span class="comment">/* segment of this file to be mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_SYMTAB    0x2    <span class="comment">/* link-edit stab symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_SYMSEG    0x3    <span class="comment">/* link-edit gdb symbol table info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_THREAD    0x4    <span class="comment">/* thread */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_UNIXTHREAD    0x5    <span class="comment">/* unix thread (includes a stack) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_LOADFVMLIB    0x6    <span class="comment">/* load a specified fixed VM shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_IDFVMLIB    0x7    <span class="comment">/* fixed VM shared library identification */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_IDENT    0x8    <span class="comment">/* object identification info (obsolete) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_FVMFILE    0x9    <span class="comment">/* fixed VM file inclusion (internal use) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_PREPAGE      0xa     <span class="comment">/* prepage command (internal use) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_DYSYMTAB    0xb    <span class="comment">/* dynamic link-edit symbol table info */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_LOAD_DYLIB    0xc    <span class="comment">/* load a dynamically linked shared library */</span></span></span><br><span class="line">......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_ENCRYPTION_INFO_64 0x2C <span class="comment">/* 64-bit encrypted segment information */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_LINKER_OPTION 0x2D <span class="comment">/* linker options in MH_OBJECT files */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    LC_LINKER_OPTIMIZATION_HINT 0x2E <span class="comment">/* optimization hints in MH_OBJECT files */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __OPEN_SOURCE__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_VERSION_MIN_TVOS 0x2F <span class="comment">/* build for AppleTV min OS version */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __OPEN_SOURCE__ */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_VERSION_MIN_WATCHOS 0x30 <span class="comment">/* build for Watch min OS version */</span></span></span><br></pre></td></tr></table></figure>

<p>所有的这些加载命令由系统内核加载器直接使用，或由动态链接器处理。</p>
<p><strong>其中几个常见的加载命令有：</strong></p>
<p><code>LC_SEGMENT</code></p>
<p><code>LC_LOAD_DYLINKER</code></p>
<p><code>LC_LOAD_DYLIB</code></p>
<p><code>LC_MAIN</code></p>
<p><code>LC_CODE_SIGNATURE</code></p>
<p><code>LC_ENCRYPTION_INFO</code>等。</p>
<h4 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h4><p>表示这是一个段加载命令，需要将它加载到对应的进程空间上去。段加载命令将在下一小节进行讨论。</p>
<h4 id="LC-LOAD-DYLIB"><a href="#LC-LOAD-DYLIB" class="headerlink" title="LC_LOAD_DYLIB"></a>LC_LOAD_DYLIB</h4><p>表示这是一个需要动态加载的链接库。它使用<code>dylib_command</code>结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;           <span class="comment">/* LC_ID_DYLIB, LC_LOAD_&#123;,WEAK_&#125;DYLIB,LC_REEXPORT_DYLIB */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;       <span class="comment">/* includes pathname string */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> <span class="title">dylib</span>;</span>        <span class="comment">/* the library identification */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当cmd类型时<code>LC_ID_DYLIB、LC_LOAD_DYLIB、LC_LOAD_WEAK_DYLIB与LC_REEXPORT_DYLIB</code>时，统一使用<code>dylib_command</code>结构体表示。<br>它使用<code>dylib</code>结构体来存储要加载的动态库的具体信息。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dylib</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> lc_str  name;            <span class="comment">/* library&#x27;s path name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> timestamp;            <span class="comment">/* library&#x27;s build time stamp */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> current_version;        <span class="comment">/* library&#x27;s current version number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> compatibility_version;    <span class="comment">/* library&#x27;s compatibility vers number*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>name</code>字段是动态库的完整路径，动态链接器在加载动态库时，通用此路径来进行加载它。<br><code>timestamp</code>字段描述了动态库构建时的时间戳。</p>
<p><code>current_version</code>与<code>compatibility_version</code>指明了前当版本与兼容的版本号。</p>
<h4 id="LC-MAIN"><a href="#LC-MAIN" class="headerlink" title="LC_MAIN"></a>LC_MAIN</h4><p>此加载命令记录了可执行文件的主函数<code>main()</code>的位置。它使用<code>entry_point_command</code>结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entry_point_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  cmd;    <span class="comment">/* LC_MAIN only used in MH_EXECUTE filetypes */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>  cmdsize;    <span class="comment">/* 24 */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>  entryoff;    <span class="comment">/* file (__TEXT) offset of main() */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>  stacksize;<span class="comment">/* if not zero, initial stack size */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>entryoff</code>字段中就指定了main()函数的文件偏移。</p>
<p><code>stacksize</code>指定了初始的堆栈大小。</p>
<h4 id="LC-CODE-SIGNATURE与代码签名过程分析"><a href="#LC-CODE-SIGNATURE与代码签名过程分析" class="headerlink" title="LC_CODE_SIGNATURE与代码签名过程分析"></a>LC_CODE_SIGNATURE与代码签名过程分析</h4><p><code>LC_CODE_SIGNATURE</code>：代码签名加载命令。描述了Mach-O的代码签名信息，它属于链接信息，使用<code>linkedit_data_command</code>结构体表示。定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linkedit_data_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO,</span></span><br><span class="line"><span class="comment">                                   LC_FUNCTION_STARTS, LC_DATA_IN_CODE,</span></span><br><span class="line"><span class="comment">                   LC_DYLIB_CODE_SIGN_DRS or</span></span><br><span class="line"><span class="comment">                   LC_LINKER_OPTIMIZATION_HINT. */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* sizeof(struct linkedit_data_command) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    dataoff;    <span class="comment">/* file offset of data in __LINKEDIT segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    datasize;    <span class="comment">/* file size of data in __LINKEDIT segment  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>dataoff</code>字段指明了相对于__LINKEDIT段的文件偏移位置</p>
<p><code>datasize</code>字段指明了数据的大小。<br>由于dataoff与datasize分别指明了代码签名的位置与大小，那么笔者在此提个问：如何删除Mach-O中包含的代码签名信息？</p>
<p>与代码签名相关的数据定义可以在xnu内核代码的“bsd/sys/codesign.h”文件中找到。整个代码签名部分的头部使用一个CS_SuperBlob结构体定义，它的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SC_SuperBlob</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                    <span class="comment">/* magic number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;                <span class="comment">/* total length of SuperBlob */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count;                    <span class="comment">/* number of index entries following */</span></span><br><span class="line">    CS_BlobIndex index[];            <span class="comment">/* (count) entries */</span></span><br><span class="line">    <span class="comment">/* followed by Blobs in no particular order as indicated by offsets in index */</span></span><br><span class="line">&#125; CS_SuperBlob;</span><br></pre></td></tr></table></figure>

<p>magic字段指明了Blob的类型，可选值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    CSMAGIC_REQUIREMENT = <span class="number">0xfade0c00</span>,        <span class="comment">/* single Requirement blob */</span></span><br><span class="line">    CSMAGIC_REQUIREMENTS = <span class="number">0xfade0c01</span>,        <span class="comment">/* Requirements vector (internal requirements) */</span></span><br><span class="line">    CSMAGIC_CODEDIRECTORY = <span class="number">0xfade0c02</span>,        <span class="comment">/* CodeDirectory blob */</span></span><br><span class="line">    CSMAGIC_EMBEDDED_SIGNATURE = <span class="number">0xfade0cc0</span>, <span class="comment">/* embedded form of signature data */</span></span><br><span class="line">    CSMAGIC_EMBEDDED_SIGNATURE_OLD = <span class="number">0xfade0b02</span>,    <span class="comment">/* XXX */</span></span><br><span class="line">    CSMAGIC_EMBEDDED_ENTITLEMENTS = <span class="number">0xfade7171</span>,    <span class="comment">/* embedded entitlements */</span></span><br><span class="line">    CSMAGIC_DETACHED_SIGNATURE = <span class="number">0xfade0cc1</span>, <span class="comment">/* multi-arch collection of embedded signatures */</span></span><br><span class="line">    CSMAGIC_BLOBWRAPPER = <span class="number">0xfade0b01</span>,    <span class="comment">/* CMS Signature, among other things */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第一个Blob来说，它的值必定是CSMAGIC_EMBEDDED_SIGNATURE，表示代码签名采用的嵌入式的签名信息。<br>length字段指明了整个SuperBlob的大小，其中包含马上的介绍的CodeDirectory、Requirement、Entitlement的大小。<br>count字段指明了接下来会有多少个子条目。<br>从index开始，就是每一个字条目的索引了，它的结构是CS_BlobIndex，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">BlobIndex</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> type;                    <span class="comment">/* type of entry */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset;                <span class="comment">/* offset of entry */</span></span><br><span class="line">&#125; CS_BlobIndex;</span><br></pre></td></tr></table></figure>

<p>type指明了子条目的类型，可选值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CSSLOT_CODEDIRECTORY = <span class="number">0</span>,                <span class="comment">/* slot index for CodeDirectory */</span></span><br><span class="line">CSSLOT_INFOSLOT = <span class="number">1</span>,</span><br><span class="line">CSSLOT_REQUIREMENTS = <span class="number">2</span>,</span><br><span class="line">CSSLOT_RESOURCEDIR = <span class="number">3</span>,</span><br><span class="line">CSSLOT_APPLICATION = <span class="number">4</span>,</span><br><span class="line">CSSLOT_ENTITLEMENTS = <span class="number">5</span>,</span><br><span class="line">CSSLOT_SIGNATURESLOT = <span class="number">0x10000</span>,            <span class="comment">/* CMS Signature */</span></span><br></pre></td></tr></table></figure>

<p>offset字段指明了子条目距离代码签名数据起始的文件偏移。</p>
<p>通常，签名后的程序，签名数据的第一个子条目指向的是一个type为CSSLOT_CODEDIRECTORY的结构，它是一个CS_CodeDirectory结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CodeDirectory</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                    <span class="comment">/* magic number (CSMAGIC_CODEDIRECTORY) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;                <span class="comment">/* total length of CodeDirectory blob */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;                <span class="comment">/* compatibility version */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                    <span class="comment">/* setup and mode flags */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> hashOffset;            <span class="comment">/* offset of hash slot element at index zero */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> identOffset;            <span class="comment">/* offset of identifier string */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nSpecialSlots;            <span class="comment">/* number of special hash slots */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nCodeSlots;            <span class="comment">/* number of ordinary (code) hash slots */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> codeLimit;                <span class="comment">/* limit to main image signature range */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> hashSize;                <span class="comment">/* size of each hash in bytes */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> hashType;                <span class="comment">/* type of hash (cdHashType* constants) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> platform;                <span class="comment">/* platform identifier; zero if not platform binary */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>    pageSize;                <span class="comment">/* log2(page size in bytes); 0 =&gt; infinite */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> spare2;                <span class="comment">/* unused (must be zero) */</span></span><br><span class="line">    <span class="comment">/* Version 0x20100 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> scatterOffset;                <span class="comment">/* offset of optional scatter vector */</span></span><br><span class="line">    <span class="comment">/* Version 0x20200 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> teamOffset;                <span class="comment">/* offset of optional team identifier */</span></span><br><span class="line">    <span class="comment">/* followed by dynamic content as located by offset fields above */</span></span><br><span class="line">&#125; CS_CodeDirectory;</span><br></pre></td></tr></table></figure>

<p>该结构体数据字段较多，此处只关注与签名相关的字段。hashOffset指明了Hash数据的文件相对偏移，注意是相对于当前结构体CS_CodeDirectory，hashType与hashSize指明了代码签名时使用的算法与每一项签名数据的长度，目前macOS使用的签名算法是SHA-1，长度为20字节。<br>nSpecialSlots与nCodeSlots指定的代码签名数据条目的个数，前者是针对代码签名中所有的Blob，后者针对程序文件内容。codesign程序在对程序进行签名时，会对SuperBlob中每个子条目进行签名，即对Blob的内容调用SHA-1算法取Hash值，nSpecialSlots的值就是子条目Blob的个数；同时，codesign会以pageSize字段指定的页大小为单位（通常取值是0x1000），对程序数据进行签名，每一页签名后生成一条签名数据，nCodeSlots的值就是签名数据的页数，即程序数据大小除以pageSize字段后的值。</p>
<p>在CS_CodeDirectory之后，就是Requirements了，它是一个CS_SuperBlob结构体，指明了Requirement的个数与每一个的偏移。接下来就是每一个Requirement数据了，它是一个CS_GenericBlob结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SC_GenericBlob</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                <span class="comment">/* magic number */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;            <span class="comment">/* total length of blob */</span></span><br><span class="line">    <span class="keyword">char</span> data[];</span><br><span class="line">&#125; CS_GenericBlob;</span><br></pre></td></tr></table></figure>

<p>可以看到，它的前两个字段与CS_SuperBlob是一样的，只是后面多出一个data字段，用来存放Blob的数据长度。<br>在Requirement数据下面，就是Entitlement了，它同样是CS_GenericBlob结构。拿本机Calculator计算器程序来说，它的Entitlement的数据内容是一个xml文件，提取出来内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">http:<span class="comment">//www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span></span><br><span class="line">&lt;plist version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.app-sandbox&lt;/key&gt;</span><br><span class="line">    &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.files.user-selected.read-write&lt;/key&gt;</span><br><span class="line">    &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.network.client&lt;/key&gt;</span><br><span class="line">    &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">    &lt;key&gt;com.apple.security.print&lt;/key&gt;</span><br><span class="line">    &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<p>最后一个Blob通常是签名使用的证书了，Certificates签名证书也是CS_GenericBlob结构，提取它的证书数据后保存为cer文件，使用macOS的文件预览证书内容，效果如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-5b1d71c9ddec02bf03421dbbcb0329b7_1440w.png"></p>
<p>下面再来看看，系统是如何实施代码签名验证的！内核加载解析Mach-O加载命令的函数是parse_machfile()，位于内核代码”/bsd/kern/mach_loader.c“文件中，部分代码片断如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">load_return_t</span> <span class="title">parse_machfile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct vnode         *vp,       </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">vm_map_t</span>        <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">thread_t</span>        thread,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct mach_header    *header,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">off_t</span>            file_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">off_t</span>            macho_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>            depth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int64_t</span>            aslr_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int64_t</span>            dyld_aslr_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">load_result_t</span>        *result</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span>        ncmds;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span>    *<span class="title">lcp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dylinker_command</span>    *<span class="title">dlp</span> = 0;</span></span><br><span class="line">    <span class="keyword">integer_t</span>        dlarchbits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *            control;</span><br><span class="line">    <span class="keyword">load_return_t</span>        ret = LOAD_SUCCESS;</span><br><span class="line">    <span class="keyword">caddr_t</span>            addr;</span><br><span class="line">    <span class="keyword">void</span> *            kl_addr;</span><br><span class="line">    <span class="keyword">vm_size_t</span>        size,kl_size;</span><br><span class="line">    <span class="keyword">size_t</span>            offset;</span><br><span class="line">    <span class="keyword">size_t</span>            oldoffset;    <span class="comment">/* for overflow check */</span></span><br><span class="line">    <span class="keyword">int</span>            pass;</span><br><span class="line">    <span class="keyword">proc_t</span>            p = current_proc();        <span class="comment">/* XXXX */</span></span><br><span class="line">    <span class="keyword">int</span>            error;</span><br><span class="line">    <span class="keyword">int</span> resid=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span>            mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header);</span><br><span class="line">    <span class="keyword">boolean_t</span>        abi64;</span><br><span class="line">    <span class="keyword">boolean_t</span>        got_code_signatures = FALSE;</span><br><span class="line">    <span class="keyword">int64_t</span>            slide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (header-&gt;magic == MH_MAGIC_64 ||</span><br><span class="line">        header-&gt;magic == MH_CIGAM_64) &#123;</span><br><span class="line">            mach_header_sz = <span class="keyword">sizeof</span>(struct mach_header_64);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> LC_CODE_SIGNATURE:</span><br><span class="line">        <span class="comment">/* CODE SIGNING */</span></span><br><span class="line">        <span class="keyword">if</span> (pass != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">/* pager -&gt; uip -&gt;</span></span><br><span class="line"><span class="comment">            load signatures &amp; store in uip</span></span><br><span class="line"><span class="comment">            set VM object &quot;signed_pages&quot;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ret = load_code_signature(</span><br><span class="line">            (struct linkedit_data_command *) lcp,</span><br><span class="line">            vp,</span><br><span class="line">            file_offset,</span><br><span class="line">            macho_size,</span><br><span class="line">            header-&gt;cputype,</span><br><span class="line">            result);</span><br><span class="line">        <span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;proc %d: load code signature error %d &quot;</span></span><br><span class="line">                    <span class="string">&quot;for file \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">                    p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                * Allow injections to be ignored on devices w/o enforcement enabled</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            <span class="keyword">if</span> (!cs_enforcement(<span class="literal">NULL</span>))</span><br><span class="line">                ret = LOAD_SUCCESS; <span class="comment">/* ignore error */</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            got_code_signatures = TRUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (got_code_signatures) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> tainted = CS_VALIDATE_TAINTED;</span><br><span class="line">            <span class="keyword">boolean_t</span> valid = FALSE;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">cs_blob</span> *<span class="title">blobs</span>;</span></span><br><span class="line">            <span class="keyword">vm_size_t</span> off = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cs_debug &gt; <span class="number">10</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;validating initial pages of %s\n&quot;</span>, vp-&gt;v_name);</span><br><span class="line">            blobs = ubc_get_cs_blobs(vp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (off &lt; size &amp;&amp; ret == LOAD_SUCCESS) &#123;</span><br><span class="line">                    tainted = CS_VALIDATE_TAINTED;</span><br><span class="line"></span><br><span class="line">                    valid = cs_validate_page(blobs,</span><br><span class="line">                                <span class="literal">NULL</span>,</span><br><span class="line">                                file_offset + off,</span><br><span class="line">                                addr + off,</span><br><span class="line">                                &amp;tainted);</span><br><span class="line">                    <span class="keyword">if</span> (!valid || (tainted &amp; CS_VALIDATE_TAINTED)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cs_debug)</span><br><span class="line">                            <span class="built_in">printf</span>(<span class="string">&quot;CODE SIGNING: %s[%d]: invalid initial page at offset %lld validated:%d tainted:%d csflags:0x%x\n&quot;</span>,</span><br><span class="line">                            vp-&gt;v_name, p-&gt;p_pid, (<span class="keyword">long</span> <span class="keyword">long</span>)(file_offset + off), valid, tainted, result-&gt;csflags);</span><br><span class="line">                        <span class="keyword">if</span> (cs_enforcement(<span class="literal">NULL</span>) ||</span><br><span class="line">                        (result-&gt;csflags &amp; (CS_HARD|CS_KILL|CS_ENFORCEMENT))) &#123;</span><br><span class="line">                            ret = LOAD_FAILURE;</span><br><span class="line">                        &#125;</span><br><span class="line">                        result-&gt;csflags &amp;= ~CS_VALID;</span><br><span class="line">                    &#125;</span><br><span class="line">                    off += PAGE_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>整个代码签名的验证过程大致分为load_code_signature()与cs_validate_page()两步，前者负责加载代码签名，后者负责验证数据页面。load_code_signature()在加载代码签名时，通过调用ubc_cs_blob_get()来获取特定CPU的cs_blob指针，ubc_cs_blob_get()第一次调用时，返回的cs_blob指针为空，会调用ubc_cs_blob_add()来加载与验证文件中的Blob信息，以后再调用ubc_cs_blob_get()，就会返回内存中的cs_blob指针，当然不是直接返回，系统会再次判断内存中的cs_blob指针是否损坏或遭到篡改，具体方法是调用ubc_cs_generation_check()做初步的检查，之后调用ubc_cs_blob_revalidate()对blob做重验证。load_code_signature()`函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">load_return_t</span></span><br><span class="line">load_code_signature(</span><br><span class="line">    struct linkedit_data_command    *lcp,</span><br><span class="line">    struct vnode            *vp,</span><br><span class="line">    <span class="keyword">off_t</span>                macho_offset,</span><br><span class="line">    <span class="keyword">off_t</span>                macho_size,</span><br><span class="line">    <span class="keyword">cpu_type_t</span>            cputype,</span><br><span class="line">    <span class="keyword">load_result_t</span>            *result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>        ret;</span><br><span class="line">    <span class="keyword">kern_return_t</span>    kr;</span><br><span class="line">    <span class="keyword">vm_offset_t</span>    addr;</span><br><span class="line">    <span class="keyword">int</span>        resid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cs_blob</span>    *<span class="title">blob</span>;</span></span><br><span class="line">    <span class="keyword">int</span>        error;</span><br><span class="line">    <span class="keyword">vm_size_t</span>    blob_size;</span><br><span class="line"></span><br><span class="line">    addr = <span class="number">0</span>;</span><br><span class="line">    blob = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lcp-&gt;cmdsize != <span class="keyword">sizeof</span> (struct linkedit_data_command) ||</span><br><span class="line">        lcp-&gt;dataoff + lcp-&gt;datasize &gt; macho_size) &#123;</span><br><span class="line">        ret = LOAD_BADMACHO;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blob = ubc_cs_blob_get(vp, cputype, macho_offset);</span><br><span class="line">    <span class="keyword">if</span> (blob != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* we already have a blob for this vnode and cputype */</span></span><br><span class="line">        <span class="keyword">if</span> (blob-&gt;csb_cpu_type == cputype &amp;&amp;</span><br><span class="line">            blob-&gt;csb_base_offset == macho_offset &amp;&amp;</span><br><span class="line">            blob-&gt;csb_mem_size == lcp-&gt;datasize) &#123;</span><br><span class="line">            <span class="comment">/* it matches the blob we want here, lets verify the version */</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> != ubc_cs_generation_check(vp)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != ubc_cs_blob_revalidate(vp, blob, <span class="number">0</span>)) &#123;</span><br><span class="line">                    ret = LOAD_FAILURE; <span class="comment">/* set error same as from ubc_cs_blob_add */</span></span><br><span class="line">                    <span class="keyword">goto</span> out;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = LOAD_SUCCESS;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* the blob has changed for this vnode: fail ! */</span></span><br><span class="line">            ret = LOAD_BADMACHO;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    blob_size = lcp-&gt;datasize;</span><br><span class="line">    kr = ubc_cs_blob_allocate(&amp;addr, &amp;blob_size);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        ret = LOAD_NOSPACE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resid = <span class="number">0</span>;</span><br><span class="line">    error = vn_rdwr(UIO_READ,</span><br><span class="line">            vp,</span><br><span class="line">            (<span class="keyword">caddr_t</span>) addr,</span><br><span class="line">            lcp-&gt;datasize,</span><br><span class="line">            macho_offset + lcp-&gt;dataoff,</span><br><span class="line">            UIO_SYSSPACE,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            kauth_cred_get(),</span><br><span class="line">            &amp;resid,</span><br><span class="line">            current_proc());</span><br><span class="line">    <span class="keyword">if</span> (error || resid != <span class="number">0</span>) &#123;</span><br><span class="line">        ret = LOAD_IOERROR;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ubc_cs_blob_add(vp,</span><br><span class="line">                cputype,</span><br><span class="line">                macho_offset,</span><br><span class="line">                addr,</span><br><span class="line">                lcp-&gt;datasize,</span><br><span class="line">                <span class="number">0</span>)) &#123;</span><br><span class="line">        ret = LOAD_FAILURE;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* ubc_cs_blob_add() has consumed &quot;addr&quot; */</span></span><br><span class="line">        addr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CHECK_CS_VALIDATION_BITMAP</span></span><br><span class="line">    ubc_cs_validation_bitmap_allocate( vp );</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    blob = ubc_cs_blob_get(vp, cputype, macho_offset);</span><br><span class="line"></span><br><span class="line">    ret = LOAD_SUCCESS;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (ret == LOAD_SUCCESS) &#123;</span><br><span class="line">        result-&gt;csflags |= blob-&gt;csb_flags;</span><br><span class="line">        result-&gt;platform_binary = blob-&gt;csb_platform_binary;</span><br><span class="line">        result-&gt;cs_end_offset = blob-&gt;csb_end_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">        ubc_cs_blob_deallocate(addr, blob_size);</span><br><span class="line">        addr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，上面提到的cs_blob指针，其实就是代码签名数据中的CS_SuperBlob指针类型。<br>ubc_cs_blob_add()的代码比较长，它主要做了三个工作：一是调用cs_validate_csblob()验证cs_blob指针的合法性，cs_validate_csblob()会对CSMAGIC_EMBEDDED_SIGNATURE与CSMAGIC_CODEDIRECTORY做相应的验证处理，包括调用cs_validate_codedirectory()验证CS_CodeDirectory结构体的合法性，以及调用cs_validate_blob()来验证CS_SuperBlob中每一个CS_GenericBlob是否合法有效；二是调用mac_vnode_check_signature()验证Blob块的代码签名，也就是比较Blob块的SHA1哈希值是否与计算的值相同；三是加载所有的代码签名Hash信息，填充cs_blobs字段，为下一步的内存页签名验证做准备。<br>ubc_cs_blob_revalidate()做着与ubc_cs_blob_add()几乎相同的验证检查，但前者因为已经有了一些缓存信息，因此检查时会快一些。</p>
<p>load_code_signature()完事以后，会调用ubc_get_cs_blobs()获取cs_blobs指针，最后调用cs_validate_page()以逐页的形式验证文件中每一页的数据的签名。<br>以上检查做完后，LC_CODE_SIGNATURE就处理完了，没有错误发生就表示代码签名验证通过了。</p>
<p>讲完了代码签名，再讲讲代码加密。Mach-O程序如果使用了代码加密技术，在加载命令列表中会有一个LC_ENCRYPTION_INFO加载命令。它存储了Mach-O的加密信息。关于此加载命令，对于搞过iOS程序逆向的读者应该不会感到陌生。iOS系统由于安全机制的原因，会对App Store中上架的应用默认开启数据加密。<br>被加密过的App文件，部分段的数据内容是经过加密的，而记录加密数据的关键就是LC_ENCRYPTION_INFO加载命令。分析人员要想对加密过的App进行逆向分析，必须先经过一次解密（俗称“砸壳”）操作。<br>LC_ENCRYPTION_INFO使用encryption_info_command结构体表示。定义如下（LC_ENCRYPTION_INFO_64使用encryption_info_command_64表示）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">encryption_info_command</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_ENCRYPTION_INFO */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* sizeof(struct encryption_info_command) */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>    cryptoff;    <span class="comment">/* file offset of encrypted range */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>    cryptsize;    <span class="comment">/* file size of encrypted range */</span></span><br><span class="line">   <span class="keyword">uint32_t</span>    cryptid;    <span class="comment">/* which enryption system, 0 means not-encrypted yet */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cryptoff与cryptsize字段分别指明了加密数据的文件偏移与大小。cryptid指定了使用的加密系统。<br>聪明的安全研究人员，根据Mach-O在内存中被加载完后即解密完成的特点，开发了针对iOS平台App的代码解密工具dumpdecrypted，<br>下载地址是：stefanesser/dumpdecrypted 。通过将内存中解密后的数据写回原位置，并将cryptid置0来达到解密App的目的。</p>
<p>再来看看系统是如何处理LC_ENCRYPTION_INFO的，它的解析函数也是parse_machfile()，代码片断如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">load_return_t</span> <span class="title">parse_machfile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    struct vnode         *vp,       </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">vm_map_t</span>        <span class="built_in">map</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">thread_t</span>        thread,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct mach_header    *header,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">off_t</span>            file_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">off_t</span>            macho_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span>            depth,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int64_t</span>            aslr_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int64_t</span>            dyld_aslr_offset,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">load_result_t</span>        *result</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line">            <span class="keyword">case</span> LC_ENCRYPTION_INFO:</span><br><span class="line">            <span class="keyword">case</span> LC_ENCRYPTION_INFO_64:</span><br><span class="line">                <span class="keyword">if</span> (pass != <span class="number">3</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ret = set_code_unprotect(</span><br><span class="line">                    (struct encryption_info_command *) lcp,</span><br><span class="line">                    addr, <span class="built_in">map</span>, slide, vp,</span><br><span class="line">                    header-&gt;cputype, header-&gt;cpusubtype);</span><br><span class="line">                <span class="keyword">if</span> (ret != LOAD_SUCCESS) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;proc %d: set_code_unprotect() error %d &quot;</span></span><br><span class="line">                           <span class="string">&quot;for file \&quot;%s\&quot;\n&quot;</span>,</span><br><span class="line">                           p-&gt;p_pid, ret, vp-&gt;v_name);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Don&#x27;t let the app run if it&#x27;s</span></span><br><span class="line"><span class="comment">                     * encrypted but we failed to set up the</span></span><br><span class="line"><span class="comment">                     * decrypter. If the keys are missing it will</span></span><br><span class="line"><span class="comment">                     * return LOAD_DECRYPTFAIL.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                     <span class="keyword">if</span> (ret == LOAD_DECRYPTFAIL) &#123;</span><br><span class="line">                        <span class="comment">/* failed to load due to missing FP keys */</span></span><br><span class="line">                        proc_lock(p);</span><br><span class="line">                        p-&gt;p_lflag |= P_LTERM_DECRYPTFAIL;</span><br><span class="line">                        proc_unlock(p);</span><br><span class="line">                    &#125;</span><br><span class="line">                     psignal(p, SIGKILL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">/* Other commands are ignored by the kernel */</span></span><br><span class="line">                ret = LOAD_SUCCESS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>当系统内核被配置为启用代码解密，即定义了CONFIG_CODE_DECRYPTION之后，parse_machfile()函数会解析LC_ENCRYPTION_INFO与LC_ENCRYPTION_INFO_64加载命令。<br>最终是调用了set_code_unprotect()函数来对代码进行解密。该函数通过encryption_info_command中的cryptid来确定使用的加密系统，然后对代码进行内存解密。它的代码片断如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_CODE_DECRYPTION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">load_return_t</span></span><br><span class="line">set_code_unprotect(</span><br><span class="line">           struct encryption_info_command *eip,</span><br><span class="line">           <span class="keyword">caddr_t</span> addr,     </span><br><span class="line">           <span class="keyword">vm_map_t</span> <span class="built_in">map</span>,</span><br><span class="line">           <span class="keyword">int64_t</span> slide,</span><br><span class="line">           struct vnode    *vp,</span><br><span class="line">           <span class="keyword">cpu_type_t</span> cputype,</span><br><span class="line">           <span class="keyword">cpu_subtype_t</span> cpusubtype)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (eip-&gt;cmdsize &lt; <span class="keyword">sizeof</span>(*eip)) <span class="keyword">return</span> LOAD_BADMACHO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(eip-&gt;cryptid) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="comment">/* not encrypted, just an empty load command */</span></span><br><span class="line">            <span class="keyword">return</span> LOAD_SUCCESS;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cryptname=<span class="string">&quot;com.apple.unfree&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x10</span>:</span><br><span class="line">            <span class="comment">/* some random cryptid that you could manually put into</span></span><br><span class="line"><span class="comment">             * your binary if you want NULL */</span></span><br><span class="line">            cryptname=<span class="string">&quot;com.apple.null&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> LOAD_BADMACHO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span> == VM_MAP_NULL) <span class="keyword">return</span> (LOAD_SUCCESS);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == text_crypter_create) <span class="keyword">return</span> LOAD_FAILURE;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set up decrypter first */</span></span><br><span class="line">    <span class="keyword">crypt_file_data_t</span> crypt_data = &#123;</span><br><span class="line">        .filename = vpath,</span><br><span class="line">        .cputype = cputype,</span><br><span class="line">        .cpusubtype = cpusubtype&#125;;</span><br><span class="line">    kr=text_crypter_create(&amp;crypt_info, cryptname, (<span class="keyword">void</span>*)&amp;crypt_data);</span><br><span class="line">    FREE_ZONE(vpath, MAXPATHLEN, M_NAMEI);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    offset = mach_header_sz;</span><br><span class="line">    <span class="keyword">uint32_t</span> ncmds = header-&gt;ncmds;</span><br><span class="line">    <span class="keyword">while</span> (ncmds--) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *    Get a pointer to the command.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> *<span class="title">lcp</span> = (<span class="title">struct</span> <span class="title">load_command</span> *)(<span class="title">addr</span> + <span class="title">offset</span>);</span></span><br><span class="line">        offset += lcp-&gt;cmdsize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(lcp-&gt;cmd) &#123;</span><br><span class="line">            <span class="keyword">case</span> LC_SEGMENT_64:</span><br><span class="line">                seg64 = (struct segment_command_64 *)lcp;</span><br><span class="line">                <span class="keyword">if</span> ((seg64-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</span><br><span class="line">                    (seg64-&gt;fileoff+seg64-&gt;filesize &gt;=</span><br><span class="line">                     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</span><br><span class="line">                    map_offset = seg64-&gt;vmaddr + eip-&gt;cryptoff - seg64-&gt;fileoff + slide;</span><br><span class="line">                    map_size = eip-&gt;cryptsize;</span><br><span class="line">                    <span class="keyword">goto</span> remap_now;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> LC_SEGMENT:</span><br><span class="line">                seg32 = (struct segment_command *)lcp;</span><br><span class="line">                <span class="keyword">if</span> ((seg32-&gt;fileoff &lt;= eip-&gt;cryptoff) &amp;&amp;</span><br><span class="line">                    (seg32-&gt;fileoff+seg32-&gt;filesize &gt;=</span><br><span class="line">                     eip-&gt;cryptoff+eip-&gt;cryptsize)) &#123;</span><br><span class="line">                    map_offset = seg32-&gt;vmaddr + eip-&gt;cryptoff - seg32-&gt;fileoff + slide;</span><br><span class="line">                    map_size = eip-&gt;cryptsize;</span><br><span class="line">                    <span class="keyword">goto</span> remap_now;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* if we get here, did not find anything */</span></span><br><span class="line">    <span class="keyword">return</span> LOAD_BADMACHO;</span><br><span class="line"></span><br><span class="line">remap_now:</span><br><span class="line">    <span class="comment">/* now remap using the decrypter */</span></span><br><span class="line">    kr = vm_map_apple_protected(<span class="built_in">map</span>, map_offset, map_offset+map_size, &amp;crypt_info);</span><br><span class="line">    <span class="keyword">if</span>(kr) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;set_code_unprotect(): mapping failed with %x\n&quot;</span>, kr);</span><br><span class="line">        crypt_info.crypt_end(crypt_info.crypt_ops);</span><br><span class="line">        <span class="keyword">return</span> LOAD_PROTECT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> LOAD_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>text_crypter_create()是一个全局的text_crypter_create_hook_t类型的指针，在内核代码“osfmk/kern/page_decrypt.c”文件中通过text_crypter_create_hook_set()进行设置。<br>text_crypter_create()在填充完解密所需的信息crypt_info后，会再次计算需要重新解密映射到内存的地址与大小，调用vm_map_apple_protected()进行解密操作。</p>
<p>由于内核的代码可以直接审阅，数据加密在macOS系统上显得意义不大，在目前最新的macOS 10.12系统上，苹果没有启用代码解密功能，LC_ENCRYPTION_INFO与LC_ENCRYPTION_INFO_64加载命令也就没那么常见了。</p>
<p>最后，可以使用otool命令行工具来查看Mach-O文件的加载命令信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> otool -l /usr/bin/python</span></span><br><span class="line">/usr/bin/python:</span><br><span class="line">Load command 0</span><br><span class="line">      cmd LC_SEGMENT_64</span><br><span class="line">  cmdsize 72</span><br><span class="line">  segname __PAGEZERO</span><br><span class="line">   vmaddr 0x0000000000000000</span><br><span class="line">   vmsize 0x0000000100000000</span><br><span class="line">  fileoff 0</span><br><span class="line"> filesize 0</span><br><span class="line">  maxprot 0x00000000</span><br><span class="line"> initprot 0x00000000</span><br><span class="line">   nsects 0</span><br><span class="line">    flags 0x0</span><br><span class="line">Load command 1</span><br><span class="line">      cmd LC_SEGMENT_64</span><br><span class="line">    ......</span><br><span class="line">Load command 15</span><br><span class="line">      cmd LC_DATA_IN_CODE</span><br><span class="line">  cmdsize 16</span><br><span class="line">  dataoff 17776</span><br><span class="line"> datasize 0</span><br><span class="line">Load command 16</span><br><span class="line">      cmd LC_CODE_SIGNATURE</span><br><span class="line">  cmdsize 16</span><br><span class="line">  dataoff 20528</span><br><span class="line"> datasize 9344</span><br></pre></td></tr></table></figure>

<p>也可以使用MachOView查看，效果如图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/v2-e34102eb91dd801500f7a68b31044b5f_1440w.png"></p>
<h4 id="LC-SEGMENT-1"><a href="#LC-SEGMENT-1" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h4><p>段加载命令LC_SEGMENT，描述了32位Mach-O文件的段的信息，使用<code>segment_command</code>结构体来表示，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* includes sizeof section structs */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment name */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    vmaddr;        <span class="comment">/* memory address of this segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    vmsize;        <span class="comment">/* memory size of this segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    fileoff;    <span class="comment">/* file offset of this segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    filesize;    <span class="comment">/* amount to map from the file */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    maxprot;    <span class="comment">/* maximum VM protection */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    initprot;    <span class="comment">/* initial VM protection */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;        <span class="comment">/* number of sections in segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>segname</code>字段是一个16字节大小的空间，用来存储段的名称。<br><code>vmaddr</code>字段指明了段要加载的虚拟内存地址。<br><code>vmsize</code>字段指明了段所占的虚拟内存的大小。<br><code>fileoff</code>字段指明了段数据所在文件中偏移地址。<br><code>filesize</code>字段指明了段数据实际的大小。<br><code>maxprot</code>字段指明了页面所需要的最高内存保护。<br><code>initprot</code>字段指明了页面初始的内存保护。<br><code>nsects</code>字段指明了段所包含的节区（section）。<br><code>flags</code>字段指明了段的标志信息。</p>
<p>与<code>LC_SEGMENT</code>对应的是<code>LC_SEGMENT_64</code>，它使用<code>segment_command_64</code>结构体表示，描述了64位Mach-O文件的段的基本信息，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segment_command_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmd;        <span class="comment">/* LC_SEGMENT_64 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    cmdsize;    <span class="comment">/* includes sizeof section_64 structs */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment name */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmaddr;        <span class="comment">/* memory address of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    vmsize;        <span class="comment">/* memory size of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    fileoff;    <span class="comment">/* file offset of this segment */</span></span><br><span class="line">    <span class="keyword">uint64_t</span>    filesize;    <span class="comment">/* amount to map from the file */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    maxprot;    <span class="comment">/* maximum VM protection */</span></span><br><span class="line">    <span class="keyword">vm_prot_t</span>    initprot;    <span class="comment">/* initial VM protection */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nsects;        <span class="comment">/* number of sections in segment */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* flags */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有的字段含义与32位基本一致。主要讨论一下它最后4个字段。</p>
<p>一个编译后可能执行的程序分成了多个段，不同的类型的数据放入了不同的段中。</p>
<p>如程序的代码被称作代码段，放入一个名为<code>__TEXT</code>的段中，代码段的<code>maxprot</code>字段在编译时被设置成VM_PROT_READ（可读）、VM_PROT_WRITE（可写）、VM_PROT_EXECUTE（可执行）<code>initprot</code>字段被设置成VM_PROT_READ（可读）与VM_PROT_EXECUTE（可执行），这样做是合理的，一个普通的应用程序，它的代码段部分通常是不可写的，特殊需求的程序，如果要求代码段可写，必须在编译时设置它的<code>initprot</code>字段为VM_PROT_WRITE（可写）。</p>
<p>nsects字段指定了段加载命令包含几个节区（section），一个段可以包含0个或多个节区。如__PAGEZERO段就不包含任何节区，该段被称为空指针陷阱段，映射到虚拟内存空间的第一页，用于捕捉对NULL指针的引用。<br>当一个段包含多个节区时，节区信息会以数组形式紧随着存储在段加载命令后面。节区使用结构体section表示（64位使用section_64表示），定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section</span> &#123;</span> <span class="comment">/* for 32-bit architectures */</span></span><br><span class="line">    <span class="keyword">char</span>        sectname[<span class="number">16</span>];    <span class="comment">/* name of this section */</span></span><br><span class="line">    <span class="keyword">char</span>        segname[<span class="number">16</span>];    <span class="comment">/* segment this section goes in */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    addr;        <span class="comment">/* memory address of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    size;        <span class="comment">/* size in bytes of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    offset;        <span class="comment">/* file offset of this section */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    align;        <span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reloff;        <span class="comment">/* file offset of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    nreloc;        <span class="comment">/* number of relocation entries */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    flags;        <span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved1;    <span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    reserved2;    <span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>sectname字段表示节区的名称，segname字段表示节区所在的段名，addr与size指明了节区所在的内存地址与大小，offset指明了区取所在的文件偏移，<br>align表示节区的内存对齐边界，reloff指明了重定位信息的文件偏移，nreloc表示重定位条目的数目，flags则是节区的一些标志属性。</p>
<p>段加载命令的最后一个字段flags存储了段的一些标志属性，它的取值有如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SG_HIGHVM    0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SG_FVMLIB    0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>    SG_NORELOC    0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SG_PROTECTED_VERSION_1    0x8</span></span><br></pre></td></tr></table></figure>

<p>值得关注的是SG_PROTECTED_VERSION_1，当段被设置了该标志位，表示段是经过加密的！在macOS版本10.6以前，系统使用AES算法进行段的加密与解密，10.6的时候，则使用的Blowfish加密算法，著名的iOS逆向工具class-dump（地址：nygard/class-dump） 提供了一个静态数据段解密工具deprotect，有兴趣的读者可以参看它的代码来了解段解密的部分。</p>
<p>最后，使用MachOView工具查看系统python程序的__TEXT段的信息如图所示：</p>
<p><img src="https://pic2.zhimg.com/80/v2-6c684f20d0c9b9bc02d482a42045e2b5_1440w.png" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/24858664">Mach-O文件格式</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bcc7ba20f900">Mach-O可执行文件</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"><span class="level-item">06-动态方法解析和消息转发机制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#一、通用二进制文件"><span class="level-left"><span class="level-item">一、通用二进制文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-通用二进制文件简介"><span class="level-left"><span class="level-item">1.1 通用二进制文件简介</span></span></a></li><li><a class="level is-mobile" href="#1-2-通用二进制的种类"><span class="level-left"><span class="level-item">1.2 通用二进制的种类</span></span></a></li><li><a class="level is-mobile" href="#1-3-操作通用二进制文件"><span class="level-left"><span class="level-item">1.3 操作通用二进制文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-3-1-查看"><span class="level-left"><span class="level-item">1.3.1 查看</span></span></a></li><li><a class="level is-mobile" href="#1-3-2-提取"><span class="level-left"><span class="level-item">1.3.2 提取</span></span></a></li><li><a class="level is-mobile" href="#1-3-3-删除"><span class="level-left"><span class="level-item">1.3.3 删除</span></span></a></li><li><a class="level is-mobile" href="#1-3-4-瘦身"><span class="level-left"><span class="level-item">1.3.4 瘦身</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-4-通用二进制文件结构"><span class="level-left"><span class="level-item">1.4 通用二进制文件结构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、Mach-O文件"><span class="level-left"><span class="level-item">二、Mach-O文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-Mach-O文件格式简介"><span class="level-left"><span class="level-item">2.1 Mach-O文件格式简介</span></span></a></li><li><a class="level is-mobile" href="#2-2-Header"><span class="level-left"><span class="level-item">2.2 Header</span></span></a></li><li><a class="level is-mobile" href="#2-3-Load-commands"><span class="level-left"><span class="level-item">2.3 Load commands</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#LC-SEGMENT"><span class="level-left"><span class="level-item">LC_SEGMENT</span></span></a></li><li><a class="level is-mobile" href="#LC-LOAD-DYLIB"><span class="level-left"><span class="level-item">LC_LOAD_DYLIB</span></span></a></li><li><a class="level is-mobile" href="#LC-MAIN"><span class="level-left"><span class="level-item">LC_MAIN</span></span></a></li><li><a class="level is-mobile" href="#LC-CODE-SIGNATURE与代码签名过程分析"><span class="level-left"><span class="level-item">LC_CODE_SIGNATURE与代码签名过程分析</span></span></a></li><li><a class="level is-mobile" href="#LC-SEGMENT-1"><span class="level-left"><span class="level-item">LC_SEGMENT</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>