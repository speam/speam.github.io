<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>09-分类、类拓展的加载过程 &amp; load、initialize分析 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="09-分类、类拓展的加载过程 &amp; load、initialize分析"><meta property="og:url" content="http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/598829a7d3423334.jpg"><meta property="article:published_time" content="2021-01-25T09:15:45.650Z"><meta property="article:modified_time" content="2021-01-30T11:19:44.032Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/598829a7d3423334.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/598829a7d3423334.jpg"],"datePublished":"2021-01-25T09:15:45.650Z","dateModified":"2021-01-30T11:19:44.032Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/598829a7d3423334.jpg" alt="09-分类、类拓展的加载过程 &amp; load、initialize分析"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T09:15:45.650Z" title="2021-01-25T09:15:45.650Z">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-30T11:19:44.032Z" title="2021-01-30T11:19:44.032Z">2021-01-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">09-分类、类拓展的加载过程 &amp; load、initialize分析</h1><div class="content"><hr>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开始正文前，先看一下runtime相关知识的<strong>运用</strong></p>
<h2 id="ro和rw衍生出来的问题"><a href="#ro和rw衍生出来的问题" class="headerlink" title="ro和rw衍生出来的问题"></a>ro和rw衍生出来的问题</h2><p><strong>1.动态创建类的时候，能否先注册到内存然后再添加成员变量？即下面2、3两步能否调换顺序？</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是正确顺序：</span></span><br><span class="line"><span class="comment">// 1: 动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2: 添加成员变量 </span></span><br><span class="line">class_addIvar(LGPerson, <span class="string">&quot;lgName&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="comment">// 3: 注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br></pre></td></tr></table></figure>

<p>答：不可以</p>
<p>原因：</p>
<p>成员变量存储在ro当中，ro在编译后就不能改了。跟属性不一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125165109291.png"></p>
<p>可以通过跑源码断点调试看一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163145632.png"></p>
<p>注册到内存的<code>objc_registerClassPair</code>方法中会调用<code>changeInfo</code>方法，改变了信息。如果在这之后调用<code>class_addIvar</code>方法，会走到分支中，直接返回NO，导致添加失败。因此顺序不能调换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163436360.png"></p>
<p><strong>2.注意点：动态添加property(成员属性)后，记得要添加相应的getter和setter方法，否则给属性设值会不成功。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br><span class="line"><span class="comment">// 3.添加property</span></span><br><span class="line">lg_class_addProperty(LGPerson, <span class="string">&quot;subject&quot;</span>);</span><br><span class="line"><span class="comment">// 4.添加setter  +  getter 方法</span></span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(setSubject:), (IMP)lgSetter, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(subject), (IMP)lgName, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始使用</span></span><br><span class="line"><span class="keyword">id</span> person = [LGPerson alloc];</span><br><span class="line">[person setValue:<span class="string">@&quot;master&quot;</span> forKey:<span class="string">@&quot;subject&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;subject&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>留意这里的2、3两步，先注册到内存，然后再添加的成员属性</strong>，为什么这里就可以了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125170037342.png"></p>
<p>因为properties存储在rw当中，是可以动态改变的。</p>
<p><strong>3.练习使用api-用runtime动态创建类</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2: 添加成员变量 </span></span><br><span class="line">class_addIvar(LGPerson, <span class="string">&quot;lgName&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="comment">// 3: 注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 3.1 添加property - rw</span></span><br><span class="line">lg_class_addProperty(LGPerson, <span class="string">&quot;subject&quot;</span>);</span><br><span class="line">lg_printerProperty(LGPerson);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 添加setter  +  getter 方法</span></span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(setSubject:), (IMP)lgSetter, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(subject), (IMP)lgName, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始使用</span></span><br><span class="line"><span class="keyword">id</span> person = [LGPerson alloc];</span><br><span class="line">[person setValue:<span class="string">@&quot;KC&quot;</span> forKey:<span class="string">@&quot;lgName&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;lgName&quot;</span>]);</span><br><span class="line"></span><br><span class="line">[person setValue:<span class="string">@&quot;master&quot;</span> forKey:<span class="string">@&quot;subject&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;subject&quot;</span>]);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>带注释的相关api</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建类对</span></span><br><span class="line"><span class="comment"> *superClass: 父类，传Nil会创建一个新的根类</span></span><br><span class="line"><span class="comment"> *name: 类名</span></span><br><span class="line"><span class="comment"> *extraBytes: 0</span></span><br><span class="line"><span class="comment"> *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败</span></span><br><span class="line"><span class="comment">  objc_allocateClassPair(&lt;#Class  _Nullable __unsafe_unretained superclass#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t extraBytes#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *添加成员变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 往哪个类添加</span></span><br><span class="line"><span class="comment"> *name 添加的名字</span></span><br><span class="line"><span class="comment"> *size 大小</span></span><br><span class="line"><span class="comment"> *alignment 对齐处理方式</span></span><br><span class="line"><span class="comment"> *types 签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量。</span></span><br><span class="line"><span class="comment"> *这个类不能是元类。不支持在元类中添加一个实例变量。</span></span><br><span class="line"><span class="comment"> *实例变量的最小对齐为1 &lt;&lt; align。实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))。</span></span><br><span class="line"><span class="comment">  class_addIvar(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t size#&gt;, &lt;#uint8_t alignment#&gt;, &lt;#const char * _Nullable types#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往内存注册类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cls 要注册的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * objc_registerClassPair(&lt;#Class  _Nonnull __unsafe_unretained cls#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往类里面添加方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 要添加方法的类</span></span><br><span class="line"><span class="comment"> *sel 方法编号</span></span><br><span class="line"><span class="comment"> *imp 函数实现指针</span></span><br><span class="line"><span class="comment"> *types 签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *class_addMethod(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;, &lt;#IMP  _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往类里面添加属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 要添加属性的类</span></span><br><span class="line"><span class="comment"> *name 属性名字</span></span><br><span class="line"><span class="comment"> *attributes 属性的属性数组。</span></span><br><span class="line"><span class="comment"> *attriCount 属性中属性的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *class_addProperty(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#const objc_property_attribute_t * _Nullable attributes#&gt;, &lt;#unsigned int attributeCount#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一、初探懒加载类"><a href="#一、初探懒加载类" class="headerlink" title="一、初探懒加载类"></a>一、初探懒加载类</h1><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p>
<h2 id="1-1-类的加载回顾"><a href="#1-1-类的加载回顾" class="headerlink" title="1.1 类的加载回顾"></a>1.1 类的加载回顾</h2><ul>
<li><p><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code>来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></p>
</li>
<li><p><code>_read_images</code></p>
<ul>
<li>主要会进行类的加载工作，会插入 <strong>所有的类</strong> 到 <code>gdb_objc_realized_classes</code> 哈希表中（插入方式为 类名为 <code>key</code>，类对象为<code>value</code>, 不包括通过 <em>共享缓存</em> 里面的类），这个表的类型为 <code>NXMapTable</code>，可以类比为 <code>NSDictionary</code>；同时还会把类插入到 <code>allocatedClasses</code> 这个集合里面，集合的类型为 <code>NXHashTable</code>，可以类比为 <code>NSSet</code>。</li>
<li>对所有的类进行重映射</li>
</ul>
</li>
<li><p>将所有的 <code>SEL</code> 插入到 <code>namedSelectors</code> 哈希表中(插入方式为：<code>SEL</code> 名称为 <code>key</code>，<code>SEL</code> 为<code>value</code>)</p>
<ul>
<li>修复函数指针遗留</li>
<li>将所有的 <code>Protocol</code> 插入到 <code>readProtocol</code> 哈希表中(插入方式为：<code>Protocol</code> 名称为 <code>key</code>，<code>Protocol</code> 为 <code>value</code>)</li>
<li>对所有的 <code>Protocol</code> 做重映射</li>
<li>初始化所有的<strong>非懒加载类</strong>，包括 <code>rw</code> 和 <code>ro</code> 的初始化操作</li>
<li>处理所有的分类(包括类的分类和元类的分类)</li>
</ul>
</li>
</ul>
<h2 id="1-2-验证类的加载流程"><a href="#1-2-验证类的加载流程" class="headerlink" title="1.2 验证类的加载流程"></a>1.2 验证类的加载流程</h2><p>我们大致明白了类的加载流程，接下来，让我们在 <code>_read_images</code> 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。</p>
<blockquote>
<p> <strong>准备代码：有三个非常纯净的类： <code>LGPerson</code> 、 <code>LGStudent</code> 、 <code>LGTeacher</code></strong></p>
<p>其中 <code>LGStudent</code> 和 <code>LGTeacher</code> 内部实现了 <code>+load</code> 方法。而 <code>LGPerson</code> 没有实现 <code>+load</code> 方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126103909231.png"></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210126104001476.png"></p>
<p>如上图所示，我们增加一行代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;_getObjc2NonlazyClassList Class:%s\n&quot;,cls-&gt;mangledName());</span><br></pre></td></tr></table></figure>

<p>接着我们观察打印结果:</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126104032118.png"></p>
<h2 id="1-3-懒加载类的发现"><a href="#1-3-懒加载类的发现" class="headerlink" title="1.3 懒加载类的发现"></a>1.3 懒加载类的发现</h2><p>我们这个时候观察 <code>_read_images</code> 源码这部分的注释:</p>
<blockquote>
<p>Realize non-lazy classes (for +load methods and static instances)</p>
<p>实现<strong>非懒加载</strong>类(实现了 <code>+load</code> 方法和静态实例)</p>
</blockquote>
<p>意思就是没有实现 <code>+load</code> 方法的类就是**懒加载类，这种类并不会在 **<code>_read_images</code> 环节被加载。我们自己实现了 <code>+load</code> 方法的两个类和其他系统内置的类由于是<code>非懒加载类</code>，所以会在这里打印。</p>
<p>那么<code>懒加载类</code>应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送 <code>alloc</code> 消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会走消息的慢速查找过程，然后就来到一个非常重要的方法：<code>lookUpImpOrForward</code> ，我们在 <code>main.m</code> 中 <code>LGPerson</code> 类初始化的地方和 <code>lookUpImpOrForward</code> 入口处打上断点:</p>
<blockquote>
<p>Tips: 这里有个小技巧，我们先打开 <code>main.m</code> 文件中<code>lookUpImpOrForward</code> 处的断点的断点，等断点来到了我们想要探索的 <code>LGPerson</code> 初始化的位置的时候，我们再打开 <code>lookUpImpOrForward</code> 处的断点，这样才能确保当前执行 <code>lookUpImpOrForward</code> 的是我们的研究对象 <code>LGPerson</code></p>
</blockquote>
<p>因为我们断点的位置是 <code>LGPerson</code> 类发送 <code>alloc</code> 消息，而显然 <code>alloc</code> 作为类方法是存储在元类上的，也就是说 <code>lookUpImpOrForward</code> 的 <code>cls</code> 其实是 <code>LGPerson</code> 元类。那么 <code>inst</code> 就应该是真正的<code>LGPerson</code>类对象，可实际如下图所示：（未初始化所以看不出是哪个类）</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155652396.png"></p>
<p>此时的 <code>inst</code> 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码:</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155642632.png"></p>
<p>这里的 <code>if</code> 判断通过方法名我们不难看出是只有当 <code>cls</code> 未实现的时候才会走里面的<code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法，那也就是说 <code>LGPerson</code> 元类没有被实现，也就是 <code>LGPerson</code> 类没有实现或者说没有被加载。</p>
<p>我们就顺着 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, <span class="keyword">bool</span> leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls = realizeSwiftClass(cls);</span><br><span class="line">        assert(cls-&gt;isRealized());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一路跟随断点来到了 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法，然后我们看到了我们熟悉的一个方法 <code>realizeClassWithoutSwift</code> ，这个方法内部会进行 <code>ro/rw</code> 的赋值操作以及 <code>category</code> 的 <code>attatch</code> ，关于这个方法更多内容可以查看上一篇文章。</p>
<p>接着我们返回到 <code>lookUpImpOrForward</code> 方法中来，然后进行一下 <code>LLDB</code> 打印，看一下当前这个 <code>inst</code> 也就是 <code>LGPerson</code> 对象是否已经被加载了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126193022790.png"></p>
<p>通过上面的打印，我们可以看到 <code>rw</code> 已经有值了，也就是说 <code>LGPerson</code> 类被加载了。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类（用到再加载）</strong></p>
</li>
<li><p>如果类实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类（提前加载）</strong>。</p>
</li>
</ul>
<p>调用堆栈如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210126194311796.png"></p>
<h2 id="1-4-懒加载类的流程"><a href="#1-4-懒加载类的流程" class="headerlink" title="1.4 懒加载类的流程"></a>1.4 懒加载类的流程</h2><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p>
<ul>
<li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> （这个方法在<a target="_blank" rel="noopener" href="https://www.evilimo.com/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/#more">05-方法的本质和消息查找流程</a>已经分析过了）</li>
<li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法在学习 <code>Runtime</code> 的过程中非常重要！</li>
<li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li>
<li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li>
<li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，最终懒加载的类就在这里加载</li>
</ul>
<h1 id="二、分类的底层实现"><a href="#二、分类的底层实现" class="headerlink" title="二、分类的底层实现"></a>二、分类的底层实现</h1><p>类分为<code>懒加载类</code>和<code>非懒加载类</code>，分类同样分为<code>懒加载分类</code>和<code>非懒加载分类</code>。在研究分类之前，我们首先需要了解下分类的底层实现。</p>
<h2 id="2-1-重写分类源文件"><a href="#2-1-重写分类源文件" class="headerlink" title="2.1 重写分类源文件"></a>2.1 重写分类源文件</h2><p>首先准备一份<code>LGTeacher+test.m</code>文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126195823741.png"></p>
<p>在终端中用 <code>clang</code> 命令重写这个分类文件为c++文件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc LGTeacher+test.m -o category.cpp</span><br></pre></td></tr></table></figure>

<p>然后查看 <code>category.cpp</code> 这个文件，来到文件尾部可以看到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_LGTeacher_</span>$_<span class="title">test</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="string">&quot;LGTeacher&quot;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_LGTeacher,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>LGTeacher+test</code> 分类在底层的实现是一个结构体，其名字为 <code>_OBJC_$_CATEGORY_LGTeacher_$_test</code> ，很明显这是一个按规则生成的符号，中间的 <code>LGTeacher</code> 是类名，后面的 <code>test</code> 是分类的名字。</p>
<p>同时，我们在后面可以看到如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这表明分类是存储在 <code>__DATA</code> 段的 <code>__objc_catlist</code> section 里面的。</p>
<h2 id="2-2-分类的定义"><a href="#2-2-分类的定义" class="headerlink" title="2.2 分类的定义"></a>2.2 分类的定义</h2><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p>
<ul>
<li><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</li>
<li><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</li>
<li><code>instanceMethods</code> : 分类上存储的实例方法</li>
<li><code>classMethods</code> ：分类上存储的类方法</li>
<li><code>protocols</code> ：分类所实现的协议</li>
<li><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</li>
<li><code>_classProperties</code> ：分类所定义的类属性。</li>
</ul>
<h1 id="三、分类的加载"><a href="#三、分类的加载" class="headerlink" title="三、分类的加载"></a>三、分类的加载</h1><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，分类同样分为<code>懒加载分类</code>和<code>非懒加载分类</code>。</p>
<blockquote>
<p>分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。</p>
</blockquote>
<p>接下来开始研究：</p>
<h2 id="3-1-懒加载分类"><a href="#3-1-懒加载分类" class="headerlink" title="3.1 懒加载分类"></a>3.1 懒加载分类</h2><p>没有实现 load 的分类-&gt;没有提前加载，所以是<code>懒加载分类</code>。</p>
<h3 id="3-1-1-懒加载分类-懒加载类"><a href="#3-1-1-懒加载分类-懒加载类" class="headerlink" title="3.1.1 懒加载分类 + 懒加载类"></a>3.1.1 懒加载分类 + 懒加载类</h3><p>也就是类和分类都不实现 <code>load</code> 方法的情况。</p>
<h4 id="懒加载类"><a href="#懒加载类" class="headerlink" title="懒加载类"></a>懒加载类</h4><p>前面分析过了，在向类<strong>第一次发送消息</strong>的时候，懒加载类才会开始加载。</p>
<h4 id="懒加载分类"><a href="#懒加载分类" class="headerlink" title="懒加载分类"></a>懒加载分类</h4><p>探索：在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方，猜测懒加载分类是不是在这里加载了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201719382.png"></p>
<p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类。此时通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201728689.png"></p>
<p>此时 <code>LGTeacher</code> 类里面是没有方法的，这里读取 <code>rw</code> 却有一个结果，我们不难看出这是位于 <code>LGTeacher+test</code> 分类中的一个 <code>initialize</code> 方法，这个方法是我手动加到这个分类的。</p>
<p>这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201919490.png"></p>
<p>突然想起来，不是在 <code>_read_images</code> 的最后那块有一个 <code>Discover categories</code> 吗，万一懒加载分类是在这里加载的呢？我们一试便知：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155604526.png"></p>
<p>这里在 <code>Discover categories</code> 内部做了一下判断，如果是 <code>LGTeacher</code> 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的，是在编译时直接加载的。</p>
<h3 id="3-1-2-懒加载分类-非懒加载类"><a href="#3-1-2-懒加载分类-非懒加载类" class="headerlink" title="3.1.2 懒加载分类+非懒加载类"></a>3.1.2 懒加载分类+非懒加载类</h3><h4 id="非懒加载类"><a href="#非懒加载类" class="headerlink" title="非懒加载类"></a>非懒加载类</h4><p>当类为<code>非懒加载类</code>的时候，同样是走 <code>_read_images</code> =&gt;<code>Realize non-lazy classes</code>=&gt;<code>realizeClassWithoutSwift</code>=&gt;<code>methodizeClass</code>。</p>
<h4 id="懒加载分类-1"><a href="#懒加载分类-1" class="headerlink" title="懒加载分类"></a>懒加载分类</h4><p>我们直接在 <code>methodizeClass</code> 方法中打上断点，并做了一下简单的判断:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cname = ro-&gt;name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *oname = <span class="string">&quot;LGTeacher&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cname, oname) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;methodizeClass :%s \n&quot;</span>,cname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果可以看到cats为空，所以分类不在这进行添加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127111718624.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210127111712706.png"></p>
<p>同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，说明<code>懒加载的分类</code>在编译时期就被加载了。</p>
<h3 id="3-1-3-懒加载分类总结"><a href="#3-1-3-懒加载分类总结" class="headerlink" title="3.1.3 懒加载分类总结"></a>3.1.3 懒加载分类总结</h3><ul>
<li><code>懒加载分类</code>的初始化其实跟类的懒加载与否并没有关系，也就是说<code>懒加载的分类</code>都是在编译时期被加载的。</li>
<li>懒加载类和非懒加载类还是1.3中所述的流程。</li>
</ul>
<h2 id="3-2-非懒加载分类"><a href="#3-2-非懒加载分类" class="headerlink" title="3.2 非懒加载分类"></a>3.2 非懒加载分类</h2><p>实现了 load 的分类-&gt;提前加载，所以是<code>非懒加载分类</code></p>
<p>他和类配合加载分下面两种情况：</p>
<ul>
<li>非懒加载分类与懒加载类</li>
<li>非懒加载分类和非懒加载类</li>
</ul>
<h3 id="3-2-1-非懒加载分类-懒加载类"><a href="#3-2-1-非懒加载分类-懒加载类" class="headerlink" title="3.2.1 非懒加载分类 + 懒加载类"></a>3.2.1 非懒加载分类 + 懒加载类</h3><p>懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<code>lookupImpOrForward</code> =&gt;<code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203136054.png"></p>
<p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203231115.png"></p>
<p>但是我们注意观察此时的调用堆栈：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203313361.png"></p>
<p>为什么走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203607376.png"></p>
<p>可以看到，其实在这里调用了 <code>realizeClassWithoutSwift</code> 方法来提前加载类。</p>
<p>而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取到所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。</p>
<p>这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么类就是在 <code>load_images</code> =&gt; <code>prepare_load_methods</code> =&gt; <code>realizeClassWithoutSwift</code> 加载的。</p>
<p>分类的加载在类加载之后的 <code>methodizeClass</code>。</p>
<h3 id="3-2-2-非懒加载分类-非懒加载类"><a href="#3-2-2-非懒加载分类-非懒加载类" class="headerlink" title="3.2.2 非懒加载分类 + 非懒加载类"></a>3.2.2 非懒加载分类 + 非懒加载类</h3><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载。而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127084924084.png"></p>
<p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127085121289.png"></p>
<p>因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 <code>remethodizeClass</code> 方法，我们进入其内部实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">&quot;(meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有一个 <code>attachCategories</code> 方法，断点也确实来到了这个地方，所以非懒加载分类在这里加载。 </p>
<h3 id="3-2-3-非懒加载分类总结"><a href="#3-2-3-非懒加载分类总结" class="headerlink" title="3.2.3 非懒加载分类总结"></a>3.2.3 非懒加载分类总结</h3><ul>
<li><p>非懒加载分类 + 懒加载类</p>
<p>类的加载在 <code>load_images</code> 处 ，分类的加载在类加载之后的 <code>methodizeClass</code></p>
</li>
<li><p>非懒加载分类 + 非懒加载类</p>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
</li>
</ul>
<h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>感觉非常绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p>
<ul>
<li>没有实现 <code>load</code> 方法的分类（不需提前加载-懒加载分类）由<strong>编译时</strong>确定</li>
<li>实现了 <code>load</code> 方法的分类（需提前加载-非懒加载分类）由<strong>运行时</strong>去确定</li>
</ul>
<p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p>
<ul>
<li>懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>非懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155534997.png"></p>
</blockquote>
<ul>
<li>非懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155520899.png"></p>
</blockquote>
<h1 id="四、类拓展的加载"><a href="#四、类拓展的加载" class="headerlink" title="四、类拓展的加载"></a>四、类拓展的加载</h1><p>类拓展<code>extension</code>又称作<code>匿名的分类</code>，为了给当前类增加<code>属性</code>和<code>方法</code></p>
<p>具体有两种形式：</p>
<ul>
<li>直接在<code>.m</code>文件中新增类拓展</li>
<li>新建类拓展的<code>.h</code>文件</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180008631.png"></p>
<h2 id="4-1-类拓展的加载"><a href="#4-1-类拓展的加载" class="headerlink" title="4.1 类拓展的加载"></a>4.1 类拓展的加载</h2><p>数据很早的时候都会来到<code>_read_image</code>，在这里断点分析一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180024002.png"></p>
<p>但是仔细一想不对呀，已经在类中有了方法实现了，此时的<code>do_hExtension</code>不足以说明问题</p>
<p>那么可以通过查看属性的<code>setter</code>和<code>getter</code>方法来验证</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180039486.png"></p>
<p>在来到<code>_read_image</code>方法之前就有了相应的getter和setter，说明</p>
<ul>
<li>类拓展在编译时便作为类的一部分进行编译，存到类的ro中</li>
</ul>
<h2 id="4-2-类拓展的细节点"><a href="#4-2-类拓展的细节点" class="headerlink" title="4.2 类拓展的细节点"></a>4.2 类拓展的细节点</h2><p>如果类拓展没有被引用（#import）-在代码中没有被用到，就不会编译到到内存中</p>
<h1 id="五、load-image分析"><a href="#五、load-image分析" class="headerlink" title="五、load_image分析"></a>五、load_image分析</h1><p>上篇文章讲到<code>dyld初始化image</code>会触发<code>load_image</code>，本文又提到了<code>懒加载类</code>和<code>非懒加载分类</code>情况下，分类加载到内存时的调用栈中有<code>load_image</code>，那么我们在该种情况下进行探索。</p>
<p>在<code>load_image</code>实现处打下断点，发现类和分类都没有打印<code>+load</code>方法——<code>load_image</code>先于<code>+load</code>方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180051663.png"></p>
<p>接着把目光移向两条注释：</p>
<ul>
<li>Discover load methods——<code>prepare_load_methods</code></li>
<li>Call +load methods——<code>call_load_methods</code></li>
</ul>
<h2 id="5-1-prepare-load-methods"><a href="#5-1-prepare-load-methods" class="headerlink" title="5.1 prepare_load_methods"></a>5.1 prepare_load_methods</h2><p>发现并准备<code>+load</code>方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Swift class extensions and categories on Swift &quot;</span></span><br><span class="line">                        <span class="string">&quot;classes are not allowed to have +load methods&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">        add_category_to_loadable_list(cat);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass);</span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls);</span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    method = cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don&#x27;t bother if cls has no +load method</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;LOAD: class &#x27;%s&#x27; scheduled for +load&quot;</span>, </span><br><span class="line">                     cls-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prepare_load_methods</code>分析：</p>
<ul>
<li><p>通过<code>_getObjc2NonlazyClassList</code>获取<code>非懒加载类</code>列表</p>
</li>
<li><p>通过<code>schedule_class_load</code>遍历这些类</p>
<ul>
<li><p>递归调用遍历父类的<code>+load</code>方法，确保父类的<code>+load</code>方法顺序排在子类的前面</p>
</li>
<li><p>调用<code>add_class_to_loadable_list</code>把类的<code>+load</code>方法存在<code>loadable_classes</code>里面</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180104279.png"></p>
</li>
</ul>
</li>
<li><p>调用<code>_getObjc2NonlazyCategoryList</code>取出<code>非懒加载分类</code>列表</p>
</li>
<li><p>遍历分类列表</p>
<ul>
<li><p>通过<code>realizeClassWithoutSwift</code>来防止类没有初始化（若已经初始化了则不影响）</p>
</li>
<li><p>调用<code>add_category_to_loadable_list</code>加载分类中的<code>+load</code>方法到<code>loadable_categories</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180112390.png"></p>
</li>
</ul>
</li>
</ul>
<p>此时就能看懂之前<code>懒加载类</code>和<code>非懒加载分类</code>的函数调用栈了</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180123734.png"></p>
<h2 id="5-2-call-load-methods"><a href="#5-2-call-load-methods" class="headerlink" title="5.2 call_load_methods"></a>5.2 call_load_methods</h2><p>唤醒<code>+load</code>方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren&#x27;t any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>objc_autoreleasePoolPush</code>压栈一个自动释放池</li>
<li><code>do-while</code>循环开始<ul>
<li>循环调用类的<code>+load</code>方法直到找不到为止</li>
<li>调用一次分类中的<code>+load</code>方法</li>
</ul>
</li>
<li>通过<code>objc_autoreleasePoolPop</code>出栈一个自动释放池</li>
</ul>
<h2 id="5-3-关于load方法我们需要知道的"><a href="#5-3-关于load方法我们需要知道的" class="headerlink" title="5.3 关于load方法我们需要知道的"></a>5.3 关于load方法我们需要知道的</h2><ul>
<li>load方法在main函数前调用</li>
<li>如果一个类实现了load方法，在调用这个方法前会先调用父类的load方法</li>
<li>因为加载时间特别早，所以可以利用这个特性进行一些特殊处理</li>
</ul>
<h1 id="六、initalize分析"><a href="#六、initalize分析" class="headerlink" title="六、initalize分析"></a>六、initalize分析</h1><p>关于<code>initalize</code>苹果文档是这么描述的</p>
<blockquote>
<p>1.在类或者其子类的第一个方法被调用前（发送消息前）调用<br>2.父类的调用在子类之前<br>补充：通常应该在里面判断当前要初始化的类，防止多次调用</p>
</blockquote>
<p>然后我们在<code>objc源码</code>中<code>lookUpImpOrForward</code>找到了它的踪迹</p>
<p><code>lookUpImpOrForward</code>-&gt;<code>initializeAndLeaveLocked</code>-&gt;<code>initializeAndMaybeRelock</code>-&gt;<code>initializeNonMetaClass</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        cls = initializeAndLeaveLocked(cls, inst, runtimeLock);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">initializeAndLeaveLocked</span><span class="params">(Class cls, id obj, <span class="keyword">mutex_t</span>&amp; lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> initializeAndMaybeRelock(cls, obj, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">initializeAndMaybeRelock</span><span class="params">(Class cls, id inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">mutex_t</span>&amp; lock, <span class="keyword">bool</span> leaveLocked)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    initializeNonMetaClass(nonmeta);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>initializeNonMetaClass</code>递归调用父类的<code>initialize</code>，然后调用<code>callInitialize</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;***********************************************************************</span><br><span class="line">* class_initialize.  Send the &#39;+initialize&#39; message on demand to any</span><br><span class="line">* uninitialized class. Force initialization of superclasses first.</span><br><span class="line">**********************************************************************&#x2F;</span><br><span class="line">void initializeNonMetaClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    supercls &#x3D; cls-&gt;superclass;</span><br><span class="line">    if (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        initializeNonMetaClass(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">            callInitialize(cls);</span><br><span class="line"></span><br><span class="line">            if (PrintInitializing) &#123;</span><br><span class="line">                _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;,</span><br><span class="line">                             pthread_self(), cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callInitialize</code>是一个普通的<code>消息发送</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callInitialize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ((<span class="keyword">void</span>(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>initialize</code>在类或者其子类的第一个方法被调用前（发送消息前）调用</li>
<li>只在类中添加<code>initialize</code>但不使用的情况下，是不会调用<code>initialize</code></li>
<li>父类的<code>initialize</code>方法会比子类先执行</li>
<li>当子类未实现<code>initialize</code>方法时，会调用父类<code>initialize</code>方法；子类实现<code>initialize</code>方法时，会覆盖父类<code>initialize</code>方法</li>
<li>当有多个分类都实现了<code>initialize</code>方法，会覆盖类中的方法，只执行一个(会执行最后被加载到内存中的分类的方法)</li>
</ul>
<h1 id="七、相关面试题"><a href="#七、相关面试题" class="headerlink" title="七、相关面试题"></a>七、相关面试题</h1><h2 id="7-1-类拓展和分类的区别"><a href="#7-1-类拓展和分类的区别" class="headerlink" title="7.1 类拓展和分类的区别"></a>7.1 类拓展和分类的区别</h2><p><strong>①区别：</strong></p>
<ul>
<li>类拓展可以添加属性(编译器会帮助我们生成属性对应的get和set方法)，方法</li>
<li>分类只能添加方法，通常不能添加属性（添加的话需要使用关联对象）</li>
<li>原因：类拓展在编译时完成加载，数据写入到ro中；而分类在运行时加载，所以数据写入到rw中，没有实现对应的set和get方法，所以无法将属性的值赋值进去，也无法取到。</li>
</ul>
<p><strong>②类拓展在代码实现形式有2种方式，第一种写到所在本类的.m文件中，第二种另一个单写一个.h文件。</strong></p>
<p>常用第一种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180143758.png"></p>
<p>第二种：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180159732.png"></p>
<p>**③加载时机的区别： **</p>
<p>在类的加载过程中—read_images处设置断点，运行进入断点，打印发现ro中包含类拓展的属性和相应的get，set方法，可以判断出类拓展在编译时就加载了。而此时类加载后没有分类的信息，由此可以判断分类是在运行时加载进来的。</p>
<p>下图断点信息图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180213377.png"></p>
<p>下图ro中查找信息图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180224188.png"></p>
<p><strong>④类拓展和分类的区别</strong></p>
<table>
<thead>
<tr>
<th>研究对象</th>
<th>加载时机</th>
<th>操作对象</th>
<th>能否通过@property声明属性生成 getter 和 setter</th>
</tr>
</thead>
<tbody><tr>
<td>分类(实现了load方法)</td>
<td>运行时</td>
<td>rw</td>
<td>不能，需要借助关联对象来实现</td>
</tr>
<tr>
<td>分类(没有实现load方法)</td>
<td>编译时</td>
<td>ro</td>
<td>不能，需要借助关联对象来实现</td>
</tr>
<tr>
<td>类拓展</td>
<td>编译时</td>
<td>ro</td>
<td>可以</td>
</tr>
</tbody></table>
<h2 id="7-2-分类中可以通过关联对象添加属性"><a href="#7-2-分类中可以通过关联对象添加属性" class="headerlink" title="7.2 分类中可以通过关联对象添加属性"></a>7.2 分类中可以通过关联对象添加属性</h2><h3 id="7-2-1-关联对象的定义和基本使用"><a href="#7-2-1-关联对象的定义和基本使用" class="headerlink" title="7.2.1 关联对象的定义和基本使用"></a>7.2.1 关联对象的定义和基本使用</h3><blockquote>
<p>模拟了将对象实例变量添加到已经存在的类中。通过使用关联引用，你可以在不修改类声明的前提下为对象添加内容。如果你无权访问该类的源代码，或者由于二进制兼容性原因而无法更改该对象的布局，则这可能很有用。</p>
<p>关联引用机制基于 <code>key</code>。对于任何对象，你都可以根据需要添加任意数量的关联引用，每个关联都使用不同的 <code>key</code>。关联引用还可以确保关联的对象至少在源对象的声明周期内保持有效。</p>
</blockquote>
<p>从苹果官方文档可以看到，关联引用其实不是只能在分类中使用，只不过对于我们日常开发来说，分类中使用关联引用还是更常用的场景。相信大多数开发者都知道怎么使用关联引用，的确，关联引用使用起来很简单，不外乎两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置关联对象</span></span><br><span class="line">objc_setAssociatedObject()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取关联对象</span></span><br><span class="line">objc_getAssociatedObject()</span><br></pre></td></tr></table></figure>

<p>我们如果要给一个分类中的属性设置关联对象，需要重写属性的 <code>setter</code> 方法，然后使用 <code>objc_setAssociatedObject</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setXXX:(关联值数据类型)关联值</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, 关联的key, 关联值, 关联对象内存管理策略);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后还需要重写 <code>getter</code> 方法，然后使用 <code>objc_getAssociatedObject</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (关联值数据类型)关联值&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, 关联的key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这其中的关联对象内存管理策略如下表所示：</p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等同的 @property</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。</td>
<td>指定一个关联对象的弱引用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (nonatomic, strong)</td>
<td>指定一个关联对象的强引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (nonatomic, copy)</td>
<td>指定一个关联对象的copy引用，不能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (atomic, strong)</td>
<td>指定一个关联对象的强引用，能被原子化使用。</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (atomic, copy)</td>
<td>指定一个关联对象的copy引用，能被原子化使用。</td>
</tr>
</tbody></table>
<h3 id="7-2-3-关联对象的底层原理"><a href="#7-2-3-关联对象的底层原理" class="headerlink" title="7.2.3 关联对象的底层原理"></a>7.2.3 关联对象的底层原理</h3><p>总结图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180256952.png"></p>
<h4 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc-runtime.mm</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span> </span>&#123;</span><br><span class="line">    _object_set_associative_reference(object, (<span class="keyword">void</span> *)key, value, policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>objc_setAssociatedObject</code> 方法的实现又包裹了一层，其实现为 <code>_object_set_associative_reference</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210130180316201.jpeg"></p>
<p>分析<code>_object_set_associative_reference</code>方法，直接看添加注释后的代码就能明白：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(id object, <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy) &#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="comment">// 容错处理</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    assert(object);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断要进行关联的对象是否禁用掉了关联引用</span></span><br><span class="line">    <span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">        _objc_fatal(<span class="string">&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;</span>, object, object_getClassName(object));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    <span class="comment">// 初始化一个 ObjcAssociation 对象，用于持有原有的关联对象</span></span><br><span class="line">    <span class="function">ObjcAssociation <span class="title">old_association</span><span class="params">(<span class="number">0</span>, nil)</span></span>;</span><br><span class="line">    <span class="comment">// 判断传入的关联对象值是否存在</span></span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关联对象的管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 获取关联的 HashMap -&gt; 存储当前关联对象</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="comment">// 对当前对象的地址做按位取反操作 - 就是 HashMap 的key (哈希函数)</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            <span class="comment">// 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                <span class="comment">// 根据key去获取关联属性的迭代器</span></span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    <span class="comment">// 替换设置新值</span></span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 到最后了——直接设置新值</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                <span class="comment">// 如果AssocistionsHashMap没有对象的关联信息表</span></span><br><span class="line">                <span class="comment">// 那么就创建一个map并通过传入的key把value存进去</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            <span class="comment">// 如果传入的value是nil，并且之前使用相同的key存储过关联对象，</span></span><br><span class="line">            <span class="comment">// 那么就把这个关联的value移除（这也是为什么传入nil对象能够把对象的关联value移除）</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="comment">// 最后把之前使用传入的这个key存储的关联的value释放（OBJC_ASSOCIATION_SETTER_RETAIN策略存储的）</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _object_get_associative_reference(object, (<span class="keyword">void</span> *)key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样也是包装了一层，分析<code>_object_get_associative_reference</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(id object, <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    <span class="keyword">uintptr_t</span> policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关联对象的管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="comment">// 生成伪装地址。处理参数 object 地址</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="comment">// 所有对象的额迭代器</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;  <span class="comment">// 还没到最后就找到了</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="comment">// 内部对象的迭代器</span></span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                <span class="comment">// 找到 - 把值和策略读取出来</span></span><br><span class="line">                ObjcAssociation &amp;entry = j-&gt;second;</span><br><span class="line">                value = entry.value();</span><br><span class="line">                policy = entry.policy();</span><br><span class="line">                <span class="comment">// 如果策略是 OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下</span></span><br><span class="line">                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) &#123;</span><br><span class="line">                    objc_retain(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        objc_autorelease(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h4><p><code>objc_removeAssociatedObjects</code> 方法我们平时可能用的不多，这个方法是用来删除关联对象。我们来到它的定义处：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        _object_remove_assocations(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析<code>_object_remove_assocations</code>方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_remove_assocations(id object) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关联对象的管理类</span></span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="comment">// 获取关联的 HashMap -&gt; 存储当前关联对象</span></span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.associations())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 对当前对象的地址做按位取反操作</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t</span> disguised_object = DISGUISE(object);</span><br><span class="line">        <span class="comment">// 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历</span></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;  <span class="comment">// 还没到最后找到了</span></span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push_back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            <span class="keyword">delete</span> refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    <span class="comment">// 这里会将对象包含的所有关联对象加入到一个 `vector` 中，然后对所有的 `ObjcAssociation` 对象调用 `ReleaseValue()` 方法，释放不再被需要的值</span></span><br><span class="line">    for_each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h3 id="objc4-756-2源码"><a href="#objc4-756-2源码" class="headerlink" title="objc4-756.2源码"></a>objc4-756.2源码</h3><p>本文使用：<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">objc4-756.2源码</a> 进行分析</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904049544790030">iOS 底层探索 - 分类的加载</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904072403910664#heading-11">iOS探索 分类、类拓展的加载过程</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904052103479309#heading-4">iOS 底层探索 - 类拓展和关联对象</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><span class="level-item">08-类的加载过程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ro和rw衍生出来的问题"><span class="level-left"><span class="level-item">ro和rw衍生出来的问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#一、初探懒加载类"><span class="level-left"><span class="level-item">一、初探懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-类的加载回顾"><span class="level-left"><span class="level-item">1.1 类的加载回顾</span></span></a></li><li><a class="level is-mobile" href="#1-2-验证类的加载流程"><span class="level-left"><span class="level-item">1.2 验证类的加载流程</span></span></a></li><li><a class="level is-mobile" href="#1-3-懒加载类的发现"><span class="level-left"><span class="level-item">1.3 懒加载类的发现</span></span></a></li><li><a class="level is-mobile" href="#1-4-懒加载类的流程"><span class="level-left"><span class="level-item">1.4 懒加载类的流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、分类的底层实现"><span class="level-left"><span class="level-item">二、分类的底层实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-重写分类源文件"><span class="level-left"><span class="level-item">2.1 重写分类源文件</span></span></a></li><li><a class="level is-mobile" href="#2-2-分类的定义"><span class="level-left"><span class="level-item">2.2 分类的定义</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、分类的加载"><span class="level-left"><span class="level-item">三、分类的加载</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-懒加载分类"><span class="level-left"><span class="level-item">3.1 懒加载分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-懒加载分类-懒加载类"><span class="level-left"><span class="level-item">3.1.1 懒加载分类 + 懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#懒加载类"><span class="level-left"><span class="level-item">懒加载类</span></span></a></li><li><a class="level is-mobile" href="#懒加载分类"><span class="level-left"><span class="level-item">懒加载分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-1-2-懒加载分类-非懒加载类"><span class="level-left"><span class="level-item">3.1.2 懒加载分类+非懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#非懒加载类"><span class="level-left"><span class="level-item">非懒加载类</span></span></a></li><li><a class="level is-mobile" href="#懒加载分类-1"><span class="level-left"><span class="level-item">懒加载分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-1-3-懒加载分类总结"><span class="level-left"><span class="level-item">3.1.3 懒加载分类总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-非懒加载分类"><span class="level-left"><span class="level-item">3.2 非懒加载分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-非懒加载分类-懒加载类"><span class="level-left"><span class="level-item">3.2.1 非懒加载分类 + 懒加载类</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-非懒加载分类-非懒加载类"><span class="level-left"><span class="level-item">3.2.2 非懒加载分类 + 非懒加载类</span></span></a></li><li><a class="level is-mobile" href="#3-2-3-非懒加载分类总结"><span class="level-left"><span class="level-item">3.2.3 非懒加载分类总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-3-总结"><span class="level-left"><span class="level-item">3.3 总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、类拓展的加载"><span class="level-left"><span class="level-item">四、类拓展的加载</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-类拓展的加载"><span class="level-left"><span class="level-item">4.1 类拓展的加载</span></span></a></li><li><a class="level is-mobile" href="#4-2-类拓展的细节点"><span class="level-left"><span class="level-item">4.2 类拓展的细节点</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、load-image分析"><span class="level-left"><span class="level-item">五、load_image分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#5-1-prepare-load-methods"><span class="level-left"><span class="level-item">5.1 prepare_load_methods</span></span></a></li><li><a class="level is-mobile" href="#5-2-call-load-methods"><span class="level-left"><span class="level-item">5.2 call_load_methods</span></span></a></li><li><a class="level is-mobile" href="#5-3-关于load方法我们需要知道的"><span class="level-left"><span class="level-item">5.3 关于load方法我们需要知道的</span></span></a></li></ul></li><li><a class="level is-mobile" href="#六、initalize分析"><span class="level-left"><span class="level-item">六、initalize分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#七、相关面试题"><span class="level-left"><span class="level-item">七、相关面试题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-类拓展和分类的区别"><span class="level-left"><span class="level-item">7.1 类拓展和分类的区别</span></span></a></li><li><a class="level is-mobile" href="#7-2-分类中可以通过关联对象添加属性"><span class="level-left"><span class="level-item">7.2 分类中可以通过关联对象添加属性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-2-1-关联对象的定义和基本使用"><span class="level-left"><span class="level-item">7.2.1 关联对象的定义和基本使用</span></span></a></li><li><a class="level is-mobile" href="#7-2-3-关联对象的底层原理"><span class="level-left"><span class="level-item">7.2.3 关联对象的底层原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#objc-setAssociatedObject"><span class="level-left"><span class="level-item">objc_setAssociatedObject</span></span></a></li><li><a class="level is-mobile" href="#objc-getAssociatedObject"><span class="level-left"><span class="level-item">objc_getAssociatedObject</span></span></a></li><li><a class="level is-mobile" href="#objc-removeAssociatedObjects"><span class="level-left"><span class="level-item">objc_removeAssociatedObjects</span></span></a></li></ul></li></ul></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#objc4-756-2源码"><span class="level-left"><span class="level-item">objc4-756.2源码</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>