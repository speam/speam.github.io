<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>09-分类的加载过程 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="09-分类的加载过程"><meta property="og:url" content="http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125165109291.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163145632.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163436360.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125170037342.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126193022790.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210126194311796.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126195823741.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201719382.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201728689.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201919490.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155604526.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127111718624.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210127111712706.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203136054.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203231115.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203313361.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203607376.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127084924084.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127085121289.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155534997.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155520899.png"><meta property="article:published_time" content="2021-01-25T09:15:45.650Z"><meta property="article:modified_time" content="2021-01-27T07:59:49.726Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125165109291.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125165109291.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163145632.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163436360.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125170037342.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126193022790.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210126194311796.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126195823741.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201719382.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201728689.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201919490.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155604526.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127111718624.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210127111712706.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203136054.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203231115.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203313361.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203607376.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127084924084.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127085121289.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155534997.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155520899.png"],"datePublished":"2021-01-25T09:15:45.650Z","dateModified":"2021-01-27T07:59:49.726Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-25T09:15:45.650Z" title="2021-01-25T09:15:45.650Z">2021-01-25</time>发表</span><span class="level-item"><time dateTime="2021-01-27T07:59:49.726Z" title="2021-01-27T07:59:49.726Z">2021-01-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">09-分类的加载过程</h1><div class="content"><hr>
<a id="more"></a>

<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开始正文前，先看一下runtime相关知识的<strong>运用</strong></p>
<h2 id="ro和rw衍生出来的问题"><a href="#ro和rw衍生出来的问题" class="headerlink" title="ro和rw衍生出来的问题"></a>ro和rw衍生出来的问题</h2><p><strong>1.动态创建类的时候，能否先注册到内存然后再添加成员变量？即下面2、3两步能否调换顺序？</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是正确顺序：</span></span><br><span class="line"><span class="comment">// 1: 动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2: 添加成员变量 </span></span><br><span class="line">class_addIvar(LGPerson, <span class="string">&quot;lgName&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="comment">// 3: 注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br></pre></td></tr></table></figure>

<p>答：不可以</p>
<p>原因：</p>
<p>成员变量存储在ro当中，ro在编译后就不能改了。跟属性不一样</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125165109291.png"></p>
<p>可以通过跑源码断点调试看一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163145632.png"></p>
<p>注册到内存的<code>objc_registerClassPair</code>方法中会调用<code>changeInfo</code>方法，改变了信息。如果在这之后调用<code>class_addIvar</code>方法，会走到分支中，直接返回NO，导致添加失败。因此顺序不能调换。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125163436360.png"></p>
<p><strong>2.注意点：动态添加property(成员属性)后，记得要添加相应的getter和setter方法，否则给属性设值会不成功。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2.注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br><span class="line"><span class="comment">// 3.添加property</span></span><br><span class="line">lg_class_addProperty(LGPerson, <span class="string">&quot;subject&quot;</span>);</span><br><span class="line"><span class="comment">// 4.添加setter  +  getter 方法</span></span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(setSubject:), (IMP)lgSetter, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(subject), (IMP)lgName, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始使用</span></span><br><span class="line"><span class="keyword">id</span> person = [LGPerson alloc];</span><br><span class="line">[person setValue:<span class="string">@&quot;master&quot;</span> forKey:<span class="string">@&quot;subject&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;subject&quot;</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>留意这里的2、3两步，先注册到内存，然后再添加的成员属性</strong>，为什么这里就可以了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210125170037342.png"></p>
<p>因为properties存储在rw当中，是可以动态改变的。</p>
<p><strong>3.练习使用api-用runtime动态创建类</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1: 动态创建类</span></span><br><span class="line">Class LGPerson = objc_allocateClassPair([<span class="built_in">NSObject</span> <span class="keyword">class</span>], <span class="string">&quot;LGPerson&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 2: 添加成员变量 </span></span><br><span class="line">class_addIvar(LGPerson, <span class="string">&quot;lgName&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log2(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="comment">// 3: 注册到内存</span></span><br><span class="line">objc_registerClassPair(LGPerson);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 3.1 添加property - rw</span></span><br><span class="line">lg_class_addProperty(LGPerson, <span class="string">&quot;subject&quot;</span>);</span><br><span class="line">lg_printerProperty(LGPerson);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.2 添加setter  +  getter 方法</span></span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(setSubject:), (IMP)lgSetter, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">class_addMethod(LGPerson, <span class="keyword">@selector</span>(subject), (IMP)lgName, <span class="string">&quot;@@:&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始使用</span></span><br><span class="line"><span class="keyword">id</span> person = [LGPerson alloc];</span><br><span class="line">[person setValue:<span class="string">@&quot;KC&quot;</span> forKey:<span class="string">@&quot;lgName&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;lgName&quot;</span>]);</span><br><span class="line"></span><br><span class="line">[person setValue:<span class="string">@&quot;master&quot;</span> forKey:<span class="string">@&quot;subject&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>,[person valueForKey:<span class="string">@&quot;subject&quot;</span>]);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>带注释的相关api</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建类对</span></span><br><span class="line"><span class="comment"> *superClass: 父类，传Nil会创建一个新的根类</span></span><br><span class="line"><span class="comment"> *name: 类名</span></span><br><span class="line"><span class="comment"> *extraBytes: 0</span></span><br><span class="line"><span class="comment"> *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败</span></span><br><span class="line"><span class="comment">  objc_allocateClassPair(&lt;#Class  _Nullable __unsafe_unretained superclass#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t extraBytes#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *添加成员变量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 往哪个类添加</span></span><br><span class="line"><span class="comment"> *name 添加的名字</span></span><br><span class="line"><span class="comment"> *size 大小</span></span><br><span class="line"><span class="comment"> *alignment 对齐处理方式</span></span><br><span class="line"><span class="comment"> *types 签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量。</span></span><br><span class="line"><span class="comment"> *这个类不能是元类。不支持在元类中添加一个实例变量。</span></span><br><span class="line"><span class="comment"> *实例变量的最小对齐为1 &lt;&lt; align。实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))。</span></span><br><span class="line"><span class="comment">  class_addIvar(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t size#&gt;, &lt;#uint8_t alignment#&gt;, &lt;#const char * _Nullable types#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往内存注册类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cls 要注册的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * objc_registerClassPair(&lt;#Class  _Nonnull __unsafe_unretained cls#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往类里面添加方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 要添加方法的类</span></span><br><span class="line"><span class="comment"> *sel 方法编号</span></span><br><span class="line"><span class="comment"> *imp 函数实现指针</span></span><br><span class="line"><span class="comment"> *types 签名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *class_addMethod(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL  _Nonnull name#&gt;, &lt;#IMP  _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *往类里面添加属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *cls 要添加属性的类</span></span><br><span class="line"><span class="comment"> *name 属性名字</span></span><br><span class="line"><span class="comment"> *attributes 属性的属性数组。</span></span><br><span class="line"><span class="comment"> *attriCount 属性中属性的数量。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *class_addProperty(&lt;#Class  _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#const objc_property_attribute_t * _Nullable attributes#&gt;, &lt;#unsigned int attributeCount#&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一、初探懒加载类"><a href="#一、初探懒加载类" class="headerlink" title="一、初探懒加载类"></a>一、初探懒加载类</h1><p>上一章我们探索了 <code>iOS</code> 中类的加载，让我们简单回顾一下大概的流程。</p>
<h2 id="1-1-类的加载回顾"><a href="#1-1-类的加载回顾" class="headerlink" title="1.1 类的加载回顾"></a>1.1 类的加载回顾</h2><ul>
<li><p><code>libObjc</code> 向 <code>dyld</code> 注册了回调 <code>_dyld_objc_notify_register</code>，当 <code>dyld</code> 把 <code>App</code> 以及 <code>App</code> 所依赖的一系列 <code>Mach-O</code> 镜像加载到当前 <code>App</code> 被分配的内存空间之后，<code>dyld</code> 会通过 <code>_dyld_objc_notify_mapped</code> 也就是 <code>map_images</code>来通知 <code>libObjc</code> 来完成具体的加载工作，<code>map_images</code> 被调用之后会来到 <code>_read_images</code></p>
</li>
<li><pre><code>_read_images
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 主要会进行类的加载工作，会插入 **所有的类** 到 &#96;gdb_objc_realized_classes&#96; 哈希表中（插入方式为 类名为 &#96;key&#96;，类对象为&#96;value&#96;, 不包括通过 *共享缓存* 里面的类），这个表的类型为 &#96;NXMapTable&#96;，可以类比为 &#96;NSDictionary&#96;；同时还会把类插入到 &#96;allocatedClasses&#96; 这个集合里面，集合的类型为 &#96;NXHashTable&#96;，可以类比为 &#96;NSSet&#96;。</span><br><span class="line">  - 对所有的类进行重映射</span><br><span class="line">  - 将所有的 &#96;SEL&#96; 插入到 &#96;namedSelectors&#96; 哈希表中(插入方式为：&#96;SEL&#96; 名称为 &#96;key&#96;，&#96;SEL&#96; 为&#96;value&#96;)</span><br><span class="line">  - 修复函数指针遗留</span><br><span class="line">  - 将所有的 &#96;Protocol&#96; 插入到 &#96;readProtocol&#96; 哈希表中(插入方式为：&#96;Protocol&#96; 名称为 &#96;key&#96;，&#96;Protocol&#96; 为 &#96;value&#96;)</span><br><span class="line">  - 对所有的 &#96;Protocol&#96; 做重映射</span><br><span class="line">  - 初始化所有的**非懒加载类**，包括 &#96;rw&#96; 和 &#96;ro&#96; 的初始化操作</span><br><span class="line">  - 处理所有的分类(包括类的分类和元类的分类)</span><br><span class="line"></span><br><span class="line">## 1.2 验证类的加载流程</span><br><span class="line"></span><br><span class="line">我们大致明白了类的加载流程，接下来，让我们在 &#96;_read_images&#96; 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。</span><br><span class="line"></span><br><span class="line">&gt;  **准备代码：有三个非常纯净的类： &#96;LGPerson&#96; 、 &#96;LGStudent&#96; 、 &#96;LGTeacher&#96;**</span><br><span class="line">&gt;</span><br><span class="line">&gt; 其中 &#96;LGStudent&#96; 和 &#96;LGTeacher&#96; 内部实现了 &#96;+load&#96; 方法。而 &#96;LGPerson&#96; 没有实现 &#96;+load&#96; 方法。</span><br><span class="line">&gt;</span><br><span class="line">&gt; ![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;speam&#x2F;blogImgs@main&#x2F;1-20210126103909231.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;speam&#x2F;blogImgs@main&#x2F;image-20210126104001476.png)</span><br><span class="line"></span><br><span class="line">如上图所示，我们增加一行代码:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
printf(&quot;_getObjc2NonlazyClassList Class:%s\n&quot;,cls-&gt;mangledName());
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接着我们观察打印结果:</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;speam&#x2F;blogImgs@main&#x2F;1-20210126104032118.png)</span><br><span class="line"></span><br><span class="line">## 1.3 懒加载类的发现</span><br><span class="line"></span><br><span class="line">我们这个时候观察 &#96;_read_images&#96; 源码这部分的注释:</span><br><span class="line"></span><br><span class="line">&gt; Realize non-lazy classes (for +load methods and static instances)</span><br><span class="line">&gt;</span><br><span class="line">&gt; 实现**非懒加载**类(实现了 &#96;+load&#96; 方法和静态实例)</span><br><span class="line"></span><br><span class="line">意思就是没有实现 &#96;+load&#96; 方法的类就是**懒加载类，这种类并不会在 **&#96;_read_images&#96; 环节被加载。我们自己实现了 &#96;+load&#96; 方法的两个类和其他系统内置的类由于是&#96;非懒加载类&#96;，所以会在这里打印。</span><br><span class="line"></span><br><span class="line">那么&#96;懒加载类&#96;应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送 &#96;alloc&#96; 消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会走消息的慢速查找过程，然后就来到一个非常重要的方法：&#96;lookUpImpOrForward&#96; ，我们在 &#96;main.m&#96; 中 &#96;LGPerson&#96; 类初始化的地方和 &#96;lookUpImpOrForward&#96; 入口处打上断点:</span><br><span class="line"></span><br><span class="line">&gt; Tips: 这里有个小技巧，我们先打开 &#96;main.m&#96; 文件中&#96;lookUpImpOrForward&#96; 处的断点的断点，等断点来到了我们想要探索的 &#96;LGPerson&#96; 初始化的位置的时候，我们再打开 &#96;lookUpImpOrForward&#96; 处的断点，这样才能确保当前执行 &#96;lookUpImpOrForward&#96; 的是我们的研究对象 &#96;LGPerson&#96;</span><br><span class="line"></span><br><span class="line">因为我们断点的位置是 &#96;LGPerson&#96; 类发送 &#96;alloc&#96; 消息，而显然 &#96;alloc&#96; 作为类方法是存储在元类上的，也就是说 &#96;lookUpImpOrForward&#96; 的 &#96;cls&#96; 其实是 &#96;LGPerson&#96; 元类。那么 &#96;inst&#96; 就应该是真正的&#96;LGPerson&#96;类对象，可实际如下图所示：（未初始化所以看不出是哪个类）</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;speam&#x2F;blogImgs@main&#x2F;1-20210127155652396.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此时的 &#96;inst&#96; 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码:</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;speam&#x2F;blogImgs@main&#x2F;1-20210127155642632.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里的 &#96;if&#96; 判断通过方法名我们不难看出是只有当 &#96;cls&#96; 未实现的时候才会走里面的&#96;realizeClassMaybeSwiftAndLeaveLocked&#96; 方法，那也就是说 &#96;LGPerson&#96; 元类没有被实现，也就是 &#96;LGPerson&#96; 类没有实现或者说没有被加载。</span><br><span class="line"></span><br><span class="line">我们就顺着 &#96;realizeClassMaybeSwiftAndLeaveLocked&#96; 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;objc</span><br><span class="line">static Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        &#x2F;&#x2F; Non-Swift class. Realize it now with the lock still held.</span><br><span class="line">        &#x2F;&#x2F; fixme wrong in the future for objc subclasses of swift classes</span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">        if (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; Swift class. We need to drop locks and call the Swift</span><br><span class="line">        &#x2F;&#x2F; runtime to initialize it.</span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls &#x3D; realizeSwiftClass(cls);</span><br><span class="line">        assert(cls-&gt;isRealized());    &#x2F;&#x2F; callback must have provoked realization</span><br><span class="line">        if (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>我们一路跟随断点来到了 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法，然后我们看到了我们熟悉的一个方法 <code>realizeClassWithoutSwift</code> ，这个方法内部会进行 <code>ro/rw</code> 的赋值操作以及 <code>category</code> 的 <code>attatch</code> ，关于这个方法更多内容可以查看上一篇文章。</p>
<p>接着我们返回到 <code>lookUpImpOrForward</code> 方法中来，然后进行一下 <code>LLDB</code> 打印，看一下当前这个 <code>inst</code> 也就是 <code>LGPerson</code> 对象是否已经被加载了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126193022790.png"></p>
<p>通过上面的打印，我们可以看到 <code>rw</code> 已经有值了，也就是说 <code>LGPerson</code> 类被加载了。</p>
<p><strong>总结：</strong></p>
<ul>
<li><p>如果类没有实现 <code>load</code> 方法，那么这个类就是<strong>懒加载类（用到再加载）</strong></p>
</li>
<li><p>如果类实现了 <code>load</code> 方法，那么这个类就是<strong>非懒加载类（提前加载）</strong>。</p>
</li>
</ul>
<p>调用堆栈如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210126194311796.png"></p>
<h2 id="1-4-懒加载类的流程"><a href="#1-4-懒加载类的流程" class="headerlink" title="1.4 懒加载类的流程"></a>1.4 懒加载类的流程</h2><p>关于<strong>非懒加载类</strong>的加载流程我们已经很熟悉了，我们总结下<strong>懒加载类</strong>的流程：</p>
<ul>
<li>类第一次发送消息的时候是没有缓存的，所以会来到 <code>_class_lookupMethodAndLoadCache3</code> （这个方法在<a target="_blank" rel="noopener" href="https://www.evilimo.com/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/#more">05-方法的本质和消息查找流程</a>已经分析过了）</li>
<li><code>_class_lookupMethodAndLoadCache3</code> 会调用 <code>lookUpImpOrForward</code> ，这个方法在学习 <code>Runtime</code> 的过程中非常重要！</li>
<li><code>lookUpImpOrForward</code> 内部会进行一下判断，如果 <code>cls</code> 没有被实现，会调用 <code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法</li>
<li><code>realizeClassMaybeSwiftAndLeaveLocked</code> 方法又会调用 <code>realizeClassMaybeSwiftMaybeRelock</code> 方法</li>
<li><code>realizeClassMaybeSwiftMaybeRelock</code> 方法内部会进行一下是否是 <code>Swift</code> 的判断，如果不是 <code>Swift</code> 环境的话，就会来到 <code>realizeClassWithoutSwift</code> ，最终懒加载的类就在这里加载</li>
</ul>
<h1 id="二、分类的底层实现"><a href="#二、分类的底层实现" class="headerlink" title="二、分类的底层实现"></a>二、分类的底层实现</h1><p>类分为<code>懒加载类</code>和<code>非懒加载类</code>，分类同样分为<code>懒加载分类</code>和<code>非懒加载分类</code>。在研究分类之前，我们首先需要了解下分类的底层实现。</p>
<h2 id="2-1-重写分类源文件"><a href="#2-1-重写分类源文件" class="headerlink" title="2.1 重写分类源文件"></a>2.1 重写分类源文件</h2><p>首先准备一份<code>LGTeacher+test.m</code>文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126195823741.png"></p>
<p>在终端中用 <code>clang</code> 命令重写这个分类文件为c++文件：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc LGTeacher+test.m -o category.cpp</span><br></pre></td></tr></table></figure>

<p>然后查看 <code>category.cpp</code> 这个文件，来到文件尾部可以看到:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_LGTeacher_</span>$_<span class="title">test</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) = </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="string">&quot;LGTeacher&quot;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_LGTeacher,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>LGTeacher+test</code> 分类在底层的实现是一个结构体，其名字为 <code>_OBJC_$_CATEGORY_LGTeacher_$_test</code> ，很明显这是一个按规则生成的符号，中间的 <code>LGTeacher</code> 是类名，后面的 <code>test</code> 是分类的名字。</p>
<p>同时，我们在后面可以看到如下的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))= &#123;</span></span><br><span class="line">	&amp;_OBJC_$_CATEGORY_LGTeacher_$_test,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这表明分类是存储在 <code>__DATA</code> 段的 <code>__objc_catlist</code> section 里面的。</p>
<h2 id="2-2-分类的定义"><a href="#2-2-分类的定义" class="headerlink" title="2.2 分类的定义"></a>2.2 分类的定义</h2><p>我们根据 <code>_category_t</code> 来到 <code>libObjc</code> 源码中进行查找，不过我们需要去掉一下 <code>_category_t</code> 的下划线，然后不难找到分类真正的定义所在：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">methodsForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">property_list_t</span> *<span class="title">propertiesForMeta</span><span class="params">(<span class="keyword">bool</span> isMeta, struct header_info *hi)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>根据刚才 <code>clang</code> 重写之后的内容，我们不难看出</p>
<ul>
<li><code>name</code> : 是分类所关联的类，也就是类的名字，而不是分类的名字</li>
<li><code>cls</code> : 我们在前面可以看到 <code>clang</code> 重写后这个值为 0，但是后面有注释为 <code>&amp;OBJC_CLASS_$_LGTeacher</code> ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在</li>
<li><code>instanceMethods</code> : 分类上存储的实例方法</li>
<li><code>classMethods</code> ：分类上存储的类方法</li>
<li><code>protocols</code> ：分类所实现的协议</li>
<li><code>instanceProperties</code> ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的</li>
<li><code>_classProperties</code> ：分类所定义的类属性。</li>
</ul>
<h1 id="三、分类的加载"><a href="#三、分类的加载" class="headerlink" title="三、分类的加载"></a>三、分类的加载</h1><p>我们现在知道了类分为了 <code>懒加载类</code> 和 <code>非懒加载类</code> ，它们的加载时机是不一样的，分类同样分为<code>懒加载分类</code>和<code>非懒加载分类</code>。</p>
<blockquote>
<p>分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。</p>
</blockquote>
<p>接下来开始研究：</p>
<h2 id="3-1-懒加载分类"><a href="#3-1-懒加载分类" class="headerlink" title="3.1 懒加载分类"></a>3.1 懒加载分类</h2><p>没有实现 load 的分类-&gt;没有提前加载，所以是<code>懒加载分类</code>。</p>
<h3 id="3-1-1-懒加载分类-懒加载类"><a href="#3-1-1-懒加载分类-懒加载类" class="headerlink" title="3.1.1 懒加载分类 + 懒加载类"></a>3.1.1 懒加载分类 + 懒加载类</h3><p>也就是类和分类都不实现 <code>load</code> 方法的情况。</p>
<h4 id="懒加载类"><a href="#懒加载类" class="headerlink" title="懒加载类"></a>懒加载类</h4><p>前面分析过了，在向类<strong>第一次发送消息</strong>的时候，懒加载类才会开始加载。</p>
<h4 id="懒加载分类"><a href="#懒加载分类" class="headerlink" title="懒加载分类"></a>懒加载分类</h4><p>探索：在 <code>realizeClassWithoutSwift</code> 方法的最后有一个 <code>methodizeClass</code> 方法，在这个方法里面会有一个 <code>Attach categories</code> 的地方，猜测懒加载分类是不是在这里加载了？</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201719382.png"></p>
<p>但是我们断点之后发现这个时候通过 <code>unattachedCategoriesForClass</code> 方法并没有取到分类。此时通过 <code>LLDB</code> 打印一下当前类里面是否已经把分类的内容附加上了。<br>前面的流程大家都很熟悉了，我们直接看 <code>cls</code> 的 <code>rw</code> 中的 <code>methods</code> 是否有内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201728689.png"></p>
<p>此时 <code>LGTeacher</code> 类里面是没有方法的，这里读取 <code>rw</code> 却有一个结果，我们不难看出这是位于 <code>LGTeacher+test</code> 分类中的一个 <code>initialize</code> 方法，这个方法是我手动加到这个分类的。</p>
<p>这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 <code>unattachedCategoriesForClass</code> ，而是直接在编译时加载到了类的 <code>ro</code> 里面，然后在运行时被拷贝到了类的 <code>rw</code> 里面。这一点可以通过下面的 <code>LLDB</code> 打印来证明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126201919490.png"></p>
<p>突然想起来，不是在 <code>_read_images</code> 的最后那块有一个 <code>Discover categories</code> 吗，万一懒加载分类是在这里加载的呢？我们一试便知：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155604526.png"></p>
<p>这里在 <code>Discover categories</code> 内部做了一下判断，如果是 <code>LGTeacher</code> 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的，是在编译时直接加载的。</p>
<h3 id="3-1-2-懒加载分类-非懒加载类"><a href="#3-1-2-懒加载分类-非懒加载类" class="headerlink" title="3.1.2 懒加载分类+非懒加载类"></a>3.1.2 懒加载分类+非懒加载类</h3><h4 id="非懒加载类"><a href="#非懒加载类" class="headerlink" title="非懒加载类"></a>非懒加载类</h4><p>当类为<code>非懒加载类</code>的时候，同样是走 <code>_read_images</code> =&gt;<code>Realize non-lazy classes</code>=&gt;<code>realizeClassWithoutSwift</code>=&gt;<code>methodizeClass</code>。</p>
<h4 id="懒加载分类-1"><a href="#懒加载分类-1" class="headerlink" title="懒加载分类"></a>懒加载分类</h4><p>我们直接在 <code>methodizeClass</code> 方法中打上断点，并做了一下简单的判断:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cname = ro-&gt;name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *oname = <span class="string">&quot;LGTeacher&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cname, oname) == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;methodizeClass :%s \n&quot;</span>,cname);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果可以看到cats为空，所以分类不在这进行添加。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127111718624.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/image-20210127111712706.png"></p>
<p>同时通过 <code>LLDB</code> 打印，发现分类的方法已经在类的 <code>ro</code> 里面了，说明<code>懒加载的分类</code>在编译时期就被加载了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>懒加载分类</code>的初始化其实跟类的懒加载与否并没有关系，也就是说<code>懒加载的分类</code>都是在编译时期被加载的。</li>
<li>懒加载类和非懒加载类还是1.3中所述的流程。</li>
</ul>
<h2 id="3-2-非懒加载分类"><a href="#3-2-非懒加载分类" class="headerlink" title="3.2 非懒加载分类"></a>3.2 非懒加载分类</h2><p>实现了 load 的分类-&gt;提前加载，所以是<code>非懒加载分类</code></p>
<p>他和类配合加载分下面两种情况：</p>
<ul>
<li>非懒加载分类与懒加载类</li>
<li>非懒加载分类和非懒加载类</li>
</ul>
<h3 id="3-2-1-非懒加载分类-懒加载类"><a href="#3-2-1-非懒加载分类-懒加载类" class="headerlink" title="3.2.1 非懒加载分类 + 懒加载类"></a>3.2.1 非懒加载分类 + 懒加载类</h3><p>懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在<code>lookupImpOrForward</code> =&gt;<code>realizeClassMaybeSwiftAndLeaveLocked</code> =&gt; <code>realizeClassMaybeSwiftMaybeRelock</code> =&gt; <code>realizeClassWithoutSwift</code> =&gt; <code>methodizeClass</code> 流程中的 <code>methodizeClass</code> 打上断点，看下在这里分类会不会被加载：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203136054.png"></p>
<p>这一次通过 <code>unattachedCategoriesForClass</code> 取出来值了，并且在这之前 <code>cls</code> 的 <code>ro</code> 中并没有分类的 <code>initialize</code> 方法：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203231115.png"></p>
<p>但是我们注意观察此时的调用堆栈：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203313361.png"></p>
<p>为什么走的是 <code>load_images</code> 里面的 <code>prepare_load_methods</code> 方法呢？我们来到 <code>prepare_load_methods</code> 方法处：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210126203607376.png"></p>
<p>可以看到，其实在这里调用了 <code>realizeClassWithoutSwift</code> 方法来提前加载类。</p>
<p>而上面的 <code>_getObjc2NonlazyCategoryList</code> 方法显示就是获取到所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。</p>
<p>这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类<strong>并不一定</strong>只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么类就是在 <code>load_images</code> =&gt; <code>prepare_load_methods</code> =&gt; <code>realizeClassWithoutSwift</code> 加载的。</p>
<p>分类的加载在类加载之后的 <code>methodizeClass</code>。</p>
<h3 id="3-2-2-非懒加载分类-非懒加载类"><a href="#3-2-2-非懒加载分类-非懒加载类" class="headerlink" title="3.2.2 非懒加载分类 + 非懒加载类"></a>3.2.2 非懒加载分类 + 非懒加载类</h3><p>非懒加载类的流程我们也十分熟悉了，在 <code>_read_images</code> 里面进行加载。而此时，分类也是非懒加载。我们还是在 <code>methodizeClass</code> 里面进行断点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127084924084.png"></p>
<p>结果如上图所示，这次从 <code>unattachedCategoriesForClass</code> 方法取出来的是 <code>NULL</code> 值，显然分类不是在这个地方被加载的，我们回到 <code>_read_images</code> 方法，还记得那个 <code>Discover categories</code> 流程吗，我们打开里面的断点：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127085121289.png"></p>
<p>因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 <code>remethodizeClass</code> 方法，我们进入其内部实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: attaching categories to class &#x27;%s&#x27; %s&quot;</span>, </span><br><span class="line">                         cls-&gt;nameForLogging(), isMeta ? <span class="string">&quot;(meta)&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/*flush caches*/</span>);        </span><br><span class="line">        <span class="built_in">free</span>(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到有一个 <code>attachCategories</code> 方法，断点也确实来到了这个地方，所以非懒加载分类在这里加载。 </p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>非懒加载分类 + 懒加载类</p>
<p>类的加载在 <code>load_images</code> 处 ，分类的加载在类加载之后的 <code>methodizeClass</code></p>
</li>
<li><p>非懒加载分类 + 非懒加载类</p>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
</li>
</ul>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>我们今天探索的内容可能会非常绕，不过其实探索下来，我们只需要保持研究重点就很简单。分类的加载其实可以笼统的分为实现 <code>load</code> 方法和没有实现 <code>load</code> 方法：</p>
<ul>
<li>没有实现 <code>load</code> 方法的分类（不需提前加载-懒加载分类）由<strong>编译时</strong>确定</li>
<li>实现了 <code>load</code> 方法的分类（需提前加载-非懒加载分类）由<strong>运行时</strong>去确定</li>
</ul>
<p>这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论：</p>
<ul>
<li>懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在<strong>第一次消息发送</strong>的时候，而分类的加载则在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载还是在<strong>编译时</strong></p>
</blockquote>
<ul>
<li>非懒加载分类 + 懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>load_images</code> 内部，分类的加载在类加载之后的 <code>methodizeClass</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155534997.png"></p>
</blockquote>
<ul>
<li>非懒加载分类 + 非懒加载类</li>
</ul>
<blockquote>
<p>类的加载在 <code>_read_images</code> 处，分类的加载在类加载之后的 <code>reMethodizeClass</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210127155520899.png"></p>
</blockquote>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h3 id="objc4-756-2源码"><a href="#objc4-756-2源码" class="headerlink" title="objc4-756.2源码"></a>objc4-756.2源码</h3><p>本文使用：<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">objc4-756.2源码</a> 进行分析</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904049544790030">iOS 底层探索 - 分类的加载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2014/03/05/objc_category_secret/">objc category的秘密 - sunnyxx</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><span class="level-item">08-类的加载过程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">前言</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#ro和rw衍生出来的问题"><span class="level-left"><span class="level-item">ro和rw衍生出来的问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#一、初探懒加载类"><span class="level-left"><span class="level-item">一、初探懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-类的加载回顾"><span class="level-left"><span class="level-item">1.1 类的加载回顾</span></span></a></li><li><a class="level is-mobile" href="#1-4-懒加载类的流程"><span class="level-left"><span class="level-item">1.4 懒加载类的流程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、分类的底层实现"><span class="level-left"><span class="level-item">二、分类的底层实现</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-重写分类源文件"><span class="level-left"><span class="level-item">2.1 重写分类源文件</span></span></a></li><li><a class="level is-mobile" href="#2-2-分类的定义"><span class="level-left"><span class="level-item">2.2 分类的定义</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、分类的加载"><span class="level-left"><span class="level-item">三、分类的加载</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-懒加载分类"><span class="level-left"><span class="level-item">3.1 懒加载分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-1-1-懒加载分类-懒加载类"><span class="level-left"><span class="level-item">3.1.1 懒加载分类 + 懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#懒加载类"><span class="level-left"><span class="level-item">懒加载类</span></span></a></li><li><a class="level is-mobile" href="#懒加载分类"><span class="level-left"><span class="level-item">懒加载分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-1-2-懒加载分类-非懒加载类"><span class="level-left"><span class="level-item">3.1.2 懒加载分类+非懒加载类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#非懒加载类"><span class="level-left"><span class="level-item">非懒加载类</span></span></a></li><li><a class="level is-mobile" href="#懒加载分类-1"><span class="level-left"><span class="level-item">懒加载分类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-2-非懒加载分类"><span class="level-left"><span class="level-item">3.2 非懒加载分类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#3-2-1-非懒加载分类-懒加载类"><span class="level-left"><span class="level-item">3.2.1 非懒加载分类 + 懒加载类</span></span></a></li><li><a class="level is-mobile" href="#3-2-2-非懒加载分类-非懒加载类"><span class="level-left"><span class="level-item">3.2.2 非懒加载分类 + 非懒加载类</span></span></a></li><li><a class="level is-mobile" href="#总结-1"><span class="level-left"><span class="level-item">总结</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#四、总结"><span class="level-left"><span class="level-item">四、总结</span></span></a></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#objc4-756-2源码"><span class="level-left"><span class="level-item">objc4-756.2源码</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>