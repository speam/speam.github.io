<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>08-类的加载过程 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="08-类的加载过程"><meta property="og:url" content="http://evilimo.com/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210122115042739.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122134933939aa.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122135003585aa.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210124134553618.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124135713603.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124160357452.png"><meta property="og:image" content="https://github.com/speam/blogImgs/blob/master/1-20210124160410989.png?raw=true"><meta property="og:image" content="https://github.com/speam/blogImgs/blob/master/1-20210124160431826.png?raw=true"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124143723789.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124143733123.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142619321.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142628347.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124152754176.png"><meta property="article:published_time" content="2021-01-21T09:35:43.932Z"><meta property="article:modified_time" content="2021-08-30T02:29:25.189Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210122115042739.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210122115042739.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122134933939aa.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122135003585aa.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210124134553618.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img1.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img2.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124135713603.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124160357452.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124143723789.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124143733123.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142619321.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142628347.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124152754176.png"],"datePublished":"2021-01-21T09:35:43.932Z","dateModified":"2021-08-30T02:29:25.189Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-21T09:35:43.932Z" title="2021-01-21T09:35:43.932Z">2021-01-21</time>发表</span><span class="level-item"><time dateTime="2021-08-30T02:29:25.189Z" title="2021-08-30T02:29:25.189Z">2021-08-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">08-类的加载过程</h1><div class="content"><hr>
<a id="more"></a>

<h2 id="前言：dyld加载流程（精简）"><a href="#前言：dyld加载流程（精简）" class="headerlink" title="前言：dyld加载流程（精简）"></a>前言：dyld加载流程（精简）</h2><p>由于<code>dyld</code>流程加载是一个比较复杂的过程，这里我们只做简单的分析。</p>
<p>下面是<code>main</code>函数之前调用堆栈的信息：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210122115042739.png"></p>
<blockquote>
<p>通过上面的堆栈信息我们可以简单分析出来一个流程</p>
<ul>
<li><code>_dyld_start</code>函数，是整个加载的入口。</li>
<li>经过<code>dyldbooststrap::start</code>-&gt;<code>dyld::start</code>-&gt;<code>ImageLoad::</code>-&gt;<code>ImageLoadMackO::</code>这些流程把<code>MachO</code>里面的信息读取到。</li>
<li><code>libSystem_initializer</code>，初始化系统库。</li>
<li><code>libdispatch_init</code>，初始化<code>libdispatch库</code>。</li>
<li><code>_os_object_init</code>-&gt;<code>::_objc_init</code>，初始化<code>objc</code>库。</li>
</ul>
</blockquote>
<ul>
<li><strong><code>dyld</code>主要的步骤都在读取<code>MachO</code>段里面的数据</strong></li>
</ul>
<p>接下来使用<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">objc4-756.2源码</a>进行分析</p>
<h2 id="一、-objc-init流程"><a href="#一、-objc-init流程" class="headerlink" title="一、_objc_init流程"></a>一、_objc_init流程</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> initialized = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (initialized) <span class="keyword">return</span>;</span><br><span class="line">    initialized = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fixme defer initialization until an objc-using image is found?</span></span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    static_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-environ-init-函数"><a href="#1-1-environ-init-函数" class="headerlink" title="1.1 environ_init 函数"></a>1.1 environ_init 函数</h3><p>初始化环境变量。这里我们的重点不是看源码，主要看下面：</p>
<p>我们可以通过在终端进行：<code>export OBJC_HELP=1</code>然后： <code>ls</code>，查看相关的环境变量，留意下面两个变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122134933939aa.png"></p>
<p>…省略中间的部分…</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210122135003585aa.png"></p>
<p>我们可以在Xcode中调整这两个环境变量玩一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/image-20210124134553618.png"></p>
<h4 id="1-1-1-修改环境变量OBJC-PRINT-LOAD-METHOD为YES后"><a href="#1-1-1-修改环境变量OBJC-PRINT-LOAD-METHOD为YES后" class="headerlink" title="1.1.1 修改环境变量OBJC_PRINT_LOAD_METHOD为YES后"></a>1.1.1 修改环境变量<code>OBJC_PRINT_LOAD_METHOD</code>为YES后</h4><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img1.png"></p>
<p>修改该环境变量之后观察控制台打印输出的结果</p>
<ul>
<li>系统的<code>load</code>方法会全部打印出来。</li>
<li>自己定义的<code>load</code>方法也会打印出来，所以我们可以从这里入手，在做启动优化的时候可以快速定位调整这些load方法。</li>
</ul>
<h4 id="1-1-2-修改OBJC-PRINT-NONPOINTER-ISA为YES后"><a href="#1-1-2-修改OBJC-PRINT-NONPOINTER-ISA为YES后" class="headerlink" title="1.1.2 修改OBJC_PRINT_NONPOINTER_ISA为YES后"></a>1.1.2 修改<code>OBJC_PRINT_NONPOINTER_ISA</code>为YES后</h4><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/img2.png"></p>
<p>修改该环境变量之后观察控制台打印输出的结果</p>
<ul>
<li>优化过的isa指针则需要&amp;上<code>ISA_MASK</code>才能的到类的内存地址。</li>
</ul>
<ul>
<li>关闭<code>nonpointer</code>之后，isa指针就不做内存优化了，所以类的内存地址和<code>isa</code>的内存地址就相同了。</li>
<li>这里也验证了<a target="_blank" rel="noopener" href="https://www.evilimo.com/2020/11/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-isa%E5%8E%9F%E7%90%86/#more">02-isa原理</a>中<code>isa</code>的初始化的时候，直接将类赋值<code>isa</code>的<code>cls</code>成员。</li>
</ul>
<h3 id="1-2-tls-init-函数"><a href="#1-2-tls-init-函数" class="headerlink" title="1.2 tls_init 函数"></a>1.2 tls_init 函数</h3><p><code>tls_init()</code>方法是关于线程key的绑定</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tls_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_DIRECT_THREAD_KEYS</span></span><br><span class="line">    _objc_pthread_key = TLS_DIRECT_KEY;</span><br><span class="line">    pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-static-init-函数"><a href="#1-3-static-init-函数" class="headerlink" title="1.3 static_init 函数"></a>1.3 static_init 函数</h3><p><code>static_init()</code>方法注释中提到：该方法会运行<code>C++静态构造函数</code>（只会运行系统级别的构造函数），在dyld调用静态构造函数之前<code>libc</code>会调用<code>_objc_init</code>，所以必须自己去实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* static_init</span></span><br><span class="line"><span class="comment">* Run C++ static constructor functions.</span></span><br><span class="line"><span class="comment">* libc calls _objc_init() before dyld would call our static constructors, </span></span><br><span class="line"><span class="comment">* so we have to do it ourselves.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="keyword">auto</span> inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        inits[i]();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-lock-init-函数"><a href="#1-4-lock-init-函数" class="headerlink" title="1.4 lock_init 函数"></a>1.4 lock_init 函数</h3><p><code>lock_init()</code>方法是个空函数，OC的锁机制完全采用C、C++那一套</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-exception-init-函数"><a href="#1-5-exception-init-函数" class="headerlink" title="1.5 exception_init 函数"></a>1.5 exception_init 函数</h3><p><code>exception_init()</code>初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exception_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    old_terminate = <span class="built_in">std</span>::set_terminate(&amp;_objc_terminate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用只声明不实现不作任何处理的方法，就会报错，来到<code>_objc_terminate</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124135713603.png"></p>
<h3 id="1-6-dyld-objc-notify-register-函数"><a href="#1-6-dyld-objc-notify-register-函数" class="headerlink" title="1.6 _dyld_objc_notify_register 函数"></a>1.6 _dyld_objc_notify_register 函数</h3><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124160357452.png"></p>
<p>通过三个函数指针直接发起回调。这里分析<code>_dyld_objc_notify_mapped</code>这个函数，在<code>dyld</code>里面通过注册函数的内存地址，然后通过函数指针又回调到了<code>map_images</code>这个函数。</p>
<p><img src="https://github.com/speam/blogImgs/blob/master/1-20210124160410989.png?raw=true" alt="1-20210124160410989.png"></p>
<p>记录保存注册函数的内存地址。</p>
<p><img src="https://github.com/speam/blogImgs/blob/master/1-20210124160431826.png?raw=true"></p>
<p>通过函数指针的形式回调这个函数即<code>map_images</code>,下面进入到<code>map_images</code>分析。</p>
<h2 id="二、map-images-函数"><a href="#二、map-images-函数" class="headerlink" title="二、map_images 函数"></a>二、map_images 函数</h2><p>当镜像加载到内存时会触发<code>map_image</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* map_images</span></span><br><span class="line"><span class="comment">* Process the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">* Calls ABI-agnostic code after taking ABI-specific locks.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">map_images(<span class="keyword">unsigned</span> count, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> paths[],</span><br><span class="line">           <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(runtimeLock)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(count, paths, mhdrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>map_images_nolock函数：</strong></p>
<p><code>map_image</code>调用<code>map_images_nolock</code>，由于代码比较多，我们去掉一些无关紧要的代码，比如打印日志信息、代码的注释、iOS系统用到的，精简之后如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">map_images_nolock(<span class="keyword">unsigned</span> mhCount, <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> mhPaths[],</span><br><span class="line">                  <span class="keyword">const</span> struct mach_header * <span class="keyword">const</span> mhdrs[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    header_info *hList[mhCount];</span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        preopt_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count classes. Size various table based on the total.</span></span><br><span class="line">    <span class="keyword">int</span> totalClasses = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unoptimizedTotalClasses = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> i = mhCount;</span><br><span class="line">        <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">            <span class="keyword">const</span> headerType *mhdr = (<span class="keyword">const</span> headerType *)mhdrs[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">auto</span> hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses);</span><br><span class="line">            <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">                <span class="comment">// no objc data in this entry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">                <span class="comment">// Size some data structures based on main executable is size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __OBJC2__</span></span><br><span class="line">                <span class="keyword">size_t</span> count;</span><br><span class="line">                _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line">                _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">                selrefCount += count;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                _getObjcSelectorRefs(hi, &amp;selrefCount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            hList[hCount++] = hi;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Perform one-time runtime initialization that must be deferred until </span></span><br><span class="line">    <span class="comment">// the executable itself is found. This needs to be done before </span></span><br><span class="line">    <span class="comment">// further initialization.</span></span><br><span class="line">    <span class="comment">// (The executable may not be present in this infoList if the </span></span><br><span class="line">    <span class="comment">// executable does not contain Objective-C code but Objective-C </span></span><br><span class="line">    <span class="comment">// is dynamically loaded later.</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123;</span><br><span class="line">        sel_init(selrefCount);</span><br><span class="line">        arr_init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    firstTime = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在开始分析精简之后的代码</p>
<ul>
<li><code>firstTime</code>一个用<code>static</code>修饰的局部成员变量，记录第一次需要做的事。</li>
<li><code>_getObjc2SelectorRefs</code>函数，从<code>mach_o</code>读取<code>__objc_selrefs</code>段的信息。</li>
<li><code>_getObjc2MessageRefs</code>函数，从<code>mach_o</code>读取<code>__objc_msgrefs</code>段的信息。</li>
<li>第一次需要执行的函数<code>preopt_init()</code>、<code>sel_init()</code>、<code>arr_init()</code>。</li>
<li><code>_read_images()</code>函数，读取镜像文件。</li>
</ul>
<h3 id="2-1-preopt-init"><a href="#2-1-preopt-init" class="headerlink" title="2.1 preopt_init()"></a>2.1 preopt_init()</h3><p>注释描述这里会延迟初始化，主要是共享缓存有了之后的处理。</p>
<h3 id="2-2-sel-init"><a href="#2-2-sel-init" class="headerlink" title="2.2 sel_init()"></a>2.2 sel_init()</h3><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124143723789.png"></p>
<p>去掉其他信息之后，我们可以看到是注册了一些系统提供的<code>API</code>。</p>
<h3 id="2-3-arr-init"><a href="#2-3-arr-init" class="headerlink" title="2.3 arr_init()"></a>2.3 arr_init()</h3><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124143733123.png"></p>
<p>这一块也是比较重要的信息，让我们知道了<code>AutorereleasePoolPage</code>和<code>SideTable</code>的初始化在这里是有执行的。</p>
<h3 id="2-4-read-images"><a href="#2-4-read-images" class="headerlink" title="2.4 _read_images()"></a>2.4 _read_images()</h3><p>前面的三个函数不是我们目前探索的重点，只是简单的分析了一下。下面我们开始深入<code>_read_images()</code>，请看接下来的<strong>类加载</strong>部分。</p>
<h2 id="三、类加载"><a href="#三、类加载" class="headerlink" title="三、类加载"></a>三、类加载</h2><h3 id="入口：-read-images-函数"><a href="#入口：-read-images-函数" class="headerlink" title="入口：_read_images() 函数"></a>入口：_read_images() 函数</h3><p>读取镜像文件。由于这个函数的代码比较多，我们把其中的代码先用伪代码的信息展示出来，然后再来讲解每一步。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _read_images(header_info **hList, <span class="keyword">uint32_t</span> hCount, <span class="keyword">int</span> totalClasses, <span class="keyword">int</span> unoptimizedTotalClasses)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="number">1.</span> 定义局部变量，处理第一次要做的事情。</span><br><span class="line">   <span class="keyword">if</span> (!doneOnce)&#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">2.</span> 类的重映射</span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">3.</span> 修复重映射</span><br><span class="line">   <span class="keyword">if</span> (!noClassesRemapped()) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">   <span class="number">4.</span> 添加SEL到namedSelectors表</span><br><span class="line">   &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">5.</span> 修复旧的函数指针调用遗留</span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">6.</span> 添加Protocol到协议表</span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">7.</span> 修复协议列表引用</span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">8.</span> 实现非懒加载的类</span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">9.</span> Realize newly-resolved <span class="built_in">future</span> classes</span><br><span class="line">   <span class="keyword">if</span> (resolvedFutureClasses) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">10.</span> 发现和处理所有Category </span><br><span class="line">   <span class="keyword">for</span> (EACH_HEADER) &#123; ... &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="number">11.</span> +<span class="function">load handled by <span class="title">prepare_load_methods</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   <span class="title">if</span> <span class="params">(DebugNonFragileIvars)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重要的有第1步、第2步、第11步。</p>
<h3 id="3-1-第一次要做的事情-doneOnce【重要】"><a href="#3-1-第一次要做的事情-doneOnce【重要】" class="headerlink" title="3.1 第一次要做的事情 - doneOnce【重要】"></a>3.1 第一次要做的事情 - <code>doneOnce</code>【重要】</h3><p>去掉打印部分的代码、与iOS操作系统不相干的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!doneOnce) &#123;</span><br><span class="line">        doneOnce = YES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> TARGET_OS_OSX</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (DisableTaggedPointers) &#123;</span><br><span class="line">            disableTaggedPointers();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        initializeTaggedPointerObfuscator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(<span class="string">&quot;CLASS: found %d classes during launch&quot;</span>, totalClasses);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// namedClasses</span></span><br><span class="line">        <span class="comment">// Preoptimized classes do not go in this table.</span></span><br><span class="line">        <span class="comment">// 4/3 is NXMapTable is load factor</span></span><br><span class="line">        <span class="keyword">int</span> namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * <span class="number">4</span> / <span class="number">3</span>;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        allocatedClasses = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, nil);</span><br><span class="line">        </span><br><span class="line">        ts.<span class="built_in">log</span>(<span class="string">&quot;IMAGE TIMES: first time tasks&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>disableTaggedPointers()</code>函数，条件允许的时候，禁用<code>taggedPointers</code>。</p>
</li>
<li><p><code>initializeTaggedPointerObfuscator</code>函数，初始化<code>taggedPointer</code>。</p>
</li>
<li><p><code>gdb_objc_realized_classes</code>通过<strong>NX</strong>技术创建的<code>mapTable</code>，这张表里面包含的所有类的信息，我们称之为<strong>总表</strong>。</p>
</li>
<li><p><code>allocatedClasses</code>通过<strong>NX</strong>技术创建的<code>HashTable</code>，这张表只包含已经开辟的类的信息，我们称之为<strong>已开辟类的表</strong>。</p>
</li>
</ul>
<h3 id="3-2-对所有类做重映射【重要】"><a href="#3-2-对所有类做重映射【重要】" class="headerlink" title="3.2 对所有类做重映射【重要】"></a>3.2 对所有类做重映射【重要】</h3><p>从列表中取出所有类，遍历进行处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// 从编译后的类列表中取出所有类，获取到的是一个classref_t类型的指针</span></span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (! mustReadClasses(hi)) &#123;</span><br><span class="line">        <span class="comment">// Image is sufficiently optimized that we need not call readClass()</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> headerIsBundle = hi-&gt;isBundle();</span><br><span class="line">    <span class="keyword">bool</span> headerIsPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">         <span class="comment">// 数组中会取出OS_dispatch_queue_concurrent、OS_xpc_object、NSRunloop等系统类，例如CF、Fundation、libdispatch中的类。以及自己创建的类</span></span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过readClass函数获取处理后的新类，</span></span><br><span class="line">        Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化所有懒加载的类需要的内存空间 - 现在数据没有加载到的 - 连类都没有初始化的</span></span><br><span class="line">        <span class="keyword">if</span> (newCls != cls  &amp;&amp;  newCls) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将懒加载的类添加到数组中</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                <span class="built_in">realloc</span>(resolvedFutureClasses, </span><br><span class="line">                        (resolvedFutureClassCount+<span class="number">1</span>) * <span class="keyword">sizeof</span>(Class));</span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = newCls;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>readClass</code>方法会返回<code>Class</code>，跟进去看看具体实现</p>
<ul>
<li>当前类的父类中若有丢失的weak-linked类，则返回<code>nil</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142619321.png"></p>
<ul>
<li><p>正常情况下不会走进<code>popFutureNamedClass</code>判断，这是<code>专门针对未来的待处理的类的特殊操作</code>，因此也不会对ro、rw进行操作（可打断点调试，创建类和系统类都不会进入）</p>
</li>
<li><p>在调用<code>addNamedClass</code>，<code>addClassTableEntry</code>方法后返回cls</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210124142628347.png"></p>
<p>将当前类添加到已创建好的<code>gdb_objc_realized_classes</code>哈希表（<code>总表</code>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNamedClass</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, Class replacing = nil)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line">    Class old;</span><br><span class="line">    <span class="keyword">if</span> ((old = getClassExceptSomeSwift(name))  &amp;&amp;  old != replacing) &#123;</span><br><span class="line">        inform_duplicate(name, old, cls);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// getMaybeUnrealizedNonMetaClass uses name lookups.</span></span><br><span class="line">        <span class="comment">// Classes not found by name lookup must be in the</span></span><br><span class="line">        <span class="comment">// secondary meta-&gt;nonmeta table.</span></span><br><span class="line">        addNonMetaClass(cls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NXMapInsert(gdb_objc_realized_classes, name, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!(cls-&gt;data()-&gt;flags &amp; RO_META));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrong: constructed classes are already realized when they get here</span></span><br><span class="line">    <span class="comment">// assert(!cls-&gt;isRealized());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前类已经初始化，所以要添加到<code>allocatedClasses</code>哈希表(<code>已开辟类的表</code>)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addClassTableEntry</span><span class="params">(Class cls, <span class="keyword">bool</span> addMeta = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This class is allowed to be a known class via the shared cache or via</span></span><br><span class="line">    <span class="comment">// data segments, but it is not allowed to be in the dynamic table already.</span></span><br><span class="line">    assert(!NXHashMember(allocatedClasses, cls));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isKnownClass(cls))</span><br><span class="line">        NXHashInsert(allocatedClasses, cls);</span><br><span class="line">    <span class="keyword">if</span> (addMeta)</span><br><span class="line">        addClassTableEntry(cls-&gt;ISA(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-修复重映射"><a href="#3-3-修复重映射" class="headerlink" title="3.3 修复重映射"></a>3.3 修复重映射</h3><p>将未映射Class和Super Class重映射，调用<code>_getObjc2ClassRefs</code>获取类的引用，调用<code>_getObjc2SuperRefs</code>获取父类的引用，通过<code>remapClassRef</code>进行重映射</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将未映射Class和Super Class重映射，被remap的类都是非懒加载的类</span></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="comment">// 重映射Class，注意是从_getObjc2ClassRefs函数中取出类的引用</span></span><br><span class="line">        Class *classrefs = _getObjc2ClassRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn&#x27;t test future1 catch the absence of this?</span></span><br><span class="line">        classrefs = _getObjc2SuperRefs(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-添加SEL到namedSelectors表"><a href="#3-4-添加SEL到namedSelectors表" class="headerlink" title="3.4 添加SEL到namedSelectors表"></a>3.4 添加SEL到namedSelectors表</h3><p>通过<code>_getObjc2SelectorRefs</code>拿到MachO中的静态段<code>__objc_selrefs</code>，遍历列表调用<code>sel_registerNameNoLock</code>将SEL添加到<code>namedSelectors</code>哈希表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有SEL都注册到哈希表中，是另外一张哈希表</span></span><br><span class="line"><span class="comment">// Fix up @selector references</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> UnfixedSelectors;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">mutex_locker_t</span> <span class="title">lock</span><span class="params">(selLock)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line">        SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">        UnfixedSelectors += count;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(sels[i]);</span><br><span class="line">            <span class="comment">// 注册SEL的操作</span></span><br><span class="line">            sels[i] = sel_registerNameNoLock(name, isBundle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-修复旧的函数指针调用遗留"><a href="#3-5-修复旧的函数指针调用遗留" class="headerlink" title="3.5 修复旧的函数指针调用遗留"></a>3.5 修复旧的函数指针调用遗留</h3><p>通过<code>_getObjc2MessageRefs</code>获取到静态段<code>__objc_selrefs</code>，<code>fixupMessageRef</code>遍历将函数指针进行注册，并fix为新的函数指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up old objc_msgSend_fixup call sites</span></span><br><span class="line"><span class="comment">// 修复旧的函数指针调用遗留</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">message_ref_t</span> *refs = _getObjc2MessageRefs(hi, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">        _objc_inform(<span class="string">&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot;</span></span><br><span class="line">                     <span class="string">&quot;call sites in %s&quot;</span>, count, hi-&gt;fname());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">         <span class="comment">// 内部将常用的alloc、objc_msgSend等函数指针进行注册，并fix为新的函数指针</span></span><br><span class="line">        fixupMessageRef(refs+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-将所有Protocol都添加到protocol-map表中"><a href="#3-6-将所有Protocol都添加到protocol-map表中" class="headerlink" title="3.6 将所有Protocol都添加到protocol_map表中"></a>3.6 将所有Protocol都添加到protocol_map表中</h3><p>调用<code>_getObjc2ProtocolList</code>获取到<code>__objc_protolist</code>协议列表，<code>readProtocol</code>遍历添加Protocol到<code>protocol_map</code>哈希表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs.</span></span><br><span class="line"><span class="comment">// 遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">extern</span> objc_class OBJC_CLASS_$_Protocol;</span><br><span class="line">    <span class="comment">// cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类</span></span><br><span class="line">    Class cls = (Class)&amp;OBJC_CLASS_$_Protocol;</span><br><span class="line">    assert(cls);</span><br><span class="line">    <span class="comment">// 获取protocol哈希表</span></span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    <span class="keyword">bool</span> isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">    <span class="keyword">bool</span> isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从编译器中读取并初始化Protocol</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-对所有Protocol做重映射"><a href="#3-7-对所有Protocol做重映射" class="headerlink" title="3.7 对所有Protocol做重映射"></a>3.7 对所有Protocol做重映射</h3><p>通过<code>_getObjc2ProtocolRefs</code>获取到<code>__objc_protorefs</code><strong>（与__objc_protolist不是同一个东西）</strong>遍历<code>remapProtocolRef</code>修复协议，<code>remapProtocolRef</code>比较当前协议和协议列表中同一内存地址的协议是否相同，如果不同则替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @protocol references</span></span><br><span class="line"><span class="comment">// Preoptimized images may have the right </span></span><br><span class="line"><span class="comment">// answer already but we don&#x27;t know for sure.</span></span><br><span class="line"><span class="comment">// 修复协议列表引用，优化后的images可能是正确的，但是并不确定</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// 需要注意到是，下面的函数是_getObjc2ProtocolRefs，和上面的_getObjc2ProtocolList不一样</span></span><br><span class="line">    <span class="keyword">protocol_t</span> **protolist = _getObjc2ProtocolRefs(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        remapProtocolRef(&amp;protolist[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8-初始化所有非懒加载的类，进行rw、ro等操作【重要】"><a href="#3-8-初始化所有非懒加载的类，进行rw、ro等操作【重要】" class="headerlink" title="3.8 初始化所有非懒加载的类，进行rw、ro等操作【重要】"></a>3.8 初始化所有非懒加载的类，进行rw、ro等操作【重要】</h3><p>苹果官方对于非懒加载类的定义是：实现了<code>+load</code>方法的类是<code>非懒加载类</code>，否则就是<code>懒加载类</code></p>
<p>下面是<code>非懒加载类</code>的加载流程:</p>
<ul>
<li><code>_getObjc2NonlazyClassList</code>获取到<code>__objc_nlclslist</code>，取出<code>非懒加载类</code></li>
<li><code>addClassTableEntry</code>再加载一遍——如果已添加就不会添加进去，确保整个结构都被添加</li>
<li><code>realizeClassWithoutSwift</code>是接下来要关注的地方</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="comment">// 实现非懒加载的类，对于load方法和静态实例变量</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);</span><br><span class="line">        <span class="comment">// printf(&quot;non-lazy Class:%s\n&quot;,cls-&gt;mangledName());</span></span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hack for class __ARCLite__, which didn&#x27;t get this above</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_SIMULATOR</span></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;cache._buckets == (<span class="keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  </span><br><span class="line">            (cls-&gt;cache._mask  ||  cls-&gt;cache._occupied)) </span><br><span class="line">        &#123;</span><br><span class="line">            cls-&gt;cache._mask = <span class="number">0</span>;</span><br><span class="line">            cls-&gt;cache._occupied = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;ISA()-&gt;cache._buckets == (<span class="keyword">void</span>*)&amp;_objc_empty_cache  &amp;&amp;  </span><br><span class="line">            (cls-&gt;ISA()-&gt;cache._mask  ||  cls-&gt;ISA()-&gt;cache._occupied)) </span><br><span class="line">        &#123;</span><br><span class="line">            cls-&gt;ISA()-&gt;cache._mask = <span class="number">0</span>;</span><br><span class="line">            cls-&gt;ISA()-&gt;cache._occupied = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        addClassTableEntry(cls);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;swiftMetadataInitializer()) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">&quot;Swift class %s with a metadata initializer &quot;</span></span><br><span class="line">                            <span class="string">&quot;is not allowed to be non-lazy&quot;</span>,</span><br><span class="line">                            cls-&gt;nameForLogging());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// fixme also disallow relocatable classes</span></span><br><span class="line">            <span class="comment">// We can&#x27;t disallow all Swift classes because of</span></span><br><span class="line">            <span class="comment">// classes like Swift.__EmptyArrayStorage</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现所有非懒加载的类(实例化类对象的一些信息，例如rw)</span></span><br><span class="line">        realizeClassWithoutSwift(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>realizeClassWithoutSwift</code>分析：</p>
<p>①<code>rw</code>初始化并将<code>ro</code>拷贝一份到<code>rw</code>中的<code>ro</code></p>
<ul>
<li><code>rw</code>表示<code>readWrite</code>，由于动态性，可能会往类中添加属性、方法、添加协议</li>
<li><code>ro</code>表示<code>readOnly</code>，在编译时已经确定了内存</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">if</span> (ro-&gt;flags &amp; RO_FUTURE) &#123;</span><br><span class="line">    <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">    rw = cls-&gt;data();</span><br><span class="line">    ro = cls-&gt;data()-&gt;ro;</span><br><span class="line">    cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">    rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">    rw-&gt;ro = ro;</span><br><span class="line">    rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">    cls-&gt;setData(rw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>②递归调用<code>realizeClassWithoutSwift</code>完善继承链并处理当前类的<code>父类</code>、<code>元类</code>；如果有<code>父类</code>，就通过<code>addSubclass</code>把<code>当前类</code>放到<code>父类</code>的<code>子类列表</code>中去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">...</span><br><span class="line">supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));</span><br><span class="line">metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">cls-&gt;superclass = supercls;</span><br><span class="line">cls-&gt;initClassIsa(metacls);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Connect this class to its superclass&#x27;s subclass lists</span></span><br><span class="line"><span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">    addSubclass(supercls, cls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addRootClass(cls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));</code>递归父类的信息初始化，出口是父类为<code>nil</code>。</p>
</li>
<li><p><code>metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));</code>递归元类的信息初始化，出口是元类的元类为自己。</p>
</li>
<li><p><code>if (supercls) &#123;addSubclass(supercls, cls);&#125; else &#123; addRootClass(cls);&#125;</code>，处理<code>class_data_bits_t</code>成员双向绑定父类，子类。</p>
</li>
</ul>
<p>③<code>remapClass</code>中对类在表中进行查找，如果表中已有该类，则返回一个空值；如果没有则返回当前类，这样保证了<strong>类只加载一次并结束递归</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = remappedClasses(NO);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>  ||  NXMapMember(<span class="built_in">map</span>, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>④最后调用了<code>methodizeClass</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories</span></span><br><span class="line">methodizeClass(cls);</span><br><span class="line"><span class="keyword">return</span> cls;</span><br></pre></td></tr></table></figure>

<p>⑤在<code>methodizeClass</code>中，从<code>ro</code>中<code>读取方法列表（包括分类中的方法）、属性列表、协议列表</code>写到<code>rw</code>中，同时也会加载分类的信息到类里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line"><span class="keyword">method_list_t</span> *<span class="built_in">list</span> = ro-&gt;baseMethods();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">    prepareMethodLists(cls, &amp;<span class="built_in">list</span>, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">    rw-&gt;methods.attachLists(&amp;<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">property_list_t</span> *proplist = ro-&gt;baseProperties;</span><br><span class="line"><span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">    rw-&gt;properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protocol_list_t</span> *protolist = ro-&gt;baseProtocols;</span><br><span class="line"><span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">    rw-&gt;protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Root classes get bonus method implementations if they don&#x27;t have </span></span><br><span class="line"><span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line"><span class="keyword">if</span> (cls-&gt;isRootMetaclass()) &#123;</span><br><span class="line">    <span class="comment">// root metaclass</span></span><br><span class="line">    addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">&quot;&quot;</span>, NO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line">category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing*/</span>);</span><br><span class="line">attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*don&#x27;t flush caches*/</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="为什么要区分ro和rw？"><a href="#为什么要区分ro和rw？" class="headerlink" title="为什么要区分ro和rw？"></a>为什么要区分ro和rw？</h4><ul>
<li>ro的特性就是在编译时就确定了。我们不希望这些原始数据被污染，所以把这些数据存到ro中</li>
<li>rw的特性是可变的。因为runtime的存在，所以我们会动态的添加属性、方法、协议等，所以我们把这些数据存到可更改的rw当中</li>
</ul>
<p>前面已经提到了实现<code>+load</code>方法的类就是<code>非懒加载类</code>，那么没有实现的类就是<code>懒加载类</code>。</p>
<p><strong>打印非懒加载类：</strong></p>
<p>可以通过<code>printf(&quot;non-lazy Class:%s\n&quot;,cls-&gt;mangledName())</code>去打印获取到所有<code>非懒加载类</code>【只有实现了<code>+load</code>的类才会走到这里然后被打印（<code>FXPerson</code>内部实现了+load，其他都是系统内置的类）】</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@master/1-20210124152754176.png"></p>
<p>那么<code>懒加载类</code>是何时加到内存中的呢？需要看下文分析。</p>
<h3 id="3-9-处理所有的分类，包括Class和Metal-Class"><a href="#3-9-处理所有的分类，包括Class和Metal-Class" class="headerlink" title="3.9 处理所有的分类，包括Class和Metal Class"></a>3.9 处理所有的分类，包括Class和Metal Class</h3><p>将在下一篇文章中具体介绍</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories.</span></span><br><span class="line"><span class="comment">// 发现和处理所有Category</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    <span class="comment">// 外部循环遍历找到当前类，查找类对应的Category数组</span></span><br><span class="line">    <span class="keyword">category_t</span> **catlist = </span><br><span class="line">        _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">bool</span> hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 内部循环遍历当前类的所有Category</span></span><br><span class="line">        <span class="keyword">category_t</span> *cat = catlist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 首先，通过其所属的类注册Category。如果这个类已经被实现，则重新构造类的方法列表。</span></span><br><span class="line">        <span class="keyword">bool</span> classExists = NO;</span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;instanceMethods ||  cat-&gt;protocols  </span><br><span class="line">            ||  cat-&gt;instanceProperties) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 将Category添加到对应Class的value中，value是Class对应的所有category数组</span></span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            <span class="comment">// 将Category的method、protocol、property添加到Class</span></span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CLASS: found category -%s(%s) %s&quot;</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cat-&gt;name, </span><br><span class="line">                             classExists ? <span class="string">&quot;on existing class&quot;</span> : <span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这块和上面逻辑一样，区别在于这块是对Meta Class做操作，而上面则是对Class做操作</span></span><br><span class="line">        <span class="comment">// 根据下面的逻辑，从代码的角度来说，是可以对原类添加Category的</span></span><br><span class="line">        <span class="keyword">if</span> (cat-&gt;classMethods  ||  cat-&gt;protocols  </span><br><span class="line">            ||  (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) </span><br><span class="line">        &#123;</span><br><span class="line">            addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi);</span><br><span class="line">            <span class="keyword">if</span> (cls-&gt;ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                remethodizeClass(cls-&gt;ISA());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;CLASS: found category +%s(%s)&quot;</span>, </span><br><span class="line">                             cls-&gt;nameForLogging(), cat-&gt;name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-10-初始化所有未初始化的类【重要】"><a href="#3-10-初始化所有未初始化的类【重要】" class="headerlink" title="3.10 初始化所有未初始化的类【重要】"></a>3.10 初始化所有未初始化的类【重要】</h3><p>实现所有的类。包括<code>Swift</code>和<code>OC</code>，同时会初始化其他<code>objc_class</code>结构体相关的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    header_info *hi;</span><br><span class="line">    <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;getNext()) &#123;</span><br><span class="line">        realizeAllClassesInImage(hi);  <span class="comment">// may drop and re-acquire runtimeLock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环处理<code>header_info</code>，调用<code>realizedAllClassesInImage()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">realizeAllClassesInImage</span><span class="params">(header_info *hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> count, i;</span><br><span class="line">    <span class="keyword">classref_t</span> *classlist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;areAllClassesRealized()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        Class cls = remapClass(classlist[i]);   <span class="comment">// 重新映射类</span></span><br><span class="line">        <span class="keyword">if</span> (cls) &#123;</span><br><span class="line">            realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hi-&gt;setAllClassesRealized(YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环调用<code>realizeClassMaybeSwiftAndLeaveLocked</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftAndLeaveLocked(Class cls, <span class="keyword">mutex_t</span>&amp; lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> realizeClassMaybeSwiftMaybeRelock(cls, lock, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>realizeClassMaybeSwiftMaybeRelock</code>函数真正调用的总入口</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Class</span><br><span class="line">realizeClassMaybeSwiftMaybeRelock(Class cls, <span class="keyword">mutex_t</span>&amp; lock, <span class="keyword">bool</span> leaveLocked)</span><br><span class="line">&#123;</span><br><span class="line">    lock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) &#123;</span><br><span class="line">        <span class="comment">// Non-Swift class. Realize it now with the lock still held.</span></span><br><span class="line">        <span class="comment">// fixme wrong in the future for objc subclasses of swift classes</span></span><br><span class="line">        realizeClassWithoutSwift(cls);  <span class="comment">// 非swift类</span></span><br><span class="line">        <span class="keyword">if</span> (!leaveLocked) lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Swift class. We need to drop locks and call the Swift</span></span><br><span class="line">        <span class="comment">// runtime to initialize it.</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">        cls = realizeSwiftClass(cls);   <span class="comment">// swift类</span></span><br><span class="line">        assert(cls-&gt;isRealized());    <span class="comment">// callback must have provoked realization</span></span><br><span class="line">        <span class="keyword">if</span> (leaveLocked) lock.lock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过判断是否<code>Swift class</code>来区分<code>Swift</code>和<code>OC</code>类的实现入口。</p>
<p>然后<code>realizeClassWithoutSwift</code>在<strong>3.8</strong>中分析过一次了。</p>
<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><h3 id="objc4-756-2源码"><a href="#objc4-756-2源码" class="headerlink" title="objc4-756.2源码"></a>objc4-756.2源码</h3><p>本文使用：<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">objc4-756.2源码</a> 进行分析</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904047875473421#heading-19">iOS 底层探索篇·Easting</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904072399585294#heading-17">iOS探索 类的加载过程</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">09-分类、类拓展的加载过程 &amp; load、initialize分析</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8B-dyld%E5%88%86%E6%9E%90/"><span class="level-item">07下-dyld分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言：dyld加载流程（精简）"><span class="level-left"><span class="level-item">前言：dyld加载流程（精简）</span></span></a></li><li><a class="level is-mobile" href="#一、-objc-init流程"><span class="level-left"><span class="level-item">一、_objc_init流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-environ-init-函数"><span class="level-left"><span class="level-item">1.1 environ_init 函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-1-1-修改环境变量OBJC-PRINT-LOAD-METHOD为YES后"><span class="level-left"><span class="level-item">1.1.1 修改环境变量OBJC_PRINT_LOAD_METHOD为YES后</span></span></a></li><li><a class="level is-mobile" href="#1-1-2-修改OBJC-PRINT-NONPOINTER-ISA为YES后"><span class="level-left"><span class="level-item">1.1.2 修改OBJC_PRINT_NONPOINTER_ISA为YES后</span></span></a></li></ul></li><li><a class="level is-mobile" href="#1-2-tls-init-函数"><span class="level-left"><span class="level-item">1.2 tls_init 函数</span></span></a></li><li><a class="level is-mobile" href="#1-3-static-init-函数"><span class="level-left"><span class="level-item">1.3 static_init 函数</span></span></a></li><li><a class="level is-mobile" href="#1-4-lock-init-函数"><span class="level-left"><span class="level-item">1.4 lock_init 函数</span></span></a></li><li><a class="level is-mobile" href="#1-5-exception-init-函数"><span class="level-left"><span class="level-item">1.5 exception_init 函数</span></span></a></li><li><a class="level is-mobile" href="#1-6-dyld-objc-notify-register-函数"><span class="level-left"><span class="level-item">1.6 _dyld_objc_notify_register 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、map-images-函数"><span class="level-left"><span class="level-item">二、map_images 函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#2-1-preopt-init"><span class="level-left"><span class="level-item">2.1 preopt_init()</span></span></a></li><li><a class="level is-mobile" href="#2-2-sel-init"><span class="level-left"><span class="level-item">2.2 sel_init()</span></span></a></li><li><a class="level is-mobile" href="#2-3-arr-init"><span class="level-left"><span class="level-item">2.3 arr_init()</span></span></a></li><li><a class="level is-mobile" href="#2-4-read-images"><span class="level-left"><span class="level-item">2.4 _read_images()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#三、类加载"><span class="level-left"><span class="level-item">三、类加载</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#入口：-read-images-函数"><span class="level-left"><span class="level-item">入口：_read_images() 函数</span></span></a></li><li><a class="level is-mobile" href="#3-1-第一次要做的事情-doneOnce【重要】"><span class="level-left"><span class="level-item">3.1 第一次要做的事情 - doneOnce【重要】</span></span></a></li><li><a class="level is-mobile" href="#3-2-对所有类做重映射【重要】"><span class="level-left"><span class="level-item">3.2 对所有类做重映射【重要】</span></span></a></li><li><a class="level is-mobile" href="#3-3-修复重映射"><span class="level-left"><span class="level-item">3.3 修复重映射</span></span></a></li><li><a class="level is-mobile" href="#3-4-添加SEL到namedSelectors表"><span class="level-left"><span class="level-item">3.4 添加SEL到namedSelectors表</span></span></a></li><li><a class="level is-mobile" href="#3-5-修复旧的函数指针调用遗留"><span class="level-left"><span class="level-item">3.5 修复旧的函数指针调用遗留</span></span></a></li><li><a class="level is-mobile" href="#3-6-将所有Protocol都添加到protocol-map表中"><span class="level-left"><span class="level-item">3.6 将所有Protocol都添加到protocol_map表中</span></span></a></li><li><a class="level is-mobile" href="#3-7-对所有Protocol做重映射"><span class="level-left"><span class="level-item">3.7 对所有Protocol做重映射</span></span></a></li><li><a class="level is-mobile" href="#3-8-初始化所有非懒加载的类，进行rw、ro等操作【重要】"><span class="level-left"><span class="level-item">3.8 初始化所有非懒加载的类，进行rw、ro等操作【重要】</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#为什么要区分ro和rw？"><span class="level-left"><span class="level-item">为什么要区分ro和rw？</span></span></a></li></ul></li><li><a class="level is-mobile" href="#3-9-处理所有的分类，包括Class和Metal-Class"><span class="level-left"><span class="level-item">3.9 处理所有的分类，包括Class和Metal Class</span></span></a></li><li><a class="level is-mobile" href="#3-10-初始化所有未初始化的类【重要】"><span class="level-left"><span class="level-item">3.10 初始化所有未初始化的类【重要】</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#objc4-756-2源码"><span class="level-left"><span class="level-item">objc4-756.2源码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>