<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>10-底层面试答疑 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="10-底层面试答疑"><meta property="og:url" content="http://evilimo.com/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://evilimo.com/img/og_image.png"><meta property="article:published_time" content="2021-02-16T09:13:47.536Z"><meta property="article:modified_time" content="2021-02-18T08:25:31.097Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"},"headline":"IMO's Blog","image":["http://evilimo.com/img/og_image.png"],"datePublished":"2021-02-16T09:13:47.536Z","dateModified":"2021-02-18T08:25:31.097Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-16T09:13:47.536Z" title="2021-02-16T09:13:47.536Z">2021-02-16</time>发表</span><span class="level-item"><time dateTime="2021-02-18T08:25:31.097Z" title="2021-02-18T08:25:31.097Z">2021-02-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">10-底层面试答疑</h1><div class="content"><hr>
<a id="more"></a>

<h1 id="一、什么是-Runtime"><a href="#一、什么是-Runtime" class="headerlink" title="一、什么是 Runtime"></a>一、什么是 Runtime</h1><p>答：用 C、C++、汇编实现的一套 API，为 OC 语言加入了面向对象和运行时的功能。</p>
<p><strong>应用举例：</strong></p>
<p>类的 ro 和 rw 属性，ro(read-only)在编译期就确定好了，而 rw(read-write)是在运行时才完全赋值。</p>
<h1 id="二、方法的本质是什么"><a href="#二、方法的本质是什么" class="headerlink" title="二、方法的本质是什么"></a>二、方法的本质是什么</h1><p>答：方法的本质就是消息的发送，就是在底层调用<code>_objc_msgSennd</code>方法寻找方法<code>IMP</code>的过程，主要经历了以下几个步骤：</p>
<ol>
<li><p>快速查找流程：通过汇编（<code>objc_msgSend</code>）查找<code>cache_t</code>中缓存的消息，找到就返回<code>imp</code>，找不到就进行慢速查找。</p>
</li>
<li><p>慢速查找流程：通过函数<code>lookUpImpOrForward</code>递归查找当前类和父类的缓存和方法列表，如果找到了就会缓存方法方便快速查找，找不到就会进行动态方法解析</p>
</li>
<li><p>动态方法解析：此时<code>OC</code>会给我们一次对<code>sel</code>的处理机会，你可以在<code>resolveInstanceMethod:</code>（类方法对应<code>resolveClassMethod:</code>）中添加一个<code>IMP</code></p>
</li>
<li><p>如果你没把握住这次机会，也就是解析失败时，会来到<strong>消息转发阶段</strong>，这个阶段有两个机会去处理<code>sel</code>，分别是快速转发的<code>forwardingTargetForSelector:</code>，以及慢速转发的<code>methodSignatureForSelector:</code>。</p>
<ol>
<li>消息快速转发：<code>forwardingTargedForSelector</code>，如果有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。</li>
<li>消息慢速转发：<code>methodSignatureForSelector</code>，进行方法签名，把方法丢出去，<code>forwardInvocation</code>来对消息处理。</li>
</ol>
</li>
<li><p>未找到消息：无法找到<code>IMP</code>，就进入到了<code>doesNotRecognizeSelector</code>报错，打印log</p>
</li>
</ol>
<h1 id="三、sel-是什么？IMP-是什么？两者之间的关系？"><a href="#三、sel-是什么？IMP-是什么？两者之间的关系？" class="headerlink" title="三、sel 是什么？IMP 是什么？两者之间的关系？"></a>三、sel 是什么？IMP 是什么？两者之间的关系？</h1><p>答：</p>
<p><code>SEL</code>是方法编号，也是方法名，在dyld加载镜像带内存时，通过<code>_read_image</code>方法加载到内存的表中了</p>
<p><code>IMP</code> 就是我们函数实现指针 ，找<code>IMP</code>就是找函数的过程</p>
<p><code>函数</code>就是对应的实现内容</p>
<h1 id="四、能否向运⾏时创建的类中添加成员变量？"><a href="#四、能否向运⾏时创建的类中添加成员变量？" class="headerlink" title="四、能否向运⾏时创建的类中添加成员变量？"></a>四、能否向运⾏时创建的类中添加成员变量？</h1><p>答：不能。</p>
<p>原因：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;     <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;    <span class="comment">// 协议列表</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;          <span class="comment">// 成员变量列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;    <span class="comment">// 属性列表</span></span><br><span class="line">  </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// Be warned that Symbolication knows the layout of this structure.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">method_array_t</span> methods;        <span class="comment">// 方法列表</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties;   <span class="comment">// 属性列表</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;    <span class="comment">// 协议列表</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为我们编译好的成员变量存储的位置在类的<code>ro</code>中，⼀旦编译完成，内存结构就完全确定⽆法修改，只能修改类的<code>rw</code>中的方法或者可以通过关联对象的方式来添加<code>属性</code>。</p>
<p>关联对象添加的主要步骤如下：</p>
<ol>
<li><code>objc_setAssociatedObject</code>设置<code>set</code>方法：找到关联对象的<strong>总哈希表</strong>，然后通过<strong>指针地址</strong>找到<strong>该类的哈希</strong>表，然后通过key值进行存储</li>
<li><code>objc_getAssociatedObject</code>设置<code>get</code>方法：和set方法一样查询表，找到值</li>
<li>在类的<code>dealloc</code>会清除关联对象的哈希表</li>
</ol>
<h1 id="五、isKindOfClass-和-isMemberOfClass的区别"><a href="#五、isKindOfClass-和-isMemberOfClass的区别" class="headerlink" title="五、isKindOfClass 和 isMemberOfClass的区别"></a>五、<code>isKindOfClass</code> 和 <code>isMemberOfClass</code>的区别</h1><h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><p>当调用者对象是<code>实例对象</code>时：【常用】</p>
<p><code>-isKindOfClass</code>：判断调用者对象是否是xx类以及他的子类的实例<br><code>-isMemberOfClass</code>：判断调用者对象是否是xx类的实例</p>
<p>当调用者对象是<code>类对象</code>时：【可忽略】</p>
<p><code>+isKindOfClass</code>：判断当前类对象的元类对象及其父类的元类对象是否等于传入的对象</p>
<p><code>+isMemberOfClass</code>：判断当前类对象的元类对象是否等于传入的这个对象</p>
<h2 id="原理探究："><a href="#原理探究：" class="headerlink" title="原理探究："></a>原理探究：</h2><p>举例：</p>
<p>1.消息接收者是实力对象-&gt;调用对象方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> re5 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">BOOL</span> re6 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> alloc] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">BOOL</span> re7 = [(<span class="keyword">id</span>)[LGPerson alloc] isKindOfClass:[LGPerson <span class="keyword">class</span>]];       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">BOOL</span> re8 = [(<span class="keyword">id</span>)[LGPerson alloc] isMemberOfClass:[LGPerson <span class="keyword">class</span>]];     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot; re5 :%hhd\n re6 :%hhd\n re7 :%hhd\n re8 :%hhd\n&quot;</span>,re5,re6,re7,re8);</span><br></pre></td></tr></table></figure>

<p>上述Log的打印结果为1，0，0，0</p>
<p>2.消息接收者是类对象-&gt;调用类方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> re1 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isKindOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];       <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">BOOL</span> re2 = [(<span class="keyword">id</span>)[<span class="built_in">NSObject</span> <span class="keyword">class</span>] isMemberOfClass:[<span class="built_in">NSObject</span> <span class="keyword">class</span>]];     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">BOOL</span> re3 = [(<span class="keyword">id</span>)[LGPerson <span class="keyword">class</span>] isKindOfClass:[LGPerson <span class="keyword">class</span>]];       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">BOOL</span> re4 = [(<span class="keyword">id</span>)[LGPerson <span class="keyword">class</span>] isMemberOfClass:[LGPerson <span class="keyword">class</span>]];     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot; re1 :%hhd\n re2 :%hhd\n re3 :%hhd\n re4 :%hhd\n&quot;</span>,re1,re2,re3,re4);</span><br></pre></td></tr></table></figure>

<p>上述Log的打印结果为1，1，1，1</p>
<p>对于第1个例子，大家都使用的非常熟练，但是对于第2个例子的打印结果就有些纳闷了。我们发现两个例子的主要区别在于消息接受者是<strong>实例对象</strong>还是<strong>类对象</strong>。</p>
<p>其实这两个方法是有对应的类方法和实例方法的，只不过我们平时不使用类方法而已，查看源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_getClass.</span></span><br><span class="line"><span class="comment">* Locking: None. If you add locking, tell gdb (rdar://7516456).</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// object_getClass()方法取得的是对象的isa指针指向的对象</span></span><br><span class="line"><span class="comment">// 对于对象来说就是获取到他的类</span></span><br><span class="line"><span class="comment">// 对于类对象来说就是获取到他的元类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断当前类对象的元类对象是否与传入的这个对象相等，所以这个cls应该是元类对象才有可能为 true</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line"><span class="keyword">return</span> object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前实例对象的类对象是否与传入的对象相等，所以cls只有可能是类对象才有可能相等</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isMemberOfClass:(Class)cls &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>] == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环判断当前类对象的元类对象及其父类的元类对象是否等于传入的cls</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">  <span class="keyword">for</span> (Class tcls = object_getClass((<span class="keyword">id</span>)<span class="keyword">self</span>); tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环判断当前实例对象的父类的类对象是否等于传入的对象cls，也就是判断实例对象是否是cls及其子类的一种</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isKindOfClass:(Class)cls &#123;</span><br><span class="line">  <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以，如果方法调用者是实例对象，那么传入的就应该是类对象；如果方法调用者是类对象，那么传入的就应该是元类对象。</strong></p>
<h1 id="六、-self-class-、-super-class-、-self-superclass-的区别以及原理分析"><a href="#六、-self-class-、-super-class-、-self-superclass-的区别以及原理分析" class="headerlink" title="六、[self class]、[super class]、[self superclass]的区别以及原理分析"></a>六、[self class]、[super class]、[self superclass]的区别以及原理分析</h1><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ul>
<li><p>class:获取当前方法调用者的类</p>
</li>
<li><p>superclass:获取当前方法调用者的父类</p>
</li>
<li><p>super:是一个结构体，结构体中消息接收者还是当前对象，所以就会让<code>当前对象</code>去<code>调用父类方法</code>，本质还是当前对象在调用</p>
</li>
</ul>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>创建一个Student类继承子Person类，查看打印：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;[self class] = %@&quot;</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);           <span class="comment">// [self class] = Student</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;[super class] = %@&quot;</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);			   <span class="comment">// [super class] = Student</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;[self superclass] = %@&quot;</span>, [<span class="keyword">self</span> superclass]); <span class="comment">// [self superclass] = Person</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;[super superclass] = %@&quot;</span>, [<span class="keyword">super</span> superclass]);<span class="comment">// [super superclass] = Person</span></span><br></pre></td></tr></table></figure>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>先上源码看一下第一个和第三个的理解</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">// object_getClass()方法取得的是对象的isa指针指向的对象</span></span><br><span class="line"> <span class="comment">// 对于对象来说就是获取到他的类</span></span><br><span class="line"> <span class="comment">// 对于类对象来说就是获取到他的元类</span></span><br><span class="line"> Class object_getClass(<span class="keyword">id</span> obj)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;getIsa();</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> + (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (Class)<span class="keyword">class</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> object_getClass(<span class="keyword">self</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> + (Class)superclass &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">self</span>-&gt;superclass;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> - (Class)superclass &#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="keyword">self</span> <span class="keyword">class</span>]-&gt;superclass;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">Class class_getSuperclass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;superclass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们知道，这里方法中的<code>self</code>都是指<code>消息的接受者</code>，在这里就表示<code>Student</code>类，根据以上源码，第一个和第三个没啥疑问，都是寻找<code>Student</code>的<code>isa</code>和父类。</p>
<p><strong>那么<code>super</code>调用时，有啥不同，我们需要先知道<code>super</code>的本质</strong></p>
<p>通过clang编译代码，我们可以发现，底层调用时<code>super</code>调用的方法不是<code>msgSend</code>,而是<code>objc_msgSendSuper(object ,superclass, @selector(class))</code>，传入了一个<code>super</code>的结构体和方法。</p>
<p>我们知道消息发送的时候，慢速查找流程是需要从自身递归查找到<code>NSObject</code>的，而<code>objc_msgSendSuper</code>就表示直接从消息接受者的父类开始递归查找，跳过了本身的方法列表，这样查找的速度可以更快。</p>
<p><code>super</code>的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super</span> &#123;</span></span><br><span class="line">    __unsafe_unretained _Nonnull id receiver;</span><br><span class="line">    __unsafe_unretained _Nonnull Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>两个参数分别为消息的接受者和父类，在这里<code>Student</code>即为消息接受者,<code>Person</code>为父类.</p>
<p>所以调用<code>[super class]</code>和<code>[super superclass]</code>本质上消息的接受者还是<code>self</code>，即<code>Student</code>类。所以就跟第一个和第三个结果没有区别。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>[self class]</code> 就是发送消息<code>objc_msgSend</code>，消息接受者是 <code>self</code>,⽅法编号：class</p>
<p><code>[super class]</code> 本质就是<code>objc_msgSendSuper</code>, 消息的接受者还是 <code>self</code> ⽅法编号：class(父类的)</p>
<p>只是<code>objc_msgSendSuper</code> 会更快 直接跳过 <code>self</code> 的查找,但是都会走到<code>NSObject</code>基类的实现方法中，但是都是以<code>self</code>为接受者</p>
<h1 id="七、Runtime-是如何实现-weak-的，为什么可以⾃动置-nil？"><a href="#七、Runtime-是如何实现-weak-的，为什么可以⾃动置-nil？" class="headerlink" title="七、Runtime 是如何实现 weak 的，为什么可以⾃动置 nil？"></a>七、Runtime 是如何实现 weak 的，为什么可以⾃动置 nil？</h1><p>主要总结如下：</p>
<ol>
<li>通过<code>SideTable</code>找到我们的<code>weak_table</code></li>
<li><code>weak_table</code> 根据<code>referent</code> 找到或者创建 <code>weak_entry_t</code></li>
<li>然后<code>append_referrer(entry, referrer)</code>将新弱引⽤的对象加进去<code>entry</code></li>
<li>最后<code>weak_entry_insert</code> 把<code>entry</code>加⼊到我们的<code>weak_table</code></li>
<li>在类<code>dealloc</code>时，会根据插入的步骤找到对应的弱引用，并置为<code>nil</code></li>
</ol>
<p>关于<code>weak</code>的相关知识做了单独的总结，详情可以看下方文章👇</p>
<p><a target="_blank" rel="noopener" href="https://www.evilimo.com/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8Bweak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/#more">11-weak原理探究</a></p>
<h1 id="八、Method-Swizzling-的坑与应⽤"><a href="#八、Method-Swizzling-的坑与应⽤" class="headerlink" title="八、Method Swizzling 的坑与应⽤"></a>八、Method Swizzling 的坑与应⽤</h1><p>详情可以看下面的文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.evilimo.com/2021/02/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/12-Method%20Swizzling%E7%9A%84%E5%9D%91%E4%B8%8E%E5%BA%94%E7%94%A8/#more">12-Method Swizzling的坑与应用</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904051876823047#heading-12">iOS底层学习 - Runtime之砖厂面试答疑</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">11-weak原理探究</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"><span class="level-item">09-分类、类拓展的加载过程 &amp; load、initialize分析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、什么是-Runtime"><span class="level-left"><span class="level-item">一、什么是 Runtime</span></span></a></li><li><a class="level is-mobile" href="#二、方法的本质是什么"><span class="level-left"><span class="level-item">二、方法的本质是什么</span></span></a></li><li><a class="level is-mobile" href="#三、sel-是什么？IMP-是什么？两者之间的关系？"><span class="level-left"><span class="level-item">三、sel 是什么？IMP 是什么？两者之间的关系？</span></span></a></li><li><a class="level is-mobile" href="#四、能否向运⾏时创建的类中添加成员变量？"><span class="level-left"><span class="level-item">四、能否向运⾏时创建的类中添加成员变量？</span></span></a></li><li><a class="level is-mobile" href="#五、isKindOfClass-和-isMemberOfClass的区别"><span class="level-left"><span class="level-item">五、isKindOfClass 和 isMemberOfClass的区别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#答："><span class="level-left"><span class="level-item">答：</span></span></a></li><li><a class="level is-mobile" href="#原理探究："><span class="level-left"><span class="level-item">原理探究：</span></span></a></li></ul></li><li><a class="level is-mobile" href="#六、-self-class-、-super-class-、-self-superclass-的区别以及原理分析"><span class="level-left"><span class="level-item">六、[self class]、[super class]、[self superclass]的区别以及原理分析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#结论"><span class="level-left"><span class="level-item">结论</span></span></a></li><li><a class="level is-mobile" href="#例"><span class="level-left"><span class="level-item">例</span></span></a></li><li><a class="level is-mobile" href="#原理"><span class="level-left"><span class="level-item">原理</span></span></a></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#七、Runtime-是如何实现-weak-的，为什么可以⾃动置-nil？"><span class="level-left"><span class="level-item">七、Runtime 是如何实现 weak 的，为什么可以⾃动置 nil？</span></span></a></li><li><a class="level is-mobile" href="#八、Method-Swizzling-的坑与应⽤"><span class="level-left"><span class="level-item">八、Method Swizzling 的坑与应⽤</span></span></a></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>