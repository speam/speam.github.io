<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>11-weak原理探究 - IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description=""><meta property="og:type" content="blog"><meta property="og:title" content="11-weak原理探究"><meta property="og:url" content="http://evilimo.com/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217195127047.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195854850.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195919677.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217204426936.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/16fbcc4ecee242a3.png"><meta property="article:published_time" content="2021-02-17T11:42:39.379Z"><meta property="article:modified_time" content="2021-02-18T01:48:20.979Z"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217195127047.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},"headline":"IMO's Blog","image":["https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217195127047.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195854850.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195919677.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217204426936.png","https://cdn.jsdelivr.net/gh/speam/blogImgs@main/16fbcc4ecee242a3.png"],"datePublished":"2021-02-17T11:42:39.379Z","dateModified":"2021-02-18T01:48:20.979Z","author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="canonical" href="http://evilimo.com/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-02-17T11:42:39.379Z" title="2021-02-17T11:42:39.379Z">2021-02-17</time>发表</span><span class="level-item"><time dateTime="2021-02-18T01:48:20.979Z" title="2021-02-18T01:48:20.979Z">2021-02-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile">11-weak原理探究</h1><div class="content"><hr>
<a id="more"></a>

<blockquote>
<p>内存管理在APP开发过程中占据着一个很重要的地位，在iOS中，系统为我们提供了ARC的开发环境，帮助我们做了很多内存管理的内容。本章我们先来看一下，平时开发中使用最多的weak在底层是如何进行实现的</p>
</blockquote>
<h1 id="一、-strong、-weak、-unsafe-unretained的区别"><a href="#一、-strong、-weak、-unsafe-unretained的区别" class="headerlink" title="一、__strong、__weak、__unsafe_unretained的区别"></a>一、<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>的区别</h1><p>我们通过例子来看一下<code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code>的区别。</p>
<p>首先是看如下例子，可以知道在临时作用域结束之后，生成的对象就会进行销毁，我们在作用域外部用修饰符来持有对象，再来看一下对象的销毁情况</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域开始&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    LGPerson *person = [[LGPerson alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person对象：%@&quot;</span>, person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">***************************打印结果******************************</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">10</span>:<span class="number">57</span>:<span class="number">13.910542</span>+<span class="number">0800</span> objc-debug[<span class="number">74175</span>:<span class="number">19740208</span>] 临时作用域开始</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">10</span>:<span class="number">57</span>:<span class="number">13.911181</span>+<span class="number">0800</span> objc-debug[<span class="number">74175</span>:<span class="number">19740208</span>] person对象：&lt;LGPerson: <span class="number">0x10221c900</span>&gt;</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">10</span>:<span class="number">57</span>:<span class="number">13.911277</span>+<span class="number">0800</span> objc-debug[<span class="number">74175</span>:<span class="number">19740208</span>] LGPerson -[LGPerson dealloc]</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">10</span>:<span class="number">57</span>:<span class="number">13.911367</span>+<span class="number">0800</span> objc-debug[<span class="number">74175</span>:<span class="number">19740208</span>] 临时作用域结束</span><br></pre></td></tr></table></figure>

<h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p>先来看一下用<code>__strong</code>修饰的结果。可以发现修饰的对象在作用域结束之后并没有销毁，说明该对象的<strong>引用计数</strong>增加了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">strong</span> LGPerson *strongPerson;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域开始&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    LGPerson *person = [[LGPerson alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person对象：%@&quot;</span>, person);</span><br><span class="line">    strongPerson = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域结束&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;strongPerson：%@&quot;</span>, strongPerson);</span><br><span class="line">***************************打印结果******************************</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">44.079292</span>+<span class="number">0800</span> objc-debug[<span class="number">74452</span>:<span class="number">19777011</span>] 临时作用域开始</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">44.080060</span>+<span class="number">0800</span> objc-debug[<span class="number">74452</span>:<span class="number">19777011</span>] person对象：&lt;LGPerson: <span class="number">0x101945ae0</span>&gt;</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">44.080172</span>+<span class="number">0800</span> objc-debug[<span class="number">74452</span>:<span class="number">19777011</span>] 临时作用域结束</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">54</span>:<span class="number">44.080292</span>+<span class="number">0800</span> objc-debug[<span class="number">74452</span>:<span class="number">19777011</span>] strongPerson：&lt;LGPerson: <span class="number">0x101945ae0</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h2><p>再来看一下<code>__weak</code>修饰的结果。通过下面的运行我们可以发现，用<code>__weak</code>修饰后，并没有增加<strong>引用计数</strong>，并且作用域结束，对象释放后，修饰的对象为<code>nil</code>，没有造成野指针的崩溃，可以说是一种安全的方案</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> LGPerson *weakPerson;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域开始&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    LGPerson *person = [[LGPerson alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person对象：%@&quot;</span>, person);</span><br><span class="line">    weakPerson = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域结束&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;weakPerson：%@&quot;</span>, weakPerson);</span><br><span class="line"></span><br><span class="line">***************************打印结果******************************</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">08.842409</span>+<span class="number">0800</span> objc-debug[<span class="number">74479</span>:<span class="number">19780263</span>] 临时作用域开始</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">08.843151</span>+<span class="number">0800</span> objc-debug[<span class="number">74479</span>:<span class="number">19780263</span>] person对象：&lt;LGPerson: <span class="number">0x101712030</span>&gt;</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">08.843382</span>+<span class="number">0800</span> objc-debug[<span class="number">74479</span>:<span class="number">19780263</span>] LGPerson -[LGPerson dealloc]</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">08.843572</span>+<span class="number">0800</span> objc-debug[<span class="number">74479</span>:<span class="number">19780263</span>] 临时作用域结束</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">11</span>:<span class="number">58</span>:<span class="number">08.843762</span>+<span class="number">0800</span> objc-debug[<span class="number">74479</span>:<span class="number">19780263</span>] weakPerson：(null)</span><br></pre></td></tr></table></figure>

<h2 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h2><p>最后我们来看一下，平时开发使用较少的<code>__unsafe_unretained</code>和上面两个的区别在哪。我们通过结果可以发现，在作用域消失，对象就进行了销毁，并且在出作用域打印修饰对象时，出现了<strong>野指针</strong>的崩溃<strong>EXC_BAD_ACCESS</strong></p>
<p>所以这样就看出了<code>__weak</code>和<code>__unsafe_unretained</code>的区别就是<strong>前者会在对象被释放的时候自动置为nil，而后者却不行。</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">unsafe_unretained</span> LGPerson *unsafePerson;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域开始&quot;</span>);</span><br><span class="line">&#123;</span><br><span class="line">    LGPerson *person = [[LGPerson alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;person对象：%@&quot;</span>, person);</span><br><span class="line">    unsafePerson = person;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;临时作用域结束&quot;</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;unsafePerson：%@&quot;</span>, unsafePerson);</span><br><span class="line"></span><br><span class="line">***************************打印结果******************************</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">02</span>:<span class="number">34.428120</span>+<span class="number">0800</span> objc-debug[<span class="number">74513</span>:<span class="number">19785153</span>] 临时作用域开始</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">02</span>:<span class="number">34.428813</span>+<span class="number">0800</span> objc-debug[<span class="number">74513</span>:<span class="number">19785153</span>] person对象：&lt;LGPerson: <span class="number">0x1019159f0</span>&gt;</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">02</span>:<span class="number">34.428901</span>+<span class="number">0800</span> objc-debug[<span class="number">74513</span>:<span class="number">19785153</span>] LGPerson -[LGPerson dealloc]</span><br><span class="line"><span class="number">2020</span><span class="number">-01</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">02</span>:<span class="number">34.429015</span>+<span class="number">0800</span> objc-debug[<span class="number">74513</span>:<span class="number">19785153</span>] 临时作用域结束</span><br></pre></td></tr></table></figure>



<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217195127047.png"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li><code>__strong</code>修饰后，对象的<strong>引用计数</strong>会增加，在作用域外不会销毁</li>
<li><code>__weak</code>修饰后，对象<strong>引用计数</strong>不会增加，在作用域外会自动置为<code>nil</code></li>
<li><code>__unsafe_unretained</code>修饰后，引用计数不会增加，在作用域外不会置空，会造成野指针崩溃</li>
</ul>
<blockquote>
<p>通过上面例子基本了解了__weak的作用，那么__weak是如何进行创建和销毁的呢，下面通过源码进行深度探索</p>
</blockquote>
<h1 id="二、weak-代码定位"><a href="#二、weak-代码定位" class="headerlink" title="二、weak 代码定位"></a>二、weak 代码定位</h1><p>打断点查看汇编</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200.png" alt="示例代码"></p>
<p>在汇编中发现<code>weak</code>底层调用的是<code>objc_initWeak</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195854850.png" alt="汇编"></p>
<p>我们给<code>objc_initWeak</code>打上符号断点重新运行，发现<code>objc_initWeak</code>存在于<code>libobjc.A.dylib</code>的动态库中。</p>
<p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1200-20210217195919677.png"></p>
<h1 id="三、weak-的保存逻辑"><a href="#三、weak-的保存逻辑" class="headerlink" title="三、weak 的保存逻辑"></a>三、weak 的保存逻辑</h1><p>通过上面的分析我们把 weak 的创建定位到了<code>objc_initWeak</code>这个方法，下面开始进行源码分析</p>
<h2 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h2><p>其中两个参数<code>location</code>和<code>newObj</code>的含义如下</p>
<ul>
<li><code>location</code>：表示<code>__weak 指针的地址</code>。之所以要存储<code>指针的地址</code>，是因为最后我们要讲<code>__weak</code>指针指向的内容置为<code>nil</code>，如果仅存储指针的话，是不能够完成这个功能的。</li>
<li><code>newObj</code>：所引用的对象。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id newObj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h2><p>查看<code>storeWeak</code>源码，根据注释，可以知道如下几点</p>
<ul>
<li><code>HaveOld</code>：<code>weak</code>指针之前是否已经指向了一个弱引用</li>
<li><code>HaveNew</code>：<code>weak</code>指针是否需要指向一个新引用</li>
<li><code>CrashIfDeallocating</code>：如果被弱引用的对象正在析构，此时再弱引用该对象，是否应该<code>crash</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update a weak variable.</span></span><br><span class="line"><span class="comment">// If HaveOld is true, the variable has an existing value </span></span><br><span class="line"><span class="comment">//   that needs to be cleaned up. This value might be nil.</span></span><br><span class="line"><span class="comment">// If HaveNew is true, there is a new value that needs to be </span></span><br><span class="line"><span class="comment">//   assigned into the variable. This value might be nil.</span></span><br><span class="line"><span class="comment">// If CrashIfDeallocating is true, the process is halted if newObj is </span></span><br><span class="line"><span class="comment">//   deallocating or newObj&#x27;s class does not support weak references. </span></span><br><span class="line"><span class="comment">//   If CrashIfDeallocating is false, nil is stored instead.</span></span><br><span class="line"><span class="keyword">enum</span> CrashIfDeallocating &#123;</span><br><span class="line">    DontCrashIfDeallocating = <span class="literal">false</span>, DoCrashIfDeallocating = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> id </span><br><span class="line">storeWeak(id *location, objc_object *newObj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(newObj == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *newTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">    <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">    <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">    <span class="comment">// ✅如果weak指针之前弱引用过一个obj，则将这个obj所对应的SideTable取出，赋值给oldTable</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        oldObj = *location;</span><br><span class="line">        oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有弱引用过，则oldTable = nil</span></span><br><span class="line">        oldTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ✅如果weak指针要弱引用一个新的obj，则将该obj对应的SideTable取出，赋值给newTable</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        newTable = &amp;SideTables()[newObj];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newTable = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ✅加锁操作，防止多线程中竞争冲突</span></span><br><span class="line">    SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ✅多线程安全：location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">        SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">    <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">    <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">        Class cls = newObj-&gt;getIsa();</span><br><span class="line">        <span class="comment">// ✅如果cls还没有初始化，先初始化，再尝试设置弱引用</span></span><br><span class="line">        <span class="keyword">if</span> (cls != previouslyInitializedClass  &amp;&amp;  </span><br><span class="line">            !((objc_class *)cls)-&gt;isInitialized()) </span><br><span class="line">        &#123;</span><br><span class="line">            SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">            class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this class is finished with +initialize then we&#x27;re good.</span></span><br><span class="line">            <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">            <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">            <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">            <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">            <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">            <span class="comment">// ✅完成初始化后进行标记</span></span><br><span class="line">            previouslyInitializedClass = cls;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ✅newObj 初始化后，重新获取一遍newObj</span></span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">    <span class="comment">// ✅ 如果weak指针之前弱引用过别的对象oldObj，则调用weak_unregister_no_lock，在oldObj的weak_entry_t中移除该weak指针地址</span></span><br><span class="line">    <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">        weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="comment">// ✅如果weak指针需要弱引用新的对象newObj</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="comment">// ✅调用weak_register_no_lock方法，将weak指针的地址记录到newObj对应的weak_entry_t中</span></span><br><span class="line">        newObj = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">        <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">        <span class="comment">// ✅更新newObj的isa指针的weakly_referenced bit标志位</span></span><br><span class="line">        <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">            newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">        <span class="comment">// ✅*location 赋值，也就是将weak指针直接指向了newObj，而且没有将newObj的引用计数+1</span></span><br><span class="line">        *location = (id)newObj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们这里是第一次调用，所以是一个新的对象，也就是<code>haveNew</code>的情况，获取到的是新的散列表<code>SideTable</code>，主要执行了<code>weak_register_no_lock</code>方法来进行插入。</p>
<h2 id="weak-register-no-lock"><a href="#weak-register-no-lock" class="headerlink" title="weak_register_no_lock"></a>weak_register_no_lock</h2><p>接着我们来分析<code>weak_register_no_lock</code>函数是怎么注册弱引用的。</p>
<p>我们发现函数内部主要进行了<code>isTaggedPointer</code>和<code>deallocating</code>的判断等前置条件，这些都是不能进行弱引用的情况。</p>
<p>如果可以被弱引用，则将被弱引用对象所在的<code>weak_table中</code>的<code>weak_entry_t</code>哈希数组中取出对应的<code>weak_entry_t</code>，如果<code>weak_entry_t</code>不存在，则会新建一个。然后将指向被弱引用对象地址的指针<code>referrer</code>通过函数<code>append_referrer</code>插入到对应的<code>weak_entry_t</code>引用数组。至此就完成了弱引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Registers a new (object, weak pointer) pair. Creates a new weak</span></span><br><span class="line"><span class="comment"> * object entry if it does not exist.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param weak_table The global weak table.</span></span><br><span class="line"><span class="comment"> * @param referent The object pointed to by the weak reference.</span></span><br><span class="line"><span class="comment"> * @param referrer The weak pointer address.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">id</span> </span><br><span class="line">weak_register_no_lock(weak_table_t *weak_table, <span class="keyword">id</span> referent_id, </span><br><span class="line">                      <span class="keyword">id</span> *referrer_id, <span class="keyword">bool</span> crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ✅首先获取需要弱引用对象</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ✅如果被弱引用对象referent为nil 或者被弱引用对象采用了TaggedPointer计数方式，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!referent  ||  referent-&gt;isTaggedPointer()) <span class="keyword">return</span> referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ensure that the referenced object is viable</span></span><br><span class="line">    <span class="comment">// ✅确保被引用的对象可用（没有在销毁，同时应该支持weak弱引用）</span></span><br><span class="line">    <span class="keyword">bool</span> deallocating;</span><br><span class="line">    <span class="keyword">if</span> (!referent-&gt;ISA()-&gt;hasCustomRR()) &#123;</span><br><span class="line">        deallocating = referent-&gt;rootIsDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> (*allowsWeakReference)(objc_object *, SEL) = </span><br><span class="line">            (<span class="built_in">BOOL</span>(*)(objc_object *, SEL))</span><br><span class="line">            object_getMethodImplementation((<span class="keyword">id</span>)referent, </span><br><span class="line">                                           SEL_allowsWeakReference);</span><br><span class="line">        <span class="keyword">if</span> ((IMP)allowsWeakReference == _objc_msgForward) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        deallocating =</span><br><span class="line">            ! (*allowsWeakReference)(referent, SEL_allowsWeakReference);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ✅如果是正在销毁的对象，那么不能够被弱引用</span></span><br><span class="line">    <span class="keyword">if</span> (deallocating) &#123;</span><br><span class="line">        <span class="keyword">if</span> (crashIfDeallocating) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">&quot;Cannot form weak reference to instance (%p) of &quot;</span></span><br><span class="line">                        <span class="string">&quot;class %s. It is possible that this object was &quot;</span></span><br><span class="line">                        <span class="string">&quot;over-released, or is in the process of deallocation.&quot;</span>,</span><br><span class="line">                        (<span class="keyword">void</span>*)referent, object_getClassName((<span class="keyword">id</span>)referent));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    <span class="comment">// ✅在 weak_table 中找到被弱引用对象 referent 对应的 weak_entry,并将 referrer 加入到 weak_entry 中</span></span><br><span class="line">    weak_entry_t *entry;</span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// ✅如果能找到 weak_entry,则讲 referrer 插入到 weak_entry 中</span></span><br><span class="line">        append_referrer(entry, referrer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ✅如果找不到 weak_entry，就新建一个</span></span><br><span class="line">        weak_entry_t new_entry(referent, referrer);</span><br><span class="line">        weak_grow_maybe(weak_table);</span><br><span class="line">        weak_entry_insert(weak_table, &amp;new_entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> referent_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="append-referrer"><a href="#append-referrer" class="headerlink" title="append_referrer"></a>append_referrer</h2><p>这一步主要是找到弱引用对象的对应的<code>weak_entry</code>哈希数组中，基本就是个遍历插入的过程，原理比较简单</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ✅如果weak_entry 使用静态数组 inline_referrers</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// ✅尝试将 referrer 插入数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn&#x27;t insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="comment">// ✅如果inline_referrers的位置已经存满了，则要转型为 referrers，动态数组</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ✅如果动态数组中元素个数大于或等于数组总空间的3/4，则扩展数组空间为当前长度的一倍，然后将 referrer 插入数组</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ✅如果不需要扩容，直接插入到weak_entry中</span></span><br><span class="line">    <span class="comment">// ✅&amp; (entry-&gt;mask) 保证 begin 的位置只能大于或等于数组的长度</span></span><br><span class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-unregister-no-lock"><a href="#weak-unregister-no-lock" class="headerlink" title="weak_unregister_no_lock"></a>weak_unregister_no_lock</h2><p>如果<code>weak</code>指针在指向<code>obj</code>之前，已经弱引用了其他的对象，则需要先将<code>weak指针</code>从其他对象的<code>weak_entry_t</code>的<code>hash</code>数组中移除。在<code>storeWeak</code>方法中会调用<code>weak_unregister_no_lock</code>函数来做移除操作。</p>
<p><code>weak_unregister_no_lock</code>函数首先会在<code>weak_table</code>中找出以前被弱引用的对象<code>referent</code>对应的<code>weak_entry_t</code>，在<code>weak_entry_t</code>中移除被弱引用的对象<code>referrer</code>。移除元素后，判断此时<code>weak_entry_t</code>中是否还有元素。如果此时<code>weak_entry_t</code>已经没有元素了，则需要将<code>weak_entry_t</code>从<code>weak_table</code>中移除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">weak_unregister_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id, </span><br><span class="line">                        id *referrer_id)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 拿到以前弱引用的对象和对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line">    objc_object **referrer = (objc_object **)referrer_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!referent) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找到以前弱引用的对象 referent 所对应的 weak_entry_t</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak_entry_for_referent(weak_table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 在以前弱引用的对象 referent 所对应的 weak_entry_t 的 hash 数组中，移除弱引用 referrer</span></span><br><span class="line">        remove_referrer(entry, referrer);</span><br><span class="line">        <span class="comment">// 移除元素之后， 要检查一下 weak_entry_t 的 hash 数组是否已经空了</span></span><br><span class="line">        <span class="keyword">bool</span> empty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;out_of_line()  &amp;&amp;  entry-&gt;num_refs != <span class="number">0</span>) &#123;</span><br><span class="line">            empty = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry-&gt;inline_referrers[i]) &#123;</span><br><span class="line">                    empty = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 weak_entry_t 的hash数组已经空了，则需要将 weak_entry_t 从 weak_table 中移除</span></span><br><span class="line">        <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">            weak_entry_remove(weak_table, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *referrer = nil. objc_storeWeak() requires that the </span></span><br><span class="line">    <span class="comment">// value not change.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此，一个对象的弱引用过程已经结束</p>
</blockquote>
<h1 id="四、weak-的销毁逻辑"><a href="#四、weak-的销毁逻辑" class="headerlink" title="四、weak 的销毁逻辑"></a>四、weak 的销毁逻辑</h1><p>通过开头的例子，我们知道，出作用域，对象<code>dealloc</code>后，会自动把弱引用对象置空，那么他是怎么实现的，我们可以简单查看下类的<code>dealloc</code>的源码：</p>
<h2 id="objc-rootDealloc"><a href="#objc-rootDealloc" class="headerlink" title="_objc_rootDealloc"></a>_objc_rootDealloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _objc_rootDealloc(self);</span><br><span class="line">&#125;</span><br><span class="line">**********************************</span><br><span class="line"><span class="keyword">void</span> _objc_rootDealloc(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    assert(obj);</span><br><span class="line"></span><br><span class="line">    obj-&gt;rootDealloc();</span><br><span class="line">&#125;</span><br><span class="line">***********************************</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">objc_object::rootDealloc()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ✅如果是Tagged Pointer，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     ✅如果同时满足</span></span><br><span class="line"><span class="comment">     1. 是优化过的isa、</span></span><br><span class="line"><span class="comment">     2. 没有被weak指针引用过、</span></span><br><span class="line"><span class="comment">     3. 没有关联对象、</span></span><br><span class="line"><span class="comment">     4. 没有C++析构函数、</span></span><br><span class="line"><span class="comment">     5. 没有sideTable，</span></span><br><span class="line"><span class="comment">     就可以直接释放内存free()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">                 !isa.weakly_referenced  &amp;&amp;  </span><br><span class="line">                 !isa.has_assoc  &amp;&amp;  </span><br><span class="line">                 !isa.has_cxx_dtor  &amp;&amp;  </span><br><span class="line">                 !isa.has_sidetable_rc))</span><br><span class="line">    &#123;</span><br><span class="line">        assert(!sidetable_present());</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//否则的话就需要通过下面的函数处理</span></span><br><span class="line">        object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里显然不满足上述条件，因为我们弱引用过，继续跟进<code>object_dispose</code></p>
<h2 id="object-dispose"><a href="#object-dispose" class="headerlink" title="object_dispose"></a>object_dispose</h2><p><code>object_dispose</code>函数中调用了<code>objc_destructInstance</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">object_dispose(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    objc_destructInstance(obj);    </span><br><span class="line">    <span class="built_in">free</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="objc-destructInstance"><a href="#objc-destructInstance" class="headerlink" title="objc_destructInstance"></a>objc_destructInstance</h2><p>我们可以看到内部会做销毁C++析构函数以及移除关联对象的操作，看来弱引用要在<code>clearDeallocating</code>中了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This order is important.</span></span><br><span class="line">        <span class="comment">// 如果有C++析构函数，则运行相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);</span><br><span class="line">        <span class="comment">// 如果有关联对象，则移除所有的关联对象，并将其自身从Association Manager的map中移除</span></span><br><span class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);</span><br><span class="line">        <span class="comment">// 继续清理其它相关的引用</span></span><br><span class="line">        obj-&gt;clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clearDeallocating"><a href="#clearDeallocating" class="headerlink" title="clearDeallocating"></a>clearDeallocating</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::clearDeallocating()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">        <span class="comment">// 如果要释放的对象没有采用了优化过的isa引用计数</span></span><br><span class="line">        sidetable_clearDeallocating();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">        <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">        <span class="comment">// ✅ 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数（现在一般都是优化过的 isa）</span></span><br><span class="line">        clearDeallocating_slow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="clearDeallocating-slow"><a href="#clearDeallocating-slow" class="headerlink" title="clearDeallocating_slow"></a>clearDeallocating_slow</h2><p>我们现在一般都是使用<code>优化的 isa </code>，所以走<code>clearDeallocating_slow</code>函数。</p>
<p>我们通过源码可以看到主要操作是找到对应的<code>SideTable</code>，然后在<code>SideTable</code>的<code>weak_table</code>中，将弱引用对象置空，主要的方法为<code>weak_clear_no_lock</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">NEVER_INLINE <span class="keyword">void</span></span><br><span class="line">objc_object::clearDeallocating_slow()</span><br><span class="line">&#123;</span><br><span class="line">    assert(isa.nonpointer  &amp;&amp;  (isa.weakly_referenced || isa.has_sidetable_rc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在全局的SideTables中，以this指针(要释放的对象)为key，找到对应的SideTable</span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line">    table.lock();</span><br><span class="line">    <span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">        <span class="comment">// ✅ 要释放的对象被弱引用了，通过weak_clear_no_lock函数将指向该对象的弱引用指针置为nil</span></span><br><span class="line">        weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用了sideTable的辅助引用计数,直接在SideTable中擦除该对象的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (isa.has_sidetable_rc) &#123;</span><br><span class="line">        table.refcnts.erase(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="weak-clear-no-lock"><a href="#weak-clear-no-lock" class="headerlink" title="weak_clear_no_lock"></a>weak_clear_no_lock</h2><p>我们通过源码可以看到，这个方法和插入时的方法比较类似，都是找到对应的<code>weak_entry_t</code>数组，然后通过遍历找到对应的指针地址，然后置为<code>nil</code>，防止了野指针的报错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取被弱引用对象的地址</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据对象地址找到被弱引用对象 referent 在 weak_table 中对应的 weak_entry_t</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn&#x27;t happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf(&quot;XXX no entry for clear deallocating %p\n&quot;, referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出弱引用该对象的所有 weak 指针地址数组</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历取出每个 weak 指针的地址</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="comment">// 如果weak指针确实弱引用了对象 referent，则将weak指针设置为nil</span></span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果所存储的weak指针没有弱引用对象 referent，这可能是由于runtime代码的逻辑错误引起的，报错</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                _objc_inform(<span class="string">&quot;__weak variable at %p holds %p instead of %p. &quot;</span></span><br><span class="line">                             <span class="string">&quot;This is probably incorrect use of &quot;</span></span><br><span class="line">                             <span class="string">&quot;objc_storeWeak() and objc_loadWeak(). &quot;</span></span><br><span class="line">                             <span class="string">&quot;Break on objc_weak_error to debug.\n&quot;</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此，一个弱引用的销毁也完成了，并自动置为nil</p>
</blockquote>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><ul>
<li>当一个对象<code>obj</code>被<code>weak指针</code>指向时，这个<code>weak指针</code>会以<code>obj</code>作为<code>key</code>，被存储到<code>sideTable</code>类的<code>weak_table</code>这个散列表上对应的一个<code>weak指针数组</code>里面。</li>
<li>当一个对象<code>obj</code>的<code>dealloc</code>方法被调用时，<code>Runtime</code>会以<code>obj</code>为<code>key</code>，从<code>sideTable</code>的<code>weak_table</code>散列表中，找出对应的<code>weak指针列</code>表，然后将里面的<code>weak</code>指针逐个置为<code>nil</code>。</li>
</ul>
<h2 id="创建流程简图"><a href="#创建流程简图" class="headerlink" title="创建流程简图"></a>创建流程简图</h2><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/1-20210217204426936.png"></p>
<h2 id="创建流程小结"><a href="#创建流程小结" class="headerlink" title="创建流程小结"></a>创建流程小结</h2><p><code>Runtime</code>维护了一个弱引用表，将所有弱引用<code>obj</code>的指针地址都保存在<code>obj</code>对应的<code>weak_entry_t中</code>。</p>
<ol>
<li>创建时，先从找到全局散列表<code>SideTables</code>中对应的弱引用表<code>weak_table</code></li>
<li>在<code>weak_table</code>中被弱引用对象的<code>referent</code>中创建或者插入对应的<code>weak_entry_t</code></li>
<li>然后<code>append_referrer(entry, referrer)</code>将我的新弱引⽤的对象加进去<code>entry</code></li>
<li>最后<code>weak_entry_insert</code> 把<code>entry</code>加⼊到我们的<code>weak_table</code></li>
</ol>
<h2 id="销毁流程简图"><a href="#销毁流程简图" class="headerlink" title="销毁流程简图"></a>销毁流程简图</h2><p><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/16fbcc4ecee242a3.png"></p>
<h2 id="销毁流程小结"><a href="#销毁流程小结" class="headerlink" title="销毁流程小结"></a>销毁流程小结</h2><ol>
<li>首先根据对象地址获取所有<code>weak</code>指针地址的数组</li>
<li>然后遍历这个数组把对应的数据清空置为<code>nil</code></li>
<li>同时，将<code>weak_entry_t</code>移除出弱引用表<code>weak_table</code>。</li>
</ol>
<h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><h2 id="objc4-756-2源码"><a href="#objc4-756-2源码" class="headerlink" title="objc4-756.2源码"></a>objc4-756.2源码</h2><p>本文使用：<a target="_blank" rel="noopener" href="https://github.com/speam/objc4-756.2.git">objc4-756.2源码</a> 进行分析</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904051029573645#heading-2">iOS底层学习 - 内存管理之weak原理探究</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/085c1f62ceff">iOS weak实现原理</a></p>
</div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/12-Method%20Swizzling%E7%9A%84%E5%9D%91%E4%B8%8E%E5%BA%94%E7%94%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">12-Method Swizzling的坑与应用</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"><span class="level-item">10-底层面试答疑</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#一、-strong、-weak、-unsafe-unretained的区别"><span class="level-left"><span class="level-item">一、__strong、__weak、__unsafe_unretained的区别</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#strong"><span class="level-left"><span class="level-item">__strong</span></span></a></li><li><a class="level is-mobile" href="#weak"><span class="level-left"><span class="level-item">__weak</span></span></a></li><li><a class="level is-mobile" href="#unsafe-unretained"><span class="level-left"><span class="level-item">__unsafe_unretained</span></span></a></li><li><a class="level is-mobile" href="#小结"><span class="level-left"><span class="level-item">小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二、weak-代码定位"><span class="level-left"><span class="level-item">二、weak 代码定位</span></span></a></li><li><a class="level is-mobile" href="#三、weak-的保存逻辑"><span class="level-left"><span class="level-item">三、weak 的保存逻辑</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#objc-initWeak"><span class="level-left"><span class="level-item">objc_initWeak</span></span></a></li><li><a class="level is-mobile" href="#storeWeak"><span class="level-left"><span class="level-item">storeWeak</span></span></a></li><li><a class="level is-mobile" href="#weak-register-no-lock"><span class="level-left"><span class="level-item">weak_register_no_lock</span></span></a></li><li><a class="level is-mobile" href="#append-referrer"><span class="level-left"><span class="level-item">append_referrer</span></span></a></li><li><a class="level is-mobile" href="#weak-unregister-no-lock"><span class="level-left"><span class="level-item">weak_unregister_no_lock</span></span></a></li></ul></li><li><a class="level is-mobile" href="#四、weak-的销毁逻辑"><span class="level-left"><span class="level-item">四、weak 的销毁逻辑</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#objc-rootDealloc"><span class="level-left"><span class="level-item">_objc_rootDealloc</span></span></a></li><li><a class="level is-mobile" href="#object-dispose"><span class="level-left"><span class="level-item">object_dispose</span></span></a></li><li><a class="level is-mobile" href="#objc-destructInstance"><span class="level-left"><span class="level-item">objc_destructInstance</span></span></a></li><li><a class="level is-mobile" href="#clearDeallocating"><span class="level-left"><span class="level-item">clearDeallocating</span></span></a></li><li><a class="level is-mobile" href="#clearDeallocating-slow"><span class="level-left"><span class="level-item">clearDeallocating_slow</span></span></a></li><li><a class="level is-mobile" href="#weak-clear-no-lock"><span class="level-left"><span class="level-item">weak_clear_no_lock</span></span></a></li></ul></li><li><a class="level is-mobile" href="#五、总结"><span class="level-left"><span class="level-item">五、总结</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建流程简图"><span class="level-left"><span class="level-item">创建流程简图</span></span></a></li><li><a class="level is-mobile" href="#创建流程小结"><span class="level-left"><span class="level-item">创建流程小结</span></span></a></li><li><a class="level is-mobile" href="#销毁流程简图"><span class="level-left"><span class="level-item">销毁流程简图</span></span></a></li><li><a class="level is-mobile" href="#销毁流程小结"><span class="level-left"><span class="level-item">销毁流程小结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#PS"><span class="level-left"><span class="level-item">PS</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#objc4-756-2源码"><span class="level-left"><span class="level-item">objc4-756.2源码</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>