{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"01-对象的创建","text":"一、前言看一个简单的例子： 思考alloc和init底层到底做了什么？带着这些问题，我们从源码的角度探索。 二、分析 alloc 源码1.0 准备工作1.从 苹果官方开源代码列表 找到 objc4源码。 苹果于 2006 年发布 Objective-C 2.0 ，重写了 Objective-C 1.0 中类与对象的定义，命名为 objc4 2.下载到本地后，需要对工程进行一番编译调试，具体步骤可参考 Cooci 的博客 iOS_objc4-756.2 最新源码编译调试。 3.编译通过后，就可以新建个 target 调试了 我 Github 上的源码：https://github.com/speam/OjbcSuorce.git 4.常用的代码跟踪方式： Xcode 菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly control + step into 下符号断点，如alloc 1.1 objc_alloc—alloc的真正入口给[Person alloc]加断点 此时，在Xcode的菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly，得到汇编代码，发现调用了objc_alloc: 定位到objc_alloc()，发现内部调用callAlloc() 1.2 callAlloc分析objc_alloc()内部调用callAlloc()，其源码为： 123456789101112131415161718192021222324252627282930313233// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){ if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls-&gt;canAllocFast())) { // 永远不走这里 // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; } else { // 永远走这里 // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } }#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];} 对callAlloc()的分析如下： ①__OBJC2__在 OC2.0 以后为1，源码： 12345678// Define __OBJC2__ for the benefit of our asm files.#ifndef __OBJC2__# if TARGET_OS_OSX &amp;&amp; !TARGET_OS_IOSMAC &amp;&amp; __i386__ // old ABI# else# define __OBJC2__ 1 // 总之都是1# endif#endif ②slowpath(bool)与fastpath(bool)：常用于if-else，可以优化判断的速度。 12345// fastpath(x)：表示返回值为x，且x很有可能为1#define fastpath(x) (__builtin_expect(bool(x), 1))// slowpath(x)：表示返回值为x，且x很有可能为0#define slowpath(x) (__builtin_expect(bool(x), 0)) ③hasCustomAWZ()：意思是hasCustomAllocWithZone，即是否有重写类的+allocWithZone:方法，但是它的值并不能简单地这么判断！先看源码 123bool hasCustomAWZ() { return ! bits.hasDefaultAWZ();} 注意：hasCustomAWZ()的值问题【非常重要，设置初始化顺序，很多博客中根本没有提到！】 类的+initialize方法主要用于初始化静态变量。在其执行之前，hasDefaultAWZ()值为false，即hasCustomAWZ()为true；其执行之后，如果当前类重写了+allocWithZone:方法，hasCustomAWZ()为true，否则为false（一般情况下不会重写，即hasCustomAWZ为false）。 类的+initialize方法会在第一次初始化该类之前调用。当调用[cls alloc]时，会触发objc_msgSend，然后会执行+initialize:。（感兴趣的同学可以分别打印+alloc和+initialize:方法加以验证） 因此，当类第一次来到callAlloc()时，最终会执行[cls alloc]。 ④canAllocFast()源码如下： 1234bool canAllocFast() { assert(!isFuture()); return bits.canAllocFast();} 再往底层找bits.canAllocFast()，发现关键宏FAST_ALLOC 1234567891011#if FAST_ALLOC ... bool canAllocFast() { return bits &amp; FAST_ALLOC; }#else ... bool canAllocFast() { return false; }#endif 继续深入，来到了FAST_ALLOC宏定义之处 123456789#if !__LP64__ // 当前操作系统不是64位...#elif 1 // 当前操作系统是64位...#else ...#define FAST_ALLOC (1UL&lt;&lt;2) // 找到了...#endif 从上面宏代码可以得出这样的结论，即无论当前操作系统是不是64位，都没有定义FAST_ALLOC，也就是说，canAllocFast()永远是false! 因此，如果hasCustomAWZ()为false时，会直接去到class_createInstance()。 1.3 alloc-&gt;_objc_rootAlloc-&gt;callAlloc-&gt;class_createInstance通过对hasCustomAWZ()的分析，我们知道类的第一次初始化最终是走到callAlloc的最后，即return [cls alloc]; ①由于执行了[cls alloc]，这次真的来到alloc()方法了 123+ (id)alloc { return _objc_rootAlloc(self);} ②接着是_objc_rootAlloc() 1234567// Base class implementation of +alloc. cls is not nil.// Calls [cls allocWithZone:nil].id_objc_rootAlloc(Class cls){ return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); // 注意这里的三个参数} ③再次来到callAlloc，此时hasCustomAWZ()的值取决于当前类是否重写了+allocWithZone:方法。 由于Person类没有重写，fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())为true，而canAllocFast()永远为false。 因此，接下来会走到class_createInstance()，其源码如下： 12345id class_createInstance(Class cls, size_t extraBytes){ return _class_createInstanceFromZone(cls, extraBytes, nil);} 1.4 _class_createInstanceFromZone顾名思义，这是要创建对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 对_class_createInstanceFromZone()的分析如下： ①cls-&gt;instanceSize(extraBytes)计算内存，此时的extraBytes是0，其源码是 1234567891011121314151617181920212223242526272829303132// 1.size_t instanceSize(size_t extraBytes) { size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;}// 2.uint32_t alignedInstanceSize() { return word_align(unalignedInstanceSize());}// 3. 字节对齐static inline uint32_t word_align(uint32_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}static inline size_t word_align(size_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}// 4.#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif 可见，WORD_MASK在64位系统下是7，否则是3，word_align()方法就是进行字节对齐的。 字节对齐算法：(x + WORD_MASK) &amp; ~WORD_MASK 12345678910111213141516假如： x = 9，已知 WORD_MASK = 7 x + WORD_MASK = 9 + 7 = 16 WORD_MASK 二进制 ：0000 0111 = 7 （4+2+1） ~WORD_MASK 二进制 : 1111 1000 16的二进制为 : 0001 0000 0001 0000 &amp; 1111 1000--------------- 0001 0000 = 16所以字节对齐后返回16 也就是8的倍数对齐，即8字节对齐 因此，word_align()在64位系统下是8字节对齐，否则是4字节对齐。 同时，instanceSize()函数又对内存大小又进行了最小16字节的限制。 ②canAllocNonpointer()是对isa的类型的区分，如果一个类使用isa_t类型的isa的话就返回true，我们不用太关心，OC 2.0以上基本上返回的都是true，所以fast就是true；而在__OBJC2__中，zone会被忽略，所以!zone也是true； 综上，接着就是calloc()和initInstanceIsa()。 ③size_t size = cls-&gt;instanceSize(extraBytes);这一步得到了计算后的size，传到calloc(1, size)中进行分配内存。 ④calloc()的底层源码是在苹果开源的libmalloc源码中(我Github中也准备了)，经过断点跟踪(中间过程比较复杂，略过先)，发现calloc()分配的内存大小受segregated_size_to_fit()影响，看下面源码： 123456789101112131415161718192021static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey) // 这里的size就是calloc(1, size)中传过来的{ size_t k, slot_bytes; if (0 == size) { // Historical behavior size = NANO_REGIME_QUANTA_SIZE; } // round up and shift for number of quanta k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // Zero-based! *pKey = k - 1; return slot_bytes;}#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16 从代码可以看出，slot_bytes等于(size + 16-1) &gt;&gt; 4 &lt;&lt; 4，是16字节对齐，所以就是将计算得到的size进行一次16字节对齐，因此calloc()分配的内存大小必然是16字节的整数倍，因此为对象分配的内存空间一定是16字节对齐的。 ⑤initInstanceIsa()就是初始化isa，并且关联cls。 从上面的代码可以看出，_class_createInstanceFromZone()做了很多事情，并且最终确实创建了对象，几乎干了所有事情，那么，init又到底做了什么呢？ 三、init和new1. init1234567891011- (id)init { return _objc_rootInit(self);}id_objc_rootInit(id obj){ // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;} 非常简单，init仅仅是将alloc创建的对象返回。是一种工厂设计方案，方便子类重写。 2. new我们再看看new 123+ (id)new { return [callAlloc(self, false/*checkNil*/) init];} 很明显，new相当于alloc+init。 四、总结关于alloc、init以及new的源码分析就到这了。在alloc的过程中，callAlloc和_class_createInstanceFromZone这两个函数是重点。 以上源码流程分析，是建立在objc4-756.2源码的基础上的，756.2是目前最新的版本。 下面用流程图总结一下alloc创建对象的过程：（这是我看过的博客中，最准确的图） 五、源码我的 malloc 源码 我的 libobjc 源码 苹果官方 objc4 源码 参考红酒牛排 https://juejin.im/post/6844904038467633160#heading-15","link":"/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"title":"URL编码和解码","text":"一、URL含义1、URL定义URL 是Uniform Resource Locator 的缩写，统一资源定位符，互联网上的每个文件都有一个唯一的URL。 URL 与 URI 很多人会混淆这两个名词。 URL：(Uniform/Universal Resource Locator 的缩写，统一资源定位符)。 URI：(Uniform Resource Identifier 的缩写，统一资源标识符)。 URI 属于 URL 更低层次的抽象，一种字符串文本标准。URL 是 URI 的一个子集。 URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http://）。 URI结构 1234567foo://example.com:8042/over/there?name=ferret#nose \\_/ \\______________/ \\________/\\_________/ \\__/ | | | | | scheme authority path query fragment 2、URL字符编码表1、URL 编码 - 从 %00 到 %ff 2、HTML特殊字符编码对照表 二、URL 编码1、为什么要编码转义推荐阅读：字符编码：ASCII、Unicode 和 UTF-8 的区别 世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，所以必须要统一字符编码。 Unicode规定了符号唯一的二进制代码值。 UTF-8是一种针对Unicode的可变长度字符编码，规定这个二进制代码应该如何存储。UTF-8用1到4个字节编码Unicode字符，在互联网上使用最广的一种 Unicode 的实现方式。 如 中 字: Unicode码值： \\u4e2d URL编码（UTF-8）： %e4%b8%ad 2、URL编码规则使用%加上两位的字符0123456789ABCDEF代表一个字节的十六进制形式。Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，我们在地址栏上输入 http://g.cn/search?q=%61%62%63 ，实际上就等同于在google上搜索abc了。又如@符号在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。 对于非ASCII字符，需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 3、URL不需要编码的字符1、英文字母（a-z A-Z） 2、数字（0-9） 3、 - _ . ~ 4个特殊字符 4、所有保留字符，RFC3986中指定了以下字符为保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ] 5、编码标记符号 % 4、URL需要编码的字符4.1、非URL定义的字符如中文字符、希腊文字符，拉丁文字符等。 4.2、会引起歧义的保留字符URL 拼接参数或路径设置时，拼接的普通字符串中含有保留字符，会引起歧义的情况。URL 参数字符串中使用 key=value 这样的键值对形式来传参，键值对之间以 &amp; 符号分隔，如宝洁公司的简称为P&amp;G，假设需要当做参数去传递，name=P&amp;G&amp;t=1450591802326，因为参数中多了一个&amp;势必会造成接收 URL 的服务器解析错误，因此必须将引起歧义的 &amp; 符号进行转义编码。 部分保留字符及其URL编码 字符 用法描述 编码 + 表示空格（在URL中不能使用空格） %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的URL和参数 %3F # 表示书签或锚点 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定的参数的值 %3D % 百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 %25 如果需要在URL中用到特殊字符或中文字符，需要将这些特殊字符换成相应的十六进制的值。 三、iOS端URL具体编码处理1、URL编码和解码是成对URL编码和解码必须是成对出现的。 这四种种字符后，URL编码后的值还是它本身： 1、英文字母（a-z A-Z） 2、数字（0-9） 3、特殊字符（ -_.） 4、部分保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? 说明：~ # [] 这四个字符是否被转码成百分号编码，因系统不同会有不同。 URL字符编码使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。因编码后的值含有 % 保留字符。再次编译% 会编译成 %25 。 例如： &amp; 第一次URL编码后：%26 第二次URL编码后：%2526 第三次URL编码后：%252526 正常解码逻辑： 第一次URL解码后：%2526 第二次URL解码后：%26 第三次URL解码后：&amp; 2、URL是怎么拆解的我们看一个常见的接口请求示例： 一般会根据 ://、: 、 / 、 ?、 &amp;、= 等拆分出请求的协议、服务器名称（或IP地址）、端口号、路径和文件名、参数名、参数值等。 3、在组装URL的什么阶段进行URL编码我们看一个常见的接口请求示例： 字符串 说明 :// 协议符号 / 分隔目录和子目录 测试 代表需要编译处理的路径 ？ 分隔实际的URL和参数 &amp; URL中指定的参数间的分隔符 = URL中指定的参数的值 搜&amp;索 搜索词含有中文，含有保留字段，需要编译 &amp;times 是key的一部分，不应该被编译，若多一次编译，会编译为 x 绿色字体是保留字符，都有特殊的含义，是不应该是被编码的。 红色字体必须要要编译的部分。 黄色背景的字符串，不应该被编译。 若以上操作不正确，会影响整个URL的解析。 常见的拼接过程： 1、先拼接实际的请求地址 https://www.baidu.com/s/测@试? 2、再拼接参数字符串 wd=搜&amp;索&amp;timestamp=32424242423 3、将1、2合并凭借成一个网址字符串。 4、将网址字符串转为NSURL 实例。 分析 1、因 测@试 含有中文和保留字符@，需要在步骤1之前，先将 测@试 编码为 %e6%b5%8b%40%e8%af%95 ，再拼接到https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95? 2、因 搜&amp;索 含有中文和保留字符&amp; ,&amp; 会影响参数解析。需要先搜&amp;索 编码为 %e6%90%9c%26%e7%b4%a2 ，再拼接到wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 3、因请求地址和参数列表已经编码过，拼接后的完整请求不应该再次编译。若再次编译 则会因含有 &amp;times 编译为 x 。 小结 上面我们分别编码特殊字符后，最后拼接到一起。也有部分写法是拼接后再统一编码处理的。但因请求路径、请求参数中都可能含有保留字符&amp;、=或中文等特殊字符，造成请求地址解析错误。建议在路径和参数拼接前对路径、参数名、参数值等先行统一编码处理，再行拼接。拼接好后不要再行编码，转为NSURL实例，发送请求。 4、可用的编码和解码APIiOS端生成NSURL实例 1NSURL *url = [NSURL URLWithString:urlString]; 注意： urlString 中含有中文字符等非定URL限定字符时，创建的NSURL对象会失败，url返回为nil。 URL编码123456789101112131415161718NSString *urlStr = @&quot;你好0123456789abcxyzABCXYZ-_.~&amp;!*'();:@&amp;=+$,/?#[]% &quot;;//方式一【推荐】NSString *encodingString = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@&quot;url编码1-1 = %@&quot;,encodingString);//方式二：NSString *encodeStr3 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url编码3-1 = %@&quot;,encodeStr3);//方式三：自定义字符集 ABC-_~.!*'();:@&amp;=+ $,/?%#[] 编码对比NSString *encodeStr2 = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)urlStr, NULL, (CFStringRef)@&quot;ABC-_~.!*'();:=+ $,/?%#[]&quot;, kCFStringEncodingUTF8)); NSLog(@&quot;url编码2-2 = %@&quot;,encodeStr2); //方式四：自定义字符不需要编译的字符集，为空字符集，将所有字符用百分号编码NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;&quot;];NSString *encodeStr4 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:characterSet]; NSLog(@&quot;url编码3-2 = %@&quot;,encodeStr4); 打印结果是 网上常见的字符集枚举说明（供参考）: 123456URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\\^`{|}URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^`{|}URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\\]^`{|}URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^` URL解码1234//上段代码的结果为encodeStr3入参NSString *decodedStr3 = [encodeStr3 stringByRemovingPercentEncoding];NSLog(@&quot;url编码3-1 = %@&quot;,decodedStr3); 打印结果是 四、总结1、在URL组装拼接前对各个部分的可能会引起歧义的字符串进行全量UTF-8编码。 2、在需要解码的地方，需要先分拆字符串，再分段解码使用。 3、在需要将已组装的数据，进行重组时，需要先拆解，分别解码后再编码，最后再重组。 4、服务端会对请求进行UTF-8解码一次，请确保请求中的字符只进行一次UTF-8编码。","link":"/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URL%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B/"},{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"02-isa原理","text":"一、 前言 在arm64架构之前，isa仅仅是一个指针，保存着类对象或元类对象的内存地址 在arm64架构之后,苹果对isa进行了优化,变成了一个isa_t类型的联合体结构,同时使用位域来存储更多的信息: 对象的isa指针并不是直接指向类对象或者元类对象的内存地址，而是需要&amp; ISA_MASK才能获取类对象或者元类对象的地址。 二、 内容补充2.1 位运算符 位运算符用来对二进制位进行操作 操作数只能为整型和字符型数据。 C语言中六种位运算符：&amp;按位与、|按位或、^按位异或、~非、&lt;&lt;左移和&gt;&gt;右移。 1)按位与&amp; 有0出0,全1出1. A B &amp; 0 0 0 1 0 0 0 1 0 1 1 1 2)按位或 | 有1出1,全0出0. A B I 0 0 0 1 0 1 0 1 1 1 1 1 3)按位异或^ 相同为0,不同为1. A B ^ 0 0 0 1 0 1 0 1 1 1 1 0 4)非 ~ 非运算即取反运算，在二进制中 1 变 0 ，0 变 1。例如110101进行非运算后为001010，即1010. 5)左移 &lt;&lt; 左移运算就是把&lt;&lt;左边的运算数的各二进位全部左移若干位，移动的位数即&lt;&lt;右边的数的数值。 高位丢弃，低位补0。 左移n位就是乘以2的n次方。例如：a&lt;&lt;4是指把a的各二进位向左移动4位。如原来a=00000011(十进制3)，左移4位后为00110000(十进制48)。 6)右移 &gt;&gt; 右移运算就是把&gt;&gt;左边的运算数的各二进位全部右移若干位，&gt;&gt;右边的数指定移动的位数。例如：设 a=15，a&gt;&gt;2 表示把00001111右移为00000011(十进制3) 2.2 位运算符的运用1)取值 可以利用按位与 &amp;运算取出指定位的值 具体操作是想取出哪一位的值就将那一位置为1,其它位都为0,然后同原数据进行按位与计算,即可取出特定的位. 例: 0000 0011取出倒数第三位的值 123456// 想取出倒数第三位的值，就将倒数第三位的值置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0100 （掩码）------------ 0000 0000 // 得出按位与运算后的结果，即可拿到原数据中倒数第三位的值为0 上面的例子中,我们从0000 0011中取值,则有0000 0011被称之为源码.进行按位与操作设定的0000 0100称之为掩码. 例: 0000 0011取出后三位的值 123456// 想取出后三位的值，就将掩码后三位置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0111 （掩码）------------ 0000 0011 // 得出按位与运算后的结果，即可拿到原数据中后三位的值为011 2)设值 可以通过按位或 |或者按位与 &amp;运算符将某一位的值设为1或0. 要将某一位的值置为1的话，那么就将掩码中对应位的值设为1，掩码其它位为0，将源码与掩码进行按位或|操作即可. 例: 将0000 0011倒数第三位的值改为1 12345// 改变倒数第三位的值，就将掩码倒数第三位的值置为1，其它位为0，跟源码按位或运算 0000 0011| 0000 0100------------ 0000 0111 // 即可将源码中倒数第三位的值改为1 要将某一位的值置为0的话，那么就将掩码中对应位的值设为0，掩码其它位为1，将源码与掩码进行按位与&amp;操作即可. 例: 将0000 0011倒数第二位的值改为0 12345// 改变倒数第二位的值，就将掩码倒数第二位的值置为0，其它位为1，跟源码`按位与&amp;`运算 0000 0011| 1111 1101------------ 0000 0001 // 即可将源码中倒数第二位的值改为0 3)实际应用 声明一个TCJCar类，类中有四个BOOL类型的属性,分别为front、back、left、right,通过这四个属性来判断这辆小车的行驶方向. 然后我们来查看一下这个TCJCar类对象所占据的内存大小: 我们看到,一个TCJCar类的对象占据16个字节.其中包括一个isa指针和四个BOOL类型的属性,8+1+1+1+1=12,根据内存对齐原则,所以一个TCJCar类的对象占16个字节. 我们知道,BOOL值只有两种情况:0或1，占据一个字节的内存空间.而一个字节的内存空间中又有8个二进制位，并且二进制同样只有0或1，那么我们完全可以使用1个二进制位来表示一个BOOL值。也就是说我们上面声明的四个BOOL值最终只使用4个二进制位就可以代替，这样就节省了内存空间。那我们如何实现呢？ 想要实现四个BOOL值存放在一个字节中，我们可以通过char类型的成员变量来实现。 char类型占一个字节内存空间，也就是8个二进制位.可以使用其中最后四个二进制位来存储4个BOOL值。 (当然不能把char类型写成属性,因为一旦写成属性,系统会自动帮我们添加成员变量,自动实现set和get方法) 123@interface TCJCar(){ char _frontBackLeftRight;} 如果我们赋值_frontBackLeftRight为1,即0b 0000 0001,只使用8个二进制位中的最后4个分别用0或者1来代表front、back、left、right的值.那么此时front、back、left、right的状态为: 结合我们上文讲的6种位运算符以及使用场景,我们可以分别声明front、back、left、right的掩码,来方便我们进行下一步的位运算取值和赋值: 1234#define TCJDirectionFrontMask 0b00001000 //此二进制数对应十进制数为 8#define TCJDirectionBackMask 0b00000100 //此二进制数对应十进制数为 4#define TCJDirectionLeftMask 0b00000010 //此二进制数对应十进制数为 2#define TCJDirectionRightMask 0b00000001 //此二进制数对应十进制数为 1 通过对位运算符的左移&lt;&lt;和右移&gt;&gt;的了解，我们可以将上面的代码优化成： 1234#define TCJDirectionFrontMask (1 &lt;&lt; 3)#define TCJDirectionBackMask (1 &lt;&lt; 2)#define TCJDirectionLeftMask (1 &lt;&lt; 1)#define TCJDirectionRightMask (1 &lt;&lt; 0) 自定义的set方法如下: 1234567891011121314151617181920212223242526272829303132- (void)setFront:(BOOL)front{ if (front) {// 如果需要将值置为1，将源码和掩码进行按位或运算 _frontBackLeftRight |= TCJDirectionFrontMask; } else {// 如果需要将值置为0 // 将源码和按位取反后的掩码进行按位与运算 _frontBackLeftRight &amp;= ~TCJDirectionFrontMask; }}- (void)setBack:(BOOL)back{ if (back) { _frontBackLeftRight |= TCJDirectionBackMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionBackMask; }}- (void)setLeft:(BOOL)left{ if (left) { _frontBackLeftRight |= TCJDirectionLeftMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionLeftMask; }}- (void)setRight:(BOOL)right{ if (right) { _frontBackLeftRight |= TCJDirectionRightMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionRightMask; }} 自定义的get方法如下: 12345678910111213141516- (BOOL)isFront{ return !!(_frontBackLeftRight &amp; TCJDirectionFrontMask);}- (BOOL)isBack{ return !!(_frontBackLeftRight &amp; TCJDirectionBackMask);}- (BOOL)isLeft{ return !!(_frontBackLeftRight &amp; TCJDirectionLeftMask);}- (BOOL)isRight{ return !!(_frontBackLeftRight &amp; TCJDirectionRightMask);} 此处需要注意的是，代码中!为逻辑运算符非，因为_frontBackLeftRight &amp; TCJDirectionFrontMask代码执行后，返回的肯定是一个整型数，如当front为YES时，说明二进制数为0b 0000 1000，对应的十进制数为8，那么进行一次逻辑非运算后，!(8)的值为0，对0再进行一次逻辑非运算!(0)，结果就成了1，那么正好跟front为YES对应.所以此处进行两次逻辑非运算，!!. 当然,还要实现初始化方法: 12345678- (instancetype)init{ self = [super init]; if (self) { _frontBackLeftRight = 0b00001000; } return self;} 通过测试验证,我们完成了取值和赋值: 2.3 位域有些信息在存储时，并不需要占用一个完整的字节(8个二进制位)， 而只需占几个或一个二进制位。“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个区域就可以存储一段信息，这样就可以把信息用一个字节来表示。 2.4 联合体这里通过与struct的对比来理解union: ①两者都可以包含多个不同类型的数据，如int、double、Class等。 ②在struct中各成员有各自的内存空间，一个struct变量的内存总长度大于等于各成员内存长度之和；而在union中，各成员共享一段内存空间，一个union的内存总长度等于各成员中内存最长的那个成员的内存长度。 ③对struct中的成员进行赋值，不会影响其他成员的值；对union中的成员赋值时，每次只能给一个成员赋值，同时其它成员的值也就不存在了。 写法： 123union 联合体名{ 成员列表} 2.5 oc 中的 GDB 调试2.5.1 简介GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, Objective-c, go, java,pascal等语言。 2.5.2 在 iOS 开发中的作用① 普通变量查看 使用 p 变量名即可： 12(gdb) p a$1 = 10 ② 打印指针指向内容 如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如： 12(gdb) p d$1 = (int *) 0x602010 而如果想要打印指针指向的内容，需要解引用： 12(gdb) p *d$2 = 0 ③ 按照特定格式打印变量 对于简单的数据，p默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。使用格式控制字符来控制 正常方式打印字符数组c： 12(gdb) p c$18 = &quot;hello world&quot; 查看它的十六进制格式打印: 123(gdb) p/x c$19 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 0x6e, 0x67, 0x0} 但是如果我们想用这种方式查看浮点数的二进制格式是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8： 12345(gdb) p e$1 = 8.5(gdb) p/t e$2 = 1000 ④ 查看内存内容 examine(简写为x)可以用来查看内存地址中的值。语法如下： 1x/[n][f][u] addr 其中： n 表示要显示的内存单元数，默认值为1(想打多少段就写几) f 表示要打印的格式，通过格式控制字符控制 u 要打印的单元长度 addr 内存地址 格式控制字符： x 按十六进制格式显示变量【常用】 d 按十进制格式显示变量 u 按十六进制格式显示无符号整型 o 按八进制格式显示变量 t 按二进制格式显示变量 a 按十六进制格式显示变量 c 按字符格式显示变量 f 按浮点数格式显示变量 单元长度： g 八字节【常用】 b 字节 h 半字，即双字节 w 字，即四字节 举例： 1234x/4xg p // 打印 p 的内存内容 // 打4段内存内容 // 16进制打印 // 每段内存内容打印8字节 三、 isa 介绍3.1 前言回顾上篇文章中的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 在上文中我们知道alloc底层会调用calloc分配内存，接着就是initInstanceIsa(cls, hasCxxDtor)，顾名思义是初始化对象的isa，其关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor){ assert(!cls-&gt;instancesRequireRawIsa()); assert(hasCxxDtor == cls-&gt;hasCxxDtor()); // 留意这里的true initIsa(cls, true, hasCxxDtor);}inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { assert(!isTaggedPointer()); if (!nonpointer) { isa.cls = cls; } else { assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif isa = newisa; }} Tagged Pointer: 据说，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及 3倍 的访问速度提升，100倍 的创建、销毁速度提升。 Tagged Pointer首次应用于iPhone 5s设备上，现在几乎都应用Tagged Pointer了。想了解更多关于Tagged Pointer的内容可参考： 深入理解 Tagged Pointer。 3.2 isa 的结构点击objc_object::initIsa()中的isa，发现isa是isa_t类型 123456789101112union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // 位域 };#endif}; 而isa_t实际上是一个union，即联合体，占8个字节，它的特性就是共用内存，或者说是互斥，比如说如果cls赋值了就不在对bits进行赋值。 3.2.1 isa 的 bits 成员变量3.2.2 isa的 cls 成员变量它是Class类型，源码： 12345678910111213141516171819202122typedef struct objc_class *Class;// 顺便了解一下id的类型，显然id是个指针变量，它的值只有一个isa变量typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; class_data_bits_t bits; class_rw_t *data() { return bits.data(); } ... // 一些方法};struct objc_object {private: isa_t isa; ... // 一些公有、私有方法}; 从源码得知，Class实际上是objc_class结构体的指针变量，而objc_class又继承自objc_object（说明类本质上也是一个对象），因此Class这个结构体指针变量的值内部有一个isa成员变量（类型为isa_t），这个isa成员变量在64位CPU架构下是8字节，且排在objc_class结构体的前8字节。 3.2.3 isa 的位域查看ISA_BITFIELD： 模拟器： 12345678910111213141516# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) 真机： 12345678910111213141516# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) 首先明确一点，在64位CPU架构下isa指针的长度也是8字节，它可以存储足够多的内容，苹果为了优化性能，存储类地址只用了一部分位（x86_64下是44位，arm64下是33位），剩下的位用来存储一些其它信息。 具体分析一下ISA_BITFIELD位域各成员的表示意义： nonpointer：表示是否对isa指针开启指针优化。 0：不优化，是纯isa指针，当访问isa指针时，直接返回其成员变量cls 1：优化，即isa 指针内容不止是类地址，还包含了类的一些信息、对象的引用计数等。 has_assoc：是否有关联对象。 has_cxx_dtor：该对象是否有C++或Objc的析构器。 如果有析构函数，则需要做一些析构的逻辑处理； 如果没有，则可以更快的释放对象。 shiftcls：存储类地址。开启指针优化的情况下，在 x86_64 架构有 44位 用来存储类地址，arm64 架构中占 33位 。 magic：用于调试器判断当前对象是真的对象，还是一段没有初始化的空间。 weakly_referenced：用于标识对象是否被指向或者曾经被指向一个ARC的弱变量，没有弱引用的对象释放的更快。 deallocating：标识对象是否正在释放内存。 has_sidetable_rc：对象的引用计数值是否有进位。 extra_rc：表示该对象的引用计数值。 extra_rc只是存储了额外的引用计数，实际的引用计数公式：实际引用计数 = extra_rc + 1。这里占了8位，所以理论上可以存储的最大引用计数是：2^8 - 1 + 1 = 256（arm64CPU架构下的extra_rc占19位，可存储的最大引用计数为2^19 - 1 + 1 = 524288）。 与has_sidetable_rc的关联：当对象的最大引用计数超过界限后，has_sidetable_rc的值为1，否则为0 3.5 isa的作用从objc_object的结构可以说明，当系统为一个对象分配好内存，并初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是isa。 同时，通过对isa的位域说明，我们知道shiftcls存储的是类地址。在arm64 架构中占 33位。 我们将ISA_MASK的值0x0000000ffffffff8ULL转化为二进制数分析一下: 从图中可以看到ISA_MASK的值转化为二进制后中间有33位都为1，那么isa指针同ISA_MASK进行按位与运算就可以取出中间33位的值，这正是中间占33位的shiftcls，所以就取出了类对象和元类对象的内存地址信息。 例： 此时通过lldb命令调试 说明： 0x001d800100001129是对象p的isa值，通过isa &amp; ISA_MASK运算得到的0x0000000100001128就是Person类的地址 证明【1】：通过p/x Person.class直接打印Person类地址，显然得到的是0x0000000100001128，如此【1】证明成立！ 结论：isa将对象和类关联起来，起到了中间桥梁的作用。 3.6 isa的初始化补充最后补充一下isa的初始化。还记得初始化isa的入口吗？是initIsa(cls, true, hasCxxDtor);，此时nonpointer的值是true，再看SUPPORT_INDEXED_ISA的定义 12345#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1#else# define SUPPORT_INDEXED_ISA 0#endif 在x86_64下，SUPPORT_INDEXED_ISA是0，所以isa的初始化最终会来到 1234567891011isa_t newisa(0);// 使用ISA_MAGIC_VALUE(0x001d800000000001ULL)赋值给bits// nonpointer为1，magic为1d，其他变量为零newisa.bits = ISA_MAGIC_VALUE;// hasCxxDtor是从类的isa中取出的newisa.has_cxx_dtor = hasCxxDtor;// 将cls右移3位后赋值给shiftclsnewisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;isa = newisa; 碍于篇幅，这里不继续深入hasCxxDtor。 四、isa 指向图在OC中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。 当对象的实例方法被调用时，它通过自己的isa来查找对应的类，然后在所属类的 class_data_bits_t结构体中查找对应方法的实现。同时，每一个objc_class 也有一个指向自己的父类的指针superclass用来查找继承的方法。 而当调用 类方法 时，它的查找流程是怎样的呢？对此OC的解决方案就是引入元类，来保证类方法也能通过相同的机制查找到。也就是说，类的isa指向的是元类。 苹果官方isa指向图： 接下来我们来验证一下吧。 4.1 准备工作创建Teacher类、Person类，其中Person类继承于NSObject，Teacher类继承于Person类。 4.2 验证过程1.获取teacher对象的类（结果是Teacher类，地址为0x0000000100001230） 123456789(lldb) x/4gx teacher0x100f59400: 0x001d800100001231 0x00000000000000000x100f59410: 0x636f72504b575b2d 0x70756f7247737365 (lldb) p/x 0x001d800100001231 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $3 = 0x0000000100001230 // 对象teacher的类地址 (lldb) po $3Teacher // 对象teacher的类 2.获取Teacher类的元类（结果是Teacher元类，地址为0x0000000100001208） 123456789(lldb) x/4gx Teacher.class0x100001230: 0x001d800100001209 0x00000001000011e00x100001240: 0x0000000100f61150 0x0000000100000003(lldb) p/x 0x001d800100001209 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $5 = 0x0000000100001208 // Teacher类的元类地址 (lldb) po $5Teacher // Teacher类的元类 Teacher类 和 Teacher元类 地址不一样 3.获取person对象的类（结果是Person类，地址为0x00000001000011e0），以及类的元类（结果是Person元类，地址为0x00000001000011b8） 12345678910111213141516171819(lldb) x/4gx person0x100f60a30: 0x001d8001000011e1 0x00000000000000000x100f60a40: 0x0000000000000002 0x00007fff9b855588 (lldb) p/x 0x001d8001000011e1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $8 = 0x00000001000011e0 // 对象person的类地址 (lldb) po $8Person // 对象person的类(lldb) x/4gx Person.class0x1000011e0: 0x001d8001000011b9 0x0000000100b381400x1000011f0: 0x0000000100f61030 0x0000000100000003 (lldb) p/x 0x001d8001000011b9 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $10 = 0x00000001000011b8 // Person类的元类地址 (lldb) po $10Person // Person类的元类 4.获取object对象的类（结果是NSObject类，地址为0x0000000100b38140），以及类的元类（结果是NSObject元类，地址为0x0000000100b380f0） 123456789101112131415161718192021(lldb) x/4gx object0x100f5cc50: 0x001d800100b38141 0x00000000000000000x100f5cc60: 0x70736e494b575b2d 0x574b57726f746365 (lldb) p/x 0x001d800100b38141 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $12 = 0x0000000100b38140 // 对象object的类地址 (lldb) po $12 NSObject // 对象object的类 (lldb) x/4gx NSObject.class0x100b38140: 0x001d800100b380f1 0x00000000000000000x100b38150: 0x0000000101913060 0x0000000200000003 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $14 = 0x0000000100b380f0 // NSObject类的元类地址 (lldb) po $14NSObject // NSObject类的元类 5.获取Teacher元类的元类，Person元类的元类，以及NSObject元类的元类 123456789101112131415161718192021222324252627282930313233(lldb) x/4gx 0x0000000100001208 // Teacher元类0x100001208: 0x001d800100b380f1 0x00000001000011b80x100001218: 0x000000010186f950 0x0000000400000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $16 = 0x0000000100b380f0 // NSObject元类 (lldb) po $16NSObject // NSObject元类 (lldb) x/4gx 0x00000001000011b8 // Person元类0x1000011b8: 0x001d800100b380f1 0x0000000100b380f00x1000011c8: 0x0000000101905a50 0x0000000300000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $17 = 0x0000000100b380f0 // NSObject元类 (lldb) po $17NSObject // NSObject元类 (lldb) x/4gx 0x0000000100b380f0 // NSObject元类0x100b380f0: 0x001d800100b380f1 0x0000000100b381400x100b38100: 0x0000000101903820 0x0000000500000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $18 = 0x0000000100b380f0 // NSObject元类 (lldb) po $18NSObject // NSObject元类 4.3 isa指向结论 基于【4.2】的验证过程，可以得出结论： 对象的isa指针指向对象的所属类 类的isa指针指向类的元类 元类的isa指针指向根元类 根元类的isa指针指向他自己(形成闭环) 4.4 继承关系的证明类的继承关系证明过程：（以 -&gt; 表示 继承自） 12345678(lldb) p class_getSuperclass(Teacher.class)(Class) $19 = Person // Teacher类 -&gt; Person类(lldb) p class_getSuperclass(Person.class)(Class) $20 = NSObject // Person类 -&gt; NSObject类(lldb) p class_getSuperclass(NSObject.class)(Class) $21 = nil // NSObject类 -&gt; nil 元类的继承关系证明过程：（以 -&gt; 表示 继承自） 1234567891011121314151617// 0x0000000100001208 是 Teacher元类(lldb) p/x class_getSuperclass((Class)0x0000000100001208)(Class) $17 = 0x00000001000011b8 // Person元类(lldb) po $17Person // Teacher元类 -&gt; Person元类// 0x00000001000011b8 是 Person元类(lldb) p/x class_getSuperclass((Class)0x00000001000011b8)(Class) $22 = 0x0000000100b380f0 // NSObject元类（根元类）(lldb) po $22NSObject // Person元类 -&gt; 根元类// 0x0000000100b380f0 是 根元类(lldb) p/x class_getSuperclass((Class)0x0000000100b380f0)(Class) $23 = 0x0000000100b38140 NSObject // NSObject类（根类）(lldb) po $23NSObject // 根元类 -&gt; 根类 根元类继承自根类（NSObject元类 -&gt; NSObject类），根类继承自nil（NSObject类 -&gt; nil） 五、总结1.isa是isa_t结构，采用 联合体+位域 的搭配来设计：在不同的位上显示不同的内容，以此来节省储存空间，进而优化内存。 2.isa包含了cls和bits两个成员变量，这两个成员变量在64位CPU架构下的长度都是8字节，所以isa在64位CPU架构下的长度也是8字节。 3.isa的位域上存储了一些对象与类的信息，并将对象与类关联起来，起到中间桥梁的作用。 4.指向图相关结论： 继承 子类 -&gt; 父类 -&gt; 根类(NSObject) 子元类 -&gt; 父元类 -&gt; 根元类 !!! 根元类 -&gt; 根类 (NSObject) 形成闭环 isa 指向 实例对象 isa -&gt; 类对象 类对象 isa -&gt; 元类对象 元类对象 isa -&gt; 根元类对象 根元类对象 isa -&gt; 他自己(形成闭环) 六、源码我的 malloc 源码 我的 libobjc 源码 参考资料OC源码分析之isa GDB调试指南","link":"/2020/11/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-isa%E5%8E%9F%E7%90%86/"},{"title":"03-类的结构","text":"一、类的结构1.1 解读类的本质从NSObject类的定义开始 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop} 注意：NSObject有个Class类型的isa成员变量 接下来用Clang编译main.m，输出.cpp文件，看一下NSObject类的底层定义 1clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 打开main.cpp文件，找到了NSObject 123456789#ifndef _REWRITER_typedef_NSObject#define _REWRITER_typedef_NSObjecttypedef struct objc_object NSObject;typedef struct {} _objc_exc_NSObject;#endifstruct NSObject_IMPL { Class isa;}; 发现NSObject类本质上是objc_object结构体，同时有定义一个NSObject_IMPL结构体（IMPL是implementation的缩写），里面有NSObject类的isa成员变量（对应于OC时的NSObject类定义中的isa成员变量）。 现在把我们自己定义的Person类用clang编译成c++看一下。我们定义的Person类：(有个age属性和run方法) 123456789101112131415@interface Person : NSObject@property (nonatomic) NSInteger age;- (void)run;@end@implementation Person- (void)run { NSLog(@&quot;I am running.&quot;);}@end 编译成c++后： 123456789101112131415161718#ifndef _REWRITER_typedef_Person#define _REWRITER_typedef_Persontypedef struct objc_object Person;typedef struct {} _objc_exc_Person;#endifextern &quot;C&quot; unsigned long OBJC_IVAR_$_Person$_age;struct Person_IMPL { struct NSObject_IMPL NSObject_IVARS; NSInteger _age;};static void _I_Person_run(Person * self, SEL _cmd) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mc_9fhhprrj4k92vxzqm3g127z40000gn_T_main_09fc70_mi_0);}static NSInteger _I_Person_age(Person * self, SEL _cmd) { return (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)); }static void _I_Person_setAge_(Person * self, SEL _cmd, NSInteger age) { (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)) = age; } 可见，Person类本质同样是objc_object结构体类型，Person_IMPL结构体内部多了个struct NSObject_IMPL类型的NSObject_IVARS成员变量——即继承自NSObject的类，都有个Class类型的isa成员变量。 1.2 objc_object结构源码： 12345678910111213141516171819202122struct objc_object {private: isa_t isa; public: ... // 一些函数};union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h };#endif}; 关于isa_t的分析见上篇文章 objc_object结构体内部的方法有五十个左右，大致可分为以下几类 一些关于isa的函数，如initIsa()、getIsa()、changeIsa()等 一些弱引用的函数，如isWeaklyReferenced()、setWeaklyReferenced_nolock()等 一些内存管理函数，如retain()、release()、autorelease()等 两个关联对象函数，分别是hasAssociatedObjects()和setHasAssociatedObjects 1.3 Class结构简介同样先上源码 1234567891011121314typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... // 一些函数}; 从源码可以看出，Class是objc_class结构体类型的指针变量，继承自objc_object结构体。也就是说，Class有4个成员变量，且它们在内存存储上是有序的，依次分别是： 1.isa：类型是isa_t，64位下长度为8字节，上篇已做过分析，这里略过 2.superclass：类型是Class，表示继承关系，指向当前类的父类，同样8字节 3.cache：类型是cache_t，表示缓存，用于缓存已调用的方法，加速方法的调用。其具体结构如下: 12345678910111213141516struct cache_t { struct bucket_t *_buckets; // 64位下是8字节 mask_t _mask; // 64位下是4字节 mask_t _occupied; // 64位下是4字节public: ... // 一些函数};#if __LP64__typedef uint32_t mask_t; // uint32_t 4字节 // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t; // uint16_t 2字节#endiftypedef unsigned int uint32_t; 可见，cache这个成员变量长度是16字节。 cache比较重要，关于它的分析可戳 OC源码分析之方法的缓存原理。 4.bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其结构如下 12345678struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; // unsigned longprivate: ... // 一些函数}; 其长度也是8字节。根据bits成员变量在objc_object结构体中的描述，它实质上是class_rw_t *加上自定义rr/alloc标志，最重要的是class_rw_t。 接下来将重点介绍它。 二、class_rw_t &amp; class_ro_t分析 rw是readwrite的意思，而ro则是readonly。 OC类中的属性、方法还有遵循的协议等信息都保存在class_rw_t中，首先看看class_rw_t的结构： 12345678910111213141516171819202122232425262728struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif ...// 一些函数};#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1 // armv7k or arm64_32#else# define SUPPORT_INDEXED_ISA 0#endif 发现class_rw_t中还有一个被const修饰的指针变量 ro，是class_ro_t结构体指针，其中存储了当前类在编译期确定的方法、成员变量、属性以及遵循的协议等信息。 1234567891011121314151617181920212223struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; ... // 一些函数}; 2.1 获取class_rw_t要想获取class_rw_t指针地址，需要知道objc_class的bits指针地址，通过对objc_class的结构分析得知，bits指针地址是objc_class首地址偏移32个字节（isa + superclass + cache = 8+8+16=32字节） 也可以从源码得知如何拿到class_rw_t指针 12345678910111213// objc_class结构体中class_rw_t *data() { return bits.data(); // bits是class_data_bits_t类型}// class_data_bits_t结构体中...class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}// 64位下#define FAST_DATA_MASK 0x00007ffffffffff8UL 在64位下，class_rw_t指针地址是在[3, 46]数据段，所以也可以用bits &amp; FAST_DATA_MASK计算出class_rw_t指针地址。 接着通过一个例子来验证class_rw_t和class_ro_t是否存储了类的信息 2.2 准备工作给Person类添加属性、方法和协议，代码如下 123456789101112131415161718192021222324252627282930313233@protocol PersonProtocol &lt;NSObject&gt;- (void)walk;@end@interface Person : NSObject &lt;PersonProtocol&gt; { NSInteger _gender;}@property (nonatomic) NSString *name;@property (nonatomic) NSInteger age;+ (void)printMyClassName;- (void)run;@end@implementation Person+ (void)printMyClassName { NSLog(@&quot;my class name is Person&quot;);}- (void)run { NSLog(@&quot;I am running.&quot;);}- (void)walk { NSLog(@&quot;I am walking.&quot;);}@end 然后打上断点 好了，准备工作完成，下面开始验证 2.3 class_rw_t验证过程1.打印Person类 1234(lldb) x/5gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x00000000000000000x100002840: 0x0000000102237404 说明： Person类首地址是0x100002820，因此，0x100002840是其bits地址（32字节就是0x20，0x100002840 = 0x100002820 + 0x20），bits内容是0x0000000102237404 0x001d8001000027f9是Person类的isa地址，指向Person元类 0x0000000100b39140是Person类的superclass地址，也就是NSObject类首地址 0x00000001003dc250 0x0000000000000000则是Person类的cache段 2.打印class_rw_t 12345678910111213141516171819202122232425262728293031323334353637// bits &amp; FAST_DATA_MASK(lldb) p (class_rw_t *)(0x0000000102237404 &amp; 0x00007ffffffffff8)(class_rw_t *) $1 = 0x0000000102237400(lldb) p *$1(class_rw_t) $2 = { flags = 2148139008 version = 0 ro = 0x0000000100002788 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002608 arrayAndFlag = 4294977032 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x0000000100002720 arrayAndFlag = 4294977312 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x00000001000025a8 arrayAndFlag = 4294976936 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000} 这里请大家留意一下class_rw_t的几个关键成员变量： ro地址是0x0000000100002788 methods的list地址是0x0000000100002608 properties的list地址是0x0000000100002720 protocols的list地址是0x0000000100002608 3.验证methods 目前来看，Person类至少有6个实例方法，分别是run、walk以及name和age的getter、setter，还有1个类方法，即printMyClassName，总计7个方法。 123456789101112131415(lldb) p (method_list_t *)0x0000000100002608 // rw的methods的list地址(method_list_t *) $7 = 0x0000000100002608(lldb) p *$7(method_list_t) $8 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 7 first = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45) } }} 正好是7个方法，让我们看看都是哪些（由于method_list_t继承自entsize_list_tt，可以通过entsize_list_tt的get()函数一一打印） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(lldb) p $8.get(0)(method_t) $9 = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45)}(lldb) p $8.get(1)(method_t) $10 = { name = &quot;.cxx_destruct&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001600 (CCTest`-[Person .cxx_destruct] at main.m:35)}(lldb) p $8.get(2)(method_t) $11 = { name = &quot;name&quot; types = 0x0000000100001eb1 &quot;@16@0:8&quot; imp = 0x0000000100001560 (CCTest`-[Person name] at main.m:27)}(lldb) p $8.get(3)(method_t) $12 = { name = &quot;setName:&quot; types = 0x0000000100001f4b &quot;v24@0:8@16&quot; imp = 0x0000000100001580 (CCTest`-[Person setName:] at main.m:27)}(lldb) p $8.get(4)(method_t) $13 = { name = &quot;age&quot; types = 0x0000000100001f56 &quot;q16@0:8&quot; imp = 0x00000001000015c0 (CCTest`-[Person age] at main.m:28)}(lldb) p $8.get(5)(method_t) $14 = { name = &quot;run&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001500 (CCTest`-[Person run] at main.m:41)}(lldb) p $8.get(6)(method_t) $15 = { name = &quot;setAge:&quot; types = 0x0000000100001f5e &quot;v24@0:8q16&quot; imp = 0x00000001000015e0 (CCTest`-[Person setAge:] at main.m:28)} 显然，class_rw_t的methods确实包含了Person类的全部实例方法，只是多了个.cxx_destruct方法。.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作，关于其原理这里略过不提。 思考：类方法printMyClassName哪里去了？ 4.验证properties 同理，Person类至少有name和age这两个属性，且看 1234567891011121314151617181920212223242526272829(lldb) p (property_list_t *)0x0000000100002720 // rw的properties的list地址(property_list_t *) $18 = 0x0000000100002720(lldb) p *$18(property_list_t) $19 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 6 first = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) }}(lldb) p $19.get(0)(property_t) $20 = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) (lldb) p $19.get(1)(property_t) $21 = (name = &quot;age&quot;, attributes = &quot;Tq,N,V_age&quot;) (lldb) p $19.get(2)(property_t) $22 = (name = &quot;hash&quot;, attributes = &quot;TQ,R&quot;) (lldb) p $19.get(3)(property_t) $23 = (name = &quot;superclass&quot;, attributes = &quot;T#,R&quot;) (lldb) p $19.get(4)(property_t) $24 = (name = &quot;description&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) (lldb) p $19.get(5)(property_t) $25 = (name = &quot;debugDescription&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) 显然name和age存储在properties中。 多余的属性也不作赘述。 5.验证protocols 在验证之前，先分析一下protocol_list_t，这个结构体并不是继承自entsize_list_tt的，其结构如下 1234567struct protocol_list_t { // count is 64-bit by accident. uintptr_t count; protocol_ref_t list[0]; // variable-size ... // 一些函数} 注意到variable-size这个注释部分（可变大小），仿佛看到了希望 123456789101112131415161718192021typedef uintptr_t protocol_ref_t; // protocol_t *, but unremappedstruct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); ... // 一些函数}; protocol_ref_t虽然未映射成protocol_t *，不过应该可以考虑一下强转，实验一下吧（这次是找到PersonProtocol协议） 1234567891011121314151617181920212223242526272829303132333435363738394041(lldb) p (protocol_list_t *)0x00000001000025a8 // rw的protocols的list地址(protocol_list_t *) $26 = 0x00000001000025a8 (lldb) p *$26(protocol_list_t) $27 = (count = 1, list = protocol_ref_t [] @ 0x00007fb5decb30f8)(lldb) p (protocol_t *)$26-&gt;list[0](protocol_t *) $32 = 0x00000001000028a8 (lldb) p *$32(protocol_t) $33 = { objc_object = { isa = { cls = Protocol bits = 4306735304 = { nonpointer = 0 has_assoc = 0 has_cxx_dtor = 0 shiftcls = 538341913 magic = 0 weakly_referenced = 0 deallocating = 0 has_sidetable_rc = 0 extra_rc = 0 } } } mangledName = 0x0000000100001d16 &quot;PersonProtocol&quot; // 出现了！！！ protocols = 0x0000000100002568 instanceMethods = 0x0000000100002580 classMethods = 0x0000000000000000 optionalInstanceMethods = 0x0000000000000000 optionalClassMethods = 0x0000000000000000 instanceProperties = 0x0000000000000000 size = 96 flags = 0 _extendedMethodTypes = 0x00000001000025a0 _demangledName = 0x0000000000000000 _classProperties = 0x0000000000000000} 功夫不负有心人，最终验证了class_rw_t的protocols中含有Person类所遵循的PersonProtocol协议。 到了这里，**class_rw_t确实存储了类的实例方法、属性和遵循的协议了。** 2.4 class_ro_t验证过程现在就剩下ro了 1.打印class_ro_t 123456789101112131415161718(lldb) p $1-&gt;ro(const class_ro_t *) $38 = 0x0000000100002788 (lldb) p *$38(const class_ro_t) $39 = { flags = 388 instanceStart = 8 instanceSize = 32 reserved = 0 ivarLayout = 0x0000000100001d2e &quot;\\x11&quot; name = 0x0000000100001d0f &quot;Person&quot; baseMethodList = 0x0000000100002608 baseProtocols = 0x00000001000025a8 ivars = 0x00000001000026b8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x0000000100002720 _swiftMetadataInitializer_NEVER_USE = {}} 有没有发现什么！**class_ro_t的方法、属性和协议的地址都与class_rw_t的一致，既然指向的是同一块内存空间，显然class_ro_t也存储了Person类的实例方法、属性和协议**。 与class_rw_t不同的是，class_ro_t多了一个ivars列表，里面存放的应该是Person类的成员变量。 2.验证ivars Person类的成员变量有：_gender、_name和_age 所幸ivar_list_t是继承自entsize_list_tt的，get()函数又可以用了。 12345678910111213141516171819202122232425262728293031323334353637383940(lldb) p $39.ivars(const ivar_list_t *const) $40 = 0x00000001000026b8(lldb) p *$40(const ivar_list_t) $41 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = { entsizeAndFlags = 32 count = 3 first = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8 } }}(lldb) p $41.get(0)(ivar_t) $42 = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(1)(ivar_t) $43 = { offset = 0x00000001000027e8 name = 0x0000000100001e8b &quot;_name&quot; type = 0x0000000100001f6b &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(2)(ivar_t) $44 = { offset = 0x00000001000027f0 name = 0x0000000100001e91 &quot;_age&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8} 完全符合预期，class_ro_t确实存储了Person类的成员变量。 2.5 rw和ro的联系【下面看不懂了】为什么class_rw_t、class_ro_t的方法、属性和协议的地址一致？ 在class_data_bits_t结构体中的safe_ro()函数中发现了端倪 12345678910const class_ro_t *safe_ro() { class_rw_t *maybe_rw = data(); if (maybe_rw-&gt;flags &amp; RW_REALIZED) { // maybe_rw is rw return maybe_rw-&gt;ro; } else { // maybe_rw is actually ro return (class_ro_t *)maybe_rw; }} 可见，rw不一定是rw，也可能是ro。实际上，在编译期间，类的class_data_bits_t *bits指针指向的是class_ro_t *，然后在OC运行时调用了realizeClassWithoutSwift()（苹果开源的objc4-756.2源码是realizeClassWithoutSwift()，在此之前的版本是realizeClass()方法），这个方法主要做的就是利用编译期确定的ro来初始化rw： 12345678910111213141516171819ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // 一般走这里 // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); // 给rw申请内存 rw-&gt;ro = ro; // 设置rw的ro rw-&gt;flags = RW_REALIZED|RW_REALIZING; // 设置flags cls-&gt;setData(rw); // 给cls设置正确的rw}... // 初始化 rw 的其他字段，更新superclass、meta class// Attach categoriesmethodizeClass(cls); 在代码的最后，还调用了methodizeClass()，其源码如下 1234567891011121314151617181920212223242526272829303132333435363738static void methodizeClass(Class cls){ runtimeLock.assertLocked(); bool isMeta = cls-&gt;isMetaClass(); auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; ... // 打印信息 // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); } property_list_t *proplist = ro-&gt;baseProperties; if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1); } if (cls-&gt;isRootMetaclass()) { addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); } category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); ... // 打印信息 if (cats) free(cats); ... // 打印信息} 在这个方法里，将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、properties 和 protocols 列表中。 这就完美解释了为什么运行时rw和ro的方法、属性和协议相同。 2.6 rw和ro在运行时的不同之处目前为止的验证都是基于Person类的现有结构，也就是在编译期就确定的，突出不了class_rw_t和class_ro_t的差异性。接下来会用runtime的api在运行时为Person动态添加一个fly()方法，再来一试。 1.添加方法 具体代码如下： 12345void fly(id obj, SEL sel) { NSLog(@&quot;I am flying&quot;);}class_addMethod([Person class], NSSelectorFromString(@&quot;fly&quot;), (IMP)fly, &quot;v@:&quot;); 再加一个打印方法，用于打印类的methods 123456789101112void printMethods(Class cls) { if (cls == nil) { return ; } CCNSLog(@&quot;------------ print %@ methods ------------&quot;, NSStringFromClass(cls)); uint32_t count; Method *methods = class_copyMethodList(cls, &amp;count); for (uint32_t i = 0; i &lt; count; i++) { Method method = methods[i]; CCNSLog(@&quot;名字：%@ -- 类型：%s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method)); }} 运行一下看效果，发现添加成功，如图 2.验证过程 先打印class_rw_t，即 还有class_ro_t 对比后发现，两者的属性、协议指针地址未发生变化，但是方法的指针地址不一样了。 由于class_rw_t是运行时才初始化的，而class_ro_t在编译期间就确定了，因此可以猜测新增的fly方法存储在class_rw_t的methods指针上，class_ro_t的baseMethodList指针从编译期之后就未发生改变。 下面继续验证，首先看class_ro_t的方法列表 OK，编译期就确定的方法都在，并且没有fly方法，也就是说class_ro_t的方法列表在运行时基本没变。 class_ro_t的属性列表、成员变量列表、协议在运行时都没有发生改变。感兴趣的同学可以自己尝试验证一下。 接着看class_rw_t的方法列表 class_rw_t的methods里面数据居然都没有了？ 没办法，这里暂时留个坑吧，暂时不知道原因。 3. 总结3.1 类的结构总结关于类的结构，我们了解到： 类本质上是objc_object结构体，也就是类也是对象，即万物是对象。 类都包含一个Class类型的成员变量isa Class是objc_class结构体类型的指针变量，内部有4个成员变量，即 isa：类型是isa_t superclass：类型是Class，表示继承关系，指向类的父类 cache：类型是cache_t，表示缓存，用于缓存指针和 vtable，加速方法的调用 bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其长度在64位CPU下为8字节，是个指针，指向class_rw_t * 3.2 class_rw_t和class_ro_t总结 class_ro_t存储了类在编译期确定的方法（包括其分类的）、成员变量、属性以及遵循的协议等信息，在运行时不会发生变化。编译期，类的bits指针指向的是class_ro_t指针（即此时class_rw_t 实际上是class_ro_t ）。 实例方法存储在类中 类方法存储在元类中（【4.1】将给出证明） 在realizeClassWithoutSwift()执行之后，class_rw_t才会被初始化，同时存储类的方法、属性以及遵循的协议，实际上，class_rw_t和class_ro_t两者的方法列表（或属性列表、协议列表）的指针是相同的。 运行时向类动态添加属性、方法时，会修改class_rw_t的属性列表、方法列表指针，但class_ro_t对应的属性列表、方法列表不会变。 一个待解决的坑：通过运行时添加方法（或属性、协议）改变了 class_rw_t 对应的方法列表（或属性列表、协议列表）的指针后，不知道为什么居然在 class_rw_t 的方法列表（或属性列表、协议列表）上找不到新增的方法（或属性、协议）了。 3.3 类方法的存储位置（Person类的类方法printMyClassName()） 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. 获取 Person元类(lldb) x/4gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x0000000000000000(lldb) p/x 0x001d8001000027f9 &amp; 0x00007ffffffffff8(long) $50 = 0x00000001000027f8(lldb) po 0x00000001000027f8Person // Person元类// 2. 获取 Person元类 的 bits(lldb) x/5gx 0x00000001000027f80x1000027f8: 0x001d800100b390f1 0x0000000100b390f00x100002808: 0x0000000102237440 0x00000001000000030x100002818: 0x00000001022373a0 // Person元类 的 bits// 3. 获取 Person元类 的 class_rw_t(lldb) p (class_rw_t *)(0x00000001022373a0 &amp; 0x00007ffffffffff8)(class_rw_t *) $52 = 0x00000001022373a0// 4. 验证 Person元类 的 methods(lldb) p $52-&gt;methods(method_array_t) $55 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002270 arrayAndFlag = 4294976112 } }}(lldb) p (method_list_t *)0x0000000100002270(method_list_t *) $56 = 0x0000000100002270(lldb) p *$56(method_list_t) $57 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 1 first = { name = &quot;printMyClassName&quot; // 成功找到 Person类的类方法 types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x00000001000014d0 (CCTest`+[Person printMyClassName] at main.m:37) } }} 结论：类方法 存储 在类的元类上，且位于元类的class_ro_t的baseMethodList指针上（或在class_rw_t的methods指针上）","link":"/2020/11/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84/"},{"title":"Hexo 配置","text":"一、升级主题1.使用 1sudo npm install -g npm-upgrade 和 123ncu -u // 自动更新所有插件或者 npm-upgrade // 手动选择插件更新 来升级Hexo中的插件 2.保存 1npm update -g 1npm update --save 3.安装配置主题 1npm install hexo-theme-icarus 1hexo config theme icarus 4.根据提示安装缺少或者需要更新的东西 5.再次配置主题 1hexo config theme icarus 这个时候应该提示配置成功了 6.本地启动看看 1hexo s 二、Icarus 配置1.进入 hexo 目录 2.一些基础配置通过修改主题的全局配置文件_config.icarus.yml 3.修改博客为：主页三栏，文章页两栏 找到hexo-theme-icarus文件夹，在此目录下添加_config.post.yml文件并配置： 123456789101112widgets: - # Where should the widget be placed, left sidebar or right sidebar position: left type: toc # Whether to show the index of each heading index: false # Whether to collapse sub-headings when they are out-of-view collapsed: true # Maximum level of headings to show (1-6) depth: 6 4.主题进行 cdn 加速 搜索并找到cdn.js文件，并修改： 123456789101112131415161718192021222324252627282930313233343536373839/** * @private */// 原来的// const PROVIDERS = {// LIBRARY: {// cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }',// loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }',// jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }',// unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }'// },// FONT: {// google: 'https://fonts.googleapis.com/${ type }?family=${ fontname }',// loli: 'https://fonts.loli.net/${ type }?family=${ fontname }'// },// ICON: {// loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css',// fontawesome: 'https://use.fontawesome.com/releases/v5.12.0/css/all.css'// }// };// 改为：const PROVIDERS = { LIBRARY: { // cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }', cdnjs: 'https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }', unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }' }, FONT: { google: 'https://fonts.loli.net/${ type }?family=${ fontname }', loli: 'https://fonts.loli.net/${ type }?family=${ fontname }' }, ICON: { loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css', fontawesome: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css' }};","link":"/2020/12/16/%E5%8D%9A%E5%AE%A2/Hexo%20%E9%85%8D%E7%BD%AE/"},{"title":"04-方法的缓存原理","text":"前言一、 cache_t源码分析当OC项目编译完成后，类的实例方法（方法编号SEL 和 函数地址IMP）就保存在类的方法列表中。我们知道 OC 为了实现其动态性，将 方法的调用包装成了 SEL 寻找 IMP 的过程。试想一下，如果每次调用方法，都要去类的方法列表（甚至父类、根类的方法列表）中查询其函数地址，势必会对性能造成极大的损耗。 为了解决这一问题，OC 采用了方法缓存的机制来提高调用效率，也就是cache_t，其作用就是缓存已调用的方法。当调用方法时，objc_msgSend会先去缓存中查找，如果找到就执行该方法；如果不在缓存中，则去类的方法列表（包括父类、根类的方法列表）查找，找到后会将方法的SEL和IMP缓存到cache_t中，以便下次调用时能够快速执行。 1.1 cache_t结构源码： 12345678910111213141516171819202122232425struct cache_t { struct bucket_t *_buckets; // 缓存数组，即哈希桶 mask_t _mask; // 缓存数组的容量临界值 mask_t _occupied; // 缓存数组中已缓存方法数量 ... // 一些函数};#if __LP64__typedef uint32_t mask_t;#elsetypedef uint16_t mask_t;#endifstruct bucket_t {private:#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif ... // 一些方法}; 从上面源码不难看出，在64位CPU架构下，cache_t长度是16字节。单从结构来看，方法是缓存在bucket_t（又称哈希桶）中，接下来用个例子验证一下cache_t是否缓存了已调用的方法。 1.2 方法缓存的验证1.创建一个简单的Person类，代码如下 1234567891011121314151617181920212223@interface Person : NSObject- (void)methodFirst;- (void)methodSecond;- (void)methodThird;@end@implementation Person- (void)methodFirst { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodSecond { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodThird { NSLog(@&quot;%s&quot;, __FUNCTION__);}@end 2.方法调用前的cache_t 在方法调用前打个断点，看看cache_t的缓存情况 说明： objc_class结构中ISA占8字节，superClass占8字节，由于我们是按照8字节为一段打印的，所以刚好0x1000011d8就是cache_t首地址。 由于还没有任何方法调用，所以_mask和_occupied都是0，即还没有方法缓存。 为什么调用了alloc和class，但是这两个方法怎么没有缓存，这里要提到我们之前探索类的方法存储中说到的，对象的方法存在类中，类的类方法以实例方法的形式存在元类中，我们这里探索的是类的cache缓存，所以只能找到实例方法。下面直接给大家看一下元类里的cache以及bucket，也找到了alloc方法的缓存，这也说明，我们的思路是正确的： 123456789101112131415161718192021(lldb) p/x 0x001d8001000012b9 &amp; 0x00007ffffffffff8ULL(unsigned long long) $5 = 0x00000001000012b8// 0x00000001000012b8这个玩意就是元类的地址了。之前的isa原理，里面介绍到了如何从类查找到元类(lldb) x/4gx 0x00000001000012b80x1000012b8: 0x001d800100b360f1 0x0000000100b360f00x1000012c8: 0x0000000101e236c0 0x0000000200000003(lldb) p (cache_t *)0x1000012c8(cache_t *) $6 = 0x00000001000012c8(lldb) p *$6(cache_t) $7 = { _buckets = 0x0000000101e236c0 _mask = 3 _occupied = 2}(lldb) p $7._buckets(bucket_t *) $8 = 0x0000000101e236c0(lldb) p *$8(bucket_t) $9 = { _key = 4298994200 _imp = 0x00000001003cc3b0 (libobjc.A.dylib`::+[NSObject alloc]() at NSObject.mm:2294)} 3.方法调用后的cache_t 执行alloc和init这两个方法后，cache_t变化如下 从上图可知，调用init后，_mask的值是3，_occupied则是1。_buckets指针的值（数组首地址）发生了变化（从0x1003db250变成0x101700090），同时缓存了init方法的SEL和IMP。 思考： 1. alloc 方法调用后，缓存在哪里？ 2. 为什么 init 方法不在 _buckets 第一个位置？ 继续执行methodFirst，再看cache_t 此时，_mask的值是3（没发生变化），_occupied则变成了2，_buckets指针地址没变，增加缓存了methodFirst方法的SEL和IMP。 接着是执行methodSecond，且看 显然，_occupied变成了3，而_buckets指针地址不改变，同时新增methodSecond的方法缓存。 最后执行methodThird后，再看cache_t变化 这次的结果就完全不同了。_mask的值变成7，_occupied则重新变成了1，而_buckets不仅首地址变了，之前缓存的init、methodFirst和methodSecond方法也没了，仅存在的只有新增的methodThird方法。看来，cache_t并非是如我们所愿的那样——调用一个方法就缓存一个方法。 思考：之前缓存的方法（init、methodFirst 和 methodSecond）哪去了？ 1.3 cache_t小结让我们梳理一下上面的例子。在依次执行Person的实例方法init、methodFirst、methodSecond、methodThird后，cache_t变化如下 调用的方法 _buckets _mask _occupied 未调用方法 空 0 0 init init 3 1 init、methodFirst init、methodFirst 3 2 init、methodFirst、methodSecond init、methodFirst、methodSecond 3 3 init、methodFirst、methodSecond、methodThird methodThird 7 1 可见，**cache_t的确能实时缓存已调用的方法**。 上面的验证过程也可以帮助我们理解cache_t三个成员变量的意义。 bucket可译为桶（即哈希桶），用于装方法； occupied可译为已占有，表示已缓存的方法数量； mask可译为面具、掩饰物，乍看无头绪，但是注意到cache_t中有获取容量的函数（capacity），其源码如下 12345678910111213141516struct cache_t { ... mask_t mask(); mask_t capacity(); ...}mask_t cache_t::mask() { return _mask; }mask_t cache_t::capacity() { return mask() ? mask()+1 : 0; } 从capacity方法看出：当_mask不等于0的时候，意味着已经调用过实例方法，此时桶的容量为_mask + 1，如果_mask是0，说明未调用实例方法，即桶的容量为0。故，_mask从侧面反映了桶的容量。 二、cache_t的方法缓存原理接下来，从方法的调用过程开始分析cache_t的方法缓存原理。 2.1 cache_fillOC方法的本质是 **消息发送（即objc_msgSend），底层是通过方法的 SEL 查找 IMP**。 简要流程： 1.调用方法时，objc_msgSend会去cache_t即缓存中查询方法的函数实现（这部分是由汇编代码实现的，非常高效），在缓存中找的过程暂且不表 2.当缓存中没有的时候，则去类的方法列表中查找，直至找到后，再调用cache_fill，目的是为了将方法缓存到cache_t中，其源码如下 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver){#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif} objc_msgSend的具体流程将另起一文分析，这里不作赘述。 2.2 cache_fill_nolockcache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 其源码以及详细分析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver){ cacheUpdateLock.assertLocked(); // 如果类未初始化 if (!cls-&gt;isInitialized()) return; // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，即 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) { // 当第一次调用类的实例方法时（如本文的【1.2】例中的`init`） cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } else if (newOccupied &lt;= capacity / 4 * 3) { // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 } else { // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); } // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);}// INIT_CACHE_SIZE 即为4enum { INIT_CACHE_SIZE_LOG2 = 2, INIT_CACHE_SIZE = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)}; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 1.决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 2.然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 思考：为什么扩容临界点是 3/4？ 2.3 reallocate在下面这两种情况下会执行reallocate： 一是第一次初始化_buckets的时候 另一种则是_buckets扩容的时候 我们来看一下reallocate做了哪些事情 1234567891011121314151617181920212223242526void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity){ // 当且仅当`_buckets`中有缓存方法时，feeOld为true bool freeOld = canBeFreed(); // 获取当前buckets指针，即_buckets bucket_t *oldBuckets = buckets(); // 开辟新的buckets指针 bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache's old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity &gt; 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); // 将新buckets、新mask（newCapacity-1）分别赋值跟当前的 _buckets 和 _mask setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) { // 释放旧的buckets内存空间 cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); }} reallocate完美解释了在例【1.2】中的几个情况： init执行完后，_buckets指针地址变了，_mask变成了3； methodThird执行完后，_buckets不仅指针地址变了，同时之前缓存的init、methodFirst和methodSecond方法也都不在了 注意，_occupied的变化是在回到cache_fill_nolock后发生的。 思考：扩容后，为什么不直接把之前缓存的方法加入新的buckets中？ 2.4 expand从cache_fill_nolock源码来看，当新的方法缓存数（_occupied+1）大于总容量（_mask+1）时，会对_buckets进行扩容，也就是执行expand函数，其源码如下 1234567891011121314151617void cache_t::expand(){ cacheUpdateLock.assertLocked(); // 获取当前总容量，即_mask+1 uint32_t oldCapacity = capacity(); // 新的容量 = 旧容量 * 2 uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) { // mask overflow - can't grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; } reallocate(oldCapacity, newCapacity);} 这个函数非常简单，仅仅是计算好新的容量后，就去调用reallocate函数。需要注意的是： 在不超过uint32_t大小（4字节）时，每次扩容为原来的2倍 如果超过了uint32_t，则重新申请跟原来一样大小的buckets 2.5 find在执行完相应的buckets策略后，接下来就需要找到合适的位置（bucket），以存储 方法的SEL和IMP。find具体做的事情就是根据方法的SEL，返回一个符合要求的bucket，同样上源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bucket_t * cache_t::find(SEL s, id receiver){ assert(s != 0); // 获取当前buckets，即_buckets bucket_t *b = buckets(); // 获取当前mask，即_mask mask_t m = mask(); // 由 sel &amp; mask 得出起始索引值 mask_t begin = cache_hash(s, m); mask_t i = begin; do { // sel为0：说明 i 这个位置尚未缓存方法； // sel等于s：命中缓存，说明 i 这个位置已缓存方法，可能是hash冲突 if (b[i].sel() == 0 || b[i].sel() == s) { return &amp;b[i]; } } while ((i = cache_next(i, m)) != begin); // hack // 找不到多余的哈希桶（出错的处理，打印问题）。一般不会走到这里！ Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache)); cache_t::bad_cache(receiver, (SEL)s, cls);}static inline mask_t cache_hash(SEL sel, mask_t mask) { return (mask_t)(uintptr_t)sel &amp; mask;}#if __arm__ || __x86_64__ || __i386__// objc_msgSend has few registers available.// Cache scan increments and wraps at special end-marking bucket.#define CACHE_END_MARKER 1static inline mask_t cache_next(mask_t i, mask_t mask) { return (i+1) &amp; mask;}#elif __arm64__// objc_msgSend has lots of registers available.// Cache scan decrements. No end marker needed.#define CACHE_END_MARKER 0static inline mask_t cache_next(mask_t i, mask_t mask) { return i ? i-1 : mask;}#else#error unknown architecture#endif 从源码可以发现，find找bucket的方式用到了hash的思想：以_buckets作为哈希桶，以cache_hash作为哈希函数，进行哈希运算后得出索引值index（本质是xx &amp; mask，所以index最大值就是_mask的值）。 由于索引值是通过哈希运算得出的，其结果自然是无序的，这也是为什么上例中init方法不在_buckets第一个位置的原因。 三、多线程对方法缓存的影响既然哈希桶的数量是在运行时动态增加的，那么在多线程环境下调用方法时，对方法的缓存有没有什么影响呢？看下面的分析。 3.1 多线程同时读取缓存在整个objc_msgSend函数中，为了达到最佳的性能，对方法缓存的读取操作是没有添加任何锁的。而多个线程同时调用已缓存的方法，并不会引发_buckets和_mask的变化，因此多个线程同时读取方法缓存的操作是不会有安全隐患的。 3.2 多线程同时写缓存从写缓存的cache_fill_nolock方法中我们知道在桶数量扩容和写桶数据之前，系统使用了一个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证写入的同步处理，并且在锁住的范围内部还做了一次查缓存的操作（if (cache_getImp(cls, sel)) return;），这样就 保证了哪怕多个线程同时写同一个方法的缓存也只会产生写一次的效果，即多线程同时写缓存的操作也不会有安全隐患。 3.3 多线程同时读写缓存这个情况就比较复杂了，我们先看一下objc_msgSend读缓存的代码（以 arm64架构汇编 为例） 12345678910111213141516171819202122232425262728293031323334353637383940.macro CacheLookup // x1 = SEL, x16 = isa ldp x10, x11, [x16, #CACHE] // x10 = buckets, x11 = occupied|mask and w12, w1, w11 // x12 = _cmd &amp; mask add x12, x10, x12, LSL #4 // x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4) ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // wrap: x12 = first bucket, w11 = mask add x12, x12, w11, UXTW #4 // x12 = buckets+(mask&lt;&lt;4) // Clone scanning loop to miss instead of hang when cache is corrupt. // The slow path may detect any corruption and halt later. ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // double wrap JumpMiss $0 .endmacro 其中，ldp指令的作用是将数据从内存读取出来存到寄存器，第一个ldp代码会 把cache_t中的_buckets 和 _occupied | _mask整个结构体成员分别读取到x10和x11两个寄存器中，并且CacheLookup的后续代码没有再次读取cache_t的成员数据，而是一直使用x10和x11中的值进行哈希查找。由于CPU能保证单条指令执行的原子性，所以 只要保证ldp x10, x11, [x16, #CACHE]这段代码读取到的_buckets与_mask是互相匹配的（即要么同时是扩容前的数据，要么同时是扩容后的数据），那么多个线程同时读写方法缓存也是没有安全隐患的。 3.3.1 编译内存屏障这里有个疑问，即系统是如何确保_buckets与_mask的这种一致性的呢？让我们看一下这两个变量的写入源码 1234567891011121314151617181920void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask){ // objc_msgSend uses mask and buckets with no locks. // It is safe for objc_msgSend to see new buckets but old mask. // (It will get a cache miss but not overrun the buckets' bounds). // It is unsafe for objc_msgSend to see old buckets and new mask. // Therefore we write new buckets, wait a lot, then write new mask. // objc_msgSend reads mask first, then buckets. // ensure other threads see buckets contents before buckets pointer mega_barrier(); _buckets = newBuckets; // ensure other threads see new buckets before new mask mega_barrier(); _mask = newMask; _occupied = 0;} 这段C++代码先修改_buckets，然后再更新_mask的值，为了确保这个顺序不被编译器优化，这里使用了mega_baerrier()来实现 编译内存屏障（Compiler Memory Barrier）。 如果不设置 编译内存屏障 的话，编译器有可能会优化代码先赋值_mask，然后才是赋值_buckets，两者的赋值之间，如果另一个线程执行ldp x10, x11, [x16, #0x10]指令，得到的就是旧_buckets和新_mask，进而出现内存数组越界引发程序崩溃。 而加入了编译内存屏障后，就算得到的是新_buckets和旧_mask，也不会导致程序崩溃。 编译内存屏障仅仅是确保_buckets的赋值会优先于_mask的赋值，也就是说，在任何场景下当指令ldp x10, x11, [x16, #CACHE]执行后，得到的_buckets数组的长度一定是大于或等于_mask+1的，如此就保证了不会出现内存数组越界导致的程序崩溃。可见，借助编译内存屏障的技巧在一定的程度上可以实现无锁读写技术。 对内存屏障感兴趣的同学可戳 理解 Memory barrier（内存屏障） 3.3.2 内存垃圾回收我们知道，在多线程读写方法缓存时，写线程可能会扩容_buckets（开辟新的_buckets内存，同时销毁旧的_buckets），此时，如果其他线程读取到的_buckets是旧的内存，就有可能会发生读内存异常而系统崩溃。为了解决这个问题，OC使用了两个全局数组objc_entryPoints、objc_exitPoints，分别保存所有会访问到cache的函数的起始地址、结束地址 12extern &quot;C&quot; uintptr_t objc_entryPoints[];extern &quot;C&quot; uintptr_t objc_exitPoints[]; 下面列出这些函数（同样以 arm64架构汇编 为例） 12345678910111213141516171819.private_extern _objc_entryPoints_objc_entryPoints: .quad _cache_getImp .quad _objc_msgSend .quad _objc_msgSendSuper .quad _objc_msgSendSuper2 .quad _objc_msgLookup .quad _objc_msgLookupSuper2 .quad 0.private_extern _objc_exitPoints_objc_exitPoints: .quad LExit_cache_getImp .quad LExit_objc_msgSend .quad LExit_objc_msgSendSuper .quad LExit_objc_msgSendSuper2 .quad LExit_objc_msgLookup .quad LExit_objc_msgLookupSuper2 .quad 0 当线程扩容哈希桶时，会先把旧的桶内存保存在一个全局的垃圾回收数组变量garbage_refs中，然后再遍历当前进程（在iOS中，一个进程就是一个应用程序）中的所有线程，查看是否有线程正在执行objc_entryPoints列表中的函数（原理是PC寄存器中的值是否在objc_entryPoints和objc_exitPoints这个范围内），如果没有则说明没有任何线程访问cache，可以放心地对garbage_refs中的所有待销毁的哈希桶内存块执行真正的销毁操作；如果有则说明有线程访问cache，这次就不做处理，下次再检查并在适当的时候进行销毁。 以上，**OC 2.0的runtime巧妙的利用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。** 深入解构objc_msgSend函数的实现 这篇博文会帮助你进一步了解Runtime的实现，尤其在多线程读写方法缓存方面 四、问题讨论来到这里，相信大家对cache_t缓存方法的原理已经有了一定的理解。现在请看下面的几个问题： 4.1 类方法的缓存位置Q：Person类调用alloc方法后，缓存在哪里？ A：缓存在 Person元类 的 cache_t 中。证明如下图 4.2 _mask的作用Q：请说明cache_t中_mask的作用 A：_mask从侧面反映了cache_t中哈希桶的数量（哈希桶的数量 = _mask + 1），保证了查找哈希桶时不会出现越界的情况。 题解：从上面的源码分析，我们知道cache_t在任何一次缓存方法的时候，哈希桶的数量一定是 &gt;=4且能被 4整除的，_mask则等于哈希桶的数量-1，也就是说，缓存方法的时候，_mask的二进制位上全都是1。当循环查询哈希桶的时候，索引值是由xx &amp; _mask运算得出的，因此索引值是小于哈希桶的数量的（index &lt;= _mask，故index &lt; capacity），也就不会出现越界的情况。 4.3 关于扩容临界点3/4的讨论Q：为什么扩容临界点是3/4？ A：一般设定临界点就不得不权衡 空间利用率 和 时间利用率 。在 3/4 这个临界点的时候，空间利用率比较高，同时又避免了相当多的哈希冲突，时间利用率也比较高。 题解：扩容临界点直接影响循环查找哈希桶的效率。设想两个极端情况： 当临界点是1的时候，也就是说当全部的哈希桶都缓存有方法时，才会扩容。这虽然让开辟出来的内存空间的利用率达到100%，但是会造成大量的哈希冲突，加剧了查找索引的时间成本，导致时间利用率低下，这与高速缓存的目的相悖； 当临界点是0.5的时候，意味着哈希桶的占用量达到总数一半的时候，就会扩容。这虽然极大避免了哈希冲突，时间利用率非常高，却浪费了一半的空间，使得空间利用率低下。这种以空间换取时间的做法同样不可取； 两相权衡下，当扩容临界点是3/4的时候，空间利用率 和 时间利用率 都相对比较高。 4.4 缓存循环查找的死循环情况Q：缓存循环查找哈希桶是否会出现死循环的情况？ A：不会出现。 题解：当哈希桶的利用率达到3/4的时候，下次缓存的时候就会进行扩容，即空桶的数量最少也会有总数的1/4，因此循环查询索引的时候，一定会出现命中缓存或者空桶的情况，从而结束循环。 五、总结通过以上例子的验证、源码的分析以及问题的讨论，现在总结一下cache_t的几个结论： 1.cache_t能缓存调用过的方法。 2.cache_t的三个成员变量中， _buckets的类型是struct bucket_t *，也就是指针数组，它表示一系列的哈希桶（已调用的方法的SEL和IMP就缓存在哈希桶中），一个桶可以缓存一个方法。 _mask的类型是mask_t（mask_t在64位架构下就是uint32_t，长度为4个字节），它的值等于哈希桶的总数-1（capacity - 1），侧面反映了哈希桶的总数。 _occupied的类型也是mask_t，它代表的是当前_buckets已缓存的方法数。 3.当缓存的方法数到达临界点（桶总数的3/4）时，下次再缓存新的方法时，首先会丢弃旧的桶，同时开辟新的内存，也就是扩容（扩容后都是全新的桶，以后每个方法都要重新缓存的），然后再把新的方法缓存下来，此时_occupied为1。 4.当多个线程同时调用一个方法时，可分以下几种情况： 多线程读缓存：读缓存由汇编实现，无锁且高效，由于并没有改变_buckets和_mask，所以并无安全隐患。 多线程写缓存：OC用了个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证不会出现写两次缓存的情况。 多线程读写缓存：OC使用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。 参考https://juejin.cn/post/6844904070596001806","link":"/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"}],"tags":[],"categories":[{"name":"iOS·底层原理","slug":"iOS·底层原理","link":"/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"}]}