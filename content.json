{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"02 - 内存对齐","text":"一、内存对齐原则三原则在 iOS 中，对象的属性需要进行内存对齐，而对象本身也需要进行内存对齐。内存对齐有三原则: 1.数据成员对齐原则: 结构体 / 联合体( union )的数据成员，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始）。 2.结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储 3.收尾工作: 结构体的总大小,也就是 sizeof 的结果，必须是其内部最大成员的整数倍，不足的要补⻬。 二、内存对齐在系统中的应用2.1 属性 8 字节对齐12345678910111213141516struct MyStruct { double a; char b; // char 在前 int 在后 int c; short d;} MyStr1; struct MyStruct2 { double a; int c; // int 在前 char 在后 char b; short d;} MyStr2; // 我们打印一下各自的所占空间NSLog(@&quot;%lu -- %lu&quot;,sizeof(MyStr1), sizeof(MyStr2)); 结果如下: 为何两者不一致? 我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。 12345678struct MyStruct { double a; // 8位 char b; // 1位 + 7 补齐 = 8 int c; // 4位 short d; // 2位 + 2 = 4} MyStr1; // 总计是 8 + 8 + 4 + 4 = 24； 而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。 12345678struct MyStruct2 { double a; // 8 int c; // 4 char b; // 1 补齐1位 short d; // 2 } MyStr2; // 8+4+2+2 = 16。 这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） = 16。 跟踪源码去证实： 1.创建对象 alloc 2.alloc方法的实现——返回rootAlloc方法 3.返回callAlloc的实现 4.当缓存区没有对象时，创建对象 5.去内存区域创建对象 6.执行类的属性方法，确定创建的空间大小 7.对齐内存 8.内存对齐的返回：类的属性大小取决于指针大小 9.8字节对齐：实现方法 补充：对象属性的内存优化1234567891011121314151617181920// 声明属性@property (nonatomic, copy) NSString *name; // 8个字节@property (nonatomic, assign) int age; // 4个字节@property (nonatomic, assign) long height; // 8个字节@property (nonatomic, copy) NSString *hobby; // 8个字节@property (nonatomic, assign) int sex; // 4个字节@property (nonatomic) char ch1; // 1个字节@property (nonatomic) char ch2; // 1个字节// 对象创建赋值MRObject *obj = [MRObject alloc];obj.name = @&quot;testAlign&quot;;obj.age = 18;obj.height = 185;obj.hobby = @&quot;money&quot;;obj.sex = 2;obj.ch1 = 'a';obj.ch2 = 'b'; 然后打印对象的内存结构，查看对应属性的内存分配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(lldb) x obj 对象的指针内存情况0x1019038d0: e9 25 00 00 01 80 1d 00 61 62 00 00 12 00 00 00 .%......ab......0x1019038e0: 02 00 00 00 00 00 00 00 48 20 00 00 01 00 00 00 ........H ...... (lldb) x/4gx obj 按照每段8字节打印内存情况，4gx 代表4段0x1019038d0: 0x001d8001000025e9 0x00000012000062610x1019038e0: 0x0000000000000002 0x0000000100002048 (lldb) x/6gx obj 按照每段8字节打印内存情况，6gx 代表6段0x1019038d0: 0x001d8001000025e9 0x00000012000062610x1019038e0: 0x0000000000000002 0x00000001000020480x1019038f0: 0x00000000000000b9 0x0000000100002068 (lldb) po 0x1019038d0 对象的首地址就是对象地址&lt;MRObject: 0x1019038d0&gt;(lldb) po 0x001d8001000025e9 打印第一个段的值，打印不出来，因为这里是 isa，但是 isa 指针要通过 mask 处理之后才能对应到具体的值8303516107941353(lldb) po 0x0000000000000002 对应 int sex 成员的值，占4字节；如果不对 sex 赋值，这里会是0x0000000000000000 代表默认的野地址，还没有赋值，但是也会有内存开辟2(lldb) po 0x0000000100002048 对应 NSString *hobby 的值，8字节testAlign(lldb) po 0x00000000000000b9 对应十进制的 long height 185，因为浮点型会系统底层优化成十进制存储185(lldb) po 0x0000000100002068 对应 NSString *nanme 的值，8字节money// 😳那么 age 和 18 到底存在哪儿呢？？// 仔细一看还有一段内存 0x0000001200006261 没有读取，但是直接读取读不出来；(lldb) po 0x000000120000626177309436513// 看这个内存的结构如果直接拆成两部分，4字节 + 4字节呢，我们单独打印尝试一下(lldb) po 0x00000012 18 // 直接打印出来了赋值的年纪 =&gt; 18 4个字节// 那么剩余的四个字节是否就是 ch1 和 ch2 呢(lldb) po 0x0000626125185// 打印不出来，这个时候我们想到 char 是占用一个字节，单独打印一半呢？？(lldb) po 0x006298(lldb) po 0x006197// 这个就很眼熟，我们恍然大悟，这不是 a 和 b 对应的 ASCII 码值么！a == 97, b = 98 从这里可以得出，在类的成员变量的内存大小分配的时候；系统会进行一次优化，将能进行对齐优化的成员变量放在一个段里面，节约内存空间，以空间换时间，加快 CPU 读取字节时候的偏移计算复杂度；而不是根据成员声明定义的顺序依次进行排布，这里就调整了顺序，然后直接最大化优化内存字节对齐。 2.2 对象 16 字节对齐2.2.1 抛出问题 这里我们看到通过class_getInstanceSize获取的内存大小8(默认属性 isa 的内存大小)；没有并没有按照之前alloc源码流程中的最少16的规则。 因为class_getInstanceSize方法没有走alloc流程中instanceSize方法的**if (size &lt; 16) size = 16**条件，这里直接调用了直接对齐alignedInstanceSize() -&gt; word_align(unalignedInstanceSize())返回的内存大小。 声明了几个属性之后发现就大于16了，因为 isa(8) + name(8) + age(4) + 补齐(4) + height(8) + hobby(8) = 5*8 = 40; 但是会发现 malloc_size 却不等于40，为48；这里就总结出 对象申请的内存大小 与 系统开辟的内存大小 不一致 2.2.2 跟踪 calloc 源码①系统开辟内存 - calloc 在objc源码中查看不了calloc源码的实现，需要在malloc源码中查看。 malloc源码：https://github.com/sunjinayushiwo/mallcoSource ②calloc =&gt; malloc_zone_calloc 这里发现是一个递归调用，跟断点会不知道递归的返回条件；然后这里直接打印 zone 的 calloc 成员，发现是一个函数default_zone_calloc; 全局搜搜函数名得到定义。 1234567static void *default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size){ zone = runtime_default_zone(); return zone-&gt;calloc(zone, num_items, size); // 递归调用} 发现又是一个递归调用，断点打印zone的calloc成员属性； ③得到nano_calloc方法 1234567891011121314151617181920212223static void *nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size){ size_t total_bytes; if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) { return NULL; } if (total_bytes &lt;= NANO_MAX_SIZE) { // 分析到走这个逻辑，才是内存开辟过程 void *p = _nano_malloc_check_clear(nanozone, total_bytes, 1); if (p) { return p; } else { // 失败的情况，不是我们要找的内存开辟计算，跳过 /* FALLTHROUGH to helper zone */ } } // 失败的情况，不是我们要找的内存开辟计算，跳过 malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone); return zone-&gt;calloc(zone, 1, total_bytes);} ④定位_nano_malloc_check_clear方法 得到计算系统开辟对象内存大小的具体方法segregated_size_to_fit，顾名思义：需要隔离填充的内存大小。 123456789101112131415161718192021#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey){ size_t k, slot_bytes; if (0 == size) { size = NANO_REGIME_QUANTA_SIZE; // Historical behavior } k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! // 上面的定义翻译出来是: slot_bytes = (size + 2^4-1) &gt;&gt; 4 &lt;&lt; 4; // &gt;&gt; 4 &lt;&lt; 4; 右移4位，然后左移4位，得到的就是16的倍数。即2^4对齐。 // 类似于之前介绍的8字节对齐; 所以这里是16字节对齐的算法； return slot_bytes;} 由这里16进制对齐的算法可以得出结论，40的类成员属性字节总数传递进来进行16字节对齐之后返回16*3 = 48字节。 三、总结 对象的属性是按照8字节进行对齐的 对象本身则是按照16字节进行对齐的 因为内存是连续的，通过 16 字节对齐规避了风险和容错，有效的防止了访问溢出 同时，也提高了寻址访问效率，也就是通常我们所说的空间换时间","link":"/2020/10/20/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"title":"01 - alloc &amp; init","text":"一、前言创建对象的例子： 二、如何探索？2.1 普通断点 + 跟踪调试 按住control + in 进入调试查看汇编调用信息；使用真机情况下能定位到 libobjc.A.dylib objc_alloc，所以是要探究的方法在 libobjc.A.dylib 这个库中。 2.2 符号断点设置 要探究alloc方法，所以我们添加一个alloc的符号断点，这时候会显示断到很多类的alloc方法，但是没有关系，因为我们断点了代码所在对象，所以我们直接调试就行；断点执行下一步，就能看到 libobjc.A.dylib + [NSObject alloc]，说明是调用了libobjc.A.dylib库中的NSObject 的 alloc 类方法。 2.3 汇编跟踪 Debug =&gt; Debug Workflow =&gt; Always Show Disassembly 开启汇跟踪设置。 可查看到代码[MRObject alloc]的汇编代码下一步是调用objc_alloc; 所以我们需要研究objc_alloc方法即为alloc的底层实现方法! 三、objc 源码 苹果开源源码地址 =&gt; opensource.apple.com/tarballs/ 搜索 objc 即可看到 objc 源码地址 当前 objc4-756.2 为最新版本! 我的 github 上传了objc4-756.2的源码：https://github.com/speam/OjbcSuorce.git 在objc源码中我们看到很多 old 和 new 的文件命名标识，这代表objc在迭代过程中过渡了两个版本，一个新版，一个旧版。 现在我们都是使用的新版本api，所以查看源码逻辑的时候只需要定位 objc2 或者 new标识的新版本~ 四、准备进行源码调试 前述方式不能直观的跟踪到底层的方法调用。 所以将objc源码集成到我们的调试工程中，通过断点跟踪才能一目了然。 如何集成objc源码 =&gt; iOS_objc4-756.2 最新源码编译调试 五、进行 objc 源码调试/查看/跟踪5.1 alloc =&gt; objc_rootAlloc入口： 5.2 callAlloc 首先看 __OBJC2__的分支，现在是使用的新版本；然后看第一个判断fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())，这里是判断该类是否有重写initWithZone；第二层判断 fastpath(cls-&gt;canAllocFast())，是否可以快速创建，这里会返回false，具体实现见下分析。 5.2.1 canAllocFast canAllocFast()最后会调 bits.canAllocFast() 跟踪bits.canAllocFast()中的canAllocFast 实现： 查看 FAST_ALLOC 宏定义 5.2.2 class_createInstance 打印obj的值，印证流程 5.3 init 六、alloc 流程图 七、lldb / gdb 命令调试 1.x/4gx obj:代表以十六进制打印obj的4段内存信息 2.p/t:代表打印二进制信息(还有p/o、p/d、p/x分别代表八进制、十进制和十六进制打印)","link":"/2020/10/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-alloc&init/"},{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"03 - isa原理","text":"一、前言 在arm64架构之前,isa仅仅是一个指针,保存着类对象(Class)或元类对象(Meta-Class)的内存地址 在arm64架构之后,苹果对isa进行了优化,变成了一个isa_t类型的联合体(union)结构,同时使用位域来存储更多的信息: 也就是说,我们之前熟知的OC对象的isa指针并不是直接指向类对象或者元类对象的内存地址,而是需要&amp; ISA_MASK通过位运算才能获取类对象或者元类对象的地址. 二、联合体位域1.位域位域是指信息在存储时，并不需要占用一个完整的字节， 而只需占一个或几个二进制位。这样一来不仅节省存储空间，还使处理更加简便。 2.位运算符 位运算符用来对二进制位进行操作 操作数只能为整型和字符型数据。 C语言中六种位运算符：&amp;按位与、|按位或、^按位异或、~非、&lt;&lt;左移和&gt;&gt;右移。 1)按位与&amp;有0出0,全1出1. A B &amp; 0 0 0 1 0 0 0 1 0 1 1 1 2)按位或 |有1出1,全0出0. A B I 0 0 0 1 0 1 0 1 1 1 1 1 3)按位异或^相同为0,不同为1. A B ^ 0 0 0 1 0 1 0 1 1 1 1 0 4)非 ~非运算即取反运算，在二进制中 1 变 0 ，0 变 1。例如110101进行非运算后为001010，即1010. 5)左移 &lt;&lt; 左移运算就是把&lt;&lt;左边的运算数的各二进位全部左移若干位，移动的位数即&lt;&lt;右边的数的数值。 高位丢弃，低位补0。 左移n位就是乘以2的n次方。例如：a&lt;&lt;4是指把a的各二进位向左移动4位。如原来a=00000011(十进制3)，左移4位后为00110000(十进制48)。 6)右移 &gt;&gt;右移运算就是把&gt;&gt;左边的运算数的各二进位全部右移若干位，&gt;&gt;右边的数指定移动的位数。例如：设 a=15，a&gt;&gt;2 表示把00001111右移为00000011(十进制3) 3.位运算符的运用1)取值 可以利用按位与 &amp;运算取出指定位的值 具体操作是想取出哪一位的值就将那一位置为1,其它位都为0,然后同原数据进行按位与计算,即可取出特定的位. 例: 0000 0011取出倒数第三位的值 123456// 想取出倒数第三位的值，就将倒数第三位的值置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0100 （掩码）------------ 0000 0000 // 得出按位与运算后的结果，即可拿到原数据中倒数第三位的值为0 上面的例子中,我们从0000 0011中取值,则有0000 0011被称之为源码.进行按位与操作设定的0000 0100称之为掩码. 例: 0000 0011取出后三位的值 123456// 想取出后三位的值，就将掩码后三位置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0111 （掩码）------------ 0000 0011 // 得出按位与运算后的结果，即可拿到原数据中后三位的值为011 2)设值 可以通过按位或 |或者按位与 &amp;运算符将某一位的值设为1或0. 要将某一位的值置为1的话，那么就将掩码中对应位的值设为1，掩码其它位为0，将源码与掩码进行按位或|操作即可. 例: 将0000 0011倒数第三位的值改为1 123456// 改变倒数第三位的值，就将掩码倒数第三位的值置为1，其它位为0，跟源码按位或运算 0000 0011| 0000 0100------------ 0000 0111 // 即可将源码中倒数第三位的值改为1 要将某一位的值置为0的话，那么就将掩码中对应位的值设为0，掩码其它位为1，将源码与掩码进行按位与&amp;操作即可. 例: 将0000 0011倒数第二位的值改为0 123456// 改变倒数第二位的值，就将掩码倒数第二位的值置为0，其它位为1，跟源码`按位与&amp;`运算 0000 0011| 1111 1101------------ 0000 0001 // 即可将源码中倒数第二位的值改为0 4.位运算的实际应用声明一个TCJCar类，类中有四个BOOL类型的属性,分别为front、back、left、right,通过这四个属性来判断这辆小车的行驶方向. 然后我们来查看一下这个TCJCar类对象所占据的内存大小: 我们看到,一个TCJCar类的对象占据16个字节.其中包括一个isa指针和四个BOOL类型的属性,8+1+1+1+1=12,根据内存对齐原则,所以一个TCJCar类的对象占16个字节. 我们知道,BOOL值只有两种情况:0或1，占据一个字节的内存空间.而一个字节的内存空间中又有8个二进制位，并且二进制同样只有0或1，那么我们完全可以使用1个二进制位来表示一个BOOL值。也就是说我们上面声明的四个BOOL值最终只使用4个二进制位就可以代替，这样就节省了内存空间。那我们如何实现呢？ 想要实现四个BOOL值存放在一个字节中，我们可以通过char类型的成员变量来实现。 char类型占一个字节内存空间，也就是8个二进制位.可以使用其中最后四个二进制位来存储4个BOOL值。 (当然不能把char类型写成属性,因为一旦写成属性,系统会自动帮我们添加成员变量,自动实现set和get方法) 123@interface TCJCar(){ char _frontBackLeftRight;} 如果我们赋值_frontBackLeftRight为1,即0b 0000 0001,只使用8个二进制位中的最后4个分别用0或者1来代表front、back、left、right的值.那么此时front、back、left、right的状态为: 结合我们上文讲的6种位运算符以及使用场景,我们可以分别声明front、back、left、right的掩码,来方便我们进行下一步的位运算取值和赋值: 1234#define TCJDirectionFrontMask 0b00001000 //此二进制数对应十进制数为 8#define TCJDirectionBackMask 0b00000100 //此二进制数对应十进制数为 4#define TCJDirectionLeftMask 0b00000010 //此二进制数对应十进制数为 2#define TCJDirectionRightMask 0b00000001 //此二进制数对应十进制数为 1 通过对位运算符的左移&lt;&lt;和右移&gt;&gt;的了解，我们可以将上面的代码优化成： 1234#define TCJDirectionFrontMask (1 &lt;&lt; 3)#define TCJDirectionBackMask (1 &lt;&lt; 2)#define TCJDirectionLeftMask (1 &lt;&lt; 1)#define TCJDirectionRightMask (1 &lt;&lt; 0) 自定义的set方法如下: 1234567891011121314151617181920212223242526272829303132- (void)setFront:(BOOL)front{ if (front) {// 如果需要将值置为1，将源码和掩码进行按位或运算 _frontBackLeftRight |= TCJDirectionFrontMask; } else {// 如果需要将值置为0 // 将源码和按位取反后的掩码进行按位与运算 _frontBackLeftRight &amp;= ~TCJDirectionFrontMask; }}- (void)setBack:(BOOL)back{ if (back) { _frontBackLeftRight |= TCJDirectionBackMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionBackMask; }}- (void)setLeft:(BOOL)left{ if (left) { _frontBackLeftRight |= TCJDirectionLeftMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionLeftMask; }}- (void)setRight:(BOOL)right{ if (right) { _frontBackLeftRight |= TCJDirectionRightMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionRightMask; }} 自定义的get方法如下: 12345678910111213141516- (BOOL)isFront{ return !!(_frontBackLeftRight &amp; TCJDirectionFrontMask);}- (BOOL)isBack{ return !!(_frontBackLeftRight &amp; TCJDirectionBackMask);}- (BOOL)isLeft{ return !!(_frontBackLeftRight &amp; TCJDirectionLeftMask);}- (BOOL)isRight{ return !!(_frontBackLeftRight &amp; TCJDirectionRightMask);} 此处需要注意的是，代码中!为逻辑运算符非，因为_frontBackLeftRight &amp; TCJDirectionFrontMask代码执行后，返回的肯定是一个整型数，如当front为YES时，说明二进制数为0b 0000 1000，对应的十进制数为8，那么进行一次逻辑非运算后，!(8)的值为0，对0再进行一次逻辑非运算!(0)，结果就成了1，那么正好跟front为YES对应.所以此处进行两次逻辑非运算，!!. 当然,还要实现初始化方法: 12345678- (instancetype)init{ self = [super init]; if (self) { _frontBackLeftRight = 0b00001000; } return self;} 通过测试验证,我们完成了取值和赋值: 5.使用结构体位域优化代码 我们在上文讲到了位域的概念,那么我们就可以使用结构体位域来优化一下我们的代码.这样就不用再额外声明上面代码中的掩码部分了. 位域声明格式是位域名: 位域长度. 在使用位域的过程中需要注意以下几点: 如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域. 位域的长度不能大于数据类型本身的长度，比如int类型就不能超过32位二进位. 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的. 使用位域优化后的代码: 来测试看一下是否正确,这次我们将front设为YES、back设为NO、left设为NO、right设为YES: 依旧能完成赋值和取值. 但是代码这样优化后我们去掉了掩码和初始化的代码,可读性很差,我们继续使用联合体进行优化: 6.使用联合体优化代码我们可以使用比较高效的位运算来进行赋值和取值，使用union联合体来对数据进行存储。这样不仅可以增加读取效率，还可以增强代码可读性. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#import &quot;TCJCar.h&quot;//#define TCJDirectionFrontMask 0b00001000 //此二进制数对应十进制数为 8//#define TCJDirectionBackMask 0b00000100 //此二进制数对应十进制数为 4//#define TCJDirectionLeftMask 0b00000010 //此二进制数对应十进制数为 2//#define TCJDirectionRightMask 0b00000001 //此二进制数对应十进制数为 1#define TCJDirectionFrontMask (1 &lt;&lt; 3)#define TCJDirectionBackMask (1 &lt;&lt; 2)#define TCJDirectionLeftMask (1 &lt;&lt; 1)#define TCJDirectionRightMask (1 &lt;&lt; 0)@interface TCJCar(){ union{ char bits; // 结构体仅仅是为了增强代码可读性 struct { char front : 1; char back : 1; char left : 1; char right : 1; }; }_frontBackLeftRight;}@end@implementation TCJCar- (instancetype)init{ self = [super init]; if (self) { _frontBackLeftRight.bits = 0b00001000; } return self;}- (void)setFront:(BOOL)front{ if (front) { _frontBackLeftRight.bits |= TCJDirectionFrontMask; } else { _frontBackLeftRight.bits &amp;= ~TCJDirectionFrontMask; }}- (BOOL)isFront{ return !!(_frontBackLeftRight.bits &amp; TCJDirectionFrontMask);}- (void)setBack:(BOOL)back{ if (back) { _frontBackLeftRight.bits |= TCJDirectionBackMask; } else { _frontBackLeftRight.bits &amp;= ~TCJDirectionBackMask; }}- (BOOL)isBack{ return !!(_frontBackLeftRight.bits &amp; TCJDirectionBackMask);}- (void)setLeft:(BOOL)left{ if (left) { _frontBackLeftRight.bits |= TCJDirectionLeftMask; } else { _frontBackLeftRight.bits &amp;= ~TCJDirectionLeftMask; }}- (BOOL)isLeft{ return !!(_frontBackLeftRight.bits &amp; TCJDirectionLeftMask);}- (void)setRight:(BOOL)right{ if (right) { _frontBackLeftRight.bits |= TCJDirectionRightMask; } else { _frontBackLeftRight.bits &amp;= ~TCJDirectionRightMask; }}- (BOOL)isRight{ return !!(_frontBackLeftRight.bits &amp; TCJDirectionRightMask);}@end 来我们测试看一下是否正确,这次我们依旧将front设为YES、back设为NO、left设为NO、right设为YES: 通过结果我们看到依旧能完成赋值和取值. 其中_frontBackLeftRight联合体只占用一个字节,因为结构体中front、back、left、right都只占一位二进制空间,所以结构体只占一个字节,而char类型的bits也只占一个字节.他们都在联合体中,因此共用一个字节的内存即可. 而且我们在set、get方法中的赋值和取值通过使用掩码进行位运算来增加效率，整体逻辑也就很清晰了。但是如果我们在日常开发中这样写代码的话，很可能会被同事打死。虽然代码已经很清晰了，但是整体阅读起来还是很吃力的。我们在这里学习了位运算以及联合体这些知识,更多的是为了方便我们阅读OC底层的代码。下面我们来回到本文主题，查看一下isa_t联合体的源码。 三、isa_t 联合体 通过源码我们发现isa它是一个联合体,占8个字节,它的特性就是共用内存,或者说是互斥,比如说如果cls赋值了就不在对bits进行赋值. 在isa_t联合体内使用宏ISA_BITFIELD定义了位域,我们进入位域内查看源码: 内部分别定义了arm64位架构和x86_64架构的掩码和位域.我们只分析arm64为架构下的部分内容(真机环境下). 可以清楚的看到ISA_BITFIELD位域的内容以及掩码ISA_MASK的值:0x0000000ffffffff8ULL. 我们重点看一下uintptr_t shiftcls : 33;,在shiftcls中存储着类对象和元类对象的内存地址信息,我们上文讲到,对象的isa指针需要同ISA_MASK经过一次按位与运算才能得出真正的类对象地址.那么我们将ISA_MASK的值0x0000000ffffffff8ULL转化为二进制数分析一下: 从图中可以看到ISA_MASK的值转化为二进制中有33位都为1，上文讲到按位与运算是可以取出这33位中的值。那么就说明同ISA_MASK进行按位与运算就可以取出类对象和元类对象的内存地址信息. 我们继续分析一下结构体位域中其他的内容代表的含义: 在不同的架构下面位域所占的内存大小不同，区别主要在于shiftcls(arm64 真机架构下占33位，x86 模拟器下占44位) 和 extra_rc(arm64 真机架构下占19位，x86 模拟器下占11位);；但是不管是什么架构下所占的整个大小都是64位 == 8字节。 本文重要总结 arm64架构之后，isa指针不单单只存储了类对象和元类对象的内存地址，而是使用联合体的方式存储了更多信息。占8字节 其中shiftcls存储了类对象和元类对象的内存地址，需要同ISA_MASK进行按位与 &amp;运算才可以取出其内存地址值. 四、isa关联对象与类 isa是对象的第一个属性，因为这一属性是来自于继承，要早于对象的成员变量、属性列表、方法列表、所遵循的协议列表. 问题：经过calloc申请内存的时候，isa这个指针是怎么和类进行关联的？ 从这里开始定位：obj-&gt;initInstanceIsa(cls, hasCxxDtor)，然后找到initIsa(cls, true, hasCxxDtor)这个方法： 12345678910111213141516171819202122232425262728293031323334353637inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { assert(!isTaggedPointer()); if (!nonpointer) { // 未优化过的指针,存储着`Class`、`Meta-Class`对象的内存地址信息 isa.cls = cls; } else { // 优化过的指针，一般都走这里 assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3; // 在这里去存储`Class`、`Meta-Class`对象的内存地址信息#endif // This write must be performed in a single store in some cases // (for example when realizing a class because other threads // may simultaneously try to use the class). // fixme use atomics here to guarantee single-store and to // guarantee memory order w.r.t. the class index table // ...but not too atomic because we don't want to hurt instantiation isa = newisa; }} 上面第一层判断是isTaggedPointer的断言,这会在后续文章中重点分析 接下来是nonpointer的判断，因为nonpointer优化，它是和普通结构不一样的！通过上文我们知道内存优化的isa_t结构：它采用的是联合体和位域的搭配.(目前我们的类都是nonpointer了) 如果是非nonpointer,代表普通的指针,存储着Class、Meta-Class对象的内存地址信息 如果是nonpointer,则会进行一系列的初始化操作。其中的newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;中的shiftcls存储着Class、Meta-Class对象的内存地址信息。验证:【可不看】 来我们来对上面LLDB相关的指令进行一波解析: 1234567891.`x/4gx obj`:代表打印`obj`的4段内存信息 2.`p/t`:代表打印二进制信息(还有`p/o`、`p/d`、`p/x`分别代表八进制、十进制和十六进制打印) 3.`p/t (uintptr_t)obj.class`将类信息进行二进制打印得到:`$3` 4.对第一个属性`isa`进行二进制打印`p/t 0x001d8001000013f1`得到:`$1` 5.因为此时我们是在`x86_64`环境下进行打印的,通过上文我们知道在`x86_64`环境下`isa`的`ISA_BITFIELD`位域结构中:前`3`位是`nonpointer`，`has_assoc`，`has_cxx_dtor`，中间`44`位是`shiftcls`，后面`17`位是剩余的内容，同时因为`iOS`是小端模式，那么我们就需要去掉右边的`3`位和左边的`17`位，所以就会采用`$1&gt;&gt;3&lt;&lt;3`然后`$4&lt;&lt;17&gt;&gt;17`的操作了. 通过这个测试，我们就知道了isa实现了对象与类之间的关联. 在上文中我们提得到OC对象的isa指针并不是直接指向类对象或者元类对象的内存地址，而是需要&amp; ISA_MASK通过位运算才能获取类对象或者元类对象的地址。我们也来验证一波: 五、对象和类对象 对象 开辟内存创建的实例对象 开发者根据类实例化出的结果，alloc所开辟的内存空间 对象可以创建多个 类对象 一个类结构的对象 代码定义的类，系统创建的对象 内存只有一份 1234567891011121314151617181920212223242526// 创建两个对象，打印内存地址以及类地址MRObject *obj1 = [MRObject alloc];MRObject *obj2 = [MRObject alloc];// lldb 调试打印(lldb) x/4gx obj1 // 打印obj1的内存段 0x001d800100001269 isa0x101a282c0: 0x001d800100001269 0x00000000000000000x101a282d0: 0x0000000080080000 0x00007fff916afa68(lldb) x/4gx obj2 // 打印obj2的内存段 0x001d800100001269 isa0x101a20500: 0x001d800100001269 0x00000000000000000x101a20510: 0x636f72504b575b2d 0x70756f7247737365// 以上两个结果可以看出两个对象的地址不同，但是isa地址是相同的，而isa是关联类的 =&gt; object_getClass 中得出 isa &amp; mask =&gt; 类对象的地址(lldb) p/x MRObject.class // 打印MRObject类对象的地址 0x0000000100001268(Class) $4 = 0x0000000100001268 MRObject// 通过上面的isa &amp; mask(_x86_ = 0x00007ffffffffff8) 得到 0x0000000100001268 和类地址相同(lldb) p/x 0x001d800100001269 &amp; 0x00007ffffffffff8(long) $5 = 0x0000000100001268// 类地址打印的结果即为MRObject类，所以类对象是只有一份的！(lldb) po 0x0000000100001268MRObject 六、isa 走向、类继承6.1 类、元类、根源类 类 class 代码构造的类，系统创建的对象 元类 meta_class 类的isa指向的虚拟类，系统创建的；在编译阶段，发现存在类对象，为了方便存储类方法信息等，创建的该类的元类对象 根元类 root_meta_class NSObject 的元类，由于 NSObject 是所有类的根类 6.2 isa 走向图苹果官方isa走位图👇👇 6.3 调试验证 MRObject 继承自 NSObject 123456789101112131415161718192021222324252627void testMRObject() { // MRObject实例对象 NSObject *object1 = [MRObject alloc]; // MRObject类 Class class = object_getClass(object1); // MRObject元类 Class metaClass = object_getClass(class); // MRObject根元类 Class rootMetaClass = object_getClass(metaClass); // MRObject根根元类 Class rootRootMetaClass = object_getClass(rootMetaClass); NSLog(@&quot;MRObject isa -----------------\\n%p 实例对象\\n%p 类\\n%p 元类\\n%p 根元类\\n%p 根根元类&quot;,object1,class,metaClass,rootMetaClass,rootRootMetaClass);}void testNSObject() { // NSObject实例对象 NSObject *object1 = [NSObject alloc]; // NSObject类 Class class = object_getClass(object1); // NSObject元类 Class metaClass = object_getClass(class); // NSObject根元类 Class rootMetaClass = object_getClass(metaClass); // NSObject根根元类 Class rootRootMetaClass = object_getClass(rootMetaClass); NSLog(@&quot;NSObject isa -----------------\\n%p 实例对象\\n%p 类\\n%p 元类\\n%p 根元类\\n%p 根根元类&quot;,object1,class,metaClass,rootMetaClass,rootRootMetaClass);} NSLog 1234567891011121314NSObject isa -----------------0x10183e7d0 实例对象0x100b35140 类0x100b350f0 元类0x100b350f0 根元类 [NSObject的元类也是根元类]0x100b350f0 根根元类 == 根元类的isa [说明根元类isa指向自己]MRObject isa -----------------0x10183e3b0 实例对象0x100001298 类0x100001270 元类0x100b350f0 根元类 == NSObject元类 [说明根类是NSObject]0x100b350f0 根根元类 6.4 总结 继承 子类 -&gt; 父类 -&gt; 根类(NSObject) 子元类 -&gt; 父元类 -&gt; 根元类(NSObject的元类) !!! 根元类 -&gt; 根类 (NSObject) 形成闭环 isa 指向 实例对象 isa -&gt; 类对象(xxxClass) 类对象(xxxClass) isa -&gt; 元类对象(xxxmetaClass) 元类对象(xxxmetaClass) isa -&gt; 根元类对象(NSObject_meta_Class) 根元类对象(NSObject_meta_Class) isa -&gt; 根元类对象(他自己)(形成闭环)","link":"/2020/10/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03-isa%E5%8E%9F%E7%90%86/"},{"title":"04 - 类的本质","text":"一、类的基本概念1.1 Class 的结构 Class在源码里的真正类型为objc_class的结构体。 先查看源码——在Xcode按下Shift+Command+O，选择objc-runtime-new.h，搜索objc_class，可以得知，Class底层编译如下： 可知类结构如下： A. //Class ISA 继承自父类 objc_object 的 isa ，指向类的指针不需显示（内存占8位），这里它返回一个nonpointer的指针，相关源码如下： 1234/// Represents an instance of a class. struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; B. Class superclass; 指向本类的父类（内存占8位） C. cache_t cache; 存储指针和vtable，加速方法调用（内存占16位） D. class_data_bits_t bits; 存储类的方法、属性、遵循的协议等信息的地方（内存占8位） E. 其他方法/函数 – 不占内存 为何cache_t cache 这个变量占位位16，而不是8？ 原因是因为这里的cache_t是结构体，其占内存为根据内部属性结构而定，为防止溢出，给予16位字节，而不是指针所需的8位。 点开cache_t 的内部结构：我们来看看属性： bucket_t， 结构体，占8位字节 mask_t，点开后具体实现为如下：typedef uint32_t mask_t; 为整型，占4个字节 又一个 mask_t，占4个字节共计8+4+4 = 16个字节 1.2 objc_class 的继承在底层实现里，objc_class 继承自objc_object结构体 1234/// Represents an instance of a class.struct objc_object { Class _Nonnull isa OBJC_ISA_AVAILABILITY;}; 1.3 Class 的继承万物皆对象 - Class 继承自NSObject 123456@interface NSObject &lt;NSObject&gt; {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop} 二、类的属性与成员变量2.1 属性的存储根据前文我们知道了Class结构中中class_data_bits_t bits是用来存储类的方法、属性、遵循的协议等信息的地方，下面探寻类里面的属性是怎么保存的。 2.1.1 分析过程【可不看】我们在代码里生成一个类，分别有成员变量hobby，以及属性nickName，代码如下: 12345@interface Person : NSObject{ NSString *hobby;}@property (nonatomic, copy) NSString *nickName; main.m 中 123456789int main(int argc, const char * argv[]) { @autoreleasepool { LGPerson *person = [LGPerson alloc]; Class pClass = object_getClass(person); NSLog(@&quot;%@ -- %p&quot;, person, pClass); } return 0;} 然后打印得到的类pClass，通过x/4gx 获取类结构如下： 123(lldb) x/4gx pClass0x1000023d0: 0x001d8001000023a9 0x0000000100b371400x1000023e0: 0x00000001003da280 0x0000000000000000 观察结果得知0x1000023d0 位pClass在内存中的首地址，根据内存偏移原则，加上16+8+8共32位，即可得到bits的结构。 0x1000023d0，偏移32位，得到0x1000023f0。注意，这里要用p打印指针，而非打印值用的po 12(lldb) p 0x1000023f04294976496 oh NO！得到的是具体的值，这里需要强转一下： 12(lldb) p (class_data_bits_t *)0x1000023f0(class_data_bits_t *) $3 = 0x00000001000023f0 ​ 得到$3 的值，并不是我们想要的结构，留意到objc_class里的方法 data() 方法: 123456789struct objc_class : objc_object { // Class ISA; // 8 Class superclass; // 8 cache_t cache; // 16，不是8 // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } data() 返回是class_rw_t，点进去看看， 123456789101112131415struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; 留意到里面有 methods、properties、protocols等，原来这里等值便是类的相关属性方法等等结构。 现在对$3 执行data() 方法: 12(lldb) p $3-&gt;data()(class_rw_t *) $5 = 0x0000000000000000 对得到的$5 进行值打印: 123456789101112131415161718192021222324252627282930313233(lldb) p *$5(class_rw_t) $5 = { flags = 2148139008 version = 0 ro = 0x0000000100002308 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000} 如上所示，$5 内结构一目了然，方法，属性，协议都显示了。继续获取属性值: 123456789(lldb) p $5.properties(property_array_t) $7 = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x00000001000022f0 arrayAndFlag = 4294976240 } }} 得到一个二维数组的$7，观察属性列表的类型为property_array_t，继承自list_array_tt，内部拥有 123(lldb) p $7.list(property_list_t *) $8 = 0x00000001000022f0 再次对$8 进行* 取值，得到如下结果： 12345678(lldb) p *$8(property_list_t) $9 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 1 first = (name = &quot;nickName&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,C,N,V_nickName&quot;) }} 从结果可以看出，我们的属性，就保存在properties 里中。 2.2.2 结论从结果可以看出，我们的属性，就保存在properties 里中。 12345678(lldb) p *$8(property_list_t) $9 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 1 first = (name = &quot;nickName&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,C,N,V_nickName&quot;) }} 2.2 成员变量的存储上面分析了属性的存储，但是我们没有看到成员变量 hobby,我们在properties 属性里，没有看到它，到底在哪里呢?下面我们继续查找。 2.2.1 分析过程【可不看】既然不在properties 里，那尝试一下在$5 的 ro 里进行取值 12(lldb) p $5.ro(const class_ro_t *) $10 = 0x0000000100002308 得到class_ro_t 类型的结构体，继续对他取值 1234567891011121314(lldb) p *$10(const class_ro_t) $11 = { flags = 388 instanceStart = 8 instanceSize = 24 reserved = 0 ivarLayout = 0x0000000100001f8a &quot;\\x02&quot; name = 0x0000000100001f81 &quot;LGPerson&quot; baseMethodList = 0x0000000100002240 baseProtocols = 0x0000000000000000 ivars = 0x00000001000022a8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x00000001000022f0} ​ 值这里可以看到ivars，就是我们需要的变量列表，打印一下： 12(lldb) p $11.ivars(const ivar_list_t *const) $12 = 0x00000001000022a8 继续对 ivar_list_t 类型的$12 取值: 12345678910111213141516171819202122(lldb) p *$12(const ivar_list_t) $13 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = { entsizeAndFlags = 32 count = 2 first = { offset = 0x0000000100002378 name = 0x0000000100001e64 &quot;hobby&quot; type = 0x0000000100001fa7 &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8 } }}(lldb) p $.first(const ivar_t) $13 = { offset = 0x0000000100002378 name = 0x0000000100001e64 &quot;hobby&quot; type = 0x0000000100001fa7 &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8} 可以看到成员变量存在类的 ivars 属性里 2.2.2 结论可以看到成员变量存在类的 ivars 属性里 三、类中的方法3.1 对象方法3.1.1 分析过程【可不看】我们继续对类进行代码编辑，对Person类添加实例方法和类方法 12- (void)sayHello; // 实例方法+ (void)sayHappy; // 类方法 还是对类结构$5 进行解析，这次我们打印它的 methods 属性 123456789(lldb) p $5.methods(method_array_t) $14 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002240 arrayAndFlag = 4294976064 } }} 得到的是method_array_t 类型的$14, 是个数组类型，继续打印: 12(lldb) p $14.list(method_list_t *) $15 = 0x0000000100002240 123456789101112(lldb) p *$15(method_list_t) $16 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 4 first = { name = &quot;sayHello&quot; types = 0x0000000100001f8c &quot;v16@0:8&quot; imp = 0x0000000100001b90 (LGTest`-[LGPerson sayHello] at LGPerson.m:13) } }} 可见，对象方法sayHello ，存储在类的methods属性里 3.1.2 结论对象方法，存储在类的methods属性里 3.2 类的类方法存储3.2.1 分析过程【可不看】类方法在上述的过程中没有看到，那么它会在哪里呢? 为了找到它，我们重新回到最初的pClass 123(lldb) x/4gx pClass0x1000023b0: 0x001d800100002389 0x0000000100b371400x1000023c0: 0x00000001003da280 0x0000000000000000 得到isa值为0x001d800100002389，这时，唤出它的掩码 ISA_MASK 来获取它的元类 12(lldb) p/x 0x001d800100002389 &amp; 0x0000000ffffffff8(long) $1 = 0x0000000100002388 继续对元类**$1**的结构进行解析： 123(lldb) x/4gx 0x00000001000023880x100002388: 0x001d800100b370f1 0x0000000100b370f00x100002398: 0x0000000100f946c0 0x0000000100000003 可知0x100002388是这个元类的地址，根据上文提到的内存便宜，我们继续加上2个16进制位，得到0x1000023a8，p一下： 12(lldb) p (class_data_bits_t *)$2(class_data_bits_t *) $3 = 0x00000001000023a8 继续执行上文实例方法类似的方案，执行data() — 取值 – 获取methods 的思路，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(lldb) p $3-&gt;data()(class_rw_t *) $4 = 0x0000000100f94620(lldb) p *$4(class_rw_t) $5 = { flags = 2685075456 version = 7 ro = 0x00000001000021f8 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x0000000000000000 arrayAndFlag = 0 } } } firstSubclass = nil nextSiblingClass = 0x00007fff942e6990 demangledName = 0x0000000000000000}(lldb) p $5.methods(method_array_t) $10 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x00000001000021d8 arrayAndFlag = 4294975960 } }}(lldb) p $10.list(method_list_t *) $11 = 0x00000001000021d8(lldb) p *$11(method_list_t) $12 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 1 first = { name = &quot;sayHappy&quot; types = 0x0000000100001f8c &quot;v16@0:8&quot; imp = 0x0000000100001bc0 (LGTest`+[LGPerson sayHappy] at LGPerson.m:17) } }}(lldb) 可见，类方法sayHappy 方法，存储在类的元类 methods 属性里 3.2.2 结论类方法存储在类的元类的methods属性里 四、总结 类的本质上一个类型为objc_class的结构体，包含有isa、父类、属性、成员变量及方法列表等 属性存在类的 properties 结构体中 成员变量存在类的 ivars 结构体中 对象方法，存在类的 methods 结构体中 类方法，存在元类 的 methods 中 如下图示：","link":"/2020/10/22/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E7%B1%BB%E7%9A%84%E6%9C%AC%E8%B4%A8/"}],"tags":[],"categories":[{"name":"iOS·底层原理","slug":"iOS·底层原理","link":"/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"}]}