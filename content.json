{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"01-对象的创建","text":"一、前言看一个简单的例子： 思考alloc和init底层到底做了什么？带着这些问题，我们从源码的角度探索。 二、分析 alloc 源码1.0 准备工作1.从 苹果官方开源代码列表 找到 objc4源码。 苹果于 2006 年发布 Objective-C 2.0 ，重写了 Objective-C 1.0 中类与对象的定义，命名为 objc4 2.下载到本地后，需要对工程进行一番编译调试，具体步骤可参考 Cooci 的博客 iOS_objc4-756.2 最新源码编译调试。 3.编译通过后，就可以新建个 target 调试了 我 Github 上的源码：https://github.com/speam/OjbcSuorce.git 4.常用的代码跟踪方式： Xcode 菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly control + step into 下符号断点，如alloc 1.1 objc_alloc—alloc的真正入口给[Person alloc]加断点 此时，在Xcode的菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly，得到汇编代码，发现调用了objc_alloc: 定位到objc_alloc()，发现内部调用callAlloc() 1.2 callAlloc分析objc_alloc()内部调用callAlloc()，其源码为： 123456789101112131415161718192021222324252627282930313233// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){ if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls-&gt;canAllocFast())) { // 永远不走这里 // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; } else { // 永远走这里 // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } }#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];} 对callAlloc()的分析如下： ①__OBJC2__在 OC2.0 以后为1，源码： 12345678// Define __OBJC2__ for the benefit of our asm files.#ifndef __OBJC2__# if TARGET_OS_OSX &amp;&amp; !TARGET_OS_IOSMAC &amp;&amp; __i386__ // old ABI# else# define __OBJC2__ 1 // 总之都是1# endif#endif ②slowpath(bool)与fastpath(bool)：常用于if-else，可以优化判断的速度。 12345// fastpath(x)：表示返回值为x，且x很有可能为1#define fastpath(x) (__builtin_expect(bool(x), 1))// slowpath(x)：表示返回值为x，且x很有可能为0#define slowpath(x) (__builtin_expect(bool(x), 0)) ③hasCustomAWZ()：意思是hasCustomAllocWithZone，即是否有重写类的+allocWithZone:方法，但是它的值并不能简单地这么判断！先看源码 123bool hasCustomAWZ() { return ! bits.hasDefaultAWZ();} 注意：hasCustomAWZ()的值问题【非常重要，设置初始化顺序，很多博客中根本没有提到！】 类的+initialize方法主要用于初始化静态变量。在其执行之前，hasDefaultAWZ()值为false，即hasCustomAWZ()为true；其执行之后，如果当前类重写了+allocWithZone:方法，hasCustomAWZ()为true，否则为false（一般情况下不会重写，即hasCustomAWZ为false）。 类的+initialize方法会在第一次初始化该类之前调用。当调用[cls alloc]时，会触发objc_msgSend，然后会执行+initialize:。（感兴趣的同学可以分别打印+alloc和+initialize:方法加以验证） 因此，当类第一次来到callAlloc()时，最终会执行[cls alloc]。 ④canAllocFast()源码如下： 1234bool canAllocFast() { assert(!isFuture()); return bits.canAllocFast();} 再往底层找bits.canAllocFast()，发现关键宏FAST_ALLOC 1234567891011#if FAST_ALLOC ... bool canAllocFast() { return bits &amp; FAST_ALLOC; }#else ... bool canAllocFast() { return false; }#endif 继续深入，来到了FAST_ALLOC宏定义之处 123456789#if !__LP64__ // 当前操作系统不是64位...#elif 1 // 当前操作系统是64位...#else ...#define FAST_ALLOC (1UL&lt;&lt;2) // 找到了...#endif 从上面宏代码可以得出这样的结论，即无论当前操作系统是不是64位，都没有定义FAST_ALLOC，也就是说，canAllocFast()永远是false! 因此，如果hasCustomAWZ()为false时，会直接去到class_createInstance()。 1.3 alloc-&gt;_objc_rootAlloc-&gt;callAlloc-&gt;class_createInstance通过对hasCustomAWZ()的分析，我们知道类的第一次初始化最终是走到callAlloc的最后，即return [cls alloc]; ①由于执行了[cls alloc]，这次真的来到alloc()方法了 123+ (id)alloc { return _objc_rootAlloc(self);} ②接着是_objc_rootAlloc() 1234567// Base class implementation of +alloc. cls is not nil.// Calls [cls allocWithZone:nil].id_objc_rootAlloc(Class cls){ return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); // 注意这里的三个参数} ③再次来到callAlloc，此时hasCustomAWZ()的值取决于当前类是否重写了+allocWithZone:方法。 由于Person类没有重写，fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())为true，而canAllocFast()永远为false。 因此，接下来会走到class_createInstance()，其源码如下： 12345id class_createInstance(Class cls, size_t extraBytes){ return _class_createInstanceFromZone(cls, extraBytes, nil);} 1.4 _class_createInstanceFromZone顾名思义，这是要创建对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 对_class_createInstanceFromZone()的分析如下： ①cls-&gt;instanceSize(extraBytes)计算内存，此时的extraBytes是0，其源码是 1234567891011121314151617181920212223242526272829303132// 1.size_t instanceSize(size_t extraBytes) { size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;}// 2.uint32_t alignedInstanceSize() { return word_align(unalignedInstanceSize());}// 3. 字节对齐static inline uint32_t word_align(uint32_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}static inline size_t word_align(size_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}// 4.#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif 可见，WORD_MASK在64位系统下是7，否则是3，word_align()方法就是进行字节对齐的。 字节对齐算法：(x + WORD_MASK) &amp; ~WORD_MASK 12345678910111213141516假如： x = 9，已知 WORD_MASK = 7 x + WORD_MASK = 9 + 7 = 16 WORD_MASK 二进制 ：0000 0111 = 7 （4+2+1） ~WORD_MASK 二进制 : 1111 1000 16的二进制为 : 0001 0000 0001 0000 &amp; 1111 1000--------------- 0001 0000 = 16所以字节对齐后返回16 也就是8的倍数对齐，即8字节对齐 因此，word_align()在64位系统下是8字节对齐，否则是4字节对齐。 同时，instanceSize()函数又对内存大小又进行了最小16字节的限制。 ②canAllocNonpointer()是对isa的类型的区分，如果一个类使用isa_t类型的isa的话就返回true，我们不用太关心，OC 2.0以上基本上返回的都是true，所以fast就是true；而在__OBJC2__中，zone会被忽略，所以!zone也是true； 综上，接着就是calloc()和initInstanceIsa()。 ③size_t size = cls-&gt;instanceSize(extraBytes);这一步得到了计算后的size，传到calloc(1, size)中进行分配内存。 ④calloc()的底层源码是在苹果开源的libmalloc源码中(我Github中也准备了)，经过断点跟踪(中间过程比较复杂，略过先)，发现calloc()分配的内存大小受segregated_size_to_fit()影响，看下面源码： 123456789101112131415161718192021static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey) // 这里的size就是calloc(1, size)中传过来的{ size_t k, slot_bytes; if (0 == size) { // Historical behavior size = NANO_REGIME_QUANTA_SIZE; } // round up and shift for number of quanta k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // Zero-based! *pKey = k - 1; return slot_bytes;}#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16 从代码可以看出，slot_bytes等于(size + 16-1) &gt;&gt; 4 &lt;&lt; 4，是16字节对齐，所以就是将计算得到的size进行一次16字节对齐，因此calloc()分配的内存大小必然是16字节的整数倍，因此为对象分配的内存空间一定是16字节对齐的。 ⑤initInstanceIsa()就是初始化isa，并且关联cls。 从上面的代码可以看出，_class_createInstanceFromZone()做了很多事情，并且最终确实创建了对象，几乎干了所有事情，那么，init又到底做了什么呢？ 三、init和new1. init1234567891011- (id)init { return _objc_rootInit(self);}id_objc_rootInit(id obj){ // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;} 非常简单，init仅仅是将alloc创建的对象返回。是一种工厂设计方案，方便子类重写。 2. new我们再看看new 123+ (id)new { return [callAlloc(self, false/*checkNil*/) init];} 很明显，new相当于alloc+init。 四、总结关于alloc、init以及new的源码分析就到这了。在alloc的过程中，callAlloc和_class_createInstanceFromZone这两个函数是重点。 以上源码流程分析，是建立在objc4-756.2源码的基础上的，756.2是目前最新的版本。 下面用流程图总结一下alloc创建对象的过程：（这是我看过的博客中，最准确的图） 五、源码我的 malloc 源码 我的 libobjc 源码 苹果官方 objc4 源码 参考红酒牛排 https://juejin.im/post/6844904038467633160#heading-15","link":"/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"title":"URL编码和解码","text":"一、URL含义1.1 URL定义URL 与 URI URL：统一资源定位符 URI：统一资源标识符 URI结构 1234567foo://example.com:8042/over/there?name=ferret#nose \\_/ \\______________/ \\________/\\_________/ \\__/ | | | | | scheme authority path query fragment 1.2 URL字符编码表1、URL 编码 - 从 %00 到 %ff 2、HTML特殊字符编码对照表 二、URL 编码2.1 为什么要编码推荐阅读：字符编码：ASCII、Unicode 和 UTF-8 的区别 世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，所以必须要统一字符编码。 Unicode规定了符号唯一的二进制代码值。(UTF-8是一种 Unicode 的实现方式。 ) 如 中 字: Unicode码值： \\u4e2d URL编码（UTF-8）： %e4%b8%ad 2.2 URL编码规则使用%加上两位的字符0123456789ABCDEF代表一个字节的十六进制形式。 2.3 URL不需要编码的字符1、英文字母（a-z A-Z） 2、数字（0-9） 3、 - _ . ~ 4个特殊字符 4、所有保留字符，RFC3986中指定了以下字符为保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ] 5、编码标记符号 % 2.4 URL需要编码的字符非URL定义的字符如中文字符、希腊文字符，拉丁文字符等。 会引起歧义的保留字符URL 拼接参数或路径设置时，拼接的普通字符串中含有保留字符，会引起歧义的情况。URL 参数字符串中使用 key=value 这样的键值对形式来传参，键值对之间以 &amp; 符号分隔，如宝洁公司的简称为P&amp;G，假设需要当做参数去传递，name=P&amp;G&amp;t=1450591802326，因为参数中多了一个&amp;势必会造成接收 URL 的服务器解析错误，因此必须将引起歧义的 &amp; 符号进行转义编码。 部分保留字符及其URL编码 字符 用法描述 编码 + 表示空格（在URL中不能使用空格） %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的URL和参数 %3F # 表示书签或锚点 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定的参数的值 %3D % 百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 %25 如果需要在URL中用到特殊字符或中文字符，需要将这些特殊字符换成相应的十六进制的值。 三、iOS端URL具体编码处理3.1 URL编码和解码是成对出现的3.2 URL 拆解和编码 demo我们看一个常见的接口请求示例： 字符串 说明 :// 协议符号 / 分隔目录和子目录 测试 代表需要编译处理的路径 ？ 分隔实际的URL和参数 &amp; URL中指定的参数间的分隔符 = URL中指定的参数的值 搜&amp;索 搜索词含有中文，含有保留字段，需要编译 &amp;times 是key的一部分，不应该被编译，若多一次编译，会编译为 x 绿色字体是保留字符，都有特殊的含义，是不应该是被编码的。 红色字体必须要要编译的部分。 黄色背景的字符串，不应该被编译。 若以上操作不正确，会影响整个URL的解析。 URL 的拼接过程 1、先拼接实际的请求地址 https://www.baidu.com/s/测@试? 2、再拼接参数字符串 wd=搜&amp;索&amp;timestamp=32424242423 3、将1、2合并凭借成一个网址字符串。 4、将网址字符串转为NSURL 实例。 URL 的拆解和编码过程 因 测@试 含有中文和保留字符@，需要在步骤1之前，先将 测@试 编码为 %e6%b5%8b%40%e8%af%95 ，再拼接到https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95? 因 搜&amp;索 含有中文和保留字符&amp; ,&amp; 会影响参数解析。需要先搜&amp;索 编码为 %e6%90%9c%26%e7%b4%a2 ，再拼接为wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 经过以上步骤，现在的 URL 为： https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95?wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 已经编码完成了，所以不应该再次编码。否则会把&amp;timestamp中的&amp;给编码了，而这是分隔参数的重要标志。 小结 URL 编码有两种常见的做法，一种是先拼接再编码，一种是先编码再拼接。 先拼接再编码会有较大概率编码错误，所以建议使用先编码再拼接的方式，也是我们这里采用的方式。 3.3 iOS 常用APIiOS端生成NSURL实例 1NSURL *url = [NSURL URLWithString:urlString]; 注意： urlString 中含有中文字符等非定URL限定字符时，创建的NSURL对象会失败，url返回为nil。 URL编码123456789101112131415161718NSString *urlStr = @&quot;你好0123456789abcxyzABCXYZ-_.~&amp;!*'();:@&amp;=+$,/?#[]% &quot;;//方式一【推荐】NSString *encodingString = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@&quot;url编码1-1 = %@&quot;,encodingString);//方式二：NSString *encodeStr3 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url编码3-1 = %@&quot;,encodeStr3);//方式三：自定义字符集 ABC-_~.!*'();:@&amp;=+ $,/?%#[] 编码对比NSString *encodeStr2 = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)urlStr, NULL, (CFStringRef)@&quot;ABC-_~.!*'();:=+ $,/?%#[]&quot;, kCFStringEncodingUTF8)); NSLog(@&quot;url编码2-2 = %@&quot;,encodeStr2); //方式四：自定义字符不需要编译的字符集，为空字符集，将所有字符用百分号编码NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;&quot;];NSString *encodeStr4 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:characterSet]; NSLog(@&quot;url编码3-2 = %@&quot;,encodeStr4); 打印结果是 网上常见的字符集枚举说明（供参考）: 123456URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\\^`{|}URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^`{|}URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\\]^`{|}URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^` URL解码1234//上段代码的结果为encodeStr3入参NSString *decodedStr3 = [encodeStr3 stringByRemovingPercentEncoding];NSLog(@&quot;url编码3-1 = %@&quot;,decodedStr3); 打印结果是","link":"/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URL%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B/"},{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"02-isa原理","text":"一、 前言 在arm64架构之前，isa仅仅是一个指针，保存着类对象或元类对象的内存地址 在arm64架构之后,苹果对isa进行了优化,变成了一个isa_t类型的联合体结构,同时使用位域来存储更多的信息: 对象的isa指针并不是直接指向类对象或者元类对象的内存地址，而是需要&amp; ISA_MASK才能获取类对象或者元类对象的地址。 二、 内容补充2.1 位运算符 位运算符用来对二进制位进行操作 操作数只能为整型和字符型数据。 C语言中六种位运算符：&amp;按位与、|按位或、^按位异或、~非、&lt;&lt;左移和&gt;&gt;右移。 1)按位与&amp; 有0出0,全1出1. A B &amp; 0 0 0 1 0 0 0 1 0 1 1 1 2)按位或 | 有1出1,全0出0. A B I 0 0 0 1 0 1 0 1 1 1 1 1 3)按位异或^ 相同为0,不同为1. A B ^ 0 0 0 1 0 1 0 1 1 1 1 0 4)非 ~ 非运算即取反运算，在二进制中 1 变 0 ，0 变 1。例如110101进行非运算后为001010，即1010. 5)左移 &lt;&lt; 左移运算就是把&lt;&lt;左边的运算数的各二进位全部左移若干位，移动的位数即&lt;&lt;右边的数的数值。 高位丢弃，低位补0。 左移n位就是乘以2的n次方。例如：a&lt;&lt;4是指把a的各二进位向左移动4位。如原来a=00000011(十进制3)，左移4位后为00110000(十进制48)。 6)右移 &gt;&gt; 右移运算就是把&gt;&gt;左边的运算数的各二进位全部右移若干位，&gt;&gt;右边的数指定移动的位数。例如：设 a=15，a&gt;&gt;2 表示把00001111右移为00000011(十进制3) 2.2 位运算符的运用1)取值 可以利用按位与 &amp;运算取出指定位的值 具体操作是想取出哪一位的值就将那一位置为1,其它位都为0,然后同原数据进行按位与计算,即可取出特定的位. 例: 0000 0011取出倒数第三位的值 123456// 想取出倒数第三位的值，就将倒数第三位的值置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0100 （掩码）------------ 0000 0000 // 得出按位与运算后的结果，即可拿到原数据中倒数第三位的值为0 上面的例子中,我们从0000 0011中取值,则有0000 0011被称之为源码.进行按位与操作设定的0000 0100称之为掩码. 例: 0000 0011取出后三位的值 123456// 想取出后三位的值，就将掩码后三位置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0111 （掩码）------------ 0000 0011 // 得出按位与运算后的结果，即可拿到原数据中后三位的值为011 2)设值 可以通过按位或 |或者按位与 &amp;运算符将某一位的值设为1或0. 要将某一位的值置为1的话，那么就将掩码中对应位的值设为1，掩码其它位为0，将源码与掩码进行按位或|操作即可. 例: 将0000 0011倒数第三位的值改为1 12345// 改变倒数第三位的值，就将掩码倒数第三位的值置为1，其它位为0，跟源码按位或运算 0000 0011| 0000 0100------------ 0000 0111 // 即可将源码中倒数第三位的值改为1 要将某一位的值置为0的话，那么就将掩码中对应位的值设为0，掩码其它位为1，将源码与掩码进行按位与&amp;操作即可. 例: 将0000 0011倒数第二位的值改为0 12345// 改变倒数第二位的值，就将掩码倒数第二位的值置为0，其它位为1，跟源码`按位与&amp;`运算 0000 0011| 1111 1101------------ 0000 0001 // 即可将源码中倒数第二位的值改为0 3)实际应用 声明一个TCJCar类，类中有四个BOOL类型的属性,分别为front、back、left、right,通过这四个属性来判断这辆小车的行驶方向. 然后我们来查看一下这个TCJCar类对象所占据的内存大小: 我们看到,一个TCJCar类的对象占据16个字节.其中包括一个isa指针和四个BOOL类型的属性,8+1+1+1+1=12,根据内存对齐原则,所以一个TCJCar类的对象占16个字节. 我们知道,BOOL值只有两种情况:0或1，占据一个字节的内存空间.而一个字节的内存空间中又有8个二进制位，并且二进制同样只有0或1，那么我们完全可以使用1个二进制位来表示一个BOOL值。也就是说我们上面声明的四个BOOL值最终只使用4个二进制位就可以代替，这样就节省了内存空间。那我们如何实现呢？ 想要实现四个BOOL值存放在一个字节中，我们可以通过char类型的成员变量来实现。 char类型占一个字节内存空间，也就是8个二进制位.可以使用其中最后四个二进制位来存储4个BOOL值。 (当然不能把char类型写成属性,因为一旦写成属性,系统会自动帮我们添加成员变量,自动实现set和get方法) 123@interface TCJCar(){ char _frontBackLeftRight;} 如果我们赋值_frontBackLeftRight为1,即0b 0000 0001,只使用8个二进制位中的最后4个分别用0或者1来代表front、back、left、right的值.那么此时front、back、left、right的状态为: 结合我们上文讲的6种位运算符以及使用场景,我们可以分别声明front、back、left、right的掩码,来方便我们进行下一步的位运算取值和赋值: 1234#define TCJDirectionFrontMask 0b00001000 //此二进制数对应十进制数为 8#define TCJDirectionBackMask 0b00000100 //此二进制数对应十进制数为 4#define TCJDirectionLeftMask 0b00000010 //此二进制数对应十进制数为 2#define TCJDirectionRightMask 0b00000001 //此二进制数对应十进制数为 1 通过对位运算符的左移&lt;&lt;和右移&gt;&gt;的了解，我们可以将上面的代码优化成： 1234#define TCJDirectionFrontMask (1 &lt;&lt; 3)#define TCJDirectionBackMask (1 &lt;&lt; 2)#define TCJDirectionLeftMask (1 &lt;&lt; 1)#define TCJDirectionRightMask (1 &lt;&lt; 0) 自定义的set方法如下: 1234567891011121314151617181920212223242526272829303132- (void)setFront:(BOOL)front{ if (front) {// 如果需要将值置为1，将源码和掩码进行按位或运算 _frontBackLeftRight |= TCJDirectionFrontMask; } else {// 如果需要将值置为0 // 将源码和按位取反后的掩码进行按位与运算 _frontBackLeftRight &amp;= ~TCJDirectionFrontMask; }}- (void)setBack:(BOOL)back{ if (back) { _frontBackLeftRight |= TCJDirectionBackMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionBackMask; }}- (void)setLeft:(BOOL)left{ if (left) { _frontBackLeftRight |= TCJDirectionLeftMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionLeftMask; }}- (void)setRight:(BOOL)right{ if (right) { _frontBackLeftRight |= TCJDirectionRightMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionRightMask; }} 自定义的get方法如下: 12345678910111213141516- (BOOL)isFront{ return !!(_frontBackLeftRight &amp; TCJDirectionFrontMask);}- (BOOL)isBack{ return !!(_frontBackLeftRight &amp; TCJDirectionBackMask);}- (BOOL)isLeft{ return !!(_frontBackLeftRight &amp; TCJDirectionLeftMask);}- (BOOL)isRight{ return !!(_frontBackLeftRight &amp; TCJDirectionRightMask);} 此处需要注意的是，代码中!为逻辑运算符非，因为_frontBackLeftRight &amp; TCJDirectionFrontMask代码执行后，返回的肯定是一个整型数，如当front为YES时，说明二进制数为0b 0000 1000，对应的十进制数为8，那么进行一次逻辑非运算后，!(8)的值为0，对0再进行一次逻辑非运算!(0)，结果就成了1，那么正好跟front为YES对应.所以此处进行两次逻辑非运算，!!. 当然,还要实现初始化方法: 12345678- (instancetype)init{ self = [super init]; if (self) { _frontBackLeftRight = 0b00001000; } return self;} 通过测试验证,我们完成了取值和赋值: 2.3 位域有些信息在存储时，并不需要占用一个完整的字节(8个二进制位)， 而只需占几个或一个二进制位。“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个区域就可以存储一段信息，这样就可以把信息用一个字节来表示。 2.4 联合体这里通过与struct的对比来理解union: ①两者都可以包含多个不同类型的数据，如int、double、Class等。 ②在struct中各成员有各自的内存空间，一个struct变量的内存总长度大于等于各成员内存长度之和；而在union中，各成员共享一段内存空间，一个union的内存总长度等于各成员中内存最长的那个成员的内存长度。 ③对struct中的成员进行赋值，不会影响其他成员的值；对union中的成员赋值时，每次只能给一个成员赋值，同时其它成员的值也就不存在了。 写法： 123union 联合体名{ 成员列表} 2.5 oc 中的 GDB 调试2.5.1 简介GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, Objective-c, go, java,pascal等语言。 2.5.2 在 iOS 开发中的作用① 普通变量查看 使用 p 变量名即可： 12(gdb) p a$1 = 10 ② 打印指针指向内容 如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如： 12(gdb) p d$1 = (int *) 0x602010 而如果想要打印指针指向的内容，需要解引用： 12(gdb) p *d$2 = 0 ③ 按照特定格式打印变量 对于简单的数据，p默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。使用格式控制字符来控制 正常方式打印字符数组c： 12(gdb) p c$18 = &quot;hello world&quot; 查看它的十六进制格式打印: 123(gdb) p/x c$19 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 0x6e, 0x67, 0x0} 但是如果我们想用这种方式查看浮点数的二进制格式是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8： 12345(gdb) p e$1 = 8.5(gdb) p/t e$2 = 1000 ④ 查看内存内容 examine(简写为x)可以用来查看内存地址中的值。语法如下： 1x/[n][f][u] addr 其中： n 表示要显示的内存单元数，默认值为1(想打多少段就写几) f 表示要打印的格式，通过格式控制字符控制 u 要打印的单元长度 addr 内存地址 格式控制字符： x 按十六进制格式显示变量【常用】 d 按十进制格式显示变量 u 按十六进制格式显示无符号整型 o 按八进制格式显示变量 t 按二进制格式显示变量 a 按十六进制格式显示变量 c 按字符格式显示变量 f 按浮点数格式显示变量 单元长度： g 八字节【常用】 b 字节 h 半字，即双字节 w 字，即四字节 举例： 1234x/4xg p // 打印 p 的内存内容 // 打4段内存内容 // 16进制打印 // 每段内存内容打印8字节 三、 isa 介绍3.1 前言回顾上篇文章中的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 在上文中我们知道alloc底层会调用calloc分配内存，接着就是initInstanceIsa(cls, hasCxxDtor)，顾名思义是初始化对象的isa，其关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor){ assert(!cls-&gt;instancesRequireRawIsa()); assert(hasCxxDtor == cls-&gt;hasCxxDtor()); // 留意这里的true initIsa(cls, true, hasCxxDtor);}inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { assert(!isTaggedPointer()); if (!nonpointer) { isa.cls = cls; } else { assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif isa = newisa; }} Tagged Pointer: 据说，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及 3倍 的访问速度提升，100倍 的创建、销毁速度提升。 Tagged Pointer首次应用于iPhone 5s设备上，现在几乎都应用Tagged Pointer了。想了解更多关于Tagged Pointer的内容可参考： 深入理解 Tagged Pointer。 3.2 isa 的结构点击objc_object::initIsa()中的isa，发现isa是isa_t类型 123456789101112union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // 位域 };#endif}; 而isa_t实际上是一个union，即联合体，占8个字节，它的特性就是共用内存，或者说是互斥，比如说如果cls赋值了就不在对bits进行赋值。 3.2.1 isa 的 bits 成员变量3.2.2 isa的 cls 成员变量它是Class类型，源码： 12345678910111213141516171819202122typedef struct objc_class *Class;// 顺便了解一下id的类型，显然id是个指针变量，它的值只有一个isa变量typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; class_data_bits_t bits; class_rw_t *data() { return bits.data(); } ... // 一些方法};struct objc_object {private: isa_t isa; ... // 一些公有、私有方法}; 从源码得知，Class实际上是objc_class结构体的指针变量，而objc_class又继承自objc_object（说明类本质上也是一个对象），因此Class这个结构体指针变量的值内部有一个isa成员变量（类型为isa_t），这个isa成员变量在64位CPU架构下是8字节，且排在objc_class结构体的前8字节。 3.2.3 isa 的位域查看ISA_BITFIELD： 模拟器： 12345678910111213141516# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) 真机： 12345678910111213141516# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) 首先明确一点，在64位CPU架构下isa指针的长度也是8字节，它可以存储足够多的内容，苹果为了优化性能，存储类地址只用了一部分位（x86_64下是44位，arm64下是33位），剩下的位用来存储一些其它信息。 具体分析一下ISA_BITFIELD位域各成员的表示意义： nonpointer：表示是否对isa指针开启指针优化。 0：不优化，是纯isa指针，当访问isa指针时，直接返回其成员变量cls 1：优化，即isa 指针内容不止是类地址，还包含了类的一些信息、对象的引用计数等。 has_assoc：是否有关联对象。 has_cxx_dtor：该对象是否有C++或Objc的析构器。 如果有析构函数，则需要做一些析构的逻辑处理； 如果没有，则可以更快的释放对象。 shiftcls：存储类地址。开启指针优化的情况下，在 x86_64 架构有 44位 用来存储类地址，arm64 架构中占 33位 。 magic：用于调试器判断当前对象是真的对象，还是一段没有初始化的空间。 weakly_referenced：用于标识对象是否被指向或者曾经被指向一个ARC的弱变量，没有弱引用的对象释放的更快。 deallocating：标识对象是否正在释放内存。 has_sidetable_rc：对象的引用计数值是否有进位。 extra_rc：表示该对象的引用计数值。 extra_rc只是存储了额外的引用计数，实际的引用计数公式：实际引用计数 = extra_rc + 1。这里占了8位，所以理论上可以存储的最大引用计数是：2^8 - 1 + 1 = 256（arm64CPU架构下的extra_rc占19位，可存储的最大引用计数为2^19 - 1 + 1 = 524288）。 与has_sidetable_rc的关联：当对象的最大引用计数超过界限后，has_sidetable_rc的值为1，否则为0 3.5 isa的作用从objc_object的结构可以说明，当系统为一个对象分配好内存，并初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是isa。 同时，通过对isa的位域说明，我们知道shiftcls存储的是类地址。在arm64 架构中占 33位。 我们将ISA_MASK的值0x0000000ffffffff8ULL转化为二进制数分析一下: 从图中可以看到ISA_MASK的值转化为二进制后中间有33位都为1，那么isa指针同ISA_MASK进行按位与运算就可以取出中间33位的值，这正是中间占33位的shiftcls，所以就取出了类对象和元类对象的内存地址信息。 例： 此时通过lldb命令调试 说明： 0x001d800100001129是对象p的isa值，通过isa &amp; ISA_MASK运算得到的0x0000000100001128就是Person类的地址 证明【1】：通过p/x Person.class直接打印Person类地址，显然得到的是0x0000000100001128，如此【1】证明成立！ 结论：isa将对象和类关联起来，起到了中间桥梁的作用。 3.6 isa的初始化补充最后补充一下isa的初始化。还记得初始化isa的入口吗？是initIsa(cls, true, hasCxxDtor);，此时nonpointer的值是true，再看SUPPORT_INDEXED_ISA的定义 12345#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1#else# define SUPPORT_INDEXED_ISA 0#endif 在x86_64下，SUPPORT_INDEXED_ISA是0，所以isa的初始化最终会来到 1234567891011isa_t newisa(0);// 使用ISA_MAGIC_VALUE(0x001d800000000001ULL)赋值给bits// nonpointer为1，magic为1d，其他变量为零newisa.bits = ISA_MAGIC_VALUE;// hasCxxDtor是从类的isa中取出的newisa.has_cxx_dtor = hasCxxDtor;// 将cls右移3位后赋值给shiftclsnewisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;isa = newisa; 碍于篇幅，这里不继续深入hasCxxDtor。 四、isa 指向图在OC中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。 当对象的实例方法被调用时，它通过自己的isa来查找对应的类，然后在所属类的 class_data_bits_t结构体中查找对应方法的实现。同时，每一个objc_class 也有一个指向自己的父类的指针superclass用来查找继承的方法。 而当调用 类方法 时，它的查找流程是怎样的呢？对此OC的解决方案就是引入元类，来保证类方法也能通过相同的机制查找到。也就是说，类的isa指向的是元类。 苹果官方isa指向图： 接下来我们来验证一下吧。 4.1 准备工作创建Teacher类、Person类，其中Person类继承于NSObject，Teacher类继承于Person类。 4.2 验证过程1.获取teacher对象的类（结果是Teacher类，地址为0x0000000100001230） 123456789(lldb) x/4gx teacher0x100f59400: 0x001d800100001231 0x00000000000000000x100f59410: 0x636f72504b575b2d 0x70756f7247737365 (lldb) p/x 0x001d800100001231 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $3 = 0x0000000100001230 // 对象teacher的类地址 (lldb) po $3Teacher // 对象teacher的类 2.获取Teacher类的元类（结果是Teacher元类，地址为0x0000000100001208） 123456789(lldb) x/4gx Teacher.class0x100001230: 0x001d800100001209 0x00000001000011e00x100001240: 0x0000000100f61150 0x0000000100000003(lldb) p/x 0x001d800100001209 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $5 = 0x0000000100001208 // Teacher类的元类地址 (lldb) po $5Teacher // Teacher类的元类 Teacher类 和 Teacher元类 地址不一样 3.获取person对象的类（结果是Person类，地址为0x00000001000011e0），以及类的元类（结果是Person元类，地址为0x00000001000011b8） 12345678910111213141516171819(lldb) x/4gx person0x100f60a30: 0x001d8001000011e1 0x00000000000000000x100f60a40: 0x0000000000000002 0x00007fff9b855588 (lldb) p/x 0x001d8001000011e1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $8 = 0x00000001000011e0 // 对象person的类地址 (lldb) po $8Person // 对象person的类(lldb) x/4gx Person.class0x1000011e0: 0x001d8001000011b9 0x0000000100b381400x1000011f0: 0x0000000100f61030 0x0000000100000003 (lldb) p/x 0x001d8001000011b9 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $10 = 0x00000001000011b8 // Person类的元类地址 (lldb) po $10Person // Person类的元类 4.获取object对象的类（结果是NSObject类，地址为0x0000000100b38140），以及类的元类（结果是NSObject元类，地址为0x0000000100b380f0） 123456789101112131415161718192021(lldb) x/4gx object0x100f5cc50: 0x001d800100b38141 0x00000000000000000x100f5cc60: 0x70736e494b575b2d 0x574b57726f746365 (lldb) p/x 0x001d800100b38141 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $12 = 0x0000000100b38140 // 对象object的类地址 (lldb) po $12 NSObject // 对象object的类 (lldb) x/4gx NSObject.class0x100b38140: 0x001d800100b380f1 0x00000000000000000x100b38150: 0x0000000101913060 0x0000000200000003 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $14 = 0x0000000100b380f0 // NSObject类的元类地址 (lldb) po $14NSObject // NSObject类的元类 5.获取Teacher元类的元类，Person元类的元类，以及NSObject元类的元类 123456789101112131415161718192021222324252627282930313233(lldb) x/4gx 0x0000000100001208 // Teacher元类0x100001208: 0x001d800100b380f1 0x00000001000011b80x100001218: 0x000000010186f950 0x0000000400000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $16 = 0x0000000100b380f0 // NSObject元类 (lldb) po $16NSObject // NSObject元类 (lldb) x/4gx 0x00000001000011b8 // Person元类0x1000011b8: 0x001d800100b380f1 0x0000000100b380f00x1000011c8: 0x0000000101905a50 0x0000000300000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $17 = 0x0000000100b380f0 // NSObject元类 (lldb) po $17NSObject // NSObject元类 (lldb) x/4gx 0x0000000100b380f0 // NSObject元类0x100b380f0: 0x001d800100b380f1 0x0000000100b381400x100b38100: 0x0000000101903820 0x0000000500000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $18 = 0x0000000100b380f0 // NSObject元类 (lldb) po $18NSObject // NSObject元类 4.3 isa指向结论 基于【4.2】的验证过程，可以得出结论： 对象的isa指针指向对象的所属类 类的isa指针指向类的元类 元类的isa指针指向根元类 根元类的isa指针指向他自己(形成闭环) 4.4 继承关系的证明类的继承关系证明过程：（以 -&gt; 表示 继承自） 12345678(lldb) p class_getSuperclass(Teacher.class)(Class) $19 = Person // Teacher类 -&gt; Person类(lldb) p class_getSuperclass(Person.class)(Class) $20 = NSObject // Person类 -&gt; NSObject类(lldb) p class_getSuperclass(NSObject.class)(Class) $21 = nil // NSObject类 -&gt; nil 元类的继承关系证明过程：（以 -&gt; 表示 继承自） 1234567891011121314151617// 0x0000000100001208 是 Teacher元类(lldb) p/x class_getSuperclass((Class)0x0000000100001208)(Class) $17 = 0x00000001000011b8 // Person元类(lldb) po $17Person // Teacher元类 -&gt; Person元类// 0x00000001000011b8 是 Person元类(lldb) p/x class_getSuperclass((Class)0x00000001000011b8)(Class) $22 = 0x0000000100b380f0 // NSObject元类（根元类）(lldb) po $22NSObject // Person元类 -&gt; 根元类// 0x0000000100b380f0 是 根元类(lldb) p/x class_getSuperclass((Class)0x0000000100b380f0)(Class) $23 = 0x0000000100b38140 NSObject // NSObject类（根类）(lldb) po $23NSObject // 根元类 -&gt; 根类 根元类继承自根类（NSObject元类 -&gt; NSObject类），根类继承自nil（NSObject类 -&gt; nil） 五、总结1.isa是isa_t结构，采用 联合体+位域 的搭配来设计：在不同的位上显示不同的内容，以此来节省储存空间，进而优化内存。 2.isa包含了cls和bits两个成员变量，这两个成员变量在64位CPU架构下的长度都是8字节，所以isa在64位CPU架构下的长度也是8字节。 3.isa的位域上存储了一些对象与类的信息，并将对象与类关联起来，起到中间桥梁的作用。 4.指向图相关结论： 继承 子类 -&gt; 父类 -&gt; 根类(NSObject) 子元类 -&gt; 父元类 -&gt; 根元类 !!! 根元类 -&gt; 根类 (NSObject) 形成闭环 isa 指向 实例对象 isa -&gt; 类对象 类对象 isa -&gt; 元类对象 元类对象 isa -&gt; 根元类对象 根元类对象 isa -&gt; 他自己(形成闭环) 六、源码我的 malloc 源码 我的 libobjc 源码 参考资料OC源码分析之isa GDB调试指南","link":"/2020/11/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-isa%E5%8E%9F%E7%90%86/"},{"title":"Hexo 配置","text":"一、升级主题1.使用 1sudo npm install -g npm-upgrade 和 123ncu -u // 自动更新所有插件或者 npm-upgrade // 手动选择插件更新 来升级Hexo中的插件 2.保存 1npm update -g 1npm update --save 3.安装配置主题 1npm install hexo-theme-icarus 1hexo config theme icarus 4.根据提示安装缺少或者需要更新的东西 5.再次配置主题 1hexo config theme icarus 这个时候应该提示配置成功了 6.本地启动看看 1hexo s 二、Icarus 配置2.1 基础配置修改通过修改主题的全局配置文件_config.icarus.yml 2.2 修改博客为：主页三栏，文章页两栏找到hexo-theme-icarus文件夹，在此目录下添加_config.post.yml文件并配置： 123456789101112widgets: - # Where should the widget be placed, left sidebar or right sidebar position: left type: toc # Whether to show the index of each heading index: false # Whether to collapse sub-headings when they are out-of-view collapsed: true # Maximum level of headings to show (1-6) depth: 6 2.3 主题进行 cdn 加速搜索并找到cdn.js文件，并修改： 123456789101112131415161718192021222324252627282930313233343536373839/** * @private */// 原来的// const PROVIDERS = {// LIBRARY: {// cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }',// loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }',// jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }',// unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }'// },// FONT: {// google: 'https://fonts.googleapis.com/${ type }?family=${ fontname }',// loli: 'https://fonts.loli.net/${ type }?family=${ fontname }'// },// ICON: {// loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css',// fontawesome: 'https://use.fontawesome.com/releases/v5.12.0/css/all.css'// }// };// 改为：const PROVIDERS = { LIBRARY: { // cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }', cdnjs: 'https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }', unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }' }, FONT: { google: 'https://fonts.loli.net/${ type }?family=${ fontname }', loli: 'https://fonts.loli.net/${ type }?family=${ fontname }' }, ICON: { loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css', fontawesome: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css' }}; 2.4 修改文章页的宽度找到layout.jsx文件 is-9-widescreen 中的 9 就是宽度比例，默认为 8 12'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3","link":"/2020/12/16/%E5%8D%9A%E5%AE%A2/Hexo%20%E9%85%8D%E7%BD%AE/"},{"title":"04-方法的缓存原理","text":"前言一、 cache_t源码分析当OC项目编译完成后，类的实例方法（方法编号SEL 和 函数地址IMP）就保存在类的方法列表中。我们知道 OC 为了实现其动态性，将 方法的调用包装成了 SEL 寻找 IMP 的过程。试想一下，如果每次调用方法，都要去类的方法列表（甚至父类、根类的方法列表）中查询其函数地址，势必会对性能造成极大的损耗。 为了解决这一问题，OC 采用了方法缓存的机制来提高调用效率，也就是cache_t，其作用就是缓存已调用的方法。当调用方法时，objc_msgSend会先去缓存中查找，如果找到就执行该方法；如果不在缓存中，则去类的方法列表（包括父类、根类的方法列表）查找，找到后会将方法的SEL和IMP缓存到cache_t中，以便下次调用时能够快速执行。 1.1 cache_t结构源码： 12345678910111213141516171819202122232425struct cache_t { struct bucket_t *_buckets; // 缓存数组，即哈希桶 mask_t _mask; // 缓存数组的容量临界值 mask_t _occupied; // 缓存数组中已缓存方法数量 ... // 一些函数};#if __LP64__typedef uint32_t mask_t;#elsetypedef uint16_t mask_t;#endifstruct bucket_t {private:#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif ... // 一些方法}; 从上面源码不难看出，在64位CPU架构下，cache_t长度是16字节。单从结构来看，方法是缓存在bucket_t（又称哈希桶）中，接下来用个例子验证一下cache_t是否缓存了已调用的方法。 1.2 方法缓存的验证1.创建一个简单的Person类，代码如下 1234567891011121314151617181920212223@interface Person : NSObject- (void)methodFirst;- (void)methodSecond;- (void)methodThird;@end@implementation Person- (void)methodFirst { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodSecond { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodThird { NSLog(@&quot;%s&quot;, __FUNCTION__);}@end 2.方法调用前的cache_t 在方法调用前打个断点，看看cache_t的缓存情况 说明： objc_class结构中ISA占8字节，superClass占8字节，由于我们是按照8字节为一段打印的，所以刚好0x1000011d8就是cache_t首地址。 由于还没有任何方法调用，所以_mask和_occupied都是0，即还没有方法缓存。 为什么调用了alloc和class，但是这两个方法怎么没有缓存，这里要提到我们之前探索类的方法存储中说到的，对象的方法存在类中，类的类方法以实例方法的形式存在元类中，我们这里探索的是类的cache缓存，所以只能找到实例方法。下面直接给大家看一下元类里的cache以及bucket，也找到了alloc方法的缓存，这也说明，我们的思路是正确的： 123456789101112131415161718192021(lldb) p/x 0x001d8001000012b9 &amp; 0x00007ffffffffff8ULL(unsigned long long) $5 = 0x00000001000012b8// 0x00000001000012b8这个玩意就是元类的地址了。之前的isa原理，里面介绍到了如何从类查找到元类(lldb) x/4gx 0x00000001000012b80x1000012b8: 0x001d800100b360f1 0x0000000100b360f00x1000012c8: 0x0000000101e236c0 0x0000000200000003(lldb) p (cache_t *)0x1000012c8(cache_t *) $6 = 0x00000001000012c8(lldb) p *$6(cache_t) $7 = { _buckets = 0x0000000101e236c0 _mask = 3 _occupied = 2}(lldb) p $7._buckets(bucket_t *) $8 = 0x0000000101e236c0(lldb) p *$8(bucket_t) $9 = { _key = 4298994200 _imp = 0x00000001003cc3b0 (libobjc.A.dylib`::+[NSObject alloc]() at NSObject.mm:2294)} 3.方法调用后的cache_t 执行alloc和init这两个方法后，cache_t变化如下 从上图可知，调用init后，_mask的值是3，_occupied则是1。_buckets指针的值（数组首地址）发生了变化（从0x1003db250变成0x101700090），同时缓存了init方法的SEL和IMP。 思考： 1. alloc 方法调用后，缓存在哪里？ 2. 为什么 init 方法不在 _buckets 第一个位置？ 继续执行methodFirst，再看cache_t 此时，_mask的值是3（没发生变化），_occupied则变成了2，_buckets指针地址没变，增加缓存了methodFirst方法的SEL和IMP。 接着是执行methodSecond，且看 显然，_occupied变成了3，而_buckets指针地址不改变，同时新增methodSecond的方法缓存。 最后执行methodThird后，再看cache_t变化 这次的结果就完全不同了。_mask的值变成7，_occupied则重新变成了1，而_buckets不仅首地址变了，之前缓存的init、methodFirst和methodSecond方法也没了，仅存在的只有新增的methodThird方法。看来，cache_t并非是如我们所愿的那样——调用一个方法就缓存一个方法。 思考：之前缓存的方法（init、methodFirst 和 methodSecond）哪去了？ 1.3 cache_t小结让我们梳理一下上面的例子。在依次执行Person的实例方法init、methodFirst、methodSecond、methodThird后，cache_t变化如下 调用的方法 _buckets _mask _occupied 未调用方法 空 0 0 init init 3 1 init、methodFirst init、methodFirst 3 2 init、methodFirst、methodSecond init、methodFirst、methodSecond 3 3 init、methodFirst、methodSecond、methodThird methodThird 7 1 可见，**cache_t的确能实时缓存已调用的方法**。 上面的验证过程也可以帮助我们理解cache_t三个成员变量的意义。 bucket可译为桶（即哈希桶），用于装方法； occupied可译为已占有，表示已缓存的方法数量； mask可译为面具、掩饰物，乍看无头绪，但是注意到cache_t中有获取容量的函数（capacity），其源码如下 12345678910111213141516struct cache_t { ... mask_t mask(); mask_t capacity(); ...}mask_t cache_t::mask() { return _mask; }mask_t cache_t::capacity() { return mask() ? mask()+1 : 0; } 从capacity方法看出：当_mask不等于0的时候，意味着已经调用过实例方法，此时桶的容量为_mask + 1，如果_mask是0，说明未调用实例方法，即桶的容量为0。故，_mask从侧面反映了桶的容量。 二、cache_t的方法缓存原理接下来，从方法的调用过程开始分析cache_t的方法缓存原理。 2.1 cache_fillOC方法的本质是 **消息发送（即objc_msgSend），底层是通过方法的 SEL 查找 IMP**。 简要流程： 1.调用方法时，objc_msgSend会去cache_t即缓存中查询方法的函数实现（这部分是由汇编代码实现的，非常高效），在缓存中找的过程暂且不表 2.当缓存中没有的时候，则去类的方法列表中查找，直至找到后，再调用cache_fill，目的是为了将方法缓存到cache_t中，其源码如下 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver){#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif} objc_msgSend的具体流程将另起一文分析，这里不作赘述。 2.2 cache_fill_nolockcache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 其源码以及详细分析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver){ cacheUpdateLock.assertLocked(); // 如果类未初始化 if (!cls-&gt;isInitialized()) return; // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，即 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) { // 当第一次调用类的实例方法时（如本文的【1.2】例中的`init`） cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } else if (newOccupied &lt;= capacity / 4 * 3) { // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 } else { // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); } // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);}// INIT_CACHE_SIZE 即为4enum { INIT_CACHE_SIZE_LOG2 = 2, INIT_CACHE_SIZE = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)}; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 1.决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 2.然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 思考：为什么扩容临界点是 3/4？ 2.3 reallocate在下面这两种情况下会执行reallocate： 一是第一次初始化_buckets的时候 另一种则是_buckets扩容的时候 我们来看一下reallocate做了哪些事情 1234567891011121314151617181920212223242526void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity){ // 当且仅当`_buckets`中有缓存方法时，feeOld为true bool freeOld = canBeFreed(); // 获取当前buckets指针，即_buckets bucket_t *oldBuckets = buckets(); // 开辟新的buckets指针 bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache's old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity &gt; 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); // 将新buckets、新mask（newCapacity-1）分别赋值跟当前的 _buckets 和 _mask setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) { // 释放旧的buckets内存空间 cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); }} reallocate完美解释了在例【1.2】中的几个情况： init执行完后，_buckets指针地址变了，_mask变成了3； methodThird执行完后，_buckets不仅指针地址变了，同时之前缓存的init、methodFirst和methodSecond方法也都不在了 注意，_occupied的变化是在回到cache_fill_nolock后发生的。 思考：扩容后，为什么不直接把之前缓存的方法加入新的buckets中？ 2.4 expand从cache_fill_nolock源码来看，当新的方法缓存数（_occupied+1）大于总容量（_mask+1）时，会对_buckets进行扩容，也就是执行expand函数，其源码如下 1234567891011121314151617void cache_t::expand(){ cacheUpdateLock.assertLocked(); // 获取当前总容量，即_mask+1 uint32_t oldCapacity = capacity(); // 新的容量 = 旧容量 * 2 uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) { // mask overflow - can't grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; } reallocate(oldCapacity, newCapacity);} 这个函数非常简单，仅仅是计算好新的容量后，就去调用reallocate函数。需要注意的是： 在不超过uint32_t大小（4字节）时，每次扩容为原来的2倍 如果超过了uint32_t，则重新申请跟原来一样大小的buckets 2.5 find在执行完相应的buckets策略后，接下来就需要找到合适的位置（bucket），以存储 方法的SEL和IMP。find具体做的事情就是根据方法的SEL，返回一个符合要求的bucket，同样上源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bucket_t * cache_t::find(SEL s, id receiver){ assert(s != 0); // 获取当前buckets，即_buckets bucket_t *b = buckets(); // 获取当前mask，即_mask mask_t m = mask(); // 由 sel &amp; mask 得出起始索引值 mask_t begin = cache_hash(s, m); mask_t i = begin; do { // sel为0：说明 i 这个位置尚未缓存方法； // sel等于s：命中缓存，说明 i 这个位置已缓存方法，可能是hash冲突 if (b[i].sel() == 0 || b[i].sel() == s) { return &amp;b[i]; } } while ((i = cache_next(i, m)) != begin); // hack // 找不到多余的哈希桶（出错的处理，打印问题）。一般不会走到这里！ Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache)); cache_t::bad_cache(receiver, (SEL)s, cls);}static inline mask_t cache_hash(SEL sel, mask_t mask) { return (mask_t)(uintptr_t)sel &amp; mask;}#if __arm__ || __x86_64__ || __i386__// objc_msgSend has few registers available.// Cache scan increments and wraps at special end-marking bucket.#define CACHE_END_MARKER 1static inline mask_t cache_next(mask_t i, mask_t mask) { return (i+1) &amp; mask;}#elif __arm64__// objc_msgSend has lots of registers available.// Cache scan decrements. No end marker needed.#define CACHE_END_MARKER 0static inline mask_t cache_next(mask_t i, mask_t mask) { return i ? i-1 : mask;}#else#error unknown architecture#endif 从源码可以发现，find找bucket的方式用到了hash的思想：以_buckets作为哈希桶，以cache_hash作为哈希函数，进行哈希运算后得出索引值index（本质是xx &amp; mask，所以index最大值就是_mask的值）。 由于索引值是通过哈希运算得出的，其结果自然是无序的，这也是为什么上例中init方法不在_buckets第一个位置的原因。 三、多线程对方法缓存的影响既然哈希桶的数量是在运行时动态增加的，那么在多线程环境下调用方法时，对方法的缓存有没有什么影响呢？看下面的分析。 3.1 多线程同时读取缓存在整个objc_msgSend函数中，为了达到最佳的性能，对方法缓存的读取操作是没有添加任何锁的。而多个线程同时调用已缓存的方法，并不会引发_buckets和_mask的变化，因此多个线程同时读取方法缓存的操作是不会有安全隐患的。 3.2 多线程同时写缓存从写缓存的cache_fill_nolock方法中我们知道在桶数量扩容和写桶数据之前，系统使用了一个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证写入的同步处理，并且在锁住的范围内部还做了一次查缓存的操作（if (cache_getImp(cls, sel)) return;），这样就 保证了哪怕多个线程同时写同一个方法的缓存也只会产生写一次的效果，即多线程同时写缓存的操作也不会有安全隐患。 3.3 多线程同时读写缓存这个情况就比较复杂了，我们先看一下objc_msgSend读缓存的代码（以 arm64架构汇编 为例） 12345678910111213141516171819202122232425262728293031323334353637383940.macro CacheLookup // x1 = SEL, x16 = isa ldp x10, x11, [x16, #CACHE] // x10 = buckets, x11 = occupied|mask and w12, w1, w11 // x12 = _cmd &amp; mask add x12, x10, x12, LSL #4 // x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4) ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // wrap: x12 = first bucket, w11 = mask add x12, x12, w11, UXTW #4 // x12 = buckets+(mask&lt;&lt;4) // Clone scanning loop to miss instead of hang when cache is corrupt. // The slow path may detect any corruption and halt later. ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // double wrap JumpMiss $0 .endmacro 其中，ldp指令的作用是将数据从内存读取出来存到寄存器，第一个ldp代码会 把cache_t中的_buckets 和 _occupied | _mask整个结构体成员分别读取到x10和x11两个寄存器中，并且CacheLookup的后续代码没有再次读取cache_t的成员数据，而是一直使用x10和x11中的值进行哈希查找。由于CPU能保证单条指令执行的原子性，所以 只要保证ldp x10, x11, [x16, #CACHE]这段代码读取到的_buckets与_mask是互相匹配的（即要么同时是扩容前的数据，要么同时是扩容后的数据），那么多个线程同时读写方法缓存也是没有安全隐患的。 3.3.1 编译内存屏障这里有个疑问，即系统是如何确保_buckets与_mask的这种一致性的呢？让我们看一下这两个变量的写入源码 1234567891011121314151617181920void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask){ // objc_msgSend uses mask and buckets with no locks. // It is safe for objc_msgSend to see new buckets but old mask. // (It will get a cache miss but not overrun the buckets' bounds). // It is unsafe for objc_msgSend to see old buckets and new mask. // Therefore we write new buckets, wait a lot, then write new mask. // objc_msgSend reads mask first, then buckets. // ensure other threads see buckets contents before buckets pointer mega_barrier(); _buckets = newBuckets; // ensure other threads see new buckets before new mask mega_barrier(); _mask = newMask; _occupied = 0;} 这段C++代码先修改_buckets，然后再更新_mask的值，为了确保这个顺序不被编译器优化，这里使用了mega_baerrier()来实现 编译内存屏障（Compiler Memory Barrier）。 如果不设置 编译内存屏障 的话，编译器有可能会优化代码先赋值_mask，然后才是赋值_buckets，两者的赋值之间，如果另一个线程执行ldp x10, x11, [x16, #0x10]指令，得到的就是旧_buckets和新_mask，进而出现内存数组越界引发程序崩溃。 而加入了编译内存屏障后，就算得到的是新_buckets和旧_mask，也不会导致程序崩溃。 编译内存屏障仅仅是确保_buckets的赋值会优先于_mask的赋值，也就是说，在任何场景下当指令ldp x10, x11, [x16, #CACHE]执行后，得到的_buckets数组的长度一定是大于或等于_mask+1的，如此就保证了不会出现内存数组越界导致的程序崩溃。可见，借助编译内存屏障的技巧在一定的程度上可以实现无锁读写技术。 对内存屏障感兴趣的同学可戳 理解 Memory barrier（内存屏障） 3.3.2 内存垃圾回收我们知道，在多线程读写方法缓存时，写线程可能会扩容_buckets（开辟新的_buckets内存，同时销毁旧的_buckets），此时，如果其他线程读取到的_buckets是旧的内存，就有可能会发生读内存异常而系统崩溃。为了解决这个问题，OC使用了两个全局数组objc_entryPoints、objc_exitPoints，分别保存所有会访问到cache的函数的起始地址、结束地址 12extern &quot;C&quot; uintptr_t objc_entryPoints[];extern &quot;C&quot; uintptr_t objc_exitPoints[]; 下面列出这些函数（同样以 arm64架构汇编 为例） 12345678910111213141516171819.private_extern _objc_entryPoints_objc_entryPoints: .quad _cache_getImp .quad _objc_msgSend .quad _objc_msgSendSuper .quad _objc_msgSendSuper2 .quad _objc_msgLookup .quad _objc_msgLookupSuper2 .quad 0.private_extern _objc_exitPoints_objc_exitPoints: .quad LExit_cache_getImp .quad LExit_objc_msgSend .quad LExit_objc_msgSendSuper .quad LExit_objc_msgSendSuper2 .quad LExit_objc_msgLookup .quad LExit_objc_msgLookupSuper2 .quad 0 当线程扩容哈希桶时，会先把旧的桶内存保存在一个全局的垃圾回收数组变量garbage_refs中，然后再遍历当前进程（在iOS中，一个进程就是一个应用程序）中的所有线程，查看是否有线程正在执行objc_entryPoints列表中的函数（原理是PC寄存器中的值是否在objc_entryPoints和objc_exitPoints这个范围内），如果没有则说明没有任何线程访问cache，可以放心地对garbage_refs中的所有待销毁的哈希桶内存块执行真正的销毁操作；如果有则说明有线程访问cache，这次就不做处理，下次再检查并在适当的时候进行销毁。 以上，**OC 2.0的runtime巧妙的利用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。** 深入解构objc_msgSend函数的实现 这篇博文会帮助你进一步了解Runtime的实现，尤其在多线程读写方法缓存方面 四、问题讨论来到这里，相信大家对cache_t缓存方法的原理已经有了一定的理解。现在请看下面的几个问题： 4.1 类方法的缓存位置Q：Person类调用alloc方法后，缓存在哪里？ A：缓存在 Person元类 的 cache_t 中。证明如下图 4.2 _mask的作用Q：请说明cache_t中_mask的作用 A：_mask从侧面反映了cache_t中哈希桶的数量（哈希桶的数量 = _mask + 1），保证了查找哈希桶时不会出现越界的情况。 题解：从上面的源码分析，我们知道cache_t在任何一次缓存方法的时候，哈希桶的数量一定是 &gt;=4且能被 4整除的，_mask则等于哈希桶的数量-1，也就是说，缓存方法的时候，_mask的二进制位上全都是1。当循环查询哈希桶的时候，索引值是由xx &amp; _mask运算得出的，因此索引值是小于哈希桶的数量的（index &lt;= _mask，故index &lt; capacity），也就不会出现越界的情况。 4.3 关于扩容临界点3/4的讨论Q：为什么扩容临界点是3/4？ A：一般设定临界点就不得不权衡 空间利用率 和 时间利用率 。在 3/4 这个临界点的时候，空间利用率比较高，同时又避免了相当多的哈希冲突，时间利用率也比较高。 题解：扩容临界点直接影响循环查找哈希桶的效率。设想两个极端情况： 当临界点是1的时候，也就是说当全部的哈希桶都缓存有方法时，才会扩容。这虽然让开辟出来的内存空间的利用率达到100%，但是会造成大量的哈希冲突，加剧了查找索引的时间成本，导致时间利用率低下，这与高速缓存的目的相悖； 当临界点是0.5的时候，意味着哈希桶的占用量达到总数一半的时候，就会扩容。这虽然极大避免了哈希冲突，时间利用率非常高，却浪费了一半的空间，使得空间利用率低下。这种以空间换取时间的做法同样不可取； 两相权衡下，当扩容临界点是3/4的时候，空间利用率 和 时间利用率 都相对比较高。 4.4 缓存循环查找的死循环情况Q：缓存循环查找哈希桶是否会出现死循环的情况？ A：不会出现。 题解：当哈希桶的利用率达到3/4的时候，下次缓存的时候就会进行扩容，即空桶的数量最少也会有总数的1/4，因此循环查询索引的时候，一定会出现命中缓存或者空桶的情况，从而结束循环。 五、总结通过以上例子的验证、源码的分析以及问题的讨论，现在总结一下cache_t的几个结论： 1.cache_t能缓存调用过的方法。 2.cache_t的三个成员变量中， _buckets的类型是struct bucket_t *，也就是指针数组，它表示一系列的哈希桶（已调用的方法的SEL和IMP就缓存在哈希桶中），一个桶可以缓存一个方法。 _mask的类型是mask_t（mask_t在64位架构下就是uint32_t，长度为4个字节），它的值等于哈希桶的总数-1（capacity - 1），侧面反映了哈希桶的总数。 _occupied的类型也是mask_t，它代表的是当前_buckets已缓存的方法数。 3.当缓存的方法数到达临界点（桶总数的3/4）时，下次再缓存新的方法时，首先会丢弃旧的桶，同时开辟新的内存，也就是扩容（扩容后都是全新的桶，以后每个方法都要重新缓存的），然后再把新的方法缓存下来，此时_occupied为1。 4.当多个线程同时调用一个方法时，可分以下几种情况： 多线程读缓存：读缓存由汇编实现，无锁且高效，由于并没有改变_buckets和_mask，所以并无安全隐患。 多线程写缓存：OC用了个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证不会出现写两次缓存的情况。 多线程读写缓存：OC使用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。 参考https://juejin.cn/post/6844904070596001806","link":"/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"},{"title":"03-对象&amp;类的结构","text":"一、对象&amp;类的结构1.1 解读类的本质从NSObject类的定义开始 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop} 注意：NSObject有个Class类型的isa成员变量 接下来用Clang编译main.m，输出.cpp文件，看一下NSObject类的底层定义 1clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 打开main.cpp文件，找到了NSObject 123456789#ifndef _REWRITER_typedef_NSObject#define _REWRITER_typedef_NSObjecttypedef struct objc_object NSObject;typedef struct {} _objc_exc_NSObject;#endifstruct NSObject_IMPL { Class isa;}; 发现NSObject类本质上是objc_object结构体，同时有定义一个NSObject_IMPL结构体（IMPL是implementation的缩写），里面有NSObject类的isa成员变量。 现在把我们自己定义的Person类用clang编译成c++看一下。我们定义的Person类：(有个age属性和run方法) 123456789101112131415@interface Person : NSObject@property (nonatomic) NSInteger age;- (void)run;@end@implementation Person- (void)run { NSLog(@&quot;I am running.&quot;);}@end 编译成c++后： 123456789101112131415161718#ifndef _REWRITER_typedef_Person#define _REWRITER_typedef_Persontypedef struct objc_object Person;typedef struct {} _objc_exc_Person;#endifextern &quot;C&quot; unsigned long OBJC_IVAR_$_Person$_age;struct Person_IMPL { struct NSObject_IMPL NSObject_IVARS; NSInteger _age;};static void _I_Person_run(Person * self, SEL _cmd) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mc_9fhhprrj4k92vxzqm3g127z40000gn_T_main_09fc70_mi_0);}static NSInteger _I_Person_age(Person * self, SEL _cmd) { return (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)); }static void _I_Person_setAge_(Person * self, SEL _cmd, NSInteger age) { (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)) = age; } 可见，Person类本质同样是objc_object结构体类型，Person_IMPL结构体内部多了个struct NSObject_IMPL类型的NSObject_IVARS成员变量——即继承自NSObject的类，都有个Class类型的isa成员变量。 1.2 objc_object结构源码： 12345678910111213141516171819202122struct objc_object {private: isa_t isa; public: ... // 一些函数};union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h };#endif}; 关于isa_t的分析见上篇文章 objc_object结构体内部的方法有五十个左右，大致可分为以下几类 一些关于isa的函数，如initIsa()、getIsa()、changeIsa()等 一些弱引用的函数，如isWeaklyReferenced()、setWeaklyReferenced_nolock()等 一些内存管理函数，如retain()、release()、autorelease()等 两个关联对象函数，分别是hasAssociatedObjects()和setHasAssociatedObjects 1.3 objc_class结构同样先上源码 1234567891011121314typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... // 一些函数}; 从源码可以看出，Class是objc_class结构体类型的指针变量，继承自objc_object结构体。Class有4个成员变量，且它们在内存存储上是有序的，依次分别是： 1.isa：类型是isa_t，64位下长度为8字节，上篇已做过分析，这里略过 2.superclass：类型是Class，表示继承关系，指向当前类的父类，同样8字节 3.cache：类型是cache_t，表示缓存，用于缓存已调用的方法，加速方法的调用。其具体结构如下: 12345678910111213141516struct cache_t { struct bucket_t *_buckets; // 64位下是8字节 mask_t _mask; // 64位下是4字节 mask_t _occupied; // 64位下是4字节public: ... // 一些函数};#if __LP64__typedef uint32_t mask_t; // uint32_t 4字节 // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t; // uint16_t 2字节#endiftypedef unsigned int uint32_t; 可见，cache这个成员变量长度是16字节。 cache比较重要，关于它的分析可戳 OC源码分析之方法的缓存原理。 4.bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其结构如下 12345678struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; // unsigned longprivate: ... // 一些函数}; 其长度也是8字节。根据bits成员变量在objc_object结构体中注释的描述，它实质上是class_rw_t *加上自定义rr/alloc标志，最重要的是class_rw_t。 接下来将重点介绍它。 二、class_rw_t &amp; class_ro_t分析 rw是readwrite的意思，而ro则是readonly。 OC类中的属性、方法还有遵循的协议等信息都保存在class_rw_t中，首先看看class_rw_t的结构： 12345678910111213141516171819202122232425262728struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif ...// 一些函数};#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1 // armv7k or arm64_32#else# define SUPPORT_INDEXED_ISA 0#endif 发现class_rw_t中还有一个被const修饰的指针变量 ro，是class_ro_t结构体指针，其中存储了当前类在编译期确定的方法、成员变量、属性以及遵循的协议等信息。 1234567891011121314151617181920212223struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; ... // 一些函数}; 2.1 获取class_rw_t要想获取class_rw_t指针地址，需要知道objc_class的bits指针地址，通过对objc_class的结构分析得知，bits指针地址是objc_class首地址偏移32个字节（isa + superclass + cache = 8+8+16=32字节） 也可以从源码得知如何拿到class_rw_t指针 12345678910111213// objc_class结构体中class_rw_t *data() { return bits.data(); // bits是class_data_bits_t类型}// class_data_bits_t结构体中...class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}// 64位下#define FAST_DATA_MASK 0x00007ffffffffff8UL 在64位下，class_rw_t指针地址是在[3, 46]数据段，所以也可以用bits &amp; FAST_DATA_MASK计算出class_rw_t指针地址。 接着通过一个例子来验证class_rw_t和class_ro_t是否存储了类的信息 2.2 准备工作给Person类添加属性、方法和协议，代码如下 123456789101112131415161718192021222324252627282930313233@protocol PersonProtocol &lt;NSObject&gt;- (void)walk;@end@interface Person : NSObject &lt;PersonProtocol&gt; { NSInteger _gender;}@property (nonatomic) NSString *name;@property (nonatomic) NSInteger age;+ (void)printMyClassName;- (void)run;@end@implementation Person+ (void)printMyClassName { NSLog(@&quot;my class name is Person&quot;);}- (void)run { NSLog(@&quot;I am running.&quot;);}- (void)walk { NSLog(@&quot;I am walking.&quot;);}@end 然后打上断点 好了，准备工作完成，下面开始验证 2.3 class_rw_t验证过程1.打印Person类 1234(lldb) x/5gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x00000000000000000x100002840: 0x0000000102237404 说明： Person类首地址是0x100002820，因此，0x100002840是其bits地址（32字节就是0x20，0x100002840 = 0x100002820 + 0x20），bits内容是0x0000000102237404 0x001d8001000027f9是Person类的isa地址，指向Person元类 0x0000000100b39140是Person类的superclass地址，也就是NSObject类首地址 0x00000001003dc250 0x0000000000000000则是Person类的cache段 2.打印class_rw_t 12345678910111213141516171819202122232425262728293031323334353637// bits &amp; FAST_DATA_MASK(lldb) p (class_rw_t *)(0x0000000102237404 &amp; 0x00007ffffffffff8)(class_rw_t *) $1 = 0x0000000102237400(lldb) p *$1(class_rw_t) $2 = { flags = 2148139008 version = 0 ro = 0x0000000100002788 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002608 arrayAndFlag = 4294977032 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x0000000100002720 arrayAndFlag = 4294977312 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x00000001000025a8 arrayAndFlag = 4294976936 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000} 这里请大家留意一下class_rw_t的几个关键成员变量： ro地址是0x0000000100002788 methods的list地址是0x0000000100002608 properties的list地址是0x0000000100002720 protocols的list地址是0x0000000100002608 3.验证methods 目前来看，Person类至少有6个实例方法，分别是run、walk以及name和age的getter、setter，还有1个类方法，即printMyClassName，总计7个方法。 123456789101112131415(lldb) p (method_list_t *)0x0000000100002608 // rw的methods的list地址(method_list_t *) $7 = 0x0000000100002608(lldb) p *$7(method_list_t) $8 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 7 first = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45) } }} 正好是7个方法，让我们看看都是哪些（由于method_list_t继承自entsize_list_tt，可以通过entsize_list_tt的get()函数一一打印） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(lldb) p $8.get(0)(method_t) $9 = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45)}(lldb) p $8.get(1)(method_t) $10 = { name = &quot;.cxx_destruct&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001600 (CCTest`-[Person .cxx_destruct] at main.m:35)}(lldb) p $8.get(2)(method_t) $11 = { name = &quot;name&quot; types = 0x0000000100001eb1 &quot;@16@0:8&quot; imp = 0x0000000100001560 (CCTest`-[Person name] at main.m:27)}(lldb) p $8.get(3)(method_t) $12 = { name = &quot;setName:&quot; types = 0x0000000100001f4b &quot;v24@0:8@16&quot; imp = 0x0000000100001580 (CCTest`-[Person setName:] at main.m:27)}(lldb) p $8.get(4)(method_t) $13 = { name = &quot;age&quot; types = 0x0000000100001f56 &quot;q16@0:8&quot; imp = 0x00000001000015c0 (CCTest`-[Person age] at main.m:28)}(lldb) p $8.get(5)(method_t) $14 = { name = &quot;run&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001500 (CCTest`-[Person run] at main.m:41)}(lldb) p $8.get(6)(method_t) $15 = { name = &quot;setAge:&quot; types = 0x0000000100001f5e &quot;v24@0:8q16&quot; imp = 0x00000001000015e0 (CCTest`-[Person setAge:] at main.m:28)} 显然，class_rw_t的methods确实包含了Person类的全部实例方法，只是多了个.cxx_destruct方法。.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作，关于其原理这里略过不提。 思考：类方法printMyClassName哪里去了？ 4.验证properties 同理，Person类至少有name和age这两个属性，且看 1234567891011121314151617181920212223242526272829(lldb) p (property_list_t *)0x0000000100002720 // rw的properties的list地址(property_list_t *) $18 = 0x0000000100002720(lldb) p *$18(property_list_t) $19 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 6 first = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) }}(lldb) p $19.get(0)(property_t) $20 = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) (lldb) p $19.get(1)(property_t) $21 = (name = &quot;age&quot;, attributes = &quot;Tq,N,V_age&quot;) (lldb) p $19.get(2)(property_t) $22 = (name = &quot;hash&quot;, attributes = &quot;TQ,R&quot;) (lldb) p $19.get(3)(property_t) $23 = (name = &quot;superclass&quot;, attributes = &quot;T#,R&quot;) (lldb) p $19.get(4)(property_t) $24 = (name = &quot;description&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) (lldb) p $19.get(5)(property_t) $25 = (name = &quot;debugDescription&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) 显然name和age存储在properties中。 多余的属性也不作赘述。 5.验证protocols 在验证之前，先分析一下protocol_list_t，这个结构体并不是继承自entsize_list_tt的，其结构如下 1234567struct protocol_list_t { // count is 64-bit by accident. uintptr_t count; protocol_ref_t list[0]; // variable-size ... // 一些函数} 注意到variable-size这个注释部分（可变大小），仿佛看到了希望 123456789101112131415161718192021typedef uintptr_t protocol_ref_t; // protocol_t *, but unremappedstruct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); ... // 一些函数}; protocol_ref_t虽然未映射成protocol_t *，不过应该可以考虑一下强转，实验一下吧（这次是找到PersonProtocol协议） 1234567891011121314151617181920212223242526272829303132333435363738394041(lldb) p (protocol_list_t *)0x00000001000025a8 // rw的protocols的list地址(protocol_list_t *) $26 = 0x00000001000025a8 (lldb) p *$26(protocol_list_t) $27 = (count = 1, list = protocol_ref_t [] @ 0x00007fb5decb30f8)(lldb) p (protocol_t *)$26-&gt;list[0](protocol_t *) $32 = 0x00000001000028a8 (lldb) p *$32(protocol_t) $33 = { objc_object = { isa = { cls = Protocol bits = 4306735304 = { nonpointer = 0 has_assoc = 0 has_cxx_dtor = 0 shiftcls = 538341913 magic = 0 weakly_referenced = 0 deallocating = 0 has_sidetable_rc = 0 extra_rc = 0 } } } mangledName = 0x0000000100001d16 &quot;PersonProtocol&quot; // 出现了！！！ protocols = 0x0000000100002568 instanceMethods = 0x0000000100002580 classMethods = 0x0000000000000000 optionalInstanceMethods = 0x0000000000000000 optionalClassMethods = 0x0000000000000000 instanceProperties = 0x0000000000000000 size = 96 flags = 0 _extendedMethodTypes = 0x00000001000025a0 _demangledName = 0x0000000000000000 _classProperties = 0x0000000000000000} 功夫不负有心人，最终验证了class_rw_t的protocols中含有Person类所遵循的PersonProtocol协议。 到了这里，**class_rw_t确实存储了类的实例方法、属性和遵循的协议了。** 2.4 class_ro_t验证过程现在就剩下ro了 1.打印class_ro_t 123456789101112131415161718(lldb) p $1-&gt;ro(const class_ro_t *) $38 = 0x0000000100002788 (lldb) p *$38(const class_ro_t) $39 = { flags = 388 instanceStart = 8 instanceSize = 32 reserved = 0 ivarLayout = 0x0000000100001d2e &quot;\\x11&quot; name = 0x0000000100001d0f &quot;Person&quot; baseMethodList = 0x0000000100002608 baseProtocols = 0x00000001000025a8 ivars = 0x00000001000026b8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x0000000100002720 _swiftMetadataInitializer_NEVER_USE = {}} 有没有发现什么！**class_ro_t的方法、属性和协议的地址都与class_rw_t的一致，既然指向的是同一块内存空间，显然class_ro_t也存储了Person类的实例方法、属性和协议**。 与class_rw_t不同的是，class_ro_t多了一个ivars列表，里面存放的应该是Person类的成员变量。 2.验证ivars Person类的成员变量有：_gender、_name和_age 所幸ivar_list_t是继承自entsize_list_tt的，get()函数又可以用了。 12345678910111213141516171819202122232425262728293031323334353637383940(lldb) p $39.ivars(const ivar_list_t *const) $40 = 0x00000001000026b8(lldb) p *$40(const ivar_list_t) $41 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = { entsizeAndFlags = 32 count = 3 first = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8 } }}(lldb) p $41.get(0)(ivar_t) $42 = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(1)(ivar_t) $43 = { offset = 0x00000001000027e8 name = 0x0000000100001e8b &quot;_name&quot; type = 0x0000000100001f6b &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(2)(ivar_t) $44 = { offset = 0x00000001000027f0 name = 0x0000000100001e91 &quot;_age&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8} 完全符合预期，class_ro_t确实存储了Person类的成员变量。 2.5 rw和ro的联系为什么class_rw_t、class_ro_t的方法、属性和协议的地址一致？ 在class_data_bits_t结构体中的safe_ro()函数中发现了端倪 12345678910const class_ro_t *safe_ro() { class_rw_t *maybe_rw = data(); if (maybe_rw-&gt;flags &amp; RW_REALIZED) { // maybe_rw is rw return maybe_rw-&gt;ro; } else { // maybe_rw is actually ro return (class_ro_t *)maybe_rw; }} 可见，rw不一定是rw，也可能是ro。实际上，在编译期间，类的class_data_bits_t *bits指针指向的是class_ro_t *，然后在OC运行时调用了realizeClassWithoutSwift()（苹果开源的objc4-756.2源码是realizeClassWithoutSwift()，在此之前的版本是realizeClass()方法），这个方法主要做的就是利用编译期确定的ro来初始化rw： 12345678910111213141516171819ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // 一般走这里 // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); // 给rw申请内存 rw-&gt;ro = ro; // 设置rw的ro rw-&gt;flags = RW_REALIZED|RW_REALIZING; // 设置flags cls-&gt;setData(rw); // 给cls设置正确的rw}... // 初始化 rw 的其他字段，更新superclass、meta class// Attach categoriesmethodizeClass(cls); 在代码的最后，还调用了methodizeClass()，其源码如下 1234567891011121314151617181920212223242526272829303132333435363738static void methodizeClass(Class cls){ runtimeLock.assertLocked(); bool isMeta = cls-&gt;isMetaClass(); auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; ... // 打印信息 // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); } property_list_t *proplist = ro-&gt;baseProperties; if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1); } if (cls-&gt;isRootMetaclass()) { addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); } category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); ... // 打印信息 if (cats) free(cats); ... // 打印信息} 在这个方法里，将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、properties 和 protocols 列表中。 这就完美解释了为什么运行时rw和ro的方法、属性和协议相同。 2.6 rw和ro在运行时的不同之处目前为止的验证都是基于Person类的现有结构，也就是在编译期就确定的，突出不了class_rw_t和class_ro_t的差异性。接下来会用runtime的api在运行时为Person动态添加一个fly()方法，再来一试。 1.添加方法 具体代码如下： 12345void fly(id obj, SEL sel) { NSLog(@&quot;I am flying&quot;);}class_addMethod([Person class], NSSelectorFromString(@&quot;fly&quot;), (IMP)fly, &quot;v@:&quot;); 再加一个打印方法，用于打印类的methods 123456789101112void printMethods(Class cls) { if (cls == nil) { return ; } CCNSLog(@&quot;------------ print %@ methods ------------&quot;, NSStringFromClass(cls)); uint32_t count; Method *methods = class_copyMethodList(cls, &amp;count); for (uint32_t i = 0; i &lt; count; i++) { Method method = methods[i]; CCNSLog(@&quot;名字：%@ -- 类型：%s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method)); }} 运行一下看效果，发现添加成功，如图 2.验证过程 先打印class_rw_t，即 还有class_ro_t 对比后发现，两者的属性、协议指针地址未发生变化，但是方法的指针地址不一样了。 由于class_rw_t是运行时才初始化的，而class_ro_t在编译期间就确定了，因此可以猜测新增的fly方法存储在class_rw_t的methods指针上，class_ro_t的baseMethodList指针从编译期之后就未发生改变。 下面继续验证，首先看class_ro_t的方法列表 OK，编译期就确定的方法都在，并且没有fly方法，也就是说class_ro_t的方法列表在运行时基本没变。 class_ro_t的属性列表、成员变量列表、协议在运行时都没有发生改变。感兴趣的同学可以自己尝试验证一下。 接着看class_rw_t的方法列表 class_rw_t的methods里面数据居然都没有了？ 没办法，这里暂时留个坑吧，暂时不知道原因。 三、总结3.1 类的结构总结关于类的结构，我们了解到： 类本质上是objc_object结构体，也就是类也是对象，即万物是对象。 类都包含一个Class类型的成员变量isa Class是objc_class结构体类型的指针变量，内部有4个成员变量，即 isa：类型是isa_t superclass：类型是Class，表示继承关系，指向类的父类 cache：类型是cache_t，表示缓存，用于缓存指针和 vtable，加速方法的调用 bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其长度在64位CPU下为8字节，是个指针，指向class_rw_t * 3.2 class_rw_t和class_ro_t总结 class_ro_t存储了类在编译期确定的方法（包括其分类的）、成员变量、属性以及遵循的协议等信息，在运行时不会发生变化。编译期，类的bits指针指向的是class_ro_t指针（即此时class_rw_t 实际上是class_ro_t ）。 实例方法存储在类中 类方法存储在元类中 在realizeClassWithoutSwift()执行之后，class_rw_t才会被初始化，同时存储类的方法、属性以及遵循的协议，实际上，class_rw_t和class_ro_t两者的方法列表（或属性列表、协议列表）的指针是相同的。 运行时向类动态添加属性、方法时，会修改class_rw_t的属性列表、方法列表指针，但class_ro_t对应的属性列表、方法列表不会变。 一个待解决的坑：通过运行时添加方法（或属性、协议）改变了 class_rw_t 对应的方法列表（或属性列表、协议列表）的指针后，不知道为什么居然在 class_rw_t 的方法列表（或属性列表、协议列表）上找不到新增的方法（或属性、协议）了。 3.3 类方法的存储位置（Person类的类方法printMyClassName()） 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. 获取 Person元类(lldb) x/4gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x0000000000000000(lldb) p/x 0x001d8001000027f9 &amp; 0x00007ffffffffff8(long) $50 = 0x00000001000027f8(lldb) po 0x00000001000027f8Person // Person元类// 2. 获取 Person元类 的 bits(lldb) x/5gx 0x00000001000027f80x1000027f8: 0x001d800100b390f1 0x0000000100b390f00x100002808: 0x0000000102237440 0x00000001000000030x100002818: 0x00000001022373a0 // Person元类 的 bits// 3. 获取 Person元类 的 class_rw_t(lldb) p (class_rw_t *)(0x00000001022373a0 &amp; 0x00007ffffffffff8)(class_rw_t *) $52 = 0x00000001022373a0// 4. 验证 Person元类 的 methods(lldb) p $52-&gt;methods(method_array_t) $55 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002270 arrayAndFlag = 4294976112 } }}(lldb) p (method_list_t *)0x0000000100002270(method_list_t *) $56 = 0x0000000100002270(lldb) p *$56(method_list_t) $57 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 1 first = { name = &quot;printMyClassName&quot; // 成功找到 Person类的类方法 types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x00000001000014d0 (CCTest`+[Person printMyClassName] at main.m:37) } }} 结论：类方法 存储 在类的元类上，且位于元类的class_ro_t的baseMethodList指针上（或在class_rw_t的methods指针上）","link":"/2020/11/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03-%E5%AF%B9%E8%B1%A1&%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84/"},{"title":"05-方法的本质和消息查找流程","text":"前言 在Objective-C中，当编译器遇到一个方法调用时，它会将方法的调用变成以下函数中的一个：objc_msgSend、objc_msgSend_stret、objc_msgSendSuper和objc_msgSendSuper_stret。 发送给对象的父类的消息（使用super关键字时）是使用objc_msgSendSuper发送的，其他消息是使用objc_msgSend发送的。如果是以数据结构体作为返回值的方法，则是使用objc_msgSendSuper_stret或objc_msgSend_stret发送的。 然而这一切，都要从Runtime开始说起 一、Runtime1.1 什么是RuntimeRuntime是一套API，由c、c++、汇编一起写成的，为OC提供了运行时的特性 运行时：代码跑起来，将可执行文件装载到内存 编译时：正在编译的时间——翻译源代码将高级语言（OC、Swift）翻译成机器语言（汇编等），最后变成二进制 1.2 Runtime版本Runtime有两个版本——Legacy和Modern，苹果开发者文档都写得清清楚楚 源码中-old、__OBJC__代表Legacy版本 -new、__OBJC2__代表Modern版本，以此做兼容 1.3 Runtime的作用及调用Runtime底层经过编译会提供一套API和供FrameWork、Service使用 1.4 Runtime 调用方式 Runtime API，如 sel_registerName() NSObject API，如 isKindOf() OC上层方式，如 @selector() 原来平常在用的这么多方法都是Runtime啊，那么方法究竟是什么呢？ 二、方法的本质2.1 研究方法通过clang编译成cpp文件可以看到底层代码，得到方法的本质 兼容编译（代码少）： 1clang -rewrite-objc main.m -o main.cpp 完整编译（不报错）： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 2.2 代码转换12FXPerson *p = [FXPerson alloc];[p fly]; 转为： 12FXPerson *p = ((FXPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FXPerson&quot;), sel_registerName(&quot;alloc&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(&quot;fly&quot;)); ((FXPerson *(*)(id, SEL))(void *)是类型强转 (id)objc_getClass(&quot;FXPerson&quot;)获取FXPerson类对象 sel_registerName(&quot;alloc&quot;)等同于@selector() 那么可以理解为((类型强转)objc_msgSend)(对象, 方法调用) 去除强转后就容易分辨多了 12Person *person = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));objc_msgSend(person, sel_registerName(&quot;personInstanceMethod1&quot;)); 发现+alloc和personInstanceMethod1这两个方法的调用，实际上就是调用objc_msgSend函数。 2.3方法的本质可以在arm64.s文件中找到objc_msgSend函数的说明 1id objc_msgSend(id self, SEL _cmd, ...) 其中，第一个参数self是调用者本身，它也是接收者；第二个参数_cmd是方法编号；剩下的可变参数列表是方法自己的参数。 简单说明一下： id指的是OC对象，每个对象在内存的结构都是不确定的，但其首地址指向的是对象的isa，通过isa，在运行时就能获取到objc_class objc_class表示对象的Class，它的结构在编译后就确定了 SEL表示选择器，通常可理解为一个字符串。OC在运行时维护着一张SEL表，将字符串相同的方法名映射到唯一一个SEL上 任意类的相同方法名映射的SEL都相同（可以把SEL近似地等同于方法名） 可以通过sel_registerName(char *name)这个C函数得到SEL，OC也提供了一个语法糖@selector用来方便的调用该函数 IMP是一个函数指针。OC中的方法最终都会转换成纯C的函数，IMP表示的就是这些函数的地址。 如果外部定义了C函数并调用如void fly() {}，在clang编译之后还是fly()而不是通过objc_msgSend去调用。因为发送消息就是找函数实现的过程，而C函数可以通过函数名——指针就可以找到 从上面的例子可以得出一个结论：方法调用的本质是通过objc_msgSend函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 也就是说，下面的两段代码实际上效果是相同的 要想使用 objc_msgSend 函数，需要改一处设置。如下图： 2.4向不同对象发送消息1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/message.h&gt;@interface FXFather: NSObject- (void)walk;+ (void)run;@end@implementation FXFather- (void)walk { NSLog(@&quot;%s&quot;,__func__); }+ (void)run { NSLog(@&quot;%s&quot;,__func__); }@end@interface FXSon: FXFather- (void)jump;+ (void)swim;@end 子类FXSon有实例方法jump、类方法swim 父类FXFather有实例方法walk、类方法run ①发送实例方法 消息接收者——实例对象 12FXSon *s = [FXSon new];objc_msgSend(s, sel_registerName(&quot;jump&quot;)); ②发送类方法 消息接收者——类对象 1objc_msgSend(objc_getClass(&quot;FXSon&quot;), sel_registerName(&quot;swim&quot;)); ③向父类发送实例方法 objc_msgSend不能向父类发送消息，需要使用objc_msgSendSuper，并给objc_super结构体赋值（在objc2中只需要赋值receiver、super_class） 123456789101112131415/// Specifies the superclass of an instance. struct objc_super { /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */};#endif receiver——实例对象；super_class——父类类对象 1234struct objc_super superInstanceMethod;superInstanceMethod.receiver = s;superInstanceMethod.super_class = objc_getClass(&quot;FXFather&quot;);objc_msgSendSuper(&amp;superInstanceMethod, sel_registerName(&quot;walk&quot;)); ④向父类发送类方法 receiver——类对象；super_class——父类元类对象 1234struct objc_super superClassMethod;superClassMethod.receiver = [s class];superClassMethod.super_class = class_getSuperclass(object_getClass([s class]));objc_msgSendSuper(&amp;superClassMethod, sel_registerName(&quot;run&quot;)); 三、消息查找流程方法的查找，也叫消息的查找，它的准备工作是从objc_msgSend开始，准备就绪后，才会展开查找。 3.1开始查找打开objc源码，由于主要研究arm64结构的汇编实现，来到objc-msg-arm64.s： 找到objc_msgSend的源码： 1id objc_msgSend(id self, SEL _cmd, ...); p0表示0寄存器的指针，x0表示它的值，w0表示低32位的值（不用过多在意） ①开始objc_msgSend ②判断消息接收者是否为空，为空直接返回 ③判断tagged_pointers（之后会讲到） ④取得对象中的isa存一份到p13中（寄存器指令在逆向篇中会讲到） ⑤根据isa进行mask地址偏移得到对应的上级对象（类、元类） 查看GetClassFromIsa_p16源码： 1.macro GetClassFromIsa_p16 主要就是进行isa &amp; mask得到class操作 ⑥开始在缓存中查找imp——开启快速流程 3.2快速流程从CacheLookup开始快速查找流程（此时x0是sel，x16是class），模式是NORMAL。 1.macro CacheLookup ①#CACHE是个宏定义表示16个字节，[x16, #CACHE]表示类对象内存地址偏移16字节得到cache。 cache一分为二：8字节的buckets存放在p10，两个4字节的occupied和mask存放在p11 12#define CLASS __SIZEOF_POINTER__#define CACHE (2 * __SIZEOF_POINTER__) ②x1是sel即cmd，取出p11中的低32位（w11）：mask，两者进行与运算得到hash下标 存放在x12 ③p12先左移动(1+PTRSHIFT)，再与p10buckets相加得到新的p12——bucket ④拿出p12bucket地址所在的值，放在p17imp和p9sel中，这点可以从bucket_t的结构中看出（sel强转成key）用bucket中的sel与x1cmd作对比，如果相同则缓存命中CacheHit得到其中的imp；如果不等就跳转 12345678910111213struct bucket_t {private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ MethodCacheIMP _imp; cache_key_t _key;#else cache_key_t _key; MethodCacheIMP _imp;#endif ...} ⑤如果bucket-&gt;sel == 0则CheckMiss；比较p12bucket和p10buckets，如果不相等就将x12bucket的值进行自减操作（查找上一个bucket），跳转回④重新循环，直到bucket == buckets遍历结束跳转⑥ 123456789101112.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro ⑥平移哈希使得p12 = first bucket，再重复进行一下类似④⑤⑥的操作： 防止不断循环的过程中多线程并发的时候正好缓存更新了。 如果bucket-&gt;sel == 0走CheckMiss，如果bucket == buckets走JumpMiss，本质是一样的 1234567891011.macro JumpMiss.if $0 == GETIMP b LGetImpMiss.elseif $0 == NORMAL b __objc_msgSend_uncached.elseif $0 == LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 当NORMAL时，CheckMiss和JumpMiss都走__objc_msgSend_uncached ⑦__objc_msgSend_uncached调用MethodTableLookup ⑧保存参数调用c++方法进入慢速流程 1.macro MethodTableLookup 快速查找的过程简要总结: 快速查找完整流程图： 3.3慢速查找汇编__class_lookupMethodAndLoadCache3与c++中_class_lookupMethodAndLoadCache3相对应 12345IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls){ return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// initialize = YES , cache = NO , resolver = YESIMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // 缓存查找，cache为NO直接跳过 if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. // lock是为了防止多线程操作； 类是否被编译 runtimeLock.lock(); checkIsKnownClass(cls); // 为查找方法做准备条件，如果类没有初始化时，初始化类和父类、元类等 if (!cls-&gt;isRealized()) { realizeClass(cls); } if (initialize &amp;&amp; !cls-&gt;isInitialized()) { runtimeLock.unlock(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.lock(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 } retry: runtimeLock.assertLocked(); // Try this class's cache. // 从缓存里面查找一遍，若有直接goto done imp = cache_getImp(cls, sel); if (imp) goto done; // Try this class's method lists. // 形成局部作用域，避免局部变量命名重复 { // 在类的方法列表中查找方法，若有直接cache_fill Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; } } // Try superclass caches and method lists. { unsigned attempts = unreasonableClassCount(); // 遍历父类进行查找 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) { // Halt if there is a cycle in the superclass chain. if (--attempts == 0) { _objc_fatal(&quot;Memory corruption in class list.&quot;); } // Superclass cache. // 在父类缓存中查找，若有直接cache_fill imp = cache_getImp(curClass, sel); if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } } // Superclass method list. // 在父类的方法列表中查找方法，若有直接cache_fill Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; } } } // No implementation found. Try method resolver once. // 如果方法仍然没找到，就开始做动态方法解析 if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); // ✅ runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } // No implementation found, and method resolver didn't help. // Use forwarding. // 开始消息转发 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;} 慢速流程主要分为几个步骤： ①_class_lookupMethodAndLoadCache3调用lookUpImpOrForward，此时参数initialize=YES cache=NO resolver=YES ②runtimeLock.lock()为了防止多线程操作 ③realizeClass(cls)为查找方法做准备条件，如果类没有初始化时，初始化类和父类、元类等 ④imp = cache_getImp(cls, sel)为了容错从缓存中再找一遍，若有goto done⑨ ⑤// Try this class's method lists局部作用域中，在类的方法列表中查找方法，若有直接log_and_fill_cache并goto done⑨ ⑥// Try superclass caches and method lists局部作用域中，遍历父类：先在父类缓存中查找，若有直接log_and_fill_cache并goto done；没有再去父类的方法列表中查找方法，若有直接log_and_fill_cache并goto done⑨ ⑦如果还没找到就动态方法解析resolveMethod，标记为triedResolver = YES（已自我拯救过）。动态方法解析结束后跳转慢速流程④ ⑧如果动态方法解析完成后再找一遍仍然没找到imp，就抛出错误_objc_msgForward_impcache得到imp并cache_fill ⑨done：多线程解锁，返回imp 接下来拆解步骤进行说明： cache_getImp这个方法后续会解释 getMethodNoSuper_nolock遍历调用search_method_list查找方法列表 12345678910111213141516171819getMethodNoSuper_nolock(Class cls, SEL sel){ runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) { method_t *m = search_method_list(*mlists, sel); if (m) return m; } return nil;} search_method_list利用二分查找寻找方法 1234567891011121314151617181920212223242526272829static method_t *search_method_list(const method_list_t *mlist, SEL sel){ int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) { // 如果方法列表已经排序好了，则通过二分查找法查找方法，以节省时间 return findMethodInSortedMethodList(sel, mlist); } else { // Linear search of unsorted method list // 如果方法列表没有排序好就遍历查找 for (auto&amp; meth : *mlist) { if (meth.name == sel) return &amp;meth; } }#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) { for (auto&amp; meth : *mlist) { if (meth.name == sel) { _objc_fatal(&quot;linear search worked when binary search did not&quot;); } } }#endif return nil;} findMethodInSortedMethodList二分查找算法的具体实现（了解即可） 12345678910111213141516171819202122232425262728293031323334353637static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list){ assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // &gt;&gt;1 表示将变量n的各个二进制位顺序右移1位，最高位补二进制0 // count &gt;&gt;= 1 如果count为偶数则值变为(count / 2)；如果count为奇数则值变为(count-1) / 2 for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) { probe = base + (count &gt;&gt; 1); // 取出中间method_t的name，也就是SEL uintptr_t probeValue = (uintptr_t)probe-&gt;name; if (keyValue == probeValue) { // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // 继续向前二分查询 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) { probe--; } // 取出 probe return (method_t *)probe; } // 如果keyValue &gt; probeValue 则折半向后查询 if (keyValue &gt; probeValue) { base = probe + 1; count--; } } return nil;} log_and_fill_cache-&gt;cache_fill-&gt;cache_fill_nolock进行缓存 12345678910111213log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer){#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) { bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; }#endif cache_fill (cls, sel, imp, receiver);} resolveMethod动态方法解析——在找不到imp时的自我拯救操作 主要逻辑是是objc_msgSend函数发送SEL_resolveInstanceMethod消息，系统调用resolveInstanceMethod 发送消息后，系统会再查找一下sel方法 123456789101112131415161718void _class_resolveMethod(Class cls, SEL sel, id inst){ if (! cls-&gt;isMetaClass()) { // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { _class_resolveInstanceMethod(cls, sel, inst); } }} _objc_msgForward_impcache在汇编中调用了_objc_msgForward，然后又进入_objc_forward_handler，它在c++调用了objc_defaultForwardHandler 123456789void *_objc_forward_handler = (void*)objc_defaultForwardHandler;objc_defaultForwardHandler(id self, SEL sel){ _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);} 原来unrecognized selector sent to instance xxx是这么来的啊… 慢速查找的过程简要总结: 慢速查找完整流程图： 四、总结来到这里，已经把消息的查找介绍完毕，是时候总结一下了。 4.1方法调用的本质 方法的调用会被编译器翻译成objc_msgSend、objc_msgSendSuper、objc_msgSend_stret和objc_msgSendSuper_stret这四个函数之一，这四个函数都是由汇编代码实现的。 如果是以数据结构体作为返回值的方法，最终会转换成相应的objc_msgSend_stret或objc_msgSendSuper_stret函数 使用super关键字调用方法时，是使用objc_msgSendSuper发送的 其他的方法调用是使用objc_msgSend函数发送消息的。 方法的调用是通过objc_msgSend（或objc_msgSendSuper，或objc_msgSend_stret，或objc_msgSendSuper_stret）函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 4.2方法的查找方法的查找流程如下： 1.从objc_msgSend源码开始，会先去 类（实例方法）/元类（类方法） 的缓存中查找，如果找到IMP则返回并调用，否则会去 类/元类 的方法列表中查找 2.“步骤1”中的“缓存+方法列表”的查找方案，会遍历类的继承体系（类、类的父类、…、根类），分别进行查找，直至找到IMP为止。 如果在当前类的缓存中没找到，但是在其方法列表（或其“父类…根类”的缓存或方法列表）中找到了IMP，需要进行一次是否是消息转发的判断，如果不是消息转发，那么就对当前类的缓存进行填充操作，方便下次调用时的查找；如果是消息转发，则不会缓存到当前类中 3.如果遍历结束后依然未找到IMP，则会启动消息的解析或转发。 五、问题讨论5.1objc_msgSend为什么要用汇编编写？A：原因大致有以下几点 C语言是静态语言，无法实现参数个数、类型未知的情况下跳转到另一个任意的函数实现的功能；而汇编的寄存器可以做到这一点 汇编执行效率比C语言的高 使用汇编可以有效防止系统函数被hook，因此更为安全。 5.2为什么索引值要左移1 + PTRSHIFT位？A：在objc4-756.2源码中找到答案，但是在objc4-779.1源码版本的cache_t结构中，存在关于这个问题的解释。其部分源码如下： 12345678910111213// How much the mask is shifted by.static constexpr uintptr_t maskShift = 48; // Additional bits after the mask which must be zero. msgSend// takes advantage of these additional bits to construct the value// `mask &lt;&lt; 4` from `_maskAndBuckets` in a single instruction.static constexpr uintptr_t maskZeroBits = 4; // The largest mask value we can store.static constexpr uintptr_t maxMask = ((uintptr_t)1 &lt;&lt; (64 - maskShift)) - 1; // The mask applied to `_maskAndBuckets` to retrieve the buckets pointer.static constexpr uintptr_t bucketsMask = ((uintptr_t)1 &lt;&lt; (maskShift - maskZeroBits)) - 1; 总的来说，在64位中，mask的偏移值为48，也就是最高的16位存储mask；接着的44位是buckets指针地址，最低的4位是附加位，即 buckets的有效指针地址仅仅是64位中的[4, 47]位。在CacheLookup源码中，由_cmd &amp; mask哈希运算可以得到索引值（索引值 &lt; ((1 &lt;&lt; 16) - 1)），如果想得到这个位置的bucket，其索引值必须左移4位后，才能与buckets指针地址相加得到正确的bucket地址。 参考 Objective-C 中的消息与消息转发 Objective-C底层汇总 https://juejin.cn/post/6844904118973104135#heading-0 OC源码分析之方法的查找原理 消息查找流程 iOS探索 方法的本质和消息查找流程","link":"/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/"},{"title":"06-动态方法解析和消息转发机制","text":"前言OC中方法的调用是通过objc_msgSend（或objc_msgSendSuper，或objc_msgSend_stret，或objc_msgSendSuper_stret）函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 找IMP时先快速查找，然后慢速查找。如果慢速查找后找不到IMP，会进行方法的解析，这相当于提供一次容错处理；方法解析之后，如果依然找不到IMP，还有最后一次机会，那就是消息的转发。 我用的源码是 objc4-756.2 一、消息查找流程消息查找流程部分不再展开详述，消息慢速查找主要经过以下流程： 先查找本类缓存，再找本类方法列表 遍历父类：查找父类缓存，再找父类方法列表 遍历父类无果后就来到动态方法解析。 二、动态方法解析动态方法解析，即method resolver（又名消息的解析，也叫方法决议），方法查找失败之后就会进行，源码如下： 12345678910// 在【类...根类】的【缓存+方法列表】中都没找到IMP，进行方法解析if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); resolveMethod(cls, sel, inst); // ✅ runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry;} 它主要是调用了resolveMethod函数。resolveMethod函数处理完毕之后，还要重新执行一次retry（再走一遍方法的查找流程）。其中，triedResolver这个变量使得消息的解析只进行一次。 2.1 resolveMethod 入口源码： 1234567891011121314151617181920212223static void resolveMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 判断当前是否是元类 if (! cls-&gt;isMetaClass()) { // 类，尝试找实例方法 // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); } else { // 是元类，先找类方法 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { resolveInstanceMethod(cls, sel, inst); } }} 这里有两个分支： 非元类的话说明是类，调用实例方法，走_class_resolveInstanceMethod cls是元类的话说明调用类方法，走_class_resolveClassMethod 2.2 实例方法解析resolveInstanceMethod源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void resolveInstanceMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 去 cls 找是否实现了 resolveInstanceMethod 方法 // 如果没有实现，则直接返回，就不会给 cls 发送 resolveInstanceMethod 消息，就不会报找不到 resolveInstanceMethod if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. // NSObject中默认有实现，所以一般不会走这里。 return; } // 本类实现了类方法 resolveInstanceMethod // 当对象找不到需要调用的方法时，系统就会主动响应 resolveInstanceMethod 方法，可以在 resolveInstanceMethod 进行自定义处理 // 向本类发送SEL_resolveInstanceMethod消息，即调用这个方法 BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls // 再次去查找方法，找到就缓存并且返回，找不到就直接返回 IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); // 一些报错信息代码 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 流程分析： ①调用lookUpImpOrNil方法检查cls中是否有SEL_resolveInstanceMethod(resolveInstanceMethod)方法。NSObject类中有实现这个类方法，所以一般会接着往下走。 lookUpImpOrNil函数源码： 1234567IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;} NSObject类中实现了resolveInstanceMethod方法： 12345678// 具体搜索 NSObject.mm+ (BOOL)resolveClassMethod:(SEL)sel { return NO;}+ (BOOL)resolveInstanceMethod:(SEL)sel { return NO;} ②向本类发送SEL_resolveInstanceMethod消息，即调用这个方法。resolveInstanceMethod 是系统给我们的一次机会，让我们可以针对没有实现的 sel 进行自定义操作。 ③lookUpImpOrNil再次查找当前实例方法IMP，找到就缓存并返回，找不到就直接返回。 假如你在+(BOOL)resolveInstanceMethod:(SEL)sel中添加了sel的函数地址IMP，此时再次去查找这个IMP就能找到。 注意到两次调用lookUpImpOrNil中，resolver都是NO，因此在其调用lookUpImpOrForward时不会触发 动态方法解析，仅仅是从“类、父类、…、根类”的缓存中和方法列表中找IMP。 ④结束动态方法解析，回到lookUpImpOrForward方法将triedResolver置YES并goto retry重新查找缓存和方法列表 实例方法解析流程图： 2.3 类方法解析resolveClassMethod 和 resolveInstanceMethod 逻辑差不多，只不过类方法是去元类里处理，源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 这里的cls是元类，因为类方法存储在元类static void resolveClassMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. // 如果你没有实现类方法 +(BOOL)resolveClassMethod:(SEL)sel， // NSObject中也有实现，所以一般不会走这里 // 注意这里的第一个参数是cls，是元类 return; } Class nonmeta; { mutex_locker_t lock(runtimeLock); // 获取 元类的对象，即类。 nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) { _objc_fatal(&quot;nonmeta class %s (%p) unexpectedly not realized&quot;, nonmeta-&gt;nameForLogging(), nonmeta); } } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; // 调用类方法： +(BOOL)resolveClassMethod:(SEL)sel bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls // 再找一次imp IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); // 一些打印 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 流程如下： ①lookUpImpOrNil查找SEL_resolveClassMethod(resolveClassMethod)是否实现 ②调用类方法： +(BOOL)resolveClassMethod:(SEL)sel ③lookUpImpOrNil再次查找当前实例方法imp，找到就填充缓存并返回，找不到就直接返回 ④结束resolveClassMethod，返回到resolveMethod方法。此时lookUpImpOrNil再次查找sel的imp，若有imp则退出动态方法解析，若无则进入_class_resolveInstanceMethod开始实例方法解析，跟之前的流程一样。 ⑤ 检查cls中是否有SEL_resolveInstanceMethod(resolveInstanceMethod)方法 ⑥向本类发送SEL_resolveInstanceMethod消息 ⑦lookUpImpOrNil再次查找当前实例方法IMP，找到就缓存并返回，找不到就直接返回。 ⑧结束动态方法解析，回到lookUpImpOrForward方法将triedResolver置否并goto retry重新查找缓存和方法列表 类方法解析流程图： 2.4 动态方法决议resolveMethod中进行类方法解析之后还要在进行一次实例方法解析，这是为什么呢？ 123456789101112131415161718192021222324static void resolveMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 判断当前是否是元类 if (! cls-&gt;isMetaClass()) { // 类，尝试找实例方法 // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); } else { // 是元类，先找类方法 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // ✅为什么这里还要查找一次呢？ resolveInstanceMethod(cls, sel, inst); } }} 既然上面的对象方法决议和类方法解析都会走 _class_resolveInstanceMethod，而最终都会找到父类 NSObject里面去，那我们不就可以在 NSObject 分类里面重写 resolveInstanceMethod 方法，在这个方法里面对没有实现的方法(不管是类方法还是对象方法)进行动态添加 imp，然后就可以进行自定义处理，比如弹个框说网络不佳，或者做bug收集等。 这其实就是Objective-C提供了一种名为动态方法决议的手段，使得我们可以在运行时动态地为一个selector 提供实现。 举个例子看看： 12345678910@interface Person : NSObject+ (void)personClassMethod1;- (void)personInstanceMethod1;@end@implementation Person@end 一个简单的Person类，里面分别有一个类方法和一个实例方法，但是都没有实现。 接着添加对这两个方法的解析： 12345678910111213141516171819202122232425- (void)unimplementedMethod:(SEL)sel { NSLog(@&quot;没实现？没关系，绝不崩溃&quot;);}+ (BOOL)resolveInstanceMethod:(SEL)sel { NSLog(@&quot;动态实例方法解析：%@&quot;, NSStringFromSelector(sel)); if (sel == @selector(personInstanceMethod1)) { IMP methodIMP = class_getMethodImplementation(self, @selector(unimplementedMethod:)); Method method = class_getInstanceMethod(Person.class, @selector(unimplementedMethod:)); const char *methodType = method_getTypeEncoding(method); return class_addMethod(Person.class, sel, methodIMP, methodType); } return [super resolveInstanceMethod:sel];}+ (BOOL)resolveClassMethod:(SEL)sel { NSLog(@&quot;动态类方法解析：%@&quot;, NSStringFromSelector(sel)); if (sel == @selector(personClassMethod1)) { IMP methodIMP = class_getMethodImplementation(self, @selector(unimplementedMethod:)); Method method = class_getInstanceMethod(Person.class, @selector(unimplementedMethod:)); const char *methodType = method_getTypeEncoding(method); return class_addMethod(objc_getMetaClass(&quot;Person&quot;), sel, methodIMP, methodType); } return [super resolveClassMethod:sel];} 调用并打印： 动态方法决议总结： 实例方法可以重写resolveInstanceMethod添加imp 类方法可以在本类重写resolveClassMethod往元类添加imp，或者在NSObject分类重写resolveInstanceMethod添加imp 动态方法解析只要在任意一步lookUpImpOrNil查找到imp就不会查找下去——即本类做了动态方法决议，不会走到NSObjct分类的动态方法决议 所有方法都可以通过在NSObject分类重写resolveInstanceMethod添加imp解决崩溃 那么把所有崩溃都在NSObjct分类中处理，加以前缀区分业务逻辑，岂不是美滋滋？错！ 统一处理起来耦合度高 逻辑判断多 可能在NSObjct分类动态方法决议之前已经做了处理 SDK封装的时候需要给一个容错空间 这也不行，那也不行，那该怎么办？放心，苹果已经给我们准备好后路了！ 三、消息转发方法的调用经过了查找、解析，如果还是没有找到IMP，就会来到消息转发流程。它的入口在lookUpImpOrForward函数靠后的位置： 12345// No implementation found, and method resolver didn't help. // Use forwarding.// 开始消息转发imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst); 继续跟进，来到objc-msg-arm64.s文件中： __objc_msgForward_impcache方法中调用__objc_msgForward，最后会来到c++中_objc_forward_handler： 123456789void *_objc_forward_handler = (void*)objc_defaultForwardHandler;objc_defaultForwardHandler(id self, SEL sel){ _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);} 当我们调用一个没实现的方法时，报的错就是unrecognized selector sent to ... 但是到这里并没有结束，我们创造一个崩溃，然后看打印信息： 崩溃之前底层还调用了___forwarding___和_CF_forwarding_prep_0等方法，但是CoreFoundation库不开源，在无从下手之际，只能根据前辈们的经验开始着手——然后在logMessageSend方法中找到了探索方向(lookUpImpOrForward-&gt;log_and_fill_cache-&gt;logMessageSend) 通过logMessageSend方法我们可以看到，日志会记录在/tmp/msgSends目录下，并且通过objcMsgLogEnabled变量来控制是否存储日志： 123456789101112131415161718192021222324252627282930313233343536bool logMessageSend(bool isClassMethod, const char *objectsClass, const char *implementingClass, SEL selector){ char buf[ 1024 ]; // Create/open the log file if (objcMsgLogFD == (-1)) { // 日志会记录在/tmp/msgSends目录下 snprintf (buf, sizeof(buf), &quot;/tmp/msgSends-%d&quot;, (int) getpid ()); objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid()); if (objcMsgLogFD &lt; 0) { // no log file - disable logging // 通过objcMsgLogEnabled变量来控制是否存储日志 objcMsgLogEnabled = false; objcMsgLogFD = -1; return true; } } // Make the log entry snprintf(buf, sizeof(buf), &quot;%c %s %s %s\\n&quot;, isClassMethod ? '+' : '-', objectsClass, implementingClass, sel_getName(selector)); objcMsgLogLock.lock(); write (objcMsgLogFD, buf, strlen(buf)); objcMsgLogLock.unlock(); // Tell caller to not cache the method return false;} 紧接着他下面的instrumentObjcMessageSends方法可以改变objcMsgLogEnabled的值： 123456789101112131415161718void instrumentObjcMessageSends(BOOL flag){ bool enable = flag; // Shortcut NOP if (objcMsgLogEnabled == enable) return; // If enabling, flush all method caches so we get some traces if (enable) _objc_flush_caches(Nil); // Sync our log file if (objcMsgLogFD != -1) fsync (objcMsgLogFD); objcMsgLogEnabled = enable;} 所以，虽然我们到这里就不能查看CoreFoundation库的源代码了，但是我们可以根据以下代码来记录并查看崩溃日志（仿佛不能在源码工程中操作）： 1234567891011extern void instrumentObjcMessageSends(BOOL flag);int main(int argc, const char * argv[]) { @autoreleasepool { FXSon *son = [[FXSon alloc] init]; instrumentObjcMessageSends(true); [son doInstanceNoImplementation]; // 调用一个声明了但是没实现的方法 instrumentObjcMessageSends(false); }} 崩溃后，在访达中command+shift+G前往/tmp/msgSends，找到最新的一份日志文件（数字最大）： 打开查看后发现，在动态方法解析和doesNotRecognizeSelector崩溃之间，就是消息转发流程，分为： 快速转发forwardingTargetForSelector 慢速转发methodSignatureForSelector 3.1 消息的快速转发forwardingTargetForSelector:对应的就是消息的快速转发流程，它在源码中只是简单的返回nil（可在子类或分类中重写） 1234567+ (id)forwardingTargetForSelector:(SEL)sel { return nil;}- (id)forwardingTargetForSelector:(SEL)sel { return nil;} 不过我们可以在开发文档中找到说明（cmd + shift + 0） 概括地说，forwardingTargetForSelector:主要是返回一个新的receiver，去处理sel这个当前类无法处理的消息，如果处理不了，会转到效率低下的forwardInvocation:。 在效率方面，forwardingTargetForSelector:领先forwardInvocation:一个数量级，因此，最好不要用后者的方式处理消息的转发逻辑。 关于forwardingTargetForSelector:返回的新的receiver，需要注意一下几点： 绝对不能返回self，否则会陷入无限循环； 不处理的话，可以返回nil，或者[super forwardingTargetForSelector:sel]（非根类的情况），此时会走methodSignatureForSelector:慢速转发流程； 如果有这个receiver，此时相当于执行objc_msgSend(newReceiver, sel, ...)，那么它必须拥有和被调用的方法相同方法签名的方法（方法名、参数列表、返回值类型都必须一致）。 举例说明： Person类中： 1234567891011121314151617181920@interface Person : NSObject+ (void)personClassMethod1;- (void)personInstanceMethod1;@end@implementation Person- (id)forwardingTargetForSelector:(SEL)aSelector { NSLog(@&quot;实例方法开始转发&quot;); return [ForwardObject alloc];}+ (id)forwardingTargetForSelector:(SEL)sel { NSLog(@&quot;类方法开始转发&quot;); return [ForwardObject class];}@end ForwardObject类中： 123456789101112131415@interface ForwardObject : NSObject@end@implementation ForwardObject+ (void)personClassMethod1 { NSLog(@&quot;类方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}- (void)personInstanceMethod1 { NSLog(@&quot;实例方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}@end 显然，ForwardObject作为消息转发后的处理类，拥有Person类的同名类方法和实例方法。现在开始验证，结果如下： 事实证明确实有效！接下来看消息的慢速转发流程。 3.2 消息的慢速转发如果forwardingTargetForSelector:没有处理消息（如返回nil），就会启动慢速转发流程，也就是methodSignatureForSelector:方法，同样需要在子类或分类中重写 1234567891011// Replaced by CF (returns an NSMethodSignature)+ (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { _objc_fatal(&quot;+[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);}// Replaced by CF (returns an NSMethodSignature)- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);} 通过阅读官方文档，我们得出以下结论： methodSignatureForSelector:方法是跟forwardInvocation:方法搭配使用的，前者需要我们根据sel返回一个方法签名，后者会把这个方法签名封装成一个NSInvocation对象，并将其作为形参。 如果有目标对象能处理Invocation中的sel，Invocation可以指派这个对象处理；否则不处理。 Invocation可以指派多个对象处理 注意：消息的慢速转发流程性能较低，如果可以的话，你应该尽可能早地处理掉消息（如在方法解析时，或在消息的快速转发流程时，除非有特殊需求）。 举例说明: 这里把快速转发例子中的Person类修改一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation Person// MARK: 慢速转发--类方法+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSLog(@&quot;类方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); if (aSelector == @selector(personClassMethod1)) { return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; } return [super methodSignatureForSelector:aSelector];}+ (void)forwardInvocation:(NSInvocation *)anInvocation { SEL aSelector = [anInvocation selector]; NSLog(@&quot;类方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); id target = [ForwardObject class]; if ([target respondsToSelector:aSelector]) { [anInvocation invokeWithTarget:target]; } { else [super forwardInvocation:anInvocation]; }}// MARK: 慢速转发--实例方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSLog(@&quot;实例方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); if (aSelector == @selector(personInstanceMethod1)) { return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; } return [super methodSignatureForSelector:aSelector];}- (void)forwardInvocation:(NSInvocation *)anInvocation { SEL aSelector = [anInvocation selector]; NSLog(@&quot;实例方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); ForwardObject *obj = [ForwardObject alloc]; if ([obj respondsToSelector:aSelector]) { [anInvocation invokeWithTarget:obj]; } else { [super forwardInvocation:anInvocation]; } }@end ForwardObject类中： 123456789101112131415@interface ForwardObject : NSObject@end@implementation ForwardObject+ (void)personClassMethod1 { NSLog(@&quot;类方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}- (void)personInstanceMethod1 { NSLog(@&quot;实例方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}@end 其结果如下图所示，显然也没有崩溃: 对方法签名类型编码不熟悉的可以查看 苹果官方的类型编码介绍 3.3 消息转发的应用 - NSProxy3.3.1 模拟实现多继承【学习使用】TestProxy继承自NSProxy，TestProxy.h文件： 123456789101112#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface TestProxy : NSProxy- (instancetype)initWithObject:(id)object;- (void)transformToObject:(id)object;@endNS_ASSUME_NONNULL_END TestProxy.m： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;TestProxy.h&quot;@interface TestProxy ()// 为这个对象转发消息@property (nonatomic, weak) id object;@end@implementation TestProxy- (instancetype)initWithObject:(id)object { self.object = object; return self;}- (void)transformToObject:(id)object { self.object = object;}// 重写-methodSignatureForSelector:方法获得方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { if (self.object &amp;&amp; [self.object respondsToSelector:sel]) { return [self.object methodSignatureForSelector:sel]; } return [super methodSignatureForSelector:sel];}// 重写-forwardInvocation:为调用设置目标- (void)forwardInvocation:(NSInvocation *)invocation { SEL sel = [invocation selector]; if (self.object &amp;&amp; [self.object respondsToSelector:sel]) { [invocation invokeWithTarget:self.object]; } else { [super forwardInvocation:invocation]; }}@end ClassA类中有funcA方法，ClassB类中有funcB方法： 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ClassA : NSObject- (void)funcA;@endNS_ASSUME_NONNULL_END #import &quot;ClassA.h&quot;@implementation ClassA- (void)funcA { NSLog(@&quot;调用了funcA*************&quot;);}@end 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ClassB : NSObject- (void)funcB;@endNS_ASSUME_NONNULL_END #import &quot;ClassB.h&quot;@implementation ClassB- (void)funcB { NSLog(@&quot;调用了funcB*************&quot;);}@end 使用一下： 123456789101112131415- (void)test2 { // 变为clsA的代理，即proxy把消息转发给了clsA ClassA *clsA = [ClassA new];// TestProxy *proxy = [[TestProxy alloc] initWithObject:clsA];// [proxy performSelector:@selector(funcA)]; // 变为clsB的代理，即proxy1把消息转发给了clsB ClassB *clsB = [ClassB new]; TestProxy *proxy1 = [[TestProxy alloc] initWithObject:clsB]; [proxy1 performSelector:@selector(funcB)]; // 又把消息转发给了clsA [proxy1 transformToObject:clsA]; [proxy1 performSelector:@selector(funcA)];} 打印： 122021-01-04 17:51:33.533056+0800 Demo[62114:6062041] 调用了funcB*************2021-01-04 17:51:33.533094+0800 Demo[62114:6062041] 调用了funcA************* 结果： 就是proxy1这个对象既能调用ClassA中的方法，又能调用ClassB中的方法，看起来就像是继承自这两个类一样。 但实际上proxy1只是消息转发的中间站，实际上还是ClassA和ClassB的实例去调用各自的方法。 3.3.2 拦截方法的调用，从中实现一些我们自己需要的功能比如埋点SDK中需要实现的UITableView点击事件全埋点，就可以把NSProxy类作为UITableView的中间代理，以实现在中间拦截代理方法并在其中添加埋点事件的功能。 这里我们使用慢速消息转发，原因是苹果在官方文档中写道： 12DiscussionThis method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 1该方法用于协议的实现。在必须创建NSInvocation对象的情况下，例如在消息转发期间，也可以使用此方法。如果对象管理代理或能够处理它没有直接实现的消息，则应重写此方法以返回适当的方法签名。 我们在这里需要管理代理，所以使用慢速消息转发。 步骤： 1.自定一个XWTrackingAnalyticsDelegateProxy类，继承自NSProxy，并在其中进行拦截和消息转发。 XWTrackingAnalyticsDelegateProxy.h： 1234567891011#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface XWTrackingAnalyticsDelegateProxy : NSProxy &lt;UITableViewDelegate&gt;+ (instancetype)proxyWithTableViewDelegate:(id&lt;UITableViewDelegate&gt;)delegate;@endNS_ASSUME_NONNULL_END XWTrackingAnalyticsDelegateProxy.m： 12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;#import &quot;XWTrackingAnalysisSDK.h&quot;@interface XWTrackingAnalyticsDelegateProxy ()@property (nonatomic, weak) id delegate;@end@implementation XWTrackingAnalyticsDelegateProxy+ (instancetype)proxyWithTableViewDelegate:(id&lt;UITableViewDelegate&gt;)delegate { XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy alloc]; proxy.delegate = delegate; return proxy;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { // 返回 delegate 对象中对应的方法签名 return [(NSObject *)self.delegate methodSignatureForSelector:sel];}- (void)forwardInvocation:(NSInvocation *)invocation { // 先执行 delegate 对象中的方法 [invocation invokeWithTarget:self.delegate]; // 判断是否是 cell 的点击事件的代理方法 if (invocation.selector == @selector(tableView:didSelectRowAtIndexPath:)) { // 将方法修改为进行数据采集的方法 invocation.selector = NSSelectorFromString(@&quot;xwtracking_tableView:didSelectRowAtIndexPath:&quot;); // 执行数据采集相关的方法 [invocation invokeWithTarget:self]; }}- (void)xwtracking_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { // 数据采集相关 [XWTrackingAnalysisSDK.shareInstance trackAppClickWithTableView:tableView didSelectRowAtIndexPath:indexPath properties:nil];}@end 2.使用方法交换把代理设置为proxy UITableView+XWTracking.m： 123456789101112131415161718192021222324252627282930313233343536#import &quot;UITableView+XWTracking.h&quot;#import &quot;NSObject+XWSwizzler.h&quot;#import &lt;objc/message.h&gt;#import &quot;XWTrackingAnalysisSDK.h&quot;#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;#import &quot;UIScrollView+XWTracking.h&quot;@implementation UITableView (XWTracking)+ (void)load { [UITableView xwtracking_swizzleMethod:@selector(setDelegate:) withMethod:@selector(xwtracking_setDelegate:)];}- (void)xwtracking_setDelegate:(id&lt;UITableViewDelegate&gt;)delegate {// [self xwtracking_setDelegate:delegate]; // // 方案一：交换方法// // 交换 delegate 中的 tableView:didSelectRowAtIndexPath: 方法// [self xwtracking_swizzleDidSelectRowAtIndexPathMethodWithDelegate:delegate]; // 方案三：NSProxy 消息转发 // 销毁保存的委托对象 self.xwtracking_delegateProxy = nil; if (delegate) { XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy proxyWithTableViewDelegate:delegate]; // 保存委托对象 self.xwtracking_delegateProxy = proxy; // 调用原始方法，将代理设置为委托对象 [self xwtracking_setDelegate:proxy]; } else { // 调用原始方法，将代理设置为nil [self xwtracking_setDelegate:nil]; }}... 3.为了解决proxy这个局部变量出代码块被释放，然后proxy这个中间代理不存在的情况下还去调用代理方法时的崩溃，需要加一个对这个委托对象加一个强引用。 为了可以同时支持UICollectionView控件，直接在UIScrollView中扩展xwtracking_delegateProxy这个属性： UIScrollView+XWTracking.h： 12345678#import &lt;UIKit/UIKit.h&gt;#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;@interface UIScrollView (XWTracking)@property (nonatomic, strong) XWTrackingAnalyticsDelegateProxy *xwtracking_delegateProxy;@end UIScrollView+XWTracking.m： 1234567891011121314#import &quot;UIScrollView+XWTracking.h&quot;#include &lt;objc/runtime.h&gt;@implementation UIScrollView (XWTracking)- (void)setXwtracking_delegateProxy:(XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy { objc_setAssociatedObject(self, @selector(setXwtracking_delegateProxy:), xwtracking_delegateProxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy { return objc_getAssociatedObject(self, @selector(xwtracking_delegateProxy));}@end 至此就已经能够拦截到tableView:didSelectRowAtIndexPath:方法并且在其中埋点了。 原理图： 四、总结综上所述，当我们调用方法时： ①首先进行方法的查找 ②如果查找失败，会进行动态方法解析，此时OC会给我们一次对sel的处理机会，你可以在resolveInstanceMethod:（类方法对应resolveClassMethod:）中添加一个IMP ③如果你没把握住这次机会，也就是解析失败时，会来到消息转发阶段，这个阶段有两个机会去处理sel，分别是快速转发的forwardingTargetForSelector:，以及慢速转发的methodSignatureForSelector:。 消息快速转发阶段forwardingTargedForSelector，如果有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。 消息慢速转发阶段methodSignatureForSelector，进行方法签名，把方法丢出去，forwardInvocation来对消息处理。 ④当然，如果这些机会你都放弃了，那OC只好让程序崩溃，就进入到了doesNotRecognizeSelector报错。 下面用一副图总结方法的解析和转发流程： 五、问题讨论为什么引入消息转发机制？在一个方法被调用之前，我们是没办法确定它的实现地址的，直到运行时，这个方法被调用的时候，我们才能真正知道它是否有实现，以及其具体的实现地址。这也就是所谓的“动态绑定”。 在编译期，如果编译器发现方法不存在，会直接报错；同样，在运行时，也有doesNotRecognizeSelector的处理。 在抛出doesNotRecognizeSelector这个异常信息之前，OC利用其动态绑定的特性，引入了消息转发机制，给予了我们额外的机会处理消息（解析 or 转发），这样的做法显然更加周全合理。 参考OC源码分析之方法的解析与转发原理-红酒牛排 iOS探索 动态方法解析和消息转发机制-我是好宝宝 iOS 底层探索篇 —— 方法的转发流程-Eating iOS 带你走进消息转发流程及防崩溃处理-流年匆匆i 《iOS全埋点解决方案》","link":"/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"title":"07上-通用二进制文件和Mach-O文件","text":"前言要研究dyld的加载流程，首先要了解通用二进制文件和Mach-O文件。 一、通用二进制文件1.1 简介Universal Binary将多种架构的 Mach-O 文件合并而成。它通过 header 来记录不同架构在文件中的偏移量。系统在加载运行该程序时，会根据Universal Binary中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。 1.2 种类通用二进制的”通用”不止针对可以直接运行的可执行程序。包含以下几种： Mach-O Object 目标文件 .o Mach-O ececutable可执行文件 Mach-O dynamically 动态库文件 .a .dylib Framework Mach-O dynamic linker 动态链接器文件 dyld Mach-O dSYM companion 符号表文件.dsym，等 插一句，有动态库就有静态库，那么它们的区别是什么？看图： 静态库： 动态库： 通过上面两幅图我们可以知道： 静态库表现为：在链接阶段会将汇编生成的目标文件与引用的库一起链接打包进可执行文件中。 动态库表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用。其中，动态库分为动态链接库和动态加载库。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后，用到再去启动】 1.3 操作通用二进制文件1.3.1 查看苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行file命令可以查看它的信息： 1234$ file /usr/bin/python/usr/bin/python: Mach-O universal binary with 2 architectures/usr/bin/python (for architecture x86_64): Mach-O 64-bit executable x86_64/usr/bin/python (for architecture i386): Mach-O executable i386 1.3.2 提取系统提供了一个命令行工具lipo来操作通用二进制文件。可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。 例如提取python中x86_64版本的二进制文件可以执行： 1$ lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64 1.3.3 删除删除x86版本的二进制文件可以执行： 1$ lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64 1.3.4 瘦身或者直接瘦身为x86_64版本： 1$ lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64 1.4 源码分析下载** MachOView**，搜索fat.h，查看源码： 12345678910111213141516171819#include &lt;stdint.h&gt;#include &lt;mach/machine.h&gt;#include &lt;architecture/byte_order.h&gt;#define FAT_MAGIC 0xcafebabe#define FAT_CIGAM 0xbebafeca /* NXSwapLong(FAT_MAGIC) */struct fat_header { uint32_t magic; /* FAT_MAGIC */ uint32_t nfat_arch; /* number of structs that follow */};struct fat_arch { cpu_type_t cputype; /* cpu specifier (int) */ cpu_subtype_t cpusubtype; /* machine specifier (int) */ uint32_t offset; /* file offset to this object file */ uint32_t size; /* size of this object file */ uint32_t align; /* alignment as a power of 2 */}; fat_header结构体中： magic字段就是我们常说的魔数（例如通常判断png文件格式，还有快速求平方根的[0x5f3759df），加载器通过这个魔数值来判断这是什么样的文件，胖二进制文件的魔数值是定值0xcafebabe nfat_arch字段是指当前的胖二进制文件包含了多少个不同架构的Mach-O文件。fat_header后会跟着一个或多个连续的fat_arch，有多少个不同架构的Mach-O文件，就有多少个fat_arch。 fat_arch结构体中： cputype指定了具体的cpu类型，它的类型是cpu_type_t，定义位于mach/machine.h中。cpu的常用类型主要有如下几种： 123456789101112#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 #define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64 macOS平台上的CPU类型一般为CPU_TYPE_X86_64。 cpusubtype指定了cpu的子类型。它的类型是cpu_subtype_t。cpu子类型主要有如下几种： 1234567#define CPU_SUBTYPE_MASK 0xff000000#define CPU_SUBTYPE_LIB64 0x80000000#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_64_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_ARCH1 ((cpu_subtype_t)4)#define CPU_SUBTYPE_X86_64_H ((cpu_subtype_t)8)...... cpu子类型一般CPU_SUBTYPE_LIB64与CPU_SUBTYPE_X86_64_ALL比较常见。 offset字段指明了当前cpu架构数据相对于当前文件开头的偏移值。 size字段指明了数据的大小。 align字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。 可以使用otool工具打印本机安装的python程序的fat_header信息。如下： 123456789101112131415161718$ otool -f -V /usr/bin/pythonFat headersfat_magic FAT_MAGICnfat_arch 2architecture i386 cputype CPU_TYPE_I386 cpusubtype CPU_SUBTYPE_I386_ALL capabilities 0x0 offset 4096 size 29632 align 2^12 (4096)architecture x86_64 cputype CPU_TYPE_X86_64 cpusubtype CPU_SUBTYPE_X86_64_ALL capabilities CPU_SUBTYPE_LIB64 offset 36864 size 29872 align 2^12 (4096) 在fat_arch结构体往下就是具体的Mach-O文件格式了。 二、Mach-O文件2.1 简介Mach-O是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式。 2.2 分类Mach-O 有三种文件类型: Executable、Dylib、Bundle。 Executable 类型 executable 是 app 的二进制主文件，同时也是 app extension 的二进制主文件 我们一般可以在 Xcode 项目中的 Products 文件夹中找到它： Dylib 类型 dylib 是动态库，在其他平台也叫 DSO 或者 DLL。 Bundle 类型 现阶段 Bundle 是一种特殊类型的 dylib，你是无法对其进行链接的。你所能做的是在 Runtime 运行时去通过 dlopen 来加载它，它可以在 macOS 上用于插件。 Image 和 Framework 镜像文件包含了上述的三种文件类型。有很多东西都叫做 Framework，但在本文中，Framework 指的是一个 dylib，它周围有一个特殊的目录结构来保存该 dylib 所需的文件。 2.3 结构 通过上图，可以看出Mach-O主要由以下三部分组成： Header 描述了Mach-O的cpu架构、文件类型以及加载命令等信息 Load commands 包含区域位置、符号表、动态符号表，加载Mach-O文件时使用这里的数据确定内存分布 Data 数据段segement，包含具体代码、常量、类、方法等，有多个segment，每个segment有0到多个section，每个段有一个虚拟地址映射到进程的地址空间 2.3.1 Header** MachOView**源码中搜索loader.h并查看： 12345678910111213141516171819struct mach_header { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */};struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */}; magic：魔数，确定是64位还是32位 cputype：cpu类型 cpusubtype：cpu子类型 filetype：Mach-O支持多种文件类型，使用filetype来标注具体文件类型 ncmds：加载命令的数量 sizeofcmds：命令区域（load commands）总的字节大小 flags：标识二进制文件所支持的功能，主要与系统的加载、链接有关 2.3.2 Load commandsHeader之后是load commands加载命令段，用于解析加载命令。 1234struct load_command { uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */}; cmd：命令类型，针对不同架构有不同的结构（32位、64位） cmdsize：命令所占字节大小（32位size必须为4字节的倍数，64位size必须为8字节的倍数）。 在文件中有两个结构体segment_command和segment_command_64针对不同架构的结构体，内部设置字段相同。以segment_command_64为例： 12345678910111213struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */}; cmd：加载命令类型 LC_SEGMENT：表示这好似一个段加载命令，需要将它加载到对应的进程空间上 LC_LOAD_DYLIB：这是一个需要动态加载的链接库，它使用dylib_command结构体表示 LC_MAIN：记录了可执行文件的主函数main()的位置，它使用entry_point_command结构体表示 LC_CODE_SIGNATURE：代码签名的加载命令，描述了Mach-O的代码签名信息，它属于链接信息，使用linkedit_data_command结构体表示 cmdsize：加载命令所占内存大小 segname：存放16字节大小的段名字，当前是__PAGEZERO。 vmaddr：段的虚拟内存起始地址 vmsize：段的虚拟内存大小 fileoff：段在文件中偏移量 filesize：段在文件大小 maxprot：段页面所需要的最高内存保护（4=r,2=w,1=x） initprot：段页面初始的内存保护 nsects：段中包含section的数量 flags：其他杂项标志位 看MachOView中的loadcommands： 以上为是应用程序所有加载命令，通过上面流程能够看到对系统库的加载顺序。对比项目中引入的库文件，顺序是一致的，如下图： 以上加载命令含义如下： LC_SEGMENT_64：将文件中的段映射到进程地址空间中 LC_DYLD_INFO_ONLY：动态链接相关信息 LC_SYMTAB：符号表信息，位置、偏移、数据个数，供dyld使用 LC_DYSYMTAB：动态符号表信息，供dyld使用 LC_LOAD_DYLINKER：链接器信息，记录使用那些链接器完成内核后序的加载工作 LC_UUID：Mach-O文件的唯一标识 LC_VERSION_MIN_MACOSX：支持最低操作系统版本 LC_SOURCE_VERSION：源代码的版本号 LC_MAIN：设置主线程的入口即栈大小 LC_LOAD_DYLIB：依赖库信息，dyld通过该命令去加载依赖库 LC_FUNCTION_STARTS：函数的起始地址表 LC_CODE_SIGNATURE：代码签名 2.3.3 DataData区域由Segment段和Section节组成： segment主要有__TEXT和__DATA组成 __text：是主程序代码 __stubs、__stub_helper：是动态链接的桩 __cstring：程序中c语言字符串 __const：常量 Section含义： Section64(__TEXT,__objc_methname)：OC类名 Section64(__DATA,__objc_classlist)：OC类列表 Section64(__DATA,__objc_protollist)：OC原型列表 Section64(__DATA,__objc_imageinfo)：OC镜像信息 Section64(__DATA,__objc_selfrefs)：OC类自引用 Section64(__DATA,__objc_superrefs)：OC类超类的引用 Section64(__DATA,__ivar)：OC类成员变量 等等，都是通过section来对OC中的具体类别做加载的。 segment段分32位和64位，字段相同，以64为例如下： 1234567891011121314struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */}; sectname：是__text ,就是主程序代码 segname：该section所属的segment名，第一个是__TEXT addr：当前section在内存中的起始位置 size：当前section所占内存大小 offset：当前section的文件偏移 align：字节大小对齐 reloff：重定位入口的文件偏移，0 nreloc：需要重定位的入口数量，0 flags：包含section的type和attributes reserved1、reserved2预留字段 参考Mach-O Mach-O可执行文件 iOS 底层探索 - 应用加载","link":"/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8CMach-O%E6%96%87%E4%BB%B6/"},{"title":"07下-dyld分析","text":"前言我们平时编写的程序的入口函数都是main.m文件里面的main函数，但是这就是App的生命起点了吗？ +load方法先于main函数执行，那么main函数之前都发生了哪些有趣的事呢？ 一、静态库与动态库1.编译过程在日常开发过程中，开发者会使用成千上万次的Command + B/R进行开发调试，但可能很少有人关注过这个过程中 Xcode帮我们做了哪些事情 事实上，这个过程分解为4个步骤，分别是预处理(Prepressing)、编译(Compilation)、汇编(Assembly)和链接(Linking)——摘自《程序员的自我修养– 链接、装载与库》 在以上4个步骤中，IDE主要做了以下几件事: **预编译**：处理代码中的# 开头的预编译指令。比如删除#define并展开宏定义，将#include包含的文件插入到该指令位置等 **编译**：对预编译处理过的文件进行词法分析、语法分析和语义分析，并进行源代码优化，然后生成汇编代码 **汇编**：通过汇编器将汇编代码转换为机器可以执行的指令，并生成目标文件.o文件 **链接**：将目标文件链接成可执行文件。这一过程中，链接器将不同的目标文件链接起来，因为不同的目标文件之间可能有相互引用的变量或调用的函数，如我们经常调用Foundation框架和UIKit框架中的方法和变量，但是这些框架跟我们的代码并不在一个目标文件中，这就需要链接器将它们与我们自己的代码链接起来 Foundation和UIKit这种可以共享代码、实现代码的复用统称为库——是可执行代码的二进制文件，可以被操作系统写入内存，它又分为静态库和动态库 2.静态库静态库是指链接时完整的拷贝到可执行文件，多次使用多次拷贝，造成冗余，使包变的更大 如.a、.lib都是静态库 3.动态库动态库是指链接时不复制，程序运行时由系统加在到内存中，供系统调用，系统只需加载一次，多次使用，共用节省内存。 如.dylib、.framework都是动态库 系统的framework是动态的，开发者创建的framework是静态的 那么链接器又是什么呢？它是怎么链接不同的目标文件的呢？ 二、dyld1.dyld简介dyld(dynamic link editor / dynamic loader)是苹果的动态链接器，负责程序的链接及加载工作，是苹果操作系统的重要组成部分，存在于MacOS系统的(/usr/lib/dyld)目录下。 在应用被编译打包成可执行文件格式的Mach-O文件之后 ，交由dyld负责链接，加载程序。 2.dyld_shared_cache由于不止一个程序需要使用UIKit系统动态库，所以不可能在每个程序加载时都去加载所有的系统动态库。 为了优化程序启动速度和利用动态库缓存，苹果从iOS3.1之后，将所有系统库（私有与公有）编译成一个大的缓存文件，这就是dyld_shared_cache，该缓存文件存在iOS系统下的/System/Library/Caches/com.apple.dyld/目录下 三、dyld加载流程新建空工程，写下load方法，并在main方法和load方法分别下断点 点击函数调用栈/使用LLVM——bt指令打印，都能看到最初的起点_dyld_start 接下来通过dyld源码(版本：dyld-635.2)展开分析_dyld_start： 1._dyld_start在源码中全局搜索_dyld_start，会发现它是由汇编实现的 在arm64中，_dyld_start调用了一个看不懂的方法 从注释中得出可能是dyldbootstrap::start方法（其实在“函数调用栈”那张图中汇编代码已经把这个方法暴露出来了） 2.dyldbootstrap::start全局搜索dyldbootstrap::start并没有任何有意义结果，那么只能根据经验来瞎蒙一下了——全局搜索空格start(“侥幸”得到了结果 其实dyldbootstrap::start是指dyldbootstrap这个命名空间作用域里的 start函数 1234567891011121314151617181920212223242526272829303132333435363738uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue){ // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables slide = slideOfMainExecutable(dyldsMachHeader); bool shouldRebase = slide != 0;#if __has_feature(ptrauth_calls) shouldRebase = true;#endif if ( shouldRebase ) { rebaseDyld(dyldsMachHeader, slide); } // allow dyld to use mach messaging mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; while(*apple != NULL) { ++apple; } ++apple; // set up random value for stack canary __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);#endif // now that we are done bootstrapping dyld, call dyld's main uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);} 在start()函数中主要做了一下几件事： 根据dyldsMachHeader计算出slide， 通过slide判定是否需要重定位；这里的slide是根据ASLR技术 计算出的一个随机值，使得程序每一次运行的偏移值都不一样，防止攻击者通过固定地址发起恶意攻击 mach_init()初始化（允许dyld使用mach消息传递） 栈溢出保护 计算appsMachHeader的偏移，调用dyld::_main()函数 3.dyld::_main()点击进入dyld::_main()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue){ if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (uint64_t)mainExecutableMH, 0, 0); } // Grab the cdHash of the main executable from the environment uint8_t mainExecutableCDHashBuffer[20]; const uint8_t* mainExecutableCDHash = nullptr; // 获取主程序hash if ( hexToBytes(_simple_getenv(apple, &quot;executable_cdhash&quot;), 40, mainExecutableCDHashBuffer) ) mainExecutableCDHash = mainExecutableCDHashBuffer; // Trace dyld's load // 通知kernal内核dyld文件已加载 notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));#if !TARGET_IPHONE_SIMULATOR // Trace the main executable's load // 通知kernal内核mach-o文件已加载 notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));#endif uintptr_t result = 0; // 保存传入的可执行文件的头部（是一个struct macho_header结构体），后面根据头部访问信息 sMainExecutableMachHeader = mainExecutableMH; sMainExecutableSlide = mainExecutableSlide;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if this is host dyld, check to see if iOS simulator is being run const char* rootPath = _simple_getenv(envp, &quot;DYLD_ROOT_PATH&quot;); if ( (rootPath != NULL) ) { // look to see if simulator has its own dyld char simDyldPath[PATH_MAX]; strlcpy(simDyldPath, rootPath, PATH_MAX); strlcat(simDyldPath, &quot;/usr/lib/dyld_sim&quot;, PATH_MAX); int fd = my_open(simDyldPath, O_RDONLY, 0); if ( fd != -1 ) { const char* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result); if ( errMessage != NULL ) halt(errMessage); return result; } }#endif CRSetCrashLogMessage(&quot;dyld: launch started&quot;); // 主要功能1⃣️：根据可执行文件头部，参数等设置上下文信息 setContext(mainExecutableMH, argc, argv, envp, apple); // Pickup the pointer to the exec path. // 获取可执行文件路径 sExecPath = _simple_getenv(apple, &quot;executable_path&quot;); // &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld if (!sExecPath) sExecPath = apple[0]; // mach-o 绝对路径 if ( sExecPath[0] != '/' ) { // have relative path, use cwd to make absolute char cwdbuff[MAXPATHLEN]; if ( getcwd(cwdbuff, MAXPATHLEN) != NULL ) { // maybe use static buffer to avoid calling malloc so early... char* s = new char[strlen(cwdbuff) + strlen(sExecPath) + 2]; strcpy(s, cwdbuff); strcat(s, &quot;/&quot;); strcat(s, sExecPath); sExecPath = s; } } // Remember short name of process for later logging // 获取可执行文件的名字 sExecShortName = ::strrchr(sExecPath, '/'); if ( sExecShortName != NULL ) ++sExecShortName; else sExecShortName = sExecPath; // 主要功能1⃣️：检测进程是否受限 configureProcessRestrictions(mainExecutableMH);#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) { pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); } else#endif { // 主要功能2⃣️：检查设置环境变量 checkEnvironmentVariables(envp); // 如果DYLD_FALLBACK为nil，将其设置为默认值 defaultUninitializedFallbackPaths(envp); }#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac) &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) { gLinkContext.rootPaths = parseColonList(&quot;/System/iOSSupport&quot;, NULL); gLinkContext.marzipan = true; if ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths ) sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths; if ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths ) sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths; }#endif // 如果设置了DYLD_PRINT_OPTS环境变量，则打印参数 if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv); // 如果设置了DYLD_PRINT_ENV环境变量，则打印环境变量 if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); // 主要功能2⃣️：根据Mach-O头部获取当前运行架构信息 getHostInfo(mainExecutableMH, mainExecutableSlide); // load shared cache // 主要功能3⃣️：检查共享缓存是否开启，iOS中必须开启 checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);#if TARGET_IPHONE_SIMULATOR // &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; // &lt;/HACK&gt;#endif if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) { // 主要功能3⃣️：加载共享缓存库 mapSharedCache(); } bool cacheCompatible = (sSharedCacheLoadInfo.loadAddress == nullptr) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion); if ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) { const dyld3::closure::LaunchClosure* mainClosure = nullptr; dyld3::closure::LoadedFileInfo mainFileInfo; mainFileInfo.fileContent = mainExecutableMH; mainFileInfo.path = sExecPath; // FIXME: If we are saving this closure, this slice offset/length is probably wrong in the case of FAT files. mainFileInfo.sliceOffset = 0; mainFileInfo.sliceLen = std::numeric_limits&lt;__typeof(mainFileInfo.sliceLen)&gt;::max(); struct stat mainExeStatBuf; if ( ::stat(sExecPath, &amp;mainExeStatBuf) == 0 ) { mainFileInfo.inode = mainExeStatBuf.st_ino; mainFileInfo.mtime = mainExeStatBuf.st_mtime; } // check for closure in cache first if ( sSharedCacheLoadInfo.loadAddress != nullptr ) { mainClosure = sSharedCacheLoadInfo.loadAddress-&gt;findClosure(sExecPath); if ( gLinkContext.verboseWarnings &amp;&amp; (mainClosure != nullptr) ) dyld::log(&quot;dyld: found closure %p (size=%lu) in dyld shared cache\\n&quot;, mainClosure, mainClosure-&gt;size()); } #if !TARGET_IPHONE_SIMULATOR if ( (mainClosure == nullptr) || !closureValid(mainClosure, mainFileInfo, mainExecutableCDHash, true, envp) ) { mainClosure = nullptr; if ( sEnableClosures || isStagedApp((dyld3::MachOFile*)mainExecutableMH, sExecPath) ) { // if forcing closures, and no closure in cache, or it is invalid, check for cached closure mainClosure = findCachedLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); if ( mainClosure == nullptr ) { // if no cached closure found, build new one mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); } } } #endif // try using launch closure if ( mainClosure != nullptr ) { CRSetCrashLogMessage(&quot;dyld3: launch started&quot;); bool launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide, argc, argv, envp, apple, &amp;result, startGlue); #if !TARGET_IPHONE_SIMULATOR if ( !launched ) { // closure is out of date, build new one mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); if ( mainClosure != nullptr ) { launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide, argc, argv, envp, apple, &amp;result, startGlue); } } #endif if ( launched ) {#if __has_feature(ptrauth_calls) // start() calls the result pointer as a function pointer so we need to sign it. result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);#endif if (sSkipMain) result = (uintptr_t)&amp;fake_main; return result; } else { if ( gLinkContext.verboseWarnings ) dyld::log(&quot;dyld: unable to use closure %p\\n&quot;, mainClosure); } } } else { if ( gLinkContext.verboseWarnings ) dyld::log(&quot;dyld: not using closure because shared cache format version does not match dyld's\\n&quot;); } // could not use closure info, launch old way // install gdb notifier stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB); stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages); // make initial allocations large enough that it is unlikely to need to be re-alloced sImageRoots.reserve(16); sAddImageCallbacks.reserve(4); sRemoveImageCallbacks.reserve(4); sAddLoadImageCallbacks.reserve(4); sImageFilesNeedingTermination.reserve(16); sImageFilesNeedingDOFUnregistration.reserve(8);#if !TARGET_IPHONE_SIMULATOR#ifdef WAIT_FOR_SYSTEM_ORDER_HANDSHAKE // &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);#endif#endif try { // add dyld itself to UUID list // 主要功能4⃣️：将dyld本身添加到UUID列表 addDyldImageToUUIDList();#if SUPPORT_ACCELERATE_TABLES#if __arm64e__ // Disable accelerator tables when we have threaded rebase/bind, which is arm64e executables only for now. if (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) sDisableAcceleratorTables = true;#endif bool mainExcutableAlreadyRebased = false; if ( (sSharedCacheLoadInfo.loadAddress != nullptr) &amp;&amp; !dylibsCanOverrideCache() &amp;&amp; !sDisableAcceleratorTables &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.accelerateInfoAddr != 0) ) { struct stat statBuf; if ( ::stat(IPHONE_DYLD_SHARED_CACHE_DIR &quot;no-dyld2-accelerator-tables&quot;, &amp;statBuf) != 0 ) sAllCacheImagesProxy = ImageLoaderMegaDylib::makeImageLoaderMegaDylib(&amp;sSharedCacheLoadInfo.loadAddress-&gt;header, sSharedCacheLoadInfo.slide, mainExecutableMH, gLinkContext); }reloadAllImages:#endif CRSetCrashLogMessage(sLoadingCrashMessage); // instantiate ImageLoader for main executable // 主要功能5⃣️：实例化主程序 // 加载可执行文件并生成一个ImageLoader实例对象 // 这里调用比较深,后续再看 sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); gLinkContext.mainExecutable = sMainExecutable; gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);#if TARGET_IPHONE_SIMULATOR // check main executable is not too new for this OS { if ( ! isSimulatorBinary((uint8_t*)mainExecutableMH, sExecPath) ) { throwf(&quot;program was built for a platform that is not supported by this runtime&quot;); } uint32_t mainMinOS = sMainExecutable-&gt;minOSVersion(); // dyld is always built for the current OS, so we can get the current OS version // from the load command in dyld itself. uint32_t dyldMinOS = ImageLoaderMachO::minOSVersion((const mach_header*)&amp;__dso_handle); if ( mainMinOS &gt; dyldMinOS ) { #if TARGET_OS_WATCH throwf(&quot;app was built for watchOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #elif TARGET_OS_TV throwf(&quot;app was built for tvOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #else throwf(&quot;app was built for iOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #endif } }#endif #if __MAC_OS_X_VERSION_MIN_REQUIRED // &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries uint32_t mainSDK = sMainExecutable-&gt;sdkVersion(); gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures; #else // simulators, iOS, tvOS, and watchOS are always strict gLinkContext.strictMachORequired = true; #endif #if SUPPORT_ACCELERATE_TABLES sAllImages.reserve((sAllCacheImagesProxy != NULL) ? 16 : INITIAL_IMAGE_COUNT); #else sAllImages.reserve(INITIAL_IMAGE_COUNT); #endif // Now that shared cache is loaded, setup an versioned dylib overrides #if SUPPORT_VERSIONED_PATHS //检查库的版本是否有更新，有则覆盖原有的 checkVersionedPaths(); #endif // dyld_all_image_infos image list does not contain dyld // add it as dyldPath field in dyld_all_image_infos // for simulator, dyld_sim is in image list, need host dyld added#if TARGET_IPHONE_SIMULATOR // get path of host dyld from table of syscall vectors in host dyld void* addressInDyld = gSyscallHelpers;#else // get path of dyld itself void* addressInDyld = (void*)&amp;__dso_handle;#endif char dyldPathBuffer[MAXPATHLEN+1]; int len = proc_regionfilename(getpid(), (uint64_t)(long)addressInDyld, dyldPathBuffer, MAXPATHLEN); if ( len &gt; 0 ) { dyldPathBuffer[len] = '\\0'; // proc_regionfilename() does not zero terminate returned string if ( strcmp(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != 0 ) gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer); } // load any inserted libraries // 主要功能6⃣️：插入动态库:加载所有 DYLD_INSERT_LIBRARIES 指定的库 if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); } // record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others. sInsertedDylibCount = sAllImages.size()-1; // link main executable gLinkContext.linkingMainExecutable = true;#if SUPPORT_ACCELERATE_TABLES if ( mainExcutableAlreadyRebased ) { // previous link() on main executable has already adjusted its internal pointers for ASLR // work around that by rebasing by inverse amount sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide); }#endif // 主要功能7⃣️：链接主程序 // link调用比较深,后续来看 link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) { gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; } // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses // 主要功能7⃣️：链接主程序和所有插入的动态库 if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); } // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; // 注册符号插入 image-&gt;registerInterposing(gLinkContext); } } // &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES for (long i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) { ImageLoader* image = sAllImages[i]; if ( image-&gt;inSharedCache() ) continue; image-&gt;registerInterposing(gLinkContext); } #if SUPPORT_ACCELERATE_TABLES if ( (sAllCacheImagesProxy != NULL) &amp;&amp; ImageLoader::haveInterposingTuples() ) { // Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled ImageLoader::clearInterposingTuples(); // unmap all loaded dylibs (but not main executable) for (long i=1; i &lt; sAllImages.size(); ++i) { ImageLoader* image = sAllImages[i]; if ( image == sMainExecutable ) continue; if ( image == sAllCacheImagesProxy ) continue; image-&gt;setCanUnload(); ImageLoader::deleteImage(image); } // note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table sAllImages.clear(); sImageRoots.clear(); sImageFilesNeedingTermination.clear(); sImageFilesNeedingDOFUnregistration.clear(); sAddImageCallbacks.clear(); sRemoveImageCallbacks.clear(); sAddLoadImageCallbacks.clear(); sDisableAcceleratorTables = true; sAllCacheImagesProxy = NULL; sMappedRangesStart = NULL; mainExcutableAlreadyRebased = true; gLinkContext.linkingMainExecutable = false; resetAllImages(); goto reloadAllImages; } #endif // apply interposing to initial set of images for(int i=0; i &lt; sImageRoots.size(); ++i) { //应用符号插入 sImageRoots[i]-&gt;applyInterposing(gLinkContext); } ImageLoader::applyInterposingToDyldCache(gLinkContext); gLinkContext.linkingMainExecutable = false; // Bind and notify for the main executable now that interposing has been registered uint64_t bindMainExecutableStartTime = mach_absolute_time(); sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); uint64_t bindMainExecutableEndTime = mach_absolute_time(); ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime; gLinkContext.notifyBatch(dyld_image_state_bound, false); // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; // 递归绑定符号表 image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); } } // &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked // 弱符号绑定 sMainExecutable-&gt;weakBind(gLinkContext); // If cache has branch island dylibs, tell debugger about them if ( (sSharedCacheLoadInfo.loadAddress != NULL) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.mappingOffset &gt;= 0x78) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset != 0) ) { uint32_t count = sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsCount; dyld_image_info info[count]; const uint64_t* poolAddress = (uint64_t*)((char*)sSharedCacheLoadInfo.loadAddress + sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset); // &lt;rdar://problem/20799203&gt; empty branch pools can be in development cache if ( ((mach_header*)poolAddress)-&gt;magic == sMainExecutableMachHeader-&gt;magic ) { for (int poolIndex=0; poolIndex &lt; count; ++poolIndex) { uint64_t poolAddr = poolAddress[poolIndex] + sSharedCacheLoadInfo.slide; info[poolIndex].imageLoadAddress = (mach_header*)(long)poolAddr; info[poolIndex].imageFilePath = &quot;dyld_shared_cache_branch_islands&quot;; info[poolIndex].imageFileModDate = 0; } // add to all_images list addImagesToAllImages(count, info); // tell gdb about new branch island images gProcessInfo-&gt;notification(dyld_image_adding, count, info); } } CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;); // 初始化主程序 #if SUPPORT_OLD_CRT_INITIALIZATION // Old way is to run initializers via a callback from crt1.o if ( ! gRunInitializersOldWay ) initializeMainExecutable(); #else // run all initializers // 主要功能8⃣️：执行初始化方法！！ initializeMainExecutable(); #endif // notify any montoring proccesses that this process is about to enter main() if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); } notifyMonitoringDyldMain(); // find entry point for main executable // 主要功能9⃣️：寻找目标可执行文件入口并执行 // 从 mach-o 中读取程序入口, 主程序则读取LC_UNIXTHREAD, 就是 main.m result = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN(); if ( result != 0 ) { // main executable uses LC_MAIN, we need to use helper in libdyld to call into main() if ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= 9) ) *startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit; else halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;); } else { // main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main() // 找到真正 main 函数入口 result = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_UNIXTHREAD(); *startGlue = 0; }#if __has_feature(ptrauth_calls) // start() calls the result pointer as a function pointer so we need to sign it. result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);#endif } catch(const char* message) { syncAllImages(); halt(message); } catch(...) { dyld::log(&quot;dyld: launch failed\\n&quot;); } CRSetCrashLogMessage(&quot;dyld2 mode&quot;); if (sSkipMain) { if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); } result = (uintptr_t)&amp;fake_main; *startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit; } // 找到真正 main 函数入口后返回 return result;} dyld::_main()主要流程为： 设置上下文信息，检测进程是否受限 配置环境变量，获取当前运行架构 检查是否开启共享缓存，并加载共享缓存库 将 dyld 本身添加到 UUID 列表 实例化主程序 加载插入动态库 链接主程序和插入的库，执行符号替换 执行初始化方法 寻找主程序入口 3.1 设置上下文信息，检测进程是否受限 调用setContext函数，传入Mach-O头部以及一些参数设置上下文 configureProcessRestrictions检测进程是否受限，在上下文中做出对应处理 1234/// _main函数中setContext(mainExecutableMH, argc, argv, envp, apple);...configureProcessRestrictions(mainExecutableMH); 3.2 配置环境变量，获取当前运行架构 从环境变量中获取主要可执行文件的cdHash checkEnvironmentVariables(envp)检查设置环境变量 defaultUninitializedFallbackPaths(envp)在DYLD_FALLBACK为空时设置默认值 getHostInfo(mainExecutableMH, mainExecutableSlide)获取程序架构 1234567/// _main函数中//如果设置了DYLD_PRINT_OPTS环境变量，则打印参数if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv);//如果设置了DYLD_PRINT_ENV环境变量，则打印环境变量if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); 只要设置了这两个环境变量参数，在App启动时就会打印相关参数、环境变量信息（自行尝试） 3.3 检查是否开启共享缓存，并加载共享缓存库 checkSharedRegionDisable检查是否开启共享缓存（iOS 下不会被禁用） mapSharedCache加载共享缓存库，其中调用loadDyldCache函数有这么几种情况： 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程） 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide 共享缓存不是第一次被加载，那么就不做任何处理 3.4 将dyld本身添加到UUID列表addDyldImageToUUIDList将dyld本身添加到UUID列表 3.5 实例化主程序1sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); 实例化主程序 , 检测可执行程序格式 . 1234567891011static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path){ // try mach-o loader if ( isCompatibleMachO((const uint8_t*)mh, path) ) { ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image); return (ImageLoaderMachO*)image; } throw &quot;main executable not a known format&quot;;} isCompatibleMachO 里就会通过 header 里的 magic , cputype , cpusubtype 去检测是否兼容 instantiateMainExecutable中调用ImageLoaderMachO::sniffLoadCommands，这才是真正实例化主程序的函数 1234567891011121314151617181920212223242526// determine if this mach-o file has classic or compressed LINKEDIT and number of segments it hasvoid ImageLoaderMachO::sniffLoadCommands(const macho_header* mh, const char* path, bool inCache, bool* compressed, unsigned int* segCount, unsigned int* libCount, const LinkContext&amp; context, const linkedit_data_command** codeSigCmd, const encryption_info_command** encryptCmd){ *compressed = false; *segCount = 0; *libCount = 0; *codeSigCmd = NULL; *encryptCmd = NULL; /* ... */ // fSegmentsArrayCount is only 8-bits if ( *segCount &gt; 255 ) dyld::throwf(&quot;malformed mach-o image: more than 255 segments in %s&quot;, path); // fSegmentsArrayCount is only 8-bits if ( *libCount &gt; 4095 ) dyld::throwf(&quot;malformed mach-o image: more than 4095 dependent libraries in %s&quot;, path); if ( needsAddedLibSystemDepency(*libCount, mh) ) *libCount = 1; ...} 这里几个字段都与MachO有关： compressed：根据LC_DYLD_INFO_ONYL来决定 segCount: MachO文件中segment数量，最多不超过255个 libCount: MachO文件中依赖的动态库的数量 codeSigCmd: 签名信息 encryptCmd: 加密信息，如cryptid等 经过以上步骤 , 主程序的实例化就已经完成了 3.6 加载插入动态库123456/// _main函数中// load any inserted librariesif ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib);} 遍历DYLD_INSERT_LIBRARIES环境变量，调用loadInsertedDylib加载，通过该环境变量我们可以注入自定义的一些动态库代码从而完成安全攻防，loadInsertedDylib内部会从DYLD_ROOT_PATH、LD_LIBRARY_PATH、DYLD_FRAMEWORK_PATH等路径查找dylib并且检查代码签名，无效则直接抛出异常 3.7 链接主程序和插入的库，执行符号替换123456789101112131415161718192021// link main executablegLinkContext.linkingMainExecutable = true;link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);sMainExecutable-&gt;setNeverUnloadRecursive();if ( sMainExecutable-&gt;forceFlat() ) { gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;}if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); } for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); }} 点击进入 link 函数 , link 函数中有一系列 recursiveLoadLibraries , recursiveBindWithAccounting -&gt; recursiveBind , 也就是递归进行符号绑定的过程 . link 函数执行完毕之后 , dyld :: main 会调用 sMainExecutable-&gt;weakBind(gLinkContext); 进行弱绑定 , 懒加载绑定 , 也就是说弱绑定一定发生在 其他库链接绑定完成之后 . 绑定的过程就是我们之前分析的共享缓存绑定的过程 . 走到了这里 , 主程序已经实例化完毕 , 但还没有加载 , framework 已经加载完毕了 , 那讲到这插一句题外话 , 不同 framework , 谁先会被加载 ? 其实根据二进制顺序有关 , Xcode 中可以自由调整 : 拖动就可以自己调整顺序了 , 编译顺序就会根据这个顺序来 , 同样你可以使用 MachOView 来查看二进制顺序 . 至此 , 配置环境变量 -&gt; 加载共享缓存 -&gt; 实例化主程序 -&gt; 加载动态库 -&gt; 链接动态库 就已经完成了 . 接下来是重中之重 3.8 执行初始化方法回顾一下函数调用栈： ①initializeMainExecutable方法调用runInitializers 12345678910111213141516171819202122232425262728void initializeMainExecutable(){ // record that we've reached this step gLinkContext.startedInitializingMainExecutable = true; // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount &gt; 1 ) { for(size_t i=1; i &lt; rootCount; ++i) { sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]); } } // run initializers for main executable and everything it brings up sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); // register cxa_atexit() handler to run static terminators in all loaded images when this process exits if ( gLibSystemHelpers != NULL ) (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); // dump info if requested if ( sEnv.DYLD_PRINT_STATISTICS ) ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]); if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS ) ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);} ②runInitializers调用processInitializers为初始化做准备 12345678910111213void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo){ uint64_t t1 = mach_absolute_time(); mach_port_t thisThread = mach_thread_self(); ImageLoader::UninitedUpwards up; up.count = 1; up.images[0] = this; processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); mach_port_deallocate(mach_task_self(), thisThread); uint64_t t2 = mach_absolute_time(); fgTotalInitTime += (t2 - t1);} ③processInitializers中遍历image，recursiveInitialization递归初始化镜像 12345678910111213141516void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread, InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images){ uint32_t maxImageCount = context.imageCount()+2; ImageLoader::UninitedUpwards upsBuffer[maxImageCount]; ImageLoader::UninitedUpwards&amp; ups = upsBuffer[0]; ups.count = 0; // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. for (uintptr_t i=0; i &lt; images.count; ++i) { images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups); } // If any upward dependencies remain, init them. if ( ups.count &gt; 0 ) processInitializers(context, thisThread, timingInfo, ups);} 点进去却只有声明，shift+cmd+O搜索recursiveInitialization ④recursiveInitialization获取到镜像的初始化 1234567891011121314151617void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps){ ... uint64_t t1 = mach_absolute_time(); fState = dyld_image_state_dependents_initialized; oldState = fState; context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo); // initialize this image bool hasInitializers = this-&gt;doInitialization(context); // let anyone know we finished initializing this image fState = dyld_image_state_initialized; oldState = fState; context.notifySingle(dyld_image_state_initialized, this, NULL); ...} ⑤notifySingle获取到镜像的回调 1234567891011121314151617static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo){ ... if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) { uint64_t t0 = mach_absolute_time(); dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); uint64_t t1 = mach_absolute_time(); uint64_t t2 = mach_absolute_time(); uint64_t timeInObjC = t1-t0; uint64_t emptyTime = (t2-t1)*100; if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != NULL) ) { timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC); } } ...} notifySingle中并没有找到函数调用栈中的load_images，其实这是一个回调函数的调用 【⑥】sNotifyObjCInit在registerObjCNotifiers函数中赋值 1234567void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped){ // record functions to call sNotifyObjCMapped = mapped; sNotifyObjCInit = init; sNotifyObjCUnmapped = unmapped;} ⑦registerObjCNotifiers在_dyld_objc_notify_register函数中被调用，这个函数只在运行时提供给objc使用 1234567891011121314151617181920212223void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped){ dyld::registerObjCNotifiers(mapped, init, unmapped);}// _objc_init 调用`_dyld_objc_notify_register`，并调用`load_image`void _objc_init(void){ static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} ⑧context.notifySingle之后，调用ImageLoaderMachO::doInitialization，内部调用 doImageInit ImageLoaderMachO::doModInitFunctions ⑨doImageInit-&gt;libSystemInitialized-&gt;【根据libObjc源码分析得到】libdispatch_init-&gt;_os_object_init，内部调用_objc_init 验证： 我们直接通过 LLDB 大法来断点调试 libObjc 源码中的 _objc_init，然后通过 bt 命令打印出当前的调用堆栈，此刻一切的一切都是那么的清晰明了： ⑩doModInitFunctions内部调用__mod_init_funcs section，也就是constructor方法——C++构造方法 initializeMainExecutable总结： runInitializers-&gt;processInitializers中，遍历recursiveInitialization 第一次执行时，进行libsystem初始化——doInitialization-&gt;doImageInit-&gt; libSystemInitialized libsystem的初始化，会调用起libdispatch_init，libdispatch初始化会调用_os_object_init， 内部调用了_objc_init _objc_init中注册并保存了map_images、load_images、unmap_image函数地址 注册完毕继续回到recursiveInitialization递归下一次调用 3.9 寻找主程序入口12// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN(); 四、dyld加载过程示意图 dyld加载流程代码较多，第一次看大概了解这个过程即可 五、总结 PS我的dyld源码(版本：dyld-635.2) 参考iOS探索 浅尝辄止dyld加载流程 更深入：iOS 底层 - 从头梳理 dyld 加载流程 iOS 底层探索 - 应用加载","link":"/2021/01/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8B-dyld%E5%88%86%E6%9E%90/"},{"title":"08-类的加载过程","text":"前言：dyld加载流程（精简）由于dyld流程加载是一个比较复杂的过程，这里我们只做简单的分析。 下面是main函数之前调用堆栈的信息： 通过上面的堆栈信息我们可以简单分析出来一个流程 _dyld_start函数，是整个加载的入口。 经过dyldbooststrap::start-&gt;dyld::start-&gt;ImageLoad::-&gt;ImageLoadMackO::这些流程把MachO里面的信息读取到。 libSystem_initializer，初始化系统库。 libdispatch_init，初始化libdispatch库。 _os_object_init-&gt;::_objc_init，初始化objc库。 dyld主要的步骤都在读取MachO段里面的数据 接下来使用objc4-756.2源码进行分析 一、_objc_init流程123456789101112131415void _objc_init(void){ static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} 1.1 environ_init 函数初始化环境变量。这里我们的重点不是看源码，主要看下面： 我们可以通过在终端进行：export OBJC_HELP=1然后： ls，查看相关的环境变量，留意下面两个变量： …省略中间的部分… 我们可以在Xcode中调整这两个环境变量玩一下： 1.1.1 修改环境变量OBJC_PRINT_LOAD_METHOD为YES后 修改该环境变量之后观察控制台打印输出的结果 系统的load方法会全部打印出来。 自己定义的load方法也会打印出来，所以我们可以从这里入手，在做启动优化的时候可以快速定位调整这些load方法。 1.1.2 修改OBJC_PRINT_NONPOINTER_ISA为YES后 修改该环境变量之后观察控制台打印输出的结果 优化过的isa指针则需要&amp;上ISA_MASK才能的到类的内存地址。 关闭nonpointer之后，isa指针就不做内存优化了，所以类的内存地址和isa的内存地址就相同了。 这里也验证了02-isa原理中isa的初始化的时候，直接将类赋值isa的cls成员。 1.2 tls_init 函数tls_init()方法是关于线程key的绑定 123456789void tls_init(void){#if SUPPORT_DIRECT_THREAD_KEYS _objc_pthread_key = TLS_DIRECT_KEY; pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);#else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);#endif} 1.3 static_init 函数static_init()方法注释中提到：该方法会运行C++静态构造函数（只会运行系统级别的构造函数），在dyld调用静态构造函数之前libc会调用_objc_init，所以必须自己去实现 1234567891011121314/************************************************************************ static_init* Run C++ static constructor functions.* libc calls _objc_init() before dyld would call our static constructors, * so we have to do it ourselves.**********************************************************************/static void static_init(){ size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) { inits[i](); }} 1.4 lock_init 函数lock_init()方法是个空函数，OC的锁机制完全采用C、C++那一套 123void lock_init(void){} 1.5 exception_init 函数exception_init()初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理 1234void exception_init(void){ old_terminate = std::set_terminate(&amp;_objc_terminate);} 调用只声明不实现不作任何处理的方法，就会报错，来到_objc_terminate 1.6 _dyld_objc_notify_register 函数 通过三个函数指针直接发起回调。这里分析_dyld_objc_notify_mapped这个函数，在dyld里面通过注册函数的内存地址，然后通过函数指针又回调到了map_images这个函数。 记录保存注册函数的内存地址。 通过函数指针的形式回调这个函数即map_images,下面进入到map_images分析。 二、map_images 函数当镜像加载到内存时会触发map_image 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]){ mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);} map_images_nolock函数： map_image调用map_images_nolock，由于代码比较多，我们去掉一些无关紧要的代码，比如打印日志信息、代码的注释、iOS系统用到的，精简之后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[]){ static bool firstTime = YES; header_info *hList[mhCount]; uint32_t hCount; size_t selrefCount = 0; if (firstTime) { preopt_init(); } // Find all images with Objective-C metadata. hCount = 0; // Count classes. Size various table based on the total. int totalClasses = 0; int unoptimizedTotalClasses = 0; { uint32_t i = mhCount; while (i--) { const headerType *mhdr = (const headerType *)mhdrs[i]; auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses); if (!hi) { // no objc data in this entry continue; } if (mhdr-&gt;filetype == MH_EXECUTE) { // Size some data structures based on main executable is size#if __OBJC2__ size_t count; _getObjc2SelectorRefs(hi, &amp;count); selrefCount += count; _getObjc2MessageRefs(hi, &amp;count); selrefCount += count;#else _getObjcSelectorRefs(hi, &amp;selrefCount);#endif } hList[hCount++] = hi; } } // Perform one-time runtime initialization that must be deferred until // the executable itself is found. This needs to be done before // further initialization. // (The executable may not be present in this infoList if the // executable does not contain Objective-C code but Objective-C // is dynamically loaded later. if (firstTime) { sel_init(selrefCount); arr_init(); } if (hCount &gt; 0) { _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); } firstTime = NO;} 现在开始分析精简之后的代码 firstTime一个用static修饰的局部成员变量，记录第一次需要做的事。 _getObjc2SelectorRefs函数，从mach_o读取__objc_selrefs段的信息。 _getObjc2MessageRefs函数，从mach_o读取__objc_msgrefs段的信息。 第一次需要执行的函数preopt_init()、sel_init()、arr_init()。 _read_images()函数，读取镜像文件。 2.1 preopt_init()注释描述这里会延迟初始化，主要是共享缓存有了之后的处理。 2.2 sel_init() 去掉其他信息之后，我们可以看到是注册了一些系统提供的API。 2.3 arr_init() 这一块也是比较重要的信息，让我们知道了AutorereleasePoolPage和SideTable的初始化在这里是有执行的。 2.4 _read_images()前面的三个函数不是我们目前探索的重点，只是简单的分析了一下。下面我们开始深入_read_images()，请看接下来的类加载部分。 三、类加载入口：_read_images() 函数读取镜像文件。由于这个函数的代码比较多，我们把其中的代码先用伪代码的信息展示出来，然后再来讲解每一步。 1234567891011121314151617181920212223242526272829303132333435void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){ 1. 定义局部变量，处理第一次要做的事情。 if (!doneOnce){ ... } 2. 类的重映射 for (EACH_HEADER) { ... } 3. 修复重映射 if (!noClassesRemapped()) { ... } 4. 添加SEL到namedSelectors表 { ... } 5. 修复旧的函数指针调用遗留 for (EACH_HEADER) { ... } 6. 添加Protocol到协议表 for (EACH_HEADER) { ... } 7. 修复协议列表引用 for (EACH_HEADER) { ... } 8. 实现非懒加载的类 for (EACH_HEADER) { ... } 9. Realize newly-resolved future classes if (resolvedFutureClasses) { ... } 10. 发现和处理所有Category for (EACH_HEADER) { ... } 11. +load handled by prepare_load_methods() if (DebugNonFragileIvars) { ... }} 重要的有第1步、第2步、第11步。 3.1 第一次要做的事情 - doneOnce【重要】去掉打印部分的代码、与iOS操作系统不相干的代码。 123456789101112131415161718192021222324252627282930313233343536if (!doneOnce) { doneOnce = YES;#if SUPPORT_NONPOINTER_ISA# if SUPPORT_INDEXED_ISA# endif# if TARGET_OS_OSX# endif#endif if (DisableTaggedPointers) { disableTaggedPointers(); } initializeTaggedPointerObfuscator(); if (PrintConnecting) { _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses); } // namedClasses // Preoptimized classes do not go in this table. // 4/3 is NXMapTable is load factor int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3; gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil); ts.log(&quot;IMAGE TIMES: first time tasks&quot;); } disableTaggedPointers()函数，条件允许的时候，禁用taggedPointers。 initializeTaggedPointerObfuscator函数，初始化taggedPointer。 gdb_objc_realized_classes通过NX技术创建的mapTable，这张表里面包含的所有类的信息，我们称之为总表。 allocatedClasses通过NX技术创建的HashTable，这张表只包含已经开辟的类的信息，我们称之为已开辟类的表。 3.2 对所有类做重映射【重要】从列表中取出所有类，遍历进行处理 123456789101112131415161718192021222324252627282930313233for (EACH_HEADER) { // 从编译后的类列表中取出所有类，获取到的是一个classref_t类型的指针 classref_t *classlist = _getObjc2ClassList(hi, &amp;count); if (! mustReadClasses(hi)) { // Image is sufficiently optimized that we need not call readClass() continue; } bool headerIsBundle = hi-&gt;isBundle(); bool headerIsPreoptimized = hi-&gt;isPreoptimized(); for (i = 0; i &lt; count; i++) { // 数组中会取出OS_dispatch_queue_concurrent、OS_xpc_object、NSRunloop等系统类，例如CF、Fundation、libdispatch中的类。以及自己创建的类 Class cls = (Class)classlist[i]; // 通过readClass函数获取处理后的新类， Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); // 初始化所有懒加载的类需要的内存空间 - 现在数据没有加载到的 - 连类都没有初始化的 if (newCls != cls &amp;&amp; newCls) { // Class was moved but not deleted. Currently this occurs // only when the new class resolved a future class. // Non-lazily realize the class below. // 将懒加载的类添加到数组中 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); resolvedFutureClasses[resolvedFutureClassCount++] = newCls; } }} readClass方法会返回Class，跟进去看看具体实现 当前类的父类中若有丢失的weak-linked类，则返回nil 正常情况下不会走进popFutureNamedClass判断，这是专门针对未来的待处理的类的特殊操作，因此也不会对ro、rw进行操作（可打断点调试，创建类和系统类都不会进入） 在调用addNamedClass，addClassTableEntry方法后返回cls 将当前类添加到已创建好的gdb_objc_realized_classes哈希表（总表） 12345678910111213141516171819static void addNamedClass(Class cls, const char *name, Class replacing = nil){ runtimeLock.assertLocked(); Class old; if ((old = getClassExceptSomeSwift(name)) &amp;&amp; old != replacing) { inform_duplicate(name, old, cls); // getMaybeUnrealizedNonMetaClass uses name lookups. // Classes not found by name lookup must be in the // secondary meta-&gt;nonmeta table. addNonMetaClass(cls); } else { NXMapInsert(gdb_objc_realized_classes, name, cls); } assert(!(cls-&gt;data()-&gt;flags &amp; RO_META)); // wrong: constructed classes are already realized when they get here // assert(!cls-&gt;isRealized());} 当前类已经初始化，所以要添加到allocatedClasses哈希表(已开辟类的表) 123456789101112static void addClassTableEntry(Class cls, bool addMeta = true) { runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. assert(!NXHashMember(allocatedClasses, cls)); if (!isKnownClass(cls)) NXHashInsert(allocatedClasses, cls); if (addMeta) addClassTableEntry(cls-&gt;ISA(), false);} 3.3 修复重映射将未映射Class和Super Class重映射，调用_getObjc2ClassRefs获取类的引用，调用_getObjc2SuperRefs获取父类的引用，通过remapClassRef进行重映射 123456789101112131415// 将未映射Class和Super Class重映射，被remap的类都是非懒加载的类if (!noClassesRemapped()) { for (EACH_HEADER) { // 重映射Class，注意是从_getObjc2ClassRefs函数中取出类的引用 Class *classrefs = _getObjc2ClassRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } // fixme why doesn't test future1 catch the absence of this? classrefs = _getObjc2SuperRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } }} 3.4 添加SEL到namedSelectors表通过_getObjc2SelectorRefs拿到MachO中的静态段__objc_selrefs，遍历列表调用sel_registerNameNoLock将SEL添加到namedSelectors哈希表 123456789101112131415161718// 将所有SEL都注册到哈希表中，是另外一张哈希表// Fix up @selector referencesstatic size_t UnfixedSelectors;{ mutex_locker_t lock(selLock); for (EACH_HEADER) { if (hi-&gt;isPreoptimized()) continue; bool isBundle = hi-&gt;isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) { const char *name = sel_cname(sels[i]); // 注册SEL的操作 sels[i] = sel_registerNameNoLock(name, isBundle); } }} 3.5 修复旧的函数指针调用遗留通过_getObjc2MessageRefs获取到静态段__objc_selrefs，fixupMessageRef遍历将函数指针进行注册，并fix为新的函数指针 123456789101112131415// Fix up old objc_msgSend_fixup call sites// 修复旧的函数指针调用遗留for (EACH_HEADER) { message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) { _objc_inform(&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot; &quot;call sites in %s&quot;, count, hi-&gt;fname()); } for (i = 0; i &lt; count; i++) { // 内部将常用的alloc、objc_msgSend等函数指针进行注册，并fix为新的函数指针 fixupMessageRef(refs+i); }} 3.6 将所有Protocol都添加到protocol_map表中调用_getObjc2ProtocolList获取到__objc_protolist协议列表，readProtocol遍历添加Protocol到protocol_map哈希表 12345678910111213141516171819// Discover protocols. Fix up protocol refs.// 遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中for (EACH_HEADER) { extern objc_class OBJC_CLASS_$_Protocol; // cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类 Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; assert(cls); // 获取protocol哈希表 NXMapTable *protocol_map = protocols(); bool isPreoptimized = hi-&gt;isPreoptimized(); bool isBundle = hi-&gt;isBundle(); // 从编译器中读取并初始化Protocol protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); }} 3.7 对所有Protocol做重映射通过_getObjc2ProtocolRefs获取到__objc_protorefs（与__objc_protolist不是同一个东西）遍历remapProtocolRef修复协议，remapProtocolRef比较当前协议和协议列表中同一内存地址的协议是否相同，如果不同则替换 1234567891011// Fix up @protocol references// Preoptimized images may have the right // answer already but we don't know for sure.// 修复协议列表引用，优化后的images可能是正确的，但是并不确定for (EACH_HEADER) { // 需要注意到是，下面的函数是_getObjc2ProtocolRefs，和上面的_getObjc2ProtocolList不一样 protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapProtocolRef(&amp;protolist[i]); }} 3.8 初始化所有非懒加载的类，进行rw、ro等操作【重要】苹果官方对于非懒加载类的定义是：实现了+load方法的类是非懒加载类，否则就是懒加载类 下面是非懒加载类的加载流程: _getObjc2NonlazyClassList获取到__objc_nlclslist，取出非懒加载类 addClassTableEntry再加载一遍——如果已添加就不会添加进去，确保整个结构都被添加 realizeClassWithoutSwift是接下来要关注的地方 123456789101112131415161718192021222324252627282930313233343536373839404142// Realize non-lazy classes (for +load methods and static instances)// 实现非懒加载的类，对于load方法和静态实例变量for (EACH_HEADER) { classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); // printf(&quot;non-lazy Class:%s\\n&quot;,cls-&gt;mangledName()); if (!cls) continue; // hack for class __ARCLite__, which didn't get this above#if TARGET_OS_SIMULATOR if (cls-&gt;cache._buckets == (void*)&amp;_objc_empty_cache &amp;&amp; (cls-&gt;cache._mask || cls-&gt;cache._occupied)) { cls-&gt;cache._mask = 0; cls-&gt;cache._occupied = 0; } if (cls-&gt;ISA()-&gt;cache._buckets == (void*)&amp;_objc_empty_cache &amp;&amp; (cls-&gt;ISA()-&gt;cache._mask || cls-&gt;ISA()-&gt;cache._occupied)) { cls-&gt;ISA()-&gt;cache._mask = 0; cls-&gt;ISA()-&gt;cache._occupied = 0; }#endif addClassTableEntry(cls); if (cls-&gt;isSwiftStable()) { if (cls-&gt;swiftMetadataInitializer()) { _objc_fatal(&quot;Swift class %s with a metadata initializer &quot; &quot;is not allowed to be non-lazy&quot;, cls-&gt;nameForLogging()); } // fixme also disallow relocatable classes // We can't disallow all Swift classes because of // classes like Swift.__EmptyArrayStorage } // 实现所有非懒加载的类(实例化类对象的一些信息，例如rw) realizeClassWithoutSwift(cls); }} realizeClassWithoutSwift分析： ①rw初始化并将ro拷贝一份到rw中的ro rw表示readWrite，由于动态性，可能会往类中添加属性、方法、添加协议 ro表示readOnly，在编译时已经确定了内存 12345678910111213ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw);} ②递归调用realizeClassWithoutSwift完善继承链并处理当前类的父类、元类；如果有父类，就通过addSubclass把当前类放到父类的子类列表中去 123456789101112131415if (!cls) return nil;...supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));...// Update superclass and metaclass in case of remappingcls-&gt;superclass = supercls;cls-&gt;initClassIsa(metacls);...// Connect this class to its superclass's subclass listsif (supercls) { addSubclass(supercls, cls);} else { addRootClass(cls);} supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));递归父类的信息初始化，出口是父类为nil。 metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));递归元类的信息初始化，出口是元类的元类为自己。 if (supercls) {addSubclass(supercls, cls);} else { addRootClass(cls);}，处理class_data_bits_t成员双向绑定父类，子类。 ③remapClass中对类在表中进行查找，如果表中已有该类，则返回一个空值；如果没有则返回当前类，这样保证了类只加载一次并结束递归 123456789101112131415static Class remapClass(Class cls){ runtimeLock.assertLocked(); Class c2; if (!cls) return nil; NXMapTable *map = remappedClasses(NO); if (!map || NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) { return cls; } else { return c2; }} ④最后调用了methodizeClass 123// Attach categoriesmethodizeClass(cls);return cls; ⑤在methodizeClass中，从ro中读取方法列表（包括分类中的方法）、属性列表、协议列表写到rw中，同时也会加载分类的信息到类里面。 1234567891011121314151617181920212223242526272829...// Install methods and properties that the class implements itself.method_list_t *list = ro-&gt;baseMethods();if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1);}property_list_t *proplist = ro-&gt;baseProperties;if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1);}protocol_list_t *protolist = ro-&gt;baseProtocols;if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1);}// Root classes get bonus method implementations if they don't have // them already. These apply before category replacements.if (cls-&gt;isRootMetaclass()) { // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);}// Attach categories.category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);attachCategories(cls, cats, false /*don't flush caches*/);... 为什么要区分ro和rw？ ro的特性就是在编译时就确定了。我们不希望这些原始数据被污染，所以把这些数据存到ro中 rw的特性是可变的。因为runtime的存在，所以我们会动态的添加属性、方法、协议等，所以我们把这些数据存到可更改的rw当中 前面已经提到了实现+load方法的类就是非懒加载类，那么没有实现的类就是懒加载类。 打印非懒加载类： 可以通过printf(&quot;non-lazy Class:%s\\n&quot;,cls-&gt;mangledName())去打印获取到所有非懒加载类【只有实现了+load的类才会走到这里然后被打印（FXPerson内部实现了+load，其他都是系统内置的类）】 那么懒加载类是何时加到内存中的呢？需要看下文分析。 3.9 处理所有的分类，包括Class和Metal Class将在下一篇文章中具体介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Discover categories.// 发现和处理所有Categoryfor (EACH_HEADER) { // 外部循环遍历找到当前类，查找类对应的Category数组 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) { // 内部循环遍历当前类的所有Category category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 首先，通过其所属的类注册Category。如果这个类已经被实现，则重新构造类的方法列表。 bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { // 将Category添加到对应Class的value中，value是Class对应的所有category数组 addUnattachedCategoryForClass(cat, cls, hi); // 将Category的method、protocol、property添加到Class if (cls-&gt;isRealized()) { remethodizeClass(cls); classExists = YES; } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, cls-&gt;nameForLogging(), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); } } // 这块和上面逻辑一样，区别在于这块是对Meta Class做操作，而上面则是对Class做操作 // 根据下面的逻辑，从代码的角度来说，是可以对原类添加Category的 if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) { addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) { remethodizeClass(cls-&gt;ISA()); } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, cls-&gt;nameForLogging(), cat-&gt;name); } } }} 3.10 初始化所有未初始化的类【重要】实现所有的类。包括Swift和OC，同时会初始化其他objc_class结构体相关的信息 123456789static void realizeAllClasses(void){ runtimeLock.assertLocked(); header_info *hi; for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) { realizeAllClassesInImage(hi); // may drop and re-acquire runtimeLock }} 循环处理header_info，调用realizedAllClassesInImage()。 1234567891011121314151617181920static void realizeAllClassesInImage(header_info *hi){ runtimeLock.assertLocked(); size_t count, i; classref_t *classlist; if (hi-&gt;areAllClassesRealized()) return; classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); // 重新映射类 if (cls) { realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); } } hi-&gt;setAllClassesRealized(YES);} 循环调用realizeClassMaybeSwiftAndLeaveLocked函数 12345static ClassrealizeClassMaybeSwiftAndLeaveLocked(Class cls, mutex_t&amp; lock){ return realizeClassMaybeSwiftMaybeRelock(cls, lock, true);} realizeClassMaybeSwiftMaybeRelock函数真正调用的总入口 123456789101112131415161718192021static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) { // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls); // 非swift类 if (!leaveLocked) lock.unlock(); } else { // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); // swift类 assert(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); } return cls;} 通过判断是否Swift class来区分Swift和OC类的实现入口。 然后realizeClassWithoutSwift在3.8中分析过一次了。 PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS 底层探索篇·Easting iOS探索 类的加载过程","link":"/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"title":"09-分类、类拓展的加载过程 &amp; load、initialize分析","text":"前言在开始正文前，先看一下runtime相关知识的运用 ro和rw衍生出来的问题1.动态创建类的时候，能否先注册到内存然后再添加成员变量？即下面2、3两步能否调换顺序？ 1234567// 这是正确顺序：// 1: 动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2: 添加成员变量 class_addIvar(LGPerson, &quot;lgName&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;);// 3: 注册到内存objc_registerClassPair(LGPerson); 答：不可以 原因： 成员变量存储在ro当中，ro在编译后就不能改了。跟属性不一样 可以通过跑源码断点调试看一下： 注册到内存的objc_registerClassPair方法中会调用changeInfo方法，改变了信息。如果在这之后调用class_addIvar方法，会走到分支中，直接返回NO，导致添加失败。因此顺序不能调换。 2.注意点：动态添加property(成员属性)后，记得要添加相应的getter和setter方法，否则给属性设值会不成功。 123456789101112131415// 1.动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2.注册到内存objc_registerClassPair(LGPerson);// 3.添加propertylg_class_addProperty(LGPerson, &quot;subject&quot;);// 4.添加setter + getter 方法class_addMethod(LGPerson, @selector(setSubject:), (IMP)lgSetter, &quot;v@:@&quot;);class_addMethod(LGPerson, @selector(subject), (IMP)lgName, &quot;@@:&quot;);// 开始使用id person = [LGPerson alloc];[person setValue:@&quot;master&quot; forKey:@&quot;subject&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;subject&quot;]); 留意这里的2、3两步，先注册到内存，然后再添加的成员属性，为什么这里就可以了？ 因为properties存储在rw当中，是可以动态改变的。 3.练习使用api-用runtime动态创建类 12345678910111213141516171819202122232425// 1: 动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2: 添加成员变量 class_addIvar(LGPerson, &quot;lgName&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;);// 3: 注册到内存objc_registerClassPair(LGPerson); // 3.1 添加property - rwlg_class_addProperty(LGPerson, &quot;subject&quot;);lg_printerProperty(LGPerson);// 3.2 添加setter + getter 方法class_addMethod(LGPerson, @selector(setSubject:), (IMP)lgSetter, &quot;v@:@&quot;);class_addMethod(LGPerson, @selector(subject), (IMP)lgName, &quot;@@:&quot;);// 开始使用id person = [LGPerson alloc];[person setValue:@&quot;KC&quot; forKey:@&quot;lgName&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;lgName&quot;]);[person setValue:@&quot;master&quot; forKey:@&quot;subject&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;subject&quot;]); 带注释的相关api 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 创建类对 *superClass: 父类，传Nil会创建一个新的根类 *name: 类名 *extraBytes: 0 *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败 objc_allocateClassPair(&lt;#Class _Nullable __unsafe_unretained superclass#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t extraBytes#&gt;) *//** *添加成员变量 * *cls 往哪个类添加 *name 添加的名字 *size 大小 *alignment 对齐处理方式 *types 签名 * *这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量。 *这个类不能是元类。不支持在元类中添加一个实例变量。 *实例变量的最小对齐为1 &lt;&lt; align。实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))。 class_addIvar(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t size#&gt;, &lt;#uint8_t alignment#&gt;, &lt;#const char * _Nullable types#&gt;) *//** *往内存注册类 * * cls 要注册的类 * * objc_registerClassPair(&lt;#Class _Nonnull __unsafe_unretained cls#&gt;) *//** *往类里面添加方法 * *cls 要添加方法的类 *sel 方法编号 *imp 函数实现指针 *types 签名 * *class_addMethod(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL _Nonnull name#&gt;, &lt;#IMP _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;) *//** *往类里面添加属性 * *cls 要添加属性的类 *name 属性名字 *attributes 属性的属性数组。 *attriCount 属性中属性的数量。 * *class_addProperty(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#const objc_property_attribute_t * _Nullable attributes#&gt;, &lt;#unsigned int attributeCount#&gt;) */ 一、初探懒加载类上一章我们探索了 iOS 中类的加载，让我们简单回顾一下大概的流程。 1.1 类的加载回顾 libObjc 向 dyld 注册了回调 _dyld_objc_notify_register，当 dyld 把 App 以及 App 所依赖的一系列 Mach-O 镜像加载到当前 App 被分配的内存空间之后，dyld 会通过 _dyld_objc_notify_mapped 也就是 map_images来通知 libObjc 来完成具体的加载工作，map_images 被调用之后会来到 _read_images _read_images 主要会进行类的加载工作，会插入 所有的类 到 gdb_objc_realized_classes 哈希表中（插入方式为 类名为 key，类对象为value, 不包括通过 共享缓存 里面的类），这个表的类型为 NXMapTable，可以类比为 NSDictionary；同时还会把类插入到 allocatedClasses 这个集合里面，集合的类型为 NXHashTable，可以类比为 NSSet。 对所有的类进行重映射 将所有的 SEL 插入到 namedSelectors 哈希表中(插入方式为：SEL 名称为 key，SEL 为value) 修复函数指针遗留 将所有的 Protocol 插入到 readProtocol 哈希表中(插入方式为：Protocol 名称为 key，Protocol 为 value) 对所有的 Protocol 做重映射 初始化所有的非懒加载类，包括 rw 和 ro 的初始化操作 处理所有的分类(包括类的分类和元类的分类) 1.2 验证类的加载流程我们大致明白了类的加载流程，接下来，让我们在 _read_images 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。 准备代码：有三个非常纯净的类： LGPerson 、 LGStudent 、 LGTeacher 其中 LGStudent 和 LGTeacher 内部实现了 +load 方法。而 LGPerson 没有实现 +load 方法。 如上图所示，我们增加一行代码: 1printf(&quot;_getObjc2NonlazyClassList Class:%s\\n&quot;,cls-&gt;mangledName()); 接着我们观察打印结果: 1.3 懒加载类的发现我们这个时候观察 _read_images 源码这部分的注释: Realize non-lazy classes (for +load methods and static instances) 实现非懒加载类(实现了 +load 方法和静态实例) 意思就是没有实现 +load 方法的类就是**懒加载类，这种类并不会在 **_read_images 环节被加载。我们自己实现了 +load 方法的两个类和其他系统内置的类由于是非懒加载类，所以会在这里打印。 那么懒加载类应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送 alloc 消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会走消息的慢速查找过程，然后就来到一个非常重要的方法：lookUpImpOrForward ，我们在 main.m 中 LGPerson 类初始化的地方和 lookUpImpOrForward 入口处打上断点: Tips: 这里有个小技巧，我们先打开 main.m 文件中lookUpImpOrForward 处的断点的断点，等断点来到了我们想要探索的 LGPerson 初始化的位置的时候，我们再打开 lookUpImpOrForward 处的断点，这样才能确保当前执行 lookUpImpOrForward 的是我们的研究对象 LGPerson 因为我们断点的位置是 LGPerson 类发送 alloc 消息，而显然 alloc 作为类方法是存储在元类上的，也就是说 lookUpImpOrForward 的 cls 其实是 LGPerson 元类。那么 inst 就应该是真正的LGPerson类对象，可实际如下图所示：（未初始化所以看不出是哪个类） 此时的 inst 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码: 这里的 if 判断通过方法名我们不难看出是只有当 cls 未实现的时候才会走里面的realizeClassMaybeSwiftAndLeaveLocked 方法，那也就是说 LGPerson 元类没有被实现，也就是 LGPerson 类没有实现或者说没有被加载。 我们就顺着 realizeClassMaybeSwiftAndLeaveLocked 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的: 123456789101112131415161718192021static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) { // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls); if (!leaveLocked) lock.unlock(); } else { // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); assert(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); } return cls;} 我们一路跟随断点来到了 realizeClassMaybeSwiftMaybeRelock 方法，然后我们看到了我们熟悉的一个方法 realizeClassWithoutSwift ，这个方法内部会进行 ro/rw 的赋值操作以及 category 的 attatch ，关于这个方法更多内容可以查看上一篇文章。 接着我们返回到 lookUpImpOrForward 方法中来，然后进行一下 LLDB 打印，看一下当前这个 inst 也就是 LGPerson 对象是否已经被加载了。 通过上面的打印，我们可以看到 rw 已经有值了，也就是说 LGPerson 类被加载了。 总结： 如果类没有实现 load 方法，那么这个类就是懒加载类（用到再加载） 如果类实现了 load 方法，那么这个类就是非懒加载类（提前加载）。 调用堆栈如下图所示： 1.4 懒加载类的流程关于非懒加载类的加载流程我们已经很熟悉了，我们总结下懒加载类的流程： 类第一次发送消息的时候是没有缓存的，所以会来到 _class_lookupMethodAndLoadCache3 （这个方法在05-方法的本质和消息查找流程已经分析过了） _class_lookupMethodAndLoadCache3 会调用 lookUpImpOrForward ，这个方法在学习 Runtime 的过程中非常重要！ lookUpImpOrForward 内部会进行一下判断，如果 cls 没有被实现，会调用 realizeClassMaybeSwiftAndLeaveLocked 方法 realizeClassMaybeSwiftAndLeaveLocked 方法又会调用 realizeClassMaybeSwiftMaybeRelock 方法 realizeClassMaybeSwiftMaybeRelock 方法内部会进行一下是否是 Swift 的判断，如果不是 Swift 环境的话，就会来到 realizeClassWithoutSwift ，最终懒加载的类就在这里加载 二、分类的底层实现类分为懒加载类和非懒加载类，分类同样分为懒加载分类和非懒加载分类。在研究分类之前，我们首先需要了解下分类的底层实现。 2.1 重写分类源文件首先准备一份LGTeacher+test.m文件： 在终端中用 clang 命令重写这个分类文件为c++文件： 1clang -rewrite-objc LGTeacher+test.m -o category.cpp 然后查看 category.cpp 这个文件，来到文件尾部可以看到: 123456789static struct _category_t _OBJC_$_CATEGORY_LGTeacher_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = { &quot;LGTeacher&quot;, 0, // &amp;OBJC_CLASS_$_LGTeacher, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,}; 可以看到 LGTeacher+test 分类在底层的实现是一个结构体，其名字为 _OBJC_$_CATEGORY_LGTeacher_$_test ，很明显这是一个按规则生成的符号，中间的 LGTeacher 是类名，后面的 test 是分类的名字。 同时，我们在后面可以看到如下的代码： 123static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= { &amp;_OBJC_$_CATEGORY_LGTeacher_$_test,}; 这表明分类是存储在 __DATA 段的 __objc_catlist section 里面的。 2.2 分类的定义我们根据 _category_t 来到 libObjc 源码中进行查找，不过我们需要去掉一下 _category_t 的下划线，然后不难找到分类真正的定义所在： 1234567891011121314151617struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);}; 根据刚才 clang 重写之后的内容，我们不难看出 name : 是分类所关联的类，也就是类的名字，而不是分类的名字 cls : 我们在前面可以看到 clang 重写后这个值为 0，但是后面有注释为 &amp;OBJC_CLASS_$_LGTeacher ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在 instanceMethods : 分类上存储的实例方法 classMethods ：分类上存储的类方法 protocols ：分类所实现的协议 instanceProperties ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的 _classProperties ：分类所定义的类属性。 三、分类的加载我们现在知道了类分为了 懒加载类 和 非懒加载类 ，它们的加载时机是不一样的，分类同样分为懒加载分类和非懒加载分类。 分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。 接下来开始研究： 3.1 懒加载分类没有实现 load 的分类-&gt;没有提前加载，所以是懒加载分类。 3.1.1 懒加载分类 + 懒加载类也就是类和分类都不实现 load 方法的情况。 懒加载类前面分析过了，在向类第一次发送消息的时候，懒加载类才会开始加载。 懒加载分类探索：在 realizeClassWithoutSwift 方法的最后有一个 methodizeClass 方法，在这个方法里面会有一个 Attach categories 的地方，猜测懒加载分类是不是在这里加载了？ 但是我们断点之后发现这个时候通过 unattachedCategoriesForClass 方法并没有取到分类。此时通过 LLDB 打印一下当前类里面是否已经把分类的内容附加上了。前面的流程大家都很熟悉了，我们直接看 cls 的 rw 中的 methods 是否有内容： 此时 LGTeacher 类里面是没有方法的，这里读取 rw 却有一个结果，我们不难看出这是位于 LGTeacher+test 分类中的一个 initialize 方法，这个方法是我手动加到这个分类的。 这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 unattachedCategoriesForClass ，而是直接在编译时加载到了类的 ro 里面，然后在运行时被拷贝到了类的 rw 里面。这一点可以通过下面的 LLDB 打印来证明。 突然想起来，不是在 _read_images 的最后那块有一个 Discover categories 吗，万一懒加载分类是在这里加载的呢？我们一试便知： 这里在 Discover categories 内部做了一下判断，如果是 LGTeacher 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的，是在编译时直接加载的。 3.1.2 懒加载分类+非懒加载类非懒加载类当类为非懒加载类的时候，同样是走 _read_images =&gt;Realize non-lazy classes=&gt;realizeClassWithoutSwift=&gt;methodizeClass。 懒加载分类我们直接在 methodizeClass 方法中打上断点，并做了一下简单的判断: 12345const char *cname = ro-&gt;name;const char *oname = &quot;LGTeacher&quot;;if (strcmp(cname, oname) == 0) { printf(&quot;methodizeClass :%s \\n&quot;,cname);} 结果可以看到cats为空，所以分类不在这进行添加。 同时通过 LLDB 打印，发现分类的方法已经在类的 ro 里面了，说明懒加载的分类在编译时期就被加载了。 3.1.3 懒加载分类总结 懒加载分类的初始化其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。 懒加载类和非懒加载类还是1.3中所述的流程。 3.2 非懒加载分类实现了 load 的分类-&gt;提前加载，所以是非懒加载分类 他和类配合加载分下面两种情况： 非懒加载分类与懒加载类 非懒加载分类和非懒加载类 3.2.1 非懒加载分类 + 懒加载类懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在lookupImpOrForward =&gt;realizeClassMaybeSwiftAndLeaveLocked =&gt; realizeClassMaybeSwiftMaybeRelock =&gt; realizeClassWithoutSwift =&gt; methodizeClass 流程中的 methodizeClass 打上断点，看下在这里分类会不会被加载： 这一次通过 unattachedCategoriesForClass 取出来值了，并且在这之前 cls 的 ro 中并没有分类的 initialize 方法： 但是我们注意观察此时的调用堆栈： 为什么走的是 load_images 里面的 prepare_load_methods 方法呢？我们来到 prepare_load_methods 方法处： 可以看到，其实在这里调用了 realizeClassWithoutSwift 方法来提前加载类。 而上面的 _getObjc2NonlazyCategoryList 方法显示就是获取到所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。 这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类并不一定只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么类就是在 load_images =&gt; prepare_load_methods =&gt; realizeClassWithoutSwift 加载的。 分类的加载在类加载之后的 methodizeClass。 3.2.2 非懒加载分类 + 非懒加载类非懒加载类的流程我们也十分熟悉了，在 _read_images 里面进行加载。而此时，分类也是非懒加载。我们还是在 methodizeClass 里面进行断点： 结果如上图所示，这次从 unattachedCategoriesForClass 方法取出来的是 NULL 值，显然分类不是在这个地方被加载的，我们回到 _read_images 方法，还记得那个 Discover categories 流程吗，我们打开里面的断点： 因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 remethodizeClass 方法，我们进入其内部实现： 1234567891011121314151617181920static void remethodizeClass(Class cls){ category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) { if (PrintConnecting) { _objc_inform(&quot;CLASS: attaching categories to class '%s' %s&quot;, cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;); } attachCategories(cls, cats, true /*flush caches*/); free(cats); }} 可以看到有一个 attachCategories 方法，断点也确实来到了这个地方，所以非懒加载分类在这里加载。 3.2.3 非懒加载分类总结 非懒加载分类 + 懒加载类 类的加载在 load_images 处 ，分类的加载在类加载之后的 methodizeClass 非懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载在类加载之后的 reMethodizeClass 3.3 总结分类的加载其实可以笼统的分为实现 load 方法和没有实现 load 方法： 没有实现 load 方法的分类（不需提前加载-懒加载分类）由编译时确定 实现了 load 方法的分类（需提前加载-非懒加载分类）由运行时去确定 这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论： 懒加载分类 + 懒加载类 类的加载在第一次消息发送的时候，而分类的加载则在编译时 懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载还是在编译时 非懒加载分类 + 懒加载类 类的加载在 load_images 内部，分类的加载在类加载之后的 methodizeClass 非懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载在类加载之后的 reMethodizeClass 四、类拓展的加载类拓展extension又称作匿名的分类，为了给当前类增加属性和方法 具体有两种形式： 直接在.m文件中新增类拓展 新建类拓展的.h文件 4.1 类拓展的加载数据很早的时候都会来到_read_image，在这里断点分析一下： 但是仔细一想不对呀，已经在类中有了方法实现了，此时的do_hExtension不足以说明问题 那么可以通过查看属性的setter和getter方法来验证 在来到_read_image方法之前就有了相应的getter和setter，说明 类拓展在编译时便作为类的一部分进行编译，存到类的ro中 4.2 类拓展的细节点如果类拓展没有被引用（#import）-在代码中没有被用到，就不会编译到到内存中 五、load_image分析上篇文章讲到dyld初始化image会触发load_image，本文又提到了懒加载类和非懒加载分类情况下，分类加载到内存时的调用栈中有load_image，那么我们在该种情况下进行探索。 在load_image实现处打下断点，发现类和分类都没有打印+load方法——load_image先于+load方法 接着把目光移向两条注释： Discover load methods——prepare_load_methods Call +load methods——call_load_methods 5.1 prepare_load_methods发现并准备+load方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void prepare_load_methods(const headerType *mhdr){ size_t count, i; runtimeLock.assertLocked(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { schedule_class_load(remapClass(classlist[i])); } category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class if (cls-&gt;isSwiftStable()) { _objc_fatal(&quot;Swift class extensions and categories on Swift &quot; &quot;classes are not allowed to have +load methods&quot;); } realizeClassWithoutSwift(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); }}/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls){ if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); }/************************************************************************ add_class_to_loadable_list* Class cls has just become connected. Schedule it for +load if* it implements a +load method.**********************************************************************/void add_class_to_loadable_list(Class cls){ IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don't bother if cls has no +load method if (PrintLoading) { _objc_inform(&quot;LOAD: class '%s' scheduled for +load&quot;, cls-&gt;nameForLogging()); } if (loadable_classes_used == loadable_classes_allocated) { loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); } loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;} prepare_load_methods分析： 通过_getObjc2NonlazyClassList获取非懒加载类列表 通过schedule_class_load遍历这些类 递归调用遍历父类的+load方法，确保父类的+load方法顺序排在子类的前面 调用add_class_to_loadable_list把类的+load方法存在loadable_classes里面 调用_getObjc2NonlazyCategoryList取出非懒加载分类列表 遍历分类列表 通过realizeClassWithoutSwift来防止类没有初始化（若已经初始化了则不影响） 调用add_category_to_loadable_list加载分类中的+load方法到loadable_categories 此时就能看懂之前懒加载类和非懒加载分类的函数调用栈了 5.2 call_load_methods唤醒+load方法 1234567891011121314151617181920212223242526272829void call_load_methods(void){ static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do { // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) { call_class_loads(); } // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories } while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;} 通过objc_autoreleasePoolPush压栈一个自动释放池 do-while循环开始 循环调用类的+load方法直到找不到为止 调用一次分类中的+load方法 通过objc_autoreleasePoolPop出栈一个自动释放池 5.3 关于load方法我们需要知道的 load方法在main函数前调用 如果一个类实现了load方法，在调用这个方法前会先调用父类的load方法 因为加载时间特别早，所以可以利用这个特性进行一些特殊处理 六、initalize分析关于initalize苹果文档是这么描述的 1.在类或者其子类的第一个方法被调用前（发送消息前）调用2.父类的调用在子类之前补充：通常应该在里面判断当前要初始化的类，防止多次调用 然后我们在objc源码中lookUpImpOrForward找到了它的踪迹 lookUpImpOrForward-&gt;initializeAndLeaveLocked-&gt;initializeAndMaybeRelock-&gt;initializeNonMetaClass 1234567891011121314151617181920212223IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ ... if (initialize &amp;&amp; !cls-&gt;isInitialized()) { cls = initializeAndLeaveLocked(cls, inst, runtimeLock); ... } ...}static Class initializeAndLeaveLocked(Class cls, id obj, mutex_t&amp; lock){ return initializeAndMaybeRelock(cls, obj, lock, true);}static Class initializeAndMaybeRelock(Class cls, id inst, mutex_t&amp; lock, bool leaveLocked){ ··· initializeNonMetaClass(nonmeta); ···} 在initializeNonMetaClass递归调用父类的initialize，然后调用callInitialize 12345678910111213141516171819202122/************************************************************************ class_initialize. Send the '+initialize' message on demand to any* uninitialized class. Force initialization of superclasses first.**********************************************************************/void initializeNonMetaClass(Class cls){ ... supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) { initializeNonMetaClass(supercls); } ... { callInitialize(cls); if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;, pthread_self(), cls-&gt;nameForLogging()); } } ...} callInitialize是一个普通的消息发送 12345void callInitialize(Class cls){ ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(&quot;&quot;);} 总结 initialize在类或者其子类的第一个方法被调用前（发送消息前）调用 只在类中添加initialize但不使用的情况下，是不会调用initialize 父类的initialize方法会比子类先执行 当子类未实现initialize方法时，会调用父类initialize方法；子类实现initialize方法时，会覆盖父类initialize方法 当有多个分类都实现了initialize方法，会覆盖类中的方法，只执行一个(会执行最后被加载到内存中的分类的方法) 七、相关面试题7.1 类拓展和分类的区别①区别： 类拓展可以添加属性(编译器会帮助我们生成属性对应的get和set方法)，方法 分类只能添加方法，通常不能添加属性（添加的话需要使用关联对象） 原因： 类拓展在编译时完成加载，数据写入到ro中； 而分类在运行时加载，所以数据写入到rw中，没有实现对应的set和get方法，所以无法将属性的值赋值进去，也无法取到。 ②类拓展在代码实现形式有2种方式，第一种写到所在本类的.m文件中，第二种另一个单写一个.h文件。 常用第一种： 第二种： **③加载时机的区别： ** 在类的加载过程中—read_images处设置断点，运行进入断点，打印发现ro中包含类拓展的属性和相应的get，set方法，可以判断出类拓展在编译时就加载了。而此时类加载后没有分类的信息，由此可以判断分类是在运行时加载进来的。 下图断点信息图： 下图ro中查找信息图： ④类拓展和分类的区别 研究对象 加载时机 操作对象 能否通过@property声明属性生成 getter 和 setter 分类(实现了load方法) 运行时 rw 不能，需要借助关联对象来实现 分类(没有实现load方法) 编译时 ro 不能，需要借助关联对象来实现 类拓展 编译时 ro 可以 7.2 分类中可以通过关联对象添加属性7.2.1 关联对象的定义和基本使用 通过使用关联引用，你可以在不修改类声明的前提下为对象添加内容。如果你无权访问该类的源代码，或者由于二进制兼容性原因而无法更改该对象的布局，则这可能很有用。 关联引用机制基于 key。对于任何对象，你都可以根据需要添加任意数量的关联引用，每个关联都使用不同的 key。 从苹果官方文档可以看到，关联引用其实不是只能在分类中使用，只不过对于我们日常开发来说，分类中使用关联引用还是更常用的场景。关联对象使用起来很简单，不外乎两个方法： 12345// 设置关联对象objc_setAssociatedObject()// 获取关联对象objc_getAssociatedObject() 我们如果要给一个分类中的属性设置关联对象，需要重写属性的 setter 方法，然后使用 objc_setAssociatedObject： 123- (void)setXXX:(关联值数据类型)关联值 objc_setAssociatedObject(self, 关联的key, 关联值, 关联对象内存管理策略);} 然后还需要重写 getter 方法，然后使用 objc_getAssociatedObject： 123- (关联值数据类型)关联值{ return objc_getAssociatedObject(self, 关联的key);} 这其中的关联对象内存管理策略如下表所示： 关联策略 等同的 @property 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用。 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 7.2.3 关联对象的底层原理总结图： objc_setAssociatedObject1234// objc-runtime.mmvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) { _object_set_associative_reference(object, (void *)key, value, policy);} objc_setAssociatedObject 方法的实现又包裹了一层，其实现为 _object_set_associative_reference 分析_object_set_associative_reference方法，直接看添加注释后的代码就能明白： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // This code used to work when nil was passed for object and key. Some code // probably relies on that to not crash. Check and handle it explicitly. // rdar://problem/44094390 // 容错处理 if (!object &amp;&amp; !value) return; assert(object); // 判断要进行关联的对象是否禁用掉了关联引用 if (object-&gt;getIsa()-&gt;forbidsAssociatedObjects()) _objc_fatal(&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;, object, object_getClassName(object)); // retain the new value (if any) outside the lock. // 初始化一个 ObjcAssociation 对象，用于持有原有的关联对象 ObjcAssociation old_association(0, nil); // 判断传入的关联对象值是否存在 id new_value = value ? acquireValue(value, policy) : nil; { // 关联对象的管理类 AssociationsManager manager; // 获取关联的 HashMap -&gt; 存储当前关联对象 AssociationsHashMap &amp;associations(manager.associations()); // 对当前对象的地址做按位取反操作 - 就是 HashMap 的key (哈希函数) disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; // 根据key去获取关联属性的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; // 替换设置新值 j-&gt;second = ObjcAssociation(policy, new_value); } else { // 到最后了——直接设置新值 (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). // 如果AssocistionsHashMap没有对象的关联信息表 // 那么就创建一个map并通过传入的key把value存进去 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); } } else { // setting the association to nil breaks the association. // 如果传入的value是nil，并且之前使用相同的key存储过关联对象， // 那么就把这个关联的value移除（这也是为什么传入nil对象能够把对象的关联value移除） AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). // 最后把之前使用传入的这个key存储的关联的value释放（OBJC_ASSOCIATION_SETTER_RETAIN策略存储的） if (old_association.hasValue()) ReleaseValue()(old_association);} objc_getAssociatedObject123id objc_getAssociatedObject(id object, const void *key) { return _object_get_associative_reference(object, (void *)key);} 同样也是包装了一层，分析_object_get_associative_reference方法： 1234567891011121314151617181920212223242526272829303132id _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { // 关联对象的管理类 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); // 生成伪装地址。处理参数 object 地址 disguised_ptr_t disguised_object = DISGUISE(object); // 所有对象的额迭代器 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // 还没到最后就找到了 ObjectAssociationMap *refs = i-&gt;second; // 内部对象的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { // 找到 - 把值和策略读取出来 ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); // 如果策略是 OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下 if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) { objc_retain(value); } } } } if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { objc_autorelease(value); } return value;} objc_removeAssociatedObjectsobjc_removeAssociatedObjects 方法我们平时可能用的不多，这个方法是用来删除关联对象。我们来到它的定义处： 123456void objc_removeAssociatedObjects(id object) { if (object &amp;&amp; object-&gt;hasAssociatedObjects()) { _object_remove_assocations(object); }} 分析_object_remove_assocations方法： 123456789101112131415161718192021222324252627void _object_remove_assocations(id object) { vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; { // 关联对象的管理类 AssociationsManager manager; // 获取关联的 HashMap -&gt; 存储当前关联对象 AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; // 对当前对象的地址做按位取反操作 disguised_ptr_t disguised_object = DISGUISE(object); // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // 还没到最后找到了 // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) { elements.push_back(j-&gt;second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. // 这里会将对象包含的所有关联对象加入到一个 `vector` 中，然后对所有的 `ObjcAssociation` 对象调用 `ReleaseValue()` 方法，释放不再被需要的值 for_each(elements.begin(), elements.end(), ReleaseValue());} PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS 底层探索 - 分类的加载 iOS探索 分类、类拓展的加载过程 iOS 底层探索 - 类拓展和关联对象","link":"/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"title":"10-底层面试答疑","text":"一、什么是 Runtime答：用 C、C++、汇编实现的一套 API，为 OC 语言加入了面向对象和运行时的功能。 应用举例： 类的 ro 和 rw 属性，ro(read-only)在编译期就确定好了，而 rw(read-write)是在运行时才完全赋值。 二、方法的本质是什么答：方法的本质就是消息的发送，就是在底层调用_objc_msgSennd方法寻找方法IMP的过程，主要经历了以下几个步骤： 快速查找流程：通过汇编（objc_msgSend）查找cache_t中缓存的消息，找到就返回imp，找不到就进行慢速查找。 慢速查找流程：通过函数lookUpImpOrForward递归查找当前类和父类的缓存和方法列表，如果找到了就会缓存方法方便快速查找，找不到就会进行动态方法解析 动态方法解析：此时OC会给我们一次对sel的处理机会，你可以在resolveInstanceMethod:（类方法对应resolveClassMethod:）中添加一个IMP 如果你没把握住这次机会，也就是解析失败时，会来到消息转发阶段，这个阶段有两个机会去处理sel，分别是快速转发的forwardingTargetForSelector:，以及慢速转发的methodSignatureForSelector:。 消息快速转发：forwardingTargedForSelector，如果有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。 消息慢速转发：methodSignatureForSelector，进行方法签名，把方法丢出去，forwardInvocation来对消息处理。 未找到消息：无法找到IMP，就进入到了doesNotRecognizeSelector报错，打印log 三、sel 是什么？IMP 是什么？两者之间的关系？答： SEL是方法编号，也是方法名，在dyld加载镜像带内存时，通过_read_image方法加载到内存的表中了 IMP 就是我们函数实现指针 ，找IMP就是找函数的过程 函数就是对应的实现内容 四、能否向运⾏时创建的类中添加成员变量？答：不能。 原因： 1234567891011121314151617181920struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 ...} 12345678910111213struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 ...} 因为我们编译好的成员变量存储的位置在类的ro中，⼀旦编译完成，内存结构就完全确定⽆法修改，只能修改类的rw中的方法或者可以通过关联对象的方式来添加属性。 关联对象添加的主要步骤如下： objc_setAssociatedObject设置set方法：找到关联对象的总哈希表，然后通过指针地址找到该类的哈希表，然后通过key值进行存储 objc_getAssociatedObject设置get方法：和set方法一样查询表，找到值 在类的dealloc会清除关联对象的哈希表 五、isKindOfClass 和 isMemberOfClass的区别答：当调用者对象是实例对象时：【常用】 -isKindOfClass：判断调用者对象是否是xx类以及他的子类的实例-isMemberOfClass：判断调用者对象是否是xx类的实例 当调用者对象是类对象时：【可忽略】 +isKindOfClass：判断当前类对象的元类对象及其父类的元类对象是否等于传入的对象 +isMemberOfClass：判断当前类对象的元类对象是否等于传入的这个对象 原理探究：举例： 1.消息接收者是实力对象-&gt;调用对象方法 12345BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]]; // 1BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]]; // 1BOOL re7 = [(id)[LGPerson alloc] isKindOfClass:[LGPerson class]]; // 1BOOL re8 = [(id)[LGPerson alloc] isMemberOfClass:[LGPerson class]]; // 1NSLog(@&quot; re5 :%hhd\\n re6 :%hhd\\n re7 :%hhd\\n re8 :%hhd\\n&quot;,re5,re6,re7,re8); 上述Log的打印结果为1，0，0，0 2.消息接收者是类对象-&gt;调用类方法 12345BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; // 1BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; // 0BOOL re3 = [(id)[LGPerson class] isKindOfClass:[LGPerson class]]; // 0BOOL re4 = [(id)[LGPerson class] isMemberOfClass:[LGPerson class]]; // 0NSLog(@&quot; re1 :%hhd\\n re2 :%hhd\\n re3 :%hhd\\n re4 :%hhd\\n&quot;,re1,re2,re3,re4); 上述Log的打印结果为1，1，1，1 对于第1个例子，大家都使用的非常熟练，但是对于第2个例子的打印结果就有些纳闷了。我们发现两个例子的主要区别在于消息接受者是实例对象还是类对象。 其实这两个方法是有对应的类方法和实例方法的，只不过我们平时不使用类方法而已，查看源码： 123456789101112/************************************************************************ object_getClass.* Locking: None. If you add locking, tell gdb (rdar://7516456).**********************************************************************/// object_getClass()方法取得的是对象的isa指针指向的对象// 对于对象来说就是获取到他的类// 对于类对象来说就是获取到他的元类Class object_getClass(id obj){ if (obj) return obj-&gt;getIsa(); else return Nil;} 12345678910111213141516171819202122232425// 判断当前类对象的元类对象是否与传入的这个对象相等，所以这个cls应该是元类对象才有可能为 true+ (BOOL)isMemberOfClass:(Class)cls {return object_getClass((id)self) == cls;}// 判断当前实例对象的类对象是否与传入的对象相等，所以cls只有可能是类对象才有可能相等- (BOOL)isMemberOfClass:(Class)cls {return [self class] == cls;}// 循环判断当前类对象的元类对象及其父类的元类对象是否等于传入的cls+ (BOOL)isKindOfClass:(Class)cls { for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;}// 循环判断当前实例对象的父类的类对象是否等于传入的对象cls，也就是判断实例对象是否是cls及其子类的一种- (BOOL)isKindOfClass:(Class)cls { for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;} 所以，如果方法调用者是实例对象，那么传入的就应该是类对象；如果方法调用者是类对象，那么传入的就应该是元类对象。 六、[self class]、[super class]、[self superclass]的区别以及原理分析结论 class:获取当前方法调用者的类 superclass:获取当前方法调用者的父类 super:是一个结构体，结构体中消息接收者还是当前对象，所以就会让当前对象去调用父类方法，本质还是当前对象在调用 例创建一个Student类继承子Person类，查看打印： 1234NSLog(@&quot;[self class] = %@&quot;, [self class]); // [self class] = StudentNSLog(@&quot;[super class] = %@&quot;, [super class]); // [super class] = StudentNSLog(@&quot;[self superclass] = %@&quot;, [self superclass]); // [self superclass] = PersonNSLog(@&quot;[super superclass] = %@&quot;, [super superclass]);// [super superclass] = Person 原理先上源码看一下第一个和第三个的理解 1234567891011121314151617181920212223242526272829303132 // object_getClass()方法取得的是对象的isa指针指向的对象 // 对于对象来说就是获取到他的类 // 对于类对象来说就是获取到他的元类 Class object_getClass(id obj) { if (obj) return obj-&gt;getIsa(); else return Nil; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } + (Class)superclass { return self-&gt;superclass; } - (Class)superclass { return [self class]-&gt;superclass; }Class class_getSuperclass(Class cls){ if (!cls) return nil; return cls-&gt;superclass;} 我们知道，这里方法中的self都是指消息的接受者，在这里就表示Student类，根据以上源码，第一个和第三个没啥疑问，都是寻找Student的isa和父类。 那么super调用时，有啥不同，我们需要先知道super的本质 通过clang编译代码，我们可以发现，底层调用时super调用的方法不是msgSend,而是objc_msgSendSuper(object ,superclass, @selector(class))，传入了一个super的结构体和方法。 我们知道消息发送的时候，慢速查找流程是需要从自身递归查找到NSObject的，而objc_msgSendSuper就表示直接从消息接受者的父类开始递归查找，跳过了本身的方法列表，这样查找的速度可以更快。 super的结构体如下 1234struct objc_super { __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class;}; 两个参数分别为消息的接受者和父类，在这里Student即为消息接受者,Person为父类. 所以调用[super class]和[super superclass]本质上消息的接受者还是self，即Student类。所以就跟第一个和第三个结果没有区别。 小结[self class] 就是发送消息objc_msgSend，消息接受者是 self,⽅法编号：class [super class] 本质就是objc_msgSendSuper, 消息的接受者还是 self ⽅法编号：class(父类的) 只是objc_msgSendSuper 会更快 直接跳过 self 的查找,但是都会走到NSObject基类的实现方法中，但是都是以self为接受者 七、Runtime 是如何实现 weak 的，为什么可以⾃动置 nil？主要总结如下： 通过SideTable找到我们的weak_table weak_table 根据referent 找到或者创建 weak_entry_t 然后append_referrer(entry, referrer)将新弱引⽤的对象加进去entry 最后weak_entry_insert 把entry加⼊到我们的weak_table 在类dealloc时，会根据插入的步骤找到对应的弱引用，并置为nil 关于weak的相关知识做了单独的总结，详情可以看下方文章👇 11-weak原理探究 八、Method Swizzling 的坑与应⽤详情可以看下面的文章： 12-Method Swizzling的坑与应用 参考iOS底层学习 - Runtime之砖厂面试答疑","link":"/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"},{"title":"12-Method Swizzling的坑与应用","text":"一、方法的本质Objective-C中，方法是由SEL和IMP组成的，前者叫做方法编号，后者叫方法实现。OC中调用方法叫做发送消息，发送消息前会先查找消息，查找过程就是通过SEL查找IMP的过程，另外，我们经常在代码中使用@selector(someMethod)这样的语法，@selector()叫做方法选择器，其返回的就是SEL，真正执行时会根据这个SEL查找对应的IMP。 二、MethodSwizzling 原理比如有方法sel1对应imp1，sel2对应imp2，经过方法交换，使得runtime在方法查找时将sel1的查找结果变为imp2： ￼ 三、Method Swizzling 相关函数 API1234567891011121314151617// 通过SEL获取一个方法class_getInstanceMethod// 获取一个方法的实现method_getImplementation// 获取一个OC实现的编码类型method_getTypeEncoding// 给方法添加实现class_addMethod// 用一个方法的实现替换另一个方法的实现class_replaceMethod// 交换两个方法的实现method_exchangeImplementations 四、简单示例新建一个iOS工程，新建一个Person类，并为Person添加两个方法-walk和-run： 123456789101112131415161718192021// Person.h@interface Person : NSObject- (void)walk;- (void)run;@end// Person.m@implementation Person- (void)walk { NSLog(@&quot;walk&quot;);}- (void)run { NSLog(@&quot;run&quot;);}@end 新建一个NSObject的分类MethodSwizzling如下： 12345678910111213141516171819// NSObject+MethodSwizzling.h@interface NSObject (MethodSwizzling)+ (void)methodswizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL;@end// NSObject+MethodSwizzling.m#import &lt;objc/runtime.h&gt;@implementation NSObject (MethodSwizzling)+ (void)methodswizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL { Method orgMethod = class_getInstanceMethod(cls, orgSEL); Method tgtMethod = class_getInstanceMethod(cls, targetSEL); method_exchangeImplementations(orgMethod, tgtMethod);}@end 在Person.m中重写+load方法： 12345678+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self methodswizzlingWithClass:self orgSEL:@selector(walk) targetSEL:@selector(run)]; });} 在ViewController的-viewDidLoad中调用-walk： 12345- (void)viewDidLoad { [super viewDidLoad]; Person *person = [[Person alloc] init]; [person walk];} 运行程序，控制台输出如下： 12020-02-09 21:26:07.613230+0800 TestObjC[1716:74628] run 调用的是-walk，实际执行的是-run，完成了方法交换。 五、坑点5.1 交换方法后再调用 load 方法第一个坑点比较简单，就是我们在load中交换完方法后，不做处理的话，如果再去调用load，方法IMP会又被交换回来，导致交换不成功。 解决的方法也比较简单：使用单例模式来交换方法，保证方法的交换只执行一次 5.2 在继承的类中进行方法交换导致交换的结果和预期不一致具体描述是：在子类中交换它独有的方法和继承自父类的方法，子类交换是成功了，但是父类中的方法也被交换了。 使用的时候多注意一下。 例： 123456789101112131415161718Person.h @interface Person : NSObject- (void)walk;@end Person.m@implementation Person- (void)walk { NSLog(@&quot;walk&quot;);}@end 123456789101112131415161718192021222324252627282930313233Student.h@interface Student : Person- (void)study;@end Student.m@implementation Student- (void)study { NSLog(@&quot;study&quot;);}+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self methodSwizzlingWithClass:self orgSEL:@selector(walk) targetSEL:@selector(study)]; });}+ (void)methodSwizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL { Method orgMethod = class_getInstanceMethod(cls, orgSEL); Method tgtMethod = class_getInstanceMethod(cls, targetSEL); method_exchangeImplementations(orgMethod, tgtMethod);}@end 123456789// Student 类中方法交换成功了Student *s = [Student new];[s walk]; // study[s study]; // walk// 但是顺便也把父类给交换了（这是我们不需要的，多注意）Person *p = [Person new];[p walk]; // study 5.3 要交换的方法未实现时会交换失败还是上面的例子，如果 Student 类中，只声明了 -study 方法，但是未实现，再交换 -walk 方法和 -study 方法就会交换失败，还是之前的老样子，这点也要注意（不过正常人写不出这种代码） 六、常见应用6.1 埋点统计6.1.1 页面浏览事件在 iOS 开发中最常见的三种埋点，就是对页面进入次数、页面停留时间、点击事件的埋点。这些都可以通过Method Swizzling来实现。 通过交换UIViewController中viewWillAppear和viewWillDisappear的方法，来实现了进入界面和退出界面的统计，并记录了相关的类名，通过映射的关系，就可以清楚的知道用户的行为了。 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation UIViewController (logger)+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 通过 @selector 获得被替换和替换方法的 SEL，作为 SMHook:hookClass:fromeSelector:toSelector 的参数传入 SEL fromSelectorAppear = @selector(viewWillAppear:); SEL toSelectorAppear = @selector(hook_viewWillAppear:); [SMHook hookClass:self fromSelector:fromSelectorAppear toSelector:toSelectorAppear]; SEL fromSelectorDisappear = @selector(viewWillDisappear:); SEL toSelectorDisappear = @selector(hook_viewWillDisappear:); [SMHook hookClass:self fromSelector:fromSelectorDisappear toSelector:toSelectorDisappear]; });}- (void)hook_viewWillAppear:(BOOL)animated { // 先执行插入代码，再执行原 viewWillAppear 方法 [self insertToViewWillAppear]; [self hook_viewWillAppear:animated];}- (void)hook_viewWillDisappear:(BOOL)animated { // 执行插入代码，再执行原 viewWillDisappear 方法 [self insertToViewWillDisappear]; [self hook_viewWillDisappear:animated];}- (void)insertToViewWillAppear { // 在 ViewWillAppear 时进行日志的埋点 [[[[SMLogger create] message:[NSString stringWithFormat:@&quot;%@ Appear&quot;,NSStringFromClass([self class])]] classify:ProjectClassifyOperation] save];}- (void)insertToViewWillDisappear { ✅/ 在 ViewWillDisappear 时进行日志的埋点 [[[[SMLogger create] message:[NSString stringWithFormat:@&quot;%@ Disappear&quot;,NSStringFromClass([self class])]] classify:ProjectClassifyOperation] save];}@end 6.1.2 控件点击事件那么点击方法，我们也可以通过运行时进行方法替换实现无侵入埋点。 原理： 当我们为一个控件添加 Target-Action 后，用户操作控件（比如点击）时，首先会调用-sendAction:to:forEvent:方法，并将事件转发给应用程序的 UIApplication 对象。（UIApplication 类中对应的是-sendAction:from:forEvent:方法） 如果 Target 不为空，应用程序会让该对象调用对应的方法响应事件；如果 Target 为空，应用程序会在响应链中搜索定义了该方法的对象，然后执行该方法。 因此我们可以通过 Method Swizzling 交换 UIApplication 类中的-sendAction:from:forEvent:方法，然后在交换后的方法中触发采集事件。 完整代码： 123456789101112131415161718192021222324#import &quot;UIApplication+XWTracking.h&quot;#import &quot;XWTrackingAnalysisSDK.h&quot;#import &quot;NSObject+XWSwizzler.h&quot;#import &quot;UIView+XWTracking.h&quot;@implementation UIApplication (XWTracking)+ (void)load { [UIApplication xwtracking_swizzleMethod:@selector(sendAction:to:from:forEvent:) withMethod:@selector(xwtracking_sendAction:to:from:forEvent:)];}- (BOOL)xwtracking_sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event { // UITabBarItem继承自NSObject，不过滤会崩溃 BOOL condition = ((event.allTouches.anyObject.phase == UITouchPhaseEnded) || [sender isKindOfClass:UISwitch.class] || [sender isKindOfClass:UISegmentedControl.class] || [sender isKindOfClass:UIStepper.class]) &amp;&amp; !([sender isKindOfClass:UITabBarItem.class] || [sender isKindOfClass:UIBarButtonItem.class]); if (condition) { // 触发$AppClick事件 [XWTrackingAnalysisSDK.shareInstance trackAppClickWithView:sender properties:nil]; } // 调用原有实现 return [self xwtracking_sendAction:action to:target from:sender forEvent:event];}@end 和 UIViewController生命周期埋点不同的是，UIButton在一个视图类中可能有多个不同的继承类，相同 UIButton的子类在不同视图类的埋点也要区别开： 123456789101112131415- (void)trackAppClickWithView:(UIView *)view properties:(NSDictionary&lt;NSString *,id&gt; *)properties { NSMutableDictionary *eventProperties = [NSMutableDictionary dictionary]; // 获取控件类型 eventProperties[@&quot;$element_type&quot;] = view.xwtracking_elementType; // 获取控件显示文本 eventProperties[@&quot;$element_content&quot;] = view.xwtracking_elementContent; // 获取控件所在的 UIViewController UIViewController *vc = view.xwtracking_viewController; // 设置页面相关属性 eventProperties[@&quot;$screen_name&quot;] = NSStringFromClass(vc.class); // 添加自定义属性 [eventProperties addEntriesFromDictionary:properties]; // 触发$AppClick事件 [XWTrackingAnalysisSDK.shareInstance track:@&quot;$AppClick&quot; properties:eventProperties];} 除了 UIViewController、UIButton 控件以外，Cocoa 框架的其他控件都可以使用这种方法来进行无侵入埋点。以 Cocoa 框架中最复杂的 UITableView 控件为例，你可以使用 hook setDelegate 方法来实现无侵入埋点。另外，对于 Cocoa 框架中的手势事件（Gesture Event），我们也可以通过 hook initWithTarget:action:方法来实现无侵入埋点。 6.2 防止数组，字典等越界崩溃数组越界等是最容易造成crash的一种方式，而且一般崩溃起来比较严重，所以我们要尽量避免。 在iOS中NSNumber、NSArray、NSDictionary等这些类都是类簇(Class Clusters)，一个NSArray的实现可能由多个类组成。所以如果想对NSArray进行Swizzling，必须获取到其真身进行Swizzling，直接对NSArray进行操作是无效的。这是因为Method Swizzling对NSArray这些的类簇是不起作用的。 因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。 所以如果我们对NSArray类进行Swizzling操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行Swizzling操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。 下面列举了NSArray和NSDictionary本类的类名，可以通过Runtime函数取出本类： 类名 真身 NSArray __NSArrayI NSMutableArray __NSArrayM NSDictionary __NSDictionaryI NSMutableDictionary __NSDictionaryM 6.2.1 处理 NSArrayNSArray+CrashHandle.h 1234567891011121314151617//// NSArray+CrashHandle.h// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSArray (CrashHandle)@endNS_ASSUME_NONNULL_END NSArray+CrashHandle.m 123456789101112131415161718192021222324252627282930313233343536//// NSArray+CrashHandle.m// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &quot;NSArray+CrashHandle.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSArray (CrashHandle)// 如果下面代码不起作用，造成这个问题的原因大多都是其调用了super load方法。在下面的load方法中，不应该调用父类的load方法。这样会导致方法交换无效+ (void)load { Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(xw_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);}- (id)xw_objectAtIndex:(NSUInteger)index { if (index &gt; self.count - 1) { // 数组越界 @try { return [self xw_objectAtIndex:index]; } @catch (NSException *exception) { // 在崩溃后会打印崩溃信息。如果是线上，可以在这里将崩溃信息发送到服务器 NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; } @finally {} } else { // 如果没有问题，则正常进行方法调用 return [self xw_objectAtIndex:index]; }}@end 12345678910**************************调用******************************- (void)viewDidLoad { [super viewDidLoad]; // 测试代码 NSArray *array = @[@0, @1, @2, @3]; [array objectAtIndex:3]; //本来要奔溃的，但是没有，打印出了信息 [array objectAtIndex:4];} 6.2.2 处理 NSMutableArrayNSMutableArray+CrashHandle.h 1234567891011121314151617//// NSMutableArray+CrashHandle.h// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSMutableArray (CrashHandle)@endNS_ASSUME_NONNULL_END NSMutableArray+CrashHandle.m 12345678910111213141516171819202122232425262728293031323334//// NSMutableArray+CrashHandle.m// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &quot;NSMutableArray+CrashHandle.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (CrashHandle)+ (void)load { Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(xw_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);}- (id)xw_objectAtIndex:(NSUInteger)index { if (index &gt; self.count - 1) { // 数组越界 @try { return [self xw_objectAtIndex:index]; } @catch (NSException *exception) { NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; } @finally {} } else { return [self xw_objectAtIndex:index]; }}@end 以上的两个例子，只是开发中常用的，还有很多其他的应用，就需要根据需求来不断调整了。这些都属于 AOP 面向切面编程的一个实际应用，Method Swizzling 也是其在 iOS 开发中应用的最常用的一种 AOP 思想 参考iOS底层学习 - Runtime之Method Swizzling黑魔法 Objective-C 的 MethodSwizzling","link":"/2021/02/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/12-Method%20Swizzling%E7%9A%84%E5%9D%91%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"title":"11-weak原理探究","text":"内存管理在APP开发过程中占据着一个很重要的地位，在iOS中，系统为我们提供了ARC的开发环境，帮助我们做了很多内存管理的内容。本章我们先来看一下，平时开发中使用最多的weak在底层是如何进行实现的 一、__strong、__weak、__unsafe_unretained的区别我们通过例子来看一下__strong、__weak、__unsafe_unretained的区别。 首先是看如下例子，可以知道在临时作用域结束之后，生成的对象就会进行销毁，我们在作用域外部用修饰符来持有对象，再来看一下对象的销毁情况 123456789101112NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person);}NSLog(@&quot;临时作用域结束&quot;);***************************打印结果******************************2020-01-19 10:57:13.910542+0800 objc-debug[74175:19740208] 临时作用域开始2020-01-19 10:57:13.911181+0800 objc-debug[74175:19740208] person对象：&lt;LGPerson: 0x10221c900&gt;2020-01-19 10:57:13.911277+0800 objc-debug[74175:19740208] LGPerson -[LGPerson dealloc]2020-01-19 10:57:13.911367+0800 objc-debug[74175:19740208] 临时作用域结束 __strong先来看一下用__strong修饰的结果。可以发现修饰的对象在作用域结束之后并没有销毁，说明该对象的引用计数增加了 123456789101112131415__strong LGPerson *strongPerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); strongPerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;strongPerson：%@&quot;, strongPerson);***************************打印结果******************************2020-01-19 11:54:44.079292+0800 objc-debug[74452:19777011] 临时作用域开始2020-01-19 11:54:44.080060+0800 objc-debug[74452:19777011] person对象：&lt;LGPerson: 0x101945ae0&gt;2020-01-19 11:54:44.080172+0800 objc-debug[74452:19777011] 临时作用域结束2020-01-19 11:54:44.080292+0800 objc-debug[74452:19777011] strongPerson：&lt;LGPerson: 0x101945ae0&gt; __weak再来看一下__weak修饰的结果。通过下面的运行我们可以发现，用__weak修饰后，并没有增加引用计数，并且作用域结束，对象释放后，修饰的对象为nil，没有造成野指针的崩溃，可以说是一种安全的方案 12345678910111213141516__weak LGPerson *weakPerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); weakPerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;weakPerson：%@&quot;, weakPerson);***************************打印结果******************************2020-01-19 11:58:08.842409+0800 objc-debug[74479:19780263] 临时作用域开始2020-01-19 11:58:08.843151+0800 objc-debug[74479:19780263] person对象：&lt;LGPerson: 0x101712030&gt;2020-01-19 11:58:08.843382+0800 objc-debug[74479:19780263] LGPerson -[LGPerson dealloc]2020-01-19 11:58:08.843572+0800 objc-debug[74479:19780263] 临时作用域结束2020-01-19 11:58:08.843762+0800 objc-debug[74479:19780263] weakPerson：(null) __unsafe_unretained最后我们来看一下，平时开发使用较少的__unsafe_unretained和上面两个的区别在哪。我们通过结果可以发现，在作用域消失，对象就进行了销毁，并且在出作用域打印修饰对象时，出现了野指针的崩溃EXC_BAD_ACCESS 所以这样就看出了__weak和__unsafe_unretained的区别就是前者会在对象被释放的时候自动置为nil，而后者却不行。 123456789101112131415__unsafe_unretained LGPerson *unsafePerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); unsafePerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;unsafePerson：%@&quot;, unsafePerson);***************************打印结果******************************2020-01-19 12:02:34.428120+0800 objc-debug[74513:19785153] 临时作用域开始2020-01-19 12:02:34.428813+0800 objc-debug[74513:19785153] person对象：&lt;LGPerson: 0x1019159f0&gt;2020-01-19 12:02:34.428901+0800 objc-debug[74513:19785153] LGPerson -[LGPerson dealloc]2020-01-19 12:02:34.429015+0800 objc-debug[74513:19785153] 临时作用域结束 小结 __strong修饰后，对象的引用计数会增加，在作用域外不会销毁 __weak修饰后，对象引用计数不会增加，在作用域外会自动置为nil __unsafe_unretained修饰后，引用计数不会增加，在作用域外不会置空，会造成野指针崩溃 通过上面例子基本了解了__weak的作用，那么__weak是如何进行创建和销毁的呢，下面通过源码进行深度探索 二、weak 代码定位打断点查看汇编 在汇编中发现weak底层调用的是objc_initWeak 我们给objc_initWeak打上符号断点重新运行，发现objc_initWeak存在于libobjc.A.dylib的动态库中。 三、weak 的保存逻辑通过上面的分析我们把 weak 的创建定位到了objc_initWeak这个方法，下面开始进行源码分析 objc_initWeak其中两个参数location和newObj的含义如下 location：表示__weak 指针的地址。之所以要存储指针的地址，是因为最后我们要讲__weak指针指向的内容置为nil，如果仅存储指针的话，是不能够完成这个功能的。 newObj：所引用的对象。 1234567891011idobjc_initWeak(id *location, id newObj){ if (!newObj) { *location = nil; return nil; } return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);} storeWeak查看storeWeak源码，根据注释，可以知道如下几点 HaveOld：weak指针之前是否已经指向了一个弱引用 HaveNew：weak指针是否需要指向一个新引用 CrashIfDeallocating：如果被弱引用的对象正在析构，此时再弱引用该对象，是否应该crash。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// Update a weak variable.// If HaveOld is true, the variable has an existing value // that needs to be cleaned up. This value might be nil.// If HaveNew is true, there is a new value that needs to be // assigned into the variable. This value might be nil.// If CrashIfDeallocating is true, the process is halted if newObj is // deallocating or newObj's class does not support weak references. // If CrashIfDeallocating is false, nil is stored instead.enum CrashIfDeallocating { DontCrashIfDeallocating = false, DoCrashIfDeallocating = true};template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj){ assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: // ✅如果weak指针之前弱引用过一个obj，则将这个obj所对应的SideTable取出，赋值给oldTable if (haveOld) { oldObj = *location; oldTable = &amp;SideTables()[oldObj]; } else { // 没有弱引用过，则oldTable = nil oldTable = nil; } // ✅如果weak指针要弱引用一个新的obj，则将该obj对应的SideTable取出，赋值给newTable if (haveNew) { newTable = &amp;SideTables()[newObj]; } else { newTable = nil; } // ✅加锁操作，防止多线程中竞争冲突 SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // ✅多线程安全：location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (haveOld &amp;&amp; *location != oldObj) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; } // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) { Class cls = newObj-&gt;getIsa(); // ✅如果cls还没有初始化，先初始化，再尝试设置弱引用 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); class_initialize(cls, (id)newObj); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. // ✅完成初始化后进行标记 previouslyInitializedClass = cls; // ✅newObj 初始化后，重新获取一遍newObj goto retry; } } // Clean up old value, if any. // ✅ 如果weak指针之前弱引用过别的对象oldObj，则调用weak_unregister_no_lock，在oldObj的weak_entry_t中移除该weak指针地址 if (haveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); } // Assign new value, if any. // ✅如果weak指针需要弱引用新的对象newObj if (haveNew) { // ✅调用weak_register_no_lock方法，将weak指针的地址记录到newObj对应的weak_entry_t中 newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. // ✅更新newObj的isa指针的weakly_referenced bit标志位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. // ✅*location 赋值，也就是将weak指针直接指向了newObj，而且没有将newObj的引用计数+1 *location = (id)newObj; } else { // No new value. The storage is not changed. } SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;} 因为我们这里是第一次调用，所以是一个新的对象，也就是haveNew的情况，获取到的是新的散列表SideTable，主要执行了weak_register_no_lock方法来进行插入。 weak_register_no_lock接着我们来分析weak_register_no_lock函数是怎么注册弱引用的。 我们发现函数内部主要进行了isTaggedPointer和deallocating的判断等前置条件，这些都是不能进行弱引用的情况。 如果可以被弱引用，则将被弱引用对象所在的weak_table中的weak_entry_t哈希数组中取出对应的weak_entry_t，如果weak_entry_t不存在，则会新建一个。然后将指向被弱引用对象地址的指针referrer通过函数append_referrer插入到对应的weak_entry_t引用数组。至此就完成了弱引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Registers a new (object, weak pointer) pair. Creates a new weak * object entry if it does not exist. * * @param weak_table The global weak table. * @param referent The object pointed to by the weak reference. * @param referrer The weak pointer address. */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating){ // ✅首先获取需要弱引用对象 objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; // ✅如果被弱引用对象referent为nil 或者被弱引用对象采用了TaggedPointer计数方式，则直接返回 if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable // ✅确保被引用的对象可用（没有在销毁，同时应该支持weak弱引用） bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) { deallocating = referent-&gt;rootIsDeallocating(); } else { BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) { return nil; } deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); } // ✅如果是正在销毁的对象，那么不能够被弱引用 if (deallocating) { if (crashIfDeallocating) { _objc_fatal(&quot;Cannot form weak reference to instance (%p) of &quot; &quot;class %s. It is possible that this object was &quot; &quot;over-released, or is in the process of deallocation.&quot;, (void*)referent, object_getClassName((id)referent)); } else { return nil; } } // now remember it and where it is being stored // ✅在 weak_table 中找到被弱引用对象 referent 对应的 weak_entry,并将 referrer 加入到 weak_entry 中 weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) { // ✅如果能找到 weak_entry,则讲 referrer 插入到 weak_entry 中 append_referrer(entry, referrer); } else { // ✅如果找不到 weak_entry，就新建一个 weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); } // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;} append_referrer这一步主要是找到弱引用对象的对应的weak_entry哈希数组中，基本就是个遍历插入的过程，原理比较简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ // ✅如果weak_entry 使用静态数组 inline_referrers if (! entry-&gt;out_of_line()) { // Try to insert inline. // ✅尝试将 referrer 插入数组 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } // Couldn't insert inline. Allocate out of line. // ✅如果inline_referrers的位置已经存满了，则要转型为 referrers，动态数组 weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { new_referrers[i] = entry-&gt;inline_referrers[i]; } entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; } assert(entry-&gt;out_of_line()); // ✅如果动态数组中元素个数大于或等于数组总空间的3/4，则扩展数组空间为当前长度的一倍，然后将 referrer 插入数组 if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) { return grow_refs_and_insert(entry, new_referrer); } // ✅如果不需要扩容，直接插入到weak_entry中 // ✅&amp; (entry-&gt;mask) 保证 begin 的位置只能大于或等于数组的长度 size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (entry-&gt;referrers[index] != nil) { hash_displacement++; index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); } if (hash_displacement &gt; entry-&gt;max_hash_displacement) { entry-&gt;max_hash_displacement = hash_displacement; } weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;} weak_unregister_no_lock如果weak指针在指向obj之前，已经弱引用了其他的对象，则需要先将weak指针从其他对象的weak_entry_t的hash数组中移除。在storeWeak方法中会调用weak_unregister_no_lock函数来做移除操作。 weak_unregister_no_lock函数首先会在weak_table中找出以前被弱引用的对象referent对应的weak_entry_t，在weak_entry_t中移除被弱引用的对象referrer。移除元素后，判断此时weak_entry_t中是否还有元素。如果此时weak_entry_t已经没有元素了，则需要将weak_entry_t从weak_table中移除。 12345678910111213141516171819202122232425262728293031323334353637383940voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id){ // 拿到以前弱引用的对象和对象的地址 objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; // 查找到以前弱引用的对象 referent 所对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) { // 在以前弱引用的对象 referent 所对应的 weak_entry_t 的 hash 数组中，移除弱引用 referrer remove_referrer(entry, referrer); // 移除元素之后， 要检查一下 weak_entry_t 的 hash 数组是否已经空了 bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) { empty = false; } else { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i]) { empty = false; break; } } } // 如果 weak_entry_t 的hash数组已经空了，则需要将 weak_entry_t 从 weak_table 中移除 if (empty) { weak_entry_remove(weak_table, entry); } } // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.} 至此，一个对象的弱引用过程已经结束 四、weak 的销毁逻辑通过开头的例子，我们知道，出作用域，对象dealloc后，会自动把弱引用对象置空，那么他是怎么实现的，我们可以简单查看下类的dealloc的源码： _objc_rootDealloc123456789101112131415161718192021222324252627282930313233343536373839- (void)dealloc { _objc_rootDealloc(self);}**********************************void _objc_rootDealloc(id obj){ assert(obj); obj-&gt;rootDealloc();}***********************************inline voidobjc_object::rootDealloc(){ // ✅如果是Tagged Pointer，就直接返回 if (isTaggedPointer()) return; // fixme necessary? /* ✅如果同时满足 1. 是优化过的isa、 2. 没有被weak指针引用过、 3. 没有关联对象、 4. 没有C++析构函数、 5. 没有sideTable， 就可以直接释放内存free() */ if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) { assert(!sidetable_present()); free(this); } else { //否则的话就需要通过下面的函数处理 object_dispose((id)this); }} 我们这里显然不满足上述条件，因为我们弱引用过，继续跟进object_dispose object_disposeobject_dispose函数中调用了objc_destructInstance 1234567891011id object_dispose(id obj){ if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;} objc_destructInstance我们可以看到内部会做销毁C++析构函数以及移除关联对象的操作，看来弱引用要在clearDeallocating中了 123456789101112131415161718void *objc_destructInstance(id obj) { if (obj) { // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. // 如果有C++析构函数，则运行相关函数 if (cxx) object_cxxDestruct(obj); // 如果有关联对象，则移除所有的关联对象，并将其自身从Association Manager的map中移除 if (assoc) _object_remove_assocations(obj); // 继续清理其它相关的引用 obj-&gt;clearDeallocating(); } return obj;} clearDeallocating12345678910111213141516inline void objc_object::clearDeallocating(){ if (slowpath(!isa.nonpointer)) { // Slow path for raw pointer isa. // 如果要释放的对象没有采用了优化过的isa引用计数 sidetable_clearDeallocating(); } else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) { // Slow path for non-pointer isa with weak refs and/or side table data. // ✅ 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数（现在一般都是优化过的 isa） clearDeallocating_slow(); } assert(!sidetable_present());} clearDeallocating_slow我们现在一般都是使用优化的 isa ，所以走clearDeallocating_slow函数。 我们通过源码可以看到主要操作是找到对应的SideTable，然后在SideTable的weak_table中，将弱引用对象置空，主要的方法为weak_clear_no_lock 123456789101112131415161718NEVER_INLINE voidobjc_object::clearDeallocating_slow(){ assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 在全局的SideTables中，以this指针(要释放的对象)为key，找到对应的SideTable SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) { // ✅ 要释放的对象被弱引用了，通过weak_clear_no_lock函数将指向该对象的弱引用指针置为nil weak_clear_no_lock(&amp;table.weak_table, (id)this); } // 使用了sideTable的辅助引用计数,直接在SideTable中擦除该对象的引用计数 if (isa.has_sidetable_rc) { table.refcnts.erase(this); } table.unlock();} weak_clear_no_lock我们通过源码可以看到，这个方法和插入时的方法比较类似，都是找到对应的weak_entry_t数组，然后通过遍历找到对应的指针地址，然后置为nil，防止了野指针的报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { // 获取被弱引用对象的地址 objc_object *referent = (objc_object *)referent_id; // 根据对象地址找到被弱引用对象 referent 在 weak_table 中对应的 weak_entry_t weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { /// XXX shouldn't happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent); return; } // zero out references weak_referrer_t *referrers; size_t count; // 找出弱引用该对象的所有 weak 指针地址数组 if (entry-&gt;out_of_line()) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; } // 遍历取出每个 weak 指针的地址 for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers[i]; if (referrer) { // 如果weak指针确实弱引用了对象 referent，则将weak指针设置为nil if (*referrer == referent) { *referrer = nil; } // 如果所存储的weak指针没有弱引用对象 referent，这可能是由于runtime代码的逻辑错误引起的，报错 else if (*referrer) { _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); } } } weak_entry_remove(weak_table, entry);} 至此，一个弱引用的销毁也完成了，并自动置为nil 五、总结 当一个对象obj被weak指针指向时，这个weak指针会以obj作为key，被存储到sideTable类的weak_table这个散列表上对应的一个weak指针数组里面。 当一个对象obj的dealloc方法被调用时，Runtime会以obj为key，从sideTable的weak_table散列表中，找出对应的weak指针列表，然后将里面的weak指针逐个置为nil。 创建流程简图 创建流程小结Runtime维护了一个弱引用表，将所有弱引用obj的指针地址都保存在obj对应的weak_entry_t中。 创建时，先从找到全局散列表SideTables中对应的弱引用表weak_table 在weak_table中被弱引用对象的referent中创建或者插入对应的weak_entry_t 然后append_referrer(entry, referrer)将我的新弱引⽤的对象加进去entry 最后weak_entry_insert 把entry加⼊到我们的weak_table 销毁流程简图 销毁流程小结 首先根据对象地址获取所有weak指针地址的数组 然后遍历这个数组把对应的数据清空置为nil 同时，将weak_entry_t移除出弱引用表weak_table。 PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS底层学习 - 内存管理之weak原理探究 iOS weak实现原理","link":"/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"title":"WKWebview 白屏问题处理","text":"一、问题描述WKWebview 载入过程中有概率会出现整个 webview 空白的情况，我们分析认为这属于 iOS 系统的 bug，猜测大概或许有可能maybe出现的原因是网页重定向过多或者其他各种原因。 虽然是系统 bug，但还是要我们自己去解决。 二、尝试解决实验一：在 webViewWebContentProcessDidTerminate 回调函数中处理实验过程： 博客摘录： 1当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用`-webViewWebContentProcessDidTerminate:`回调函数，然后在该函数里执行`[webView reload]`去解决白屏问题。 实验结果： 页面即将白屏的时候并不走上面的代理方法。而且跟 WKWebView 内存占用没任何关系，因为我直接在 MacBook Pro with M1 chip 上跑真机也会出现白屏问题，使用电脑16 GB内存，足够大了。 实验二：在 webViewWebContentProcessDidTerminate 回调函数中处理实验过程： 博客摘录： 1当h5页面即将白屏时，会调用`-(void)webViewWebContentProcessDidTerminate:`方法，我们只需在这个方法中重新加载webview即可 实验结果： 页面即将白屏的时候并不走上面的代理方法。实验过程中发现出现白屏问题时有时候会调用：didFailNavigation:方法，并且当时的报错是重定向过多。但是有时候又不走didFailNavigation这个方法，所以也不能在这里去处理。 实验三：检测 webView.title 是否为空实验过程： 在-viewWillAppear的时候检测webView.title，如果为空则reload页面。 实验结果： 所有页面在-viewWillAppear的时候webView.title都为空，因为页面都没加载完，方案就有问题，所以 pass。 实验四：js 注入资源加载错误检测代码实验过程： 注入下面的 js 代码，监测到出错就重新加载网页 123456789101112// 监控资源加载错误(img,script,css,以及jsonp)，出错就重新加载window.addEventListener('error', function (e) { console.log(&quot;===&quot; + e.message + &quot;===&quot;); location.reload();}, true);window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) { console.log(&quot;错误信息：&quot;, errorMessage); console.log(&quot;出错文件：&quot;, scriptURI); console.log(&quot;出错行号：&quot;, lineNumber); console.log(&quot;出错列号：&quot;, columnNumber); console.log(&quot;错误详情：&quot;, errorObj);} 实验结果： 注入 js 代码后会出现页面无限重载问题，而且后续我们分析页面白屏是 iOS 系统问题，那么把问题的检测交给 H5 去做显然是不合理也不对的。 三、最终方案：像素遍历，纯白像素超过阈值就重新载入参考字节跳动团队的解决方案，采用在网页加载完毕后对当前 webview 的可视区域截图，并对此快照进行像素点遍历，如果纯白色像素所占百分比超过阈值，则认为出现白屏，然后让当前页面重新加载的方式去处理。 3.1 获取快照ios官方提供了简易的获取webview快照接口，通过异步回调拿到当前可视区域的屏幕截图。 1- (void)takeSnapshotWithConfiguration:(nullable WKSnapshotConfiguration *)snapshotConfiguration completionHandler:(void (^)(UIImage * _Nullable snapshotImage, NSError * _Nullable error))completionHandler API_AVAILABLE(ios(11.0)); 其中snapshotConfiguration参数可用于配置快照大小范围，默认截取当前客户端整个屏幕区域。当然要剔除导航栏，因为一般导航栏的颜色都是自定义的颜色，非纯白，会干扰检测结果。 12345678910111213141516- (void)judgeLoadingStatus:(WKWebView *)webview { if (@available(iOS 11.0, *)) { if (webView &amp;&amp; [webView isKindOfClass:[WKWebView class]]) { // 状态栏高度 CGFloat statusBarHeight = [[UIApplication sharedApplication] statusBarFrame].size.height; // 导航栏高度 CGFloat navigationHeight = webView.viewController.navigationController.navigationBar.frame.size.height; // ✅仅截图检测导航栏以下部分内容 WKSnapshotConfiguration *shotConfiguration = [[WKSnapshotConfiguration alloc] init]; shotConfiguration.rect = CGRectMake(0, statusBarHeight + navigationHeight, _webView.bounds.size.width, (_webView.bounds.size.height - navigationHeight - statusBarHeight)); [_webView takeSnapshotWithConfiguration:shotConfiguration completionHandler:^(UIImage * _Nullable snapshotImage, NSError * _Nullable error) { //todo }]; } }} 3.2 缩放快照 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度。 1234567891011121314- (UIImage *)scaleImage:(UIImage *)image { CGFloat scale = 0.2; CGSize newsize; newsize.width = floor(image.size.width * scale); newsize.height = floor(image.size.height * scale); if (@available(iOS 10.0, *)) { UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:newsize]; return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) { [image drawInRect:CGRectMake(0, 0, newsize.width, newsize.height)]; }]; } else { return image; }} 经测试缩放后遍历过程大概在20ms以内。 注意这里有个坑：由于缩放后的图的尺寸在 原图宽高*缩放系数后可能不是整数，在布置画布重绘时默认向上取整，这就造成重绘的画布比理论上缩放后的图大。在遍历缩放后图片的像素时，会将图外画布上的像素纳入考虑范围，导致实际白屏页像素占比并非100%。因此使用floor将其尺寸大小向下取整（使用 floor 函数）。 3.3 遍历快照遍历快照缩放后图片的像素点，对纯白像素占比大于99%的页面，认定其为白屏问题页。 12345678910111213141516171819202122232425262728293031323334353637// 遍历像素点 白色像素占比大于99%认定为白屏- (BOOL)searchEveryPixel:(UIImage *)image { CGImageRef cgImage = [image CGImage]; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 每个像素点包含r g b a 四个字节 size_t bytesPerRow = CGImageGetBytesPerRow(cgImage); size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage); CGDataProviderRef dataProvider = CGImageGetDataProvider(cgImage); CFDataRef data = CGDataProviderCopyData(dataProvider); UInt8 *buffer = (UInt8 *)CFDataGetBytePtr(data); int whiteCount = 0; int totalCount = 0; for (int j = 0; j &lt; height; j ++ ) { for (int i = 0; i &lt; width; i ++) { UInt8 *pt = buffer + j * bytesPerRow + i * (bitsPerPixel / 8); UInt8 red = * pt; UInt8 green = *(pt + 1); UInt8 blue = *(pt + 2); totalCount ++; if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254) { whiteCount ++; } } } float proportion = (float)whiteCount / totalCount ; NSLog(@&quot;当前像素点数：%d,白色像素点数:%d , 占比: %f&quot;,totalCount , whiteCount , proportion ); if (proportion &gt; 0.99) { return YES; } else { return NO; }} 注意这里有个坑：有时候出现白屏了，但是检测出来的 RGB 值有些为254，有些为255，所以需要if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254)这样处理。 3.4 使用在页面加载完成后调用-judgeLoadingStatus:方法判断是否出现白屏，出现了就重新刷新页面，经测试可以完美解决白屏问题。 12345678910111213141516171819- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation { @weakify(self); [self judgeLoadingStatus:webView withBlock:^(webviewLoadingStatus status) { @strongify(self); switch (status) { case WebViewErrorStatus: self.reloadTime += 1; if (self.reloadTime &gt; 2) { return; } [webView reload]; NSLog(@&quot;遇到白屏，重新加载🆘&quot;); break; default: break; } }];} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma mark - 处理白屏问题// 判断是否白屏- (void)judgeLoadingStatus:(WKWebView *)webview withBlock:(void (^)(webviewLoadingStatus status))completionBlock { webviewLoadingStatus __block status = WebViewPendStatus; if (@available(iOS 11.0, *)) { if (webview) { // 状态栏高度 CGFloat statusBarHeight = [[UIApplication sharedApplication] statusBarFrame].size.height; // 导航栏高度 CGFloat navigationHeight = webview.viewController.navigationController.navigationBar.frame.size.height; WKSnapshotConfiguration *shotConfiguration = [[WKSnapshotConfiguration alloc] init]; // 仅截图检测导航栏以下部分内容(底部安全区域不影响) shotConfiguration.rect = CGRectMake(0, statusBarHeight + navigationHeight, webview.bounds.size.width, (webview.bounds.size.height - navigationHeight - statusBarHeight)); @weakify(self); [webview takeSnapshotWithConfiguration:shotConfiguration completionHandler:^(UIImage * _Nullable snapshotImage, NSError * _Nullable error) { @strongify(self); if (snapshotImage) { UIImage *scaleImage = [self scaleImage:snapshotImage]; BOOL isWhiteScreen = [self searchEveryPixel:scaleImage]; if (isWhiteScreen) { status = WebViewErrorStatus; } else { status = WebViewNormalStatus; } } if (completionBlock) { completionBlock(status); } }]; } }}// 遍历像素点 白色像素占比大于99%认定为白屏- (BOOL)searchEveryPixel:(UIImage *)image { CGImageRef cgImage = [image CGImage]; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 每个像素点包含r g b a 四个字节 size_t bytesPerRow = CGImageGetBytesPerRow(cgImage); size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage); CGDataProviderRef dataProvider = CGImageGetDataProvider(cgImage); CFDataRef data = CGDataProviderCopyData(dataProvider); UInt8 *buffer = (UInt8 *)CFDataGetBytePtr(data); int whiteCount = 0; int totalCount = 0; for (int j = 0; j &lt; height; j ++ ) { for (int i = 0; i &lt; width; i ++) { UInt8 *pt = buffer + j * bytesPerRow + i * (bitsPerPixel / 8); UInt8 red = * pt; UInt8 green = *(pt + 1); UInt8 blue = *(pt + 2); totalCount ++; if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254) { whiteCount ++; } } } float proportion = (float)whiteCount / totalCount ; NSLog(@&quot;当前像素点数：%d,白色像素点数:%d , 占比: %f&quot;,totalCount , whiteCount , proportion ); if (proportion &gt; 0.99) { return YES; } else { return NO; }}// 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度- (UIImage *)scaleImage:(UIImage *)image { CGFloat scale = 0.2; CGSize newsize; newsize.width = floor(image.size.width * scale); newsize.height = floor(image.size.height * scale); if (@available(iOS 10.0, *)) { UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:newsize]; return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) { [image drawInRect:CGRectMake(0, 0, newsize.width, newsize.height)]; }]; } else { return image; }} 后记保持怀疑精神。","link":"/2021/02/22/iOS%C2%B7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/WKWebview-%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"iOS+SQLite","text":"一、SQLite31.1 基本操作数据库操作最基本的无非就是==增，删，改，查==四个功能。增删改可以统一归为修改数据： 在 SQLite 中，修改数据的基本流程为： 第一步 sqlite3_open_v2 打开数据库第二步 sqlite3_prepare_v2 预处理 SQL 语句操作第三步 sqlite3_bind_xxx 绑定参数第四步 sqlite3_step / sqlite3_exec 执行 SQL 语句第五步 sqlite3_finalize 和 sqlite3_close 释放资源 1.2 APIsqlite3_open_v2打开数据库 参数1:数据库文件路径 参数2:数据库句柄 / 数据库实例 参数3:标记 有以下几种： SQLITE_OPEN_NOMUTEX: 设置数据库连接运行在多线程模式(没有指定单线程模式的情况下)SQLITE_OPEN_FULLMUTEX：设置数据库连接运行在串行模式。SQLITE_OPEN_SHAREDCACHE：设置运行在共享缓存模式。SQLITE_OPEN_PRIVATECACHE：设置运行在非共享缓存模式。SQLITE_OPEN_READWRITE：指定数据库连接可以读写。SQLITE_OPEN_CREATE：如果数据库不存在，则创建。 参数4:使用该数据库的虚拟机的名字，这里我们不需要用，直接传 NULL sqlite3_prepare_v2检查SQL语句的合法性（查询前的准备） 若语句合法即编译通过，则将语句产生的指令塞进 stmt 句柄（此时并未执行指令） 参数1:数据库实例 参数2:需要检查的 SQL 语句 参数3:SQL 语句的最大字节长度，-1代表总长度 参数4:stmt 句柄，用来存储 SQL stmt 指令 参数5:指向 zSql 未使用部分的指针，传 null sqlite3_bind通过 prepare 接口可以支持参数化的 SQL 语句，即带问号的SQL语句。比如查询语句select * from t where id=?，或者插入语句insert into t(a,b,c) values(?,?,?)。由于问号是没有意义的，因此需要调用sqlite3_bind_xxx接口来绑定具体的参数。 主要有以下几类：sqlite3_bind_intsqlite3_bind_int64sqlite3_bind_doublesqlite3_bind_textsqlite3_bind_blobsqlite3_bind_null 参数1:语句对象 参数2:参数开始执行的序号 参数3:我们要绑定的值 参数4:绑定的字符串的长度 参数5:指针，传 NULL sqlite3_step执行stmt句柄（执行存储在 stmt 句柄的指令） 如果指令能查询到下一行数据，就会返回SQLITE_ROW 如果指令（例如写入数据）不需要返还数据，就会返还SQLITE_DONE 参数：stmt 句柄 sqlite3_exec直接编译并执行 SQL 语句 特点：1、没有SQL语法检查 2、每一句SQL语句即使完全一样，也会重新编译执行，对批量指令来说效率不高。 参数1:一个打开的数据库实例 参数2:需要执行的SQL语句 参数3:SQL语句执行完毕后的回调 参数4:回调函数的第1个参数 参数5:错误信息 sqlite3_finalize清理语句句柄(以便重复使用同一个 stmt 句柄) 参数：stmt 句柄 sqlite3_close关闭数据库连接 参数：数据库实例 sqlite3_reset将已编译的SQL语句恢复到初始状态，保留语句相关的资源，重置后可重新绑定数据 参数：stmt 句柄 1.3 SQLite 多线程SQLite 多线程操作的特点为保证线程安全，SQLite 数据库只能并发读，不能并发写。 SQLite 多线程操作的正确方式 多线程读写，使用同一个数据库。【采用】 这种情况下由于使用的是同一个数据库连接，SQLite 内部有锁机制，不会出现异常。这种多线程操作并不是真正的并发操作，由于锁机制的存在所以仍然是阻塞的。 多线程读，单线程写，每个线程使用各自独立的数据库连接（但是需要开启wal模式，以开启数据库连接池）。 这种情况下是真的实现了多线程并发读操作，但是写操作仍能只可以单线程，如果多线程写(每个线程使用各自的数据库连接)就会出现问题。 两种方案对比： 理论上并发操作越多，方案2效率越高。实际测试也是如此。 二、iOS 中的使用方式对于方案一，采用异步函数+一个串行队列去操作同一个数据库(开启数据库后不关闭)。 这种情况下就会开辟一个子线程，同时串行的操作同一个数据库，所以既能够不阻塞 UI，又能够保证线程安全。 代码封装： XWTrackingAnalyticsDatabase.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// XWTrackingAnalyticsDatabase.h// XWTrackingSDK//// Created by IMO on 2021/2/20.//// 命令行验证：// 1. 进入数据库缓存的 Caches 路径// 2. 执行 sqlite3 XWTrackingAnalyticsDatabase.sqlite// 3. sqlite&gt; .tables// 4. sqlite&gt; select * from events#import &lt;Foundation/Foundation.h&gt;#import &lt;sqlite3.h&gt;NS_ASSUME_NONNULL_BEGIN@interface XWTrackingAnalyticsDatabase : NSObject@property (nonatomic, copy, readonly) NSString *filePath;@property (nonatomic) sqlite3 *database;/// 本地事件存储总量@property (nonatomic) NSUInteger eventCount;/// 初始化方法/// @param filePath 数据库路径，如果为空，则使用默认路径- (instancetype)initWithFilePath:(nullable NSString *)filePath NS_DESIGNATED_INITIALIZER;/// 向数据库中插入事件数据/// @param event 事件- (void)insertEvent:(NSDictionary *)event;/// 从数据库中获取事件数据/// @param count 获取事件数据的条数- (NSArray&lt;NSString *&gt; *)selectEventsForCount:(NSUInteger)count;/// 从数据库中删除一定数量的事件数据，返回是否删除成功/// @param count 删除事件数据的条数- (BOOL)deleteEventsForCount:(NSUInteger)count;@endNS_ASSUME_NONNULL_END XWTrackingAnalyticsDatabase.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#import &quot;XWTrackingAnalyticsDatabase.h&quot;static NSString * const XWTrackingAnalyticsDatabaseName = @&quot;XWTrackingAnalyticsDatabase.sqlite&quot;;@interface XWTrackingAnalyticsDatabase ()@property (nonatomic, strong) dispatch_queue_t queue;@end@implementation XWTrackingAnalyticsDatabase- (instancetype)init { return [self initWithFilePath:nil];}- (instancetype)initWithFilePath:(NSString *)filePath { self = [super init]; if (self) { _filePath = filePath ? : [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:XWTrackingAnalyticsDatabaseName]; NSLog(@&quot;数据库路径是：%@&quot;, _filePath); // 初始化队列的唯一标识 NSString *label = [NSString stringWithFormat:@&quot;cn.imo.serialQueue.%p&quot;, self]; // 创建一个串行队列 _queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL); [self open]; [self queryLocalDatabaseEventCount]; } return self;}- (void)open { dispatch_async(self.queue, ^{ // 初始化 SQLite 库 if (sqlite3_open_v2(self.filePath.UTF8String, &amp;(self-&gt;_database), SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } char *error; // 创建数据库表的 SQL 语句 NSString *sql = @&quot;CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, event BLOB);&quot;; // 运行创建表格的 SQL 语句 if (sqlite3_exec(self.database, sql.UTF8String, NULL, NULL, &amp;error) != SQLITE_OK) { return NSLog(@&quot;Create events Failure %s&quot;, error); } });}static sqlite3_stmt *insertStmt = NULL;- (void)insertEvent:(NSDictionary *)event { dispatch_async(self.queue, ^{ if (insertStmt) { // 重置插入语句，重置后可重新绑定数据 sqlite3_reset(insertStmt); } else { // 插入语句 NSString *sql = @&quot;INSERT INTO events (event) values(?)&quot;; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;insertStmt, NULL) != SQLITE_OK) { // 准备执行 SQL 语句失败，打印 log 返回失败 (NO) return NSLog(@&quot;SQlite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } } NSError *error = nil; // 将 event 转换成 JSON 数据 NSData *data = [NSJSONSerialization dataWithJSONObject:event options:NSJSONWritingPrettyPrinted error:&amp;error]; if (error) { // event 转换失败 return NSLog(@&quot;JSON Serialization error:%@&quot;, error); } // 将 JSON 数据与 stmt 绑定 sqlite3_bind_blob(insertStmt, 1, data.bytes, (int)data.length, SQLITE_TRANSIENT); // 执行 stmt if (sqlite3_step(insertStmt) != SQLITE_DONE) { // 执行失败 return NSLog(@&quot;Insert event into events error&quot;); } // 数据插入成功，事件数量加一 self.eventCount++; });}// 最后一次查询的事件数量static NSUInteger lastSelectEventCount = 50;static sqlite3_stmt *selectStmt = NULL;- (NSArray&lt;NSString *&gt; *)selectEventsForCount:(NSUInteger)count { NSMutableArray&lt;NSString *&gt; *events = [NSMutableArray arrayWithCapacity:count]; // 这里需要使用同步函数，否则会导致返回的事件不完整 dispatch_sync(self.queue, ^{ if (self.eventCount == 0) { return; } if (count != lastSelectEventCount) { lastSelectEventCount = count; selectStmt = NULL; } if (selectStmt) { // 重置查询语句，重置之后可以重新查询数据 sqlite3_reset(selectStmt); } else { // 查询语句（按 id 升序插） NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, event FROM events ORDER BY id ASC LIMIT %lu&quot;, (unsigned long)count]; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;selectStmt, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } } // 执行 SQL 语句 while (sqlite3_step(selectStmt) == SQLITE_ROW) { // 将查询到的这条数据转换成 NSData 对象 NSData *data = [[NSData alloc] initWithBytes:sqlite3_column_blob(selectStmt, 1) length:sqlite3_column_bytes(selectStmt, 1)]; // 将查询到的事件数据转换成 JSON 字符串 NSString *jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];#if DEBUG NSLog(@&quot;%@&quot;, jsonString);#endif // 将 JSON 字符串添加到数组中 [events addObject:jsonString]; } }); return events;}- (BOOL)deleteEventsForCount:(NSUInteger)count { __block BOOL success = YES; dispatch_sync(self.queue, ^{ if (self.eventCount == 0) { return; } // 删除语句 NSString *sql = [NSString stringWithFormat:@&quot;DELETE FROM events WHERE id IN (SELECT id FROM events ORDER BY id ASC LIMIT %lu);&quot;, (unsigned long)count]; char *errmsg; // 执行删除语句 if (sqlite3_exec(self.database, sql.UTF8String, NULL, NULL, &amp;errmsg) != SQLITE_OK) { success = NO; return NSLog(@&quot;Failed to delete record msg=%s&quot;, errmsg); } self.eventCount = self.eventCount &lt; count ? 0 : self.eventCount - count; }); return success;}// 查询数据库中已缓存的事件条数- (void)queryLocalDatabaseEventCount { dispatch_async(self.queue, ^{ // 查询语句 NSString *sql = @&quot;SELECT count(*) FROM events;&quot;; sqlite3_stmt *stmt = NULL; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;stmt, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } while (sqlite3_step(stmt) == SQLITE_ROW) { self.eventCount = sqlite3_column_int(stmt, 0); } });}@end 参考SQLite多线程并发操作 SQLite使用(三)&amp;&amp;核心API使用","link":"/2021/02/25/iOS%C2%B7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/iOS+SQLite/"},{"title":"解析 ips 文件","text":"一、前言如果 iOS 设备上的某款 APP 发生 crash，那么是能够在手机内查找到 crash 信息的。 方法就是设置-&gt;隐私-&gt;分析-&gt;分析数据；文件名格式就是 APP 包名+时间的 ips 文件，一眼就能定位出哪一个APP什么时间发生的 crash，接下来导出你关注的 ips 文件。 因为解析前的 ips 文件是十六进制的堆栈信息，所以我们需要对这些数据进行符号化转换，将堆栈地址转化为我们可识别的一些类名、方法名等符号信息。 二、解析在桌面新建名为 crash 的文件夹，该文件夹需要导入四样东西； 第一个：从设备导出的 ips 文件，需要改后缀名为 crash 第二个：找到 /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 路径，把 symbolicatecrash 拷贝到 crash 文件夹中 第三个：打开 Xcode-&gt;window-&gt;Organizer，找到对应版本的 archives，右键 Show in Finder，选中xcarchive 文件右键显示包内容，拷贝出 dSYMs 文件夹下的 dSYM 文件 第四个：打开 Xcode-&gt;window-&gt;Organizer，找到对应版本的 archives，右键Show in Finder，选中xcarchive 文件右键显示包内容，拷贝出 Products-&gt;Applications 文件夹下的APP文件 此时crash文件夹下文件： 然后打开终端，cd 到 crash 文件夹下执行以下命令： ./symbolicatecrash xxx.carsh xxx.dSYM &gt; log.carsh 执行之后，终端可能报错 Error: “DEVELOPER_DIR” is not defined at ./symbolicatecrash line 69. 继续执行以下命令： export DEVELOPER_DIR=”/Applications/Xcode.app/Contents/Developer” 然后，再继续执行第一条生成 log 的命令，此时 crash 文件夹内应该就能看到一个 log.crash 文件，打开此文件，就能更好的定位问题所在了。","link":"/2021/03/11/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E8%A7%A3%E6%9E%90%20ips%E6%96%87%E4%BB%B6/"},{"title":"JsDelivr图床达到50MB上限的解决办法","text":"一、继续使用 CDN 加速在图床是 GitHub + PicGo + JsDelivr 的图床环境下，如果图片到达50MB 后，就无法靠原来的地址访问了。 解决方法是在 GitHub 随便发布一个 Release，然后把 1234567/ 仓库名@分之名 /改为/ 仓库名@Tag名 / 即可继续使用 例如： 1234不能使用的：https://cdn.jsdelivr.net/gh/speam/blogImgs@master/v2-3c7b92a4b87ff685dbc95291decbc9c1_1440w.jpg改为：https://cdn.jsdelivr.net/gh/speam/blogImgs@1.0/v2-3c7b92a4b87ff685dbc95291decbc9c1_1440w.jpg 二、放弃 CDN 加速，直接全存到 GitHub 上【采用】不可能每次超过50 MB 限制的时候都按照上面的操作一遍，太麻烦了，所以把图直接放在 GitHub 上。 但是这样有个缺点就是不开全局代理的情况下，图片下载非常慢或者直接显示不出来，但为了保证图片长期有效，只能开全局代理了。","link":"/2021/03/18/%E5%8D%9A%E5%AE%A2/JsDelivr%E5%9B%BE%E5%BA%8A%E8%BE%BE%E5%88%B050MB%E4%B8%8A%E9%99%90%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"},{"title":"13-KVC原理","text":"一、KVC初探1.KVC定义KVC(Key-Value Coding)是利用NSKeyValueCoding 协议实现的一种机制，对象采用这种机制来提供对其属性的间接访问。 写下 KVC 代码setValue并点击跟进，发现其位于Foundation框架中 KVC在NSObject类的扩展NSObject(NSKeyValueCoding)中 =&gt; 所有继承自NSObject的类均可以使用KVC NSArray、NSDictionary、NSMutableDictionary、NSOrderedSet、NSSet等也遵守KVC协议 除少数类型(结构体)以外都可以使用KVC 2.常用 API1234567891011// 通过 key 设值- (void)setValue:(nullable id)value forKey:(NSString *)key;// 通过 key 取值- (nullable id)valueForKey:(NSString *)key;// 通过 keyPath 设值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;// 通过 keyPath 取值- (nullable id)valueForKeyPath:(NSString *)keyPath; NSKeyValueCoding类别的其它方法 1234567891011121314151617// 默认为YES。 如果返回为YES,如果没有找到 set&lt;Key&gt; 方法的话, 会按照_key, _isKey, key, isKey的顺序搜索成员变量, 返回NO则不会搜索+ (BOOL)accessInstanceVariablesDirectly;// 键值验证, 可以通过该方法检验键值的正确性, 然后做出相应的处理- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;// 如果key不存在, 并且没有搜索到和key有关的字段, 会调用此方法, 默认抛出异常。两个方法分别对应 get 和 set 的情况- (nullable id)valueForUndefinedKey:(NSString *)key;- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;// setValue方法传 nil 时调用的方法// 注意文档说明: 当且仅当 NSNumber 和 NSValue 类型时才会调用此方法 - (void)setNilValueForKey:(NSString *)key;// 一组 key对应的value, 将其转成字典返回, 可用于将 Model 转成字典- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys; 3.拓展——自动生成的setter和getter方法试想一下编译器要为成千上万个属性分别生成setter和getter方法那不得歇菜了嘛 于是乎苹果开发者们就运用通用原则给所有属性都提供了同一个入口——objc-accessors.mm中setter方法根据修饰符不同调用不同方法，最后统一调用reallySetProperty方法 至于是哪里调用的objc_setProperty_nonatomic_copy？ 并不是在objc源码中，而在llvm源码中发现了它，根据它一层层找上去就能找到源头 二、KVC使用12345678910111213141516typedef struct { float x, y, z;} ThreeFloats;@interface FXPerson : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@property (nonatomic, copy) NSArray *family;@property (nonatomic) ThreeFloats threeFloats;@property (nonatomic, strong) FXFriend *friend;@end@interface FXFriend : NSObject@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;@end 1.基本类型注意一下NSInteger这类的属性赋值时要转成NSNumber或NSString 123456FXPerson *person = [FXPerson new];[person setValue:@&quot;imo&quot; forKey:@&quot;name&quot;];[person setValue:@(18) forKey:@&quot;age&quot;];NSLog(@&quot;名字%@ 年龄%@&quot;, [person valueForKey:@&quot;name&quot;], [person valueForKey:@&quot;age&quot;]); 打印结果： 1名字imo 年龄18 2.集合类型两种方法对数组进行赋值，更推荐使用第二种方法 123456789101112FXPerson *person = [FXPerson new];person.family = @[@&quot;FXPerson&quot;, @&quot;FXFather&quot;];// 直接用新的数组赋值NSArray *temp = @[@&quot;FXPerson&quot;, @&quot;FXFather&quot;, @&quot;FXMother&quot;];[person setValue:temp forKey:@&quot;family&quot;];NSLog(@&quot;第一次改变%@&quot;, [person valueForKey:@&quot;family&quot;]);// 取出数组以可变数组形式保存，再修改NSMutableArray *mTemp = [person mutableArrayValueForKeyPath:@&quot;family&quot;];[mTemp addObject:@&quot;FXChild&quot;];NSLog(@&quot;第二次改变%@&quot;, [person valueForKey:@&quot;family&quot;]); 打印结果： 123456789101112第一次改变( FXPerson, FXFather, FXMother)第二次改变( FXPerson, FXFather, FXMother, FXChild) 3.访问非对象类型——结构体 对于非对象类型的赋值总是把它先转成NSValue类型再进行存储 取值时转成对应类型后再使用 12345678910111213FXPerson *person = [FXPerson new];// 赋值ThreeFloats floats = {180.0, 180.0, 18.0};NSValue *value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];[person setValue:value forKey:@&quot;threeFloats&quot;];NSLog(@&quot;非对象类型%@&quot;, [person valueForKey:@&quot;threeFloats&quot;]);// 取值ThreeFloats th;NSValue *currentValue = [person valueForKey:@&quot;threeFloats&quot;];[currentValue getValue:&amp;th];NSLog(@&quot;非对象类型的值%f-%f-%f&quot;, th.x, th.y, th.z); 4.集合操作符 聚合操作符 @avg: 返回操作对象指定属性的平均值 @count: 返回操作对象指定属性的个数 @max: 返回操作对象指定属性的最大值 @min: 返回操作对象指定属性的最小值 @sum: 返回操作对象指定属性值之和 数组操作符 @distinctUnionOfObjects: 返回操作对象指定属性的集合–去重 @unionOfObjects: 返回操作对象指定属性的集合 嵌套操作符 @distinctUnionOfArrays: 返回操作对象(嵌套集合)指定属性的集合–去重，返回的是 NSArray @unionOfArrays: 返回操作对象(集合)指定属性的集合 @distinctUnionOfSets: 返回操作对象(嵌套集合)指定属性的集合–去重，返回的是 NSSet 集合操作符用得少之又少。下面举个🌰 12345678910111213141516171819202122232425262728FXPerson *person = [FXPerson new];NSMutableArray *friendArray = [NSMutableArray array];for (int i = 0; i &lt; 6; i++) { FXFriend *f = [FXFriend new]; NSDictionary *dict = @{ @&quot;name&quot;:@&quot;Felix&quot;, @&quot;age&quot;:@(18+i), }; [f setValuesForKeysWithDictionary:dict]; [friendArray addObject:f];}NSLog(@&quot;%@&quot;, [friendArray valueForKey:@&quot;age&quot;]);float avg = [[friendArray valueForKeyPath:@&quot;@avg.age&quot;] floatValue];NSLog(@&quot;平均年龄%f&quot;, avg);int count = [[friendArray valueForKeyPath:@&quot;@count.age&quot;] intValue];NSLog(@&quot;调查人口%d&quot;, count);int sum = [[friendArray valueForKeyPath:@&quot;@sum.age&quot;] intValue];NSLog(@&quot;年龄总和%d&quot;, sum);int max = [[friendArray valueForKeyPath:@&quot;@max.age&quot;] intValue];NSLog(@&quot;最大年龄%d&quot;, max);int min = [[friendArray valueForKeyPath:@&quot;@min.age&quot;] intValue];NSLog(@&quot;最小年龄%d&quot;, min); 打印结果： 123452020-03-08 14:06:20.914503+0800 FXDemo[2998:151140] 平均年龄20.5000002020-03-08 14:06:20.914577+0800 FXDemo[2998:151140] 调查人口62020-03-08 14:06:20.914652+0800 FXDemo[2998:151140] 年龄总和1232020-03-08 14:06:20.914739+0800 FXDemo[2998:151140] 最大年龄232020-03-08 14:06:20.914832+0800 FXDemo[2998:151140] 最小年龄18 5.层层嵌套通过forKeyPath对实例变量（friends）进行取值赋值 123456789FXPerson *person = [FXPerson new];FXFriend *f = [[FXFriend alloc] init];f.name = @&quot;Felix的朋友&quot;;f.age = 18;person.friend = f;[person setValue:@&quot;Feng&quot; forKeyPath:@&quot;friend.name&quot;];NSLog(@&quot;%@&quot;, [person valueForKeyPath:@&quot;friend.name&quot;]); 打印结果： 1Feng 三、KVC底层原理由于NSKeyValueCoding的实现在Foundation框架，但它又不开源，我们只能通过KVO官方文档来了解它 1.设值过程官方文档上对Setter方法的过程进行了这样一段讲解： 按set&lt;Key&gt;:、_set&lt;Key&gt;:顺序查找对象中是否有对应的方法 找到了直接调用设值 没有找到跳转第2步 判断accessInstanceVariablesDirectly结果 为YES时按照_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的顺序查找成员变量，找到了就赋值；找不到就跳转第3步 为NO时跳转第3步 调用setValue：forUndefinedKey:。默认情况下会引发一个异常，但是继承于NSObject的子类可以重写该方法就可以避免崩溃并做出相应措施 2.取值过程同样的官方文档上也给出了Getter方法的过程： 按照get&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;、_&lt;key&gt;顺序查找对象中是否有对应的方法 如果有则调用getter，执行第5步 如果没有找到，跳转到第2步 查找是否有countOf&lt;Key&gt;和objectIn&lt;Key&gt;AtIndex: 方法(对应于NSArray类定义的原始方法)， 以及&lt;key&gt;AtIndexes: 方法(对应于NSArray方法objectsAtIndexes:)。 如果找到其中的第一个(countOf&lt;Key&gt;)，再找到其他两个中的至少一个，则创建一个响应所有 NSArray方法的代理集合对象，并返回该对象(即要么是countOf&lt;Key&gt; + objectIn&lt;Key&gt;AtIndex:，要么是countOf&lt;Key&gt; + &lt;key&gt;AtIndexes:，要么是countOf&lt;Key&gt; + objectIn&lt;Key&gt;AtIndex: + &lt;key&gt;AtIndexes:) 如果没有找到，跳转到第3步 查找名为countOf&lt;Key&gt;、enumeratorOf&lt;Key&gt;和 memberOf&lt;Key&gt;这三个方法(对应于NSSet类定义的原始方法） 如果找到这三个方法，则创建一个响应所有NSSet方法的代理集合对象，并返回该对象 如果没有找到，跳转到第4步 判断accessInstanceVariablesDirectly 为YES时按照_&lt;key&gt;、_is&lt;Key&gt;、&lt;key&gt;、is&lt;Key&gt;的顺序查找成员变量，找到了就取值，跳转第5步 为NO时跳转第6步 判断取出的属性值 属性值是对象，直接返回 属性值不是对象，但是可以转化为NSNumber类型，则将属性值转化为NSNumber 类型返回 属性值不是对象，也不能转化为NSNumber类型，则将属性值转化为NSValue类型返回 调用valueForUndefinedKey:。默认情况下会引发一个异常，但是继承于NSObject的子类可以重写该方法就可以避免崩溃并做出相应措施 四、自定义KVC新建一个NSObject+FXKVC的分类，.h开放两个方法，.m引入&lt;objc/runtime.h&gt; - (void)fx_setValue:(nullable id)value forKey:(NSString *)key; - (nullable id)fx_valueForKey:(NSString *)key; 1.自定义setter方法1.非空判断 1if (key == nil || key.length == 0) return; 2.找到相关方法set&lt;Key&gt;、_set&lt;Key&gt;、setIs&lt;Key&gt;，若存在就直接调用 123456789101112131415NSString *Key = key.capitalizedString;NSString *setKey = [NSString stringWithFormat:@&quot;set%@:&quot;,Key];NSString *_setKey = [NSString stringWithFormat:@&quot;_set%@:&quot;,Key];NSString *setIsKey = [NSString stringWithFormat:@&quot;setIs%@:&quot;,Key];if ([self fx_performSelectorWithMethodName:setKey value:value]) { NSLog(@&quot;*********%@**********&quot;,setKey); return;} else if ([self fx_performSelectorWithMethodName:_setKey value:value]) { NSLog(@&quot;*********%@**********&quot;,_setKey); return;} else if ([self fx_performSelectorWithMethodName:setIsKey value:value]) { NSLog(@&quot;*********%@**********&quot;,setIsKey); return;} 3.判断是否能够直接赋值实例变量，不能的情况下就调用setValue:forUndefinedKey:或抛出异常 1234567891011NSString *undefinedMethodName = @&quot;setValue:forUndefinedKey:&quot;;IMP undefinedIMP = class_getMethodImplementation([self class], NSSelectorFromString(undefinedMethodName));if (![self.class accessInstanceVariablesDirectly]) { if (undefinedIMP) { [self fx_performSelectorWithMethodName:undefinedMethodName value:value key:key]; } else { @throw [NSException exceptionWithName:@&quot;FXUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key %@.&quot;, self, NSStringFromSelector(_cmd), key] userInfo:nil]; } return;} 4.找相关实例变量进行赋值 123456789101112131415161718192021NSMutableArray *mArray = [self getIvarListName];NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];if ([mArray containsObject:_key]) { Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String); object_setIvar(self , ivar, value); return;} else if ([mArray containsObject:_isKey]) { Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String); object_setIvar(self , ivar, value); return;} else if ([mArray containsObject:key]) { Ivar ivar = class_getInstanceVariable([self class], key.UTF8String); object_setIvar(self , ivar, value); return;} else if ([mArray containsObject:isKey]) { Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String); object_setIvar(self , ivar, value); return;} 5.调用setValue:forUndefinedKey:或抛出异常 12345if (undefinedIMP) { [self fx_performSelectorWithMethodName:undefinedMethodName value:value key:key];} else { @throw [NSException exceptionWithName:@&quot;FXUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key %@.&quot;, self, NSStringFromSelector(_cmd), key] userInfo:nil];} 2.自定义getter方法1.非空判断 1if (key == nil || key.length == 0) return nil; 2.找相关方法get&lt;Key&gt;、&lt;key&gt;，找到就返回（这里使用-Warc-performSelector-leaks消除警告） 1234567891011NSString *Key = key.capitalizedString;NSString *getKey = [NSString stringWithFormat:@&quot;get%@&quot;,Key]; #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;if ([self respondsToSelector:NSSelectorFromString(getKey)]) { return [self performSelector:NSSelectorFromString(getKey)];} else if ([self respondsToSelector:NSSelectorFromString(key)]) { return [self performSelector:NSSelectorFromString(key)];}#pragma clang diagnostic pop 3.对NSArray进行操作：查找countOf&lt;Key&gt;、objectIn&lt;Key&gt;AtIndex方法 1234567891011121314151617181920NSString *countOfKey = [NSString stringWithFormat:@&quot;countOf%@&quot;,Key];NSString *objectInKeyAtIndex = [NSString stringWithFormat:@&quot;objectIn%@AtIndex:&quot;,Key];#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot;if ([self respondsToSelector:NSSelectorFromString(countOfKey)]) { if ([self respondsToSelector:NSSelectorFromString(objectInKeyAtIndex)]) { int num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1]; for (int i = 0; i&lt;num-1; i++) { num = (int)[self performSelector:NSSelectorFromString(countOfKey)]; } for (int j = 0; j&lt;num; j++) { id objc = [self performSelector:NSSelectorFromString(objectInKeyAtIndex) withObject:@(num)]; [mArray addObject:objc]; } return mArray; }}#pragma clang diagnostic pop 4.判断是否能够直接赋值实例变量，不能的情况下就调用valueForUndefinedKey:或抛出异常 123456789101112131415NSString *undefinedMethodName = @&quot;valueForUndefinedKey:&quot;;IMP undefinedIMP = class_getMethodImplementation([self class], NSSelectorFromString(undefinedMethodName));if (![self.class accessInstanceVariablesDirectly]) { if (undefinedIMP) { #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [self performSelector:NSSelectorFromString(undefinedMethodName) withObject:key];#pragma clang diagnostic pop } else { @throw [NSException exceptionWithName:@&quot;FXUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key %@.&quot;, self, NSStringFromSelector(_cmd), key] userInfo:nil]; }} 5.找相关实例变量，找到了就返回 1234567891011121314151617NSMutableArray *mArray = [self getIvarListName];NSString *_key = [NSString stringWithFormat:@&quot;_%@&quot;,key];NSString *_isKey = [NSString stringWithFormat:@&quot;_is%@&quot;,Key];NSString *isKey = [NSString stringWithFormat:@&quot;is%@&quot;,Key];if ([mArray containsObject:_key]) { Ivar ivar = class_getInstanceVariable([self class], _key.UTF8String); return object_getIvar(self, ivar);;} else if ([mArray containsObject:_isKey]) { Ivar ivar = class_getInstanceVariable([self class], _isKey.UTF8String); return object_getIvar(self, ivar);;} else if ([mArray containsObject:key]) { Ivar ivar = class_getInstanceVariable([self class], key.UTF8String); return object_getIvar(self, ivar);;} else if ([mArray containsObject:isKey]) { Ivar ivar = class_getInstanceVariable([self class], isKey.UTF8String); return object_getIvar(self, ivar);;} 6.调用valueForUndefinedKey:或抛出异常 123456789if (undefinedIMP) { #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [self performSelector:NSSelectorFromString(undefinedMethodName) withObject:key];#pragma clang diagnostic pop} else { @throw [NSException exceptionWithName:@&quot;FXUnknownKeyException&quot; reason:[NSString stringWithFormat:@&quot;****[%@ %@]: this class is not key value coding-compliant for the key %@.&quot;, self, NSStringFromSelector(_cmd), key] userInfo:nil];} 3.封装的方法这里简单封装了几个用到的方法 fx_performSelectorWithMethodName:value:key:安全调用方法及传两个参数 123456789101112- (BOOL)fx_performSelectorWithMethodName:(NSString *)methodName value:(id)value key:(id)key { if ([self respondsToSelector:NSSelectorFromString(methodName)]) { #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self performSelector:NSSelectorFromString(methodName) withObject:value withObject:key];#pragma clang diagnostic pop return YES; } return NO;} fx_performSelectorWithMethodName:key:安全调用方法及传参 123456789101112- (BOOL)fx_performSelectorWithMethodName:(NSString *)methodName key:(id)key { if ([self respondsToSelector:NSSelectorFromString(methodName)]) { #pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [self performSelector:NSSelectorFromString(methodName) withObject:key];#pragma clang diagnostic pop return YES; } return NO;} getIvarListName取成员变量 123456789101112131415- (NSMutableArray *)getIvarListName { NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1]; unsigned int count = 0; Ivar *ivars = class_copyIvarList([self class], &amp;count); for (int i = 0; i&lt;count; i++) { Ivar ivar = ivars[i]; const char *ivarNameChar = ivar_getName(ivar); NSString *ivarName = [NSString stringWithUTF8String:ivarNameChar]; NSLog(@&quot;ivarName == %@&quot;,ivarName); [mArray addObject:ivarName]; } free(ivars); return mArray;} 五、KVC异常小技巧1.技巧一：自动转换类型 用int类型赋值会自动转成__NSCFNumber 1234[person setValue:@18 forKey:@&quot;age&quot;];[person setValue:@&quot;20&quot; forKey:@&quot;age&quot;];NSLog(@&quot;%@-%@&quot;, [person valueForKey:@&quot;age&quot;], [[person valueForKey:@&quot;age&quot;] class]); 用结构体类型类型赋值会自动转成NSConcreteValue 12345ThreeFloats floats = {1.0, 2.0, 3.0};NSValue *value = [NSValue valueWithBytes:&amp;floats objCType:@encode(ThreeFloats)];[person setValue:value forKey:@&quot;threeFloats&quot;];NSLog(@&quot;%@-%@&quot;, [person valueForKey:@&quot;threeFloats&quot;], [[person valueForKey:@&quot;threeFloats&quot;] class]); 2.技巧二：设置空值有时候在设值时设置空值，可以通过重写setNilValueForKey来监听，但只对NSNumber类型有效。 3.技巧三：未定义的key对于未定义的key我们可以通过重写setValue:forUndefinedKey:、valueForUndefinedKey:来监听 123456789101112@implementation FXPerson- (void)setValue:(id)value forUndefinedKey:(NSString *)key { NSLog(@&quot;未定义的key——%@&quot;,key);}- (id)valueForUndefinedKey:(NSString *)key { NSLog(@&quot;未定义的key——%@&quot;,key); return @&quot;未定义的key&quot;;}@end","link":"/2021/03/23/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/13-KVC%E5%8E%9F%E7%90%86/"},{"title":"《指数基金投资指南》读书笔记","text":"一、书籍信息书名：指数基金投资指南 作者：银行螺丝钉 分类：投资理财工具书 读完时间：2021.3 二、前言作者在其前言中提到的自己“将会采取”的组合：50%沪深300指数基金，15%上证红利基金，30%标普500指数基金，5%纳斯达克综合基金。 三、理解3.1 指数基金的分类宽基指数基金 行业指数基金 3.2 如何选指数基金？3.2.1 基本理念低估值价值投资。巴菲特的老师格雷厄姆基于价值投资总结了三个理论：价格与价值的关系、能力圈、安全边际。 价格与价值的关系： 价格围绕价值上下波动 能力圈： 了解自己的投资品种，判断其大致价值，很重要 安全边际： 价格低于价值的时候才可以投资 3.2.2 估值指标市盈率$$市盈率 = \\frac{市值}{盈利}$$ 市值会波动，低代表低估，越低越好 盈利收益率$$盈利收益率=\\frac{盈利}{市值}$$ 越高代表估值越低，越高越好 市净率$$市净率=\\frac{市值}{净资产}$$ 越低越好 股息率$$股息率=\\frac{分红}{市值}$$ 越高越好 分红率$$分红率=\\frac{分红}{净利润}$$ 一般不变 ROE(净资产收益率)$$ROE=\\frac{净利润}{净资产}$$ 3.2.3 估值查询方式公众号：定投十年赚十倍 3.2.4 两种方式挑选盈利收益率法当盈利收益率大于10%时，开始定投 当盈利收益率在6.4%～10%时，坚持持有 当盈利收益率小于6.4%时，分批卖出 博格公式法指数基金未来的年复合收益率 = 指数基金的投资初期股息率 + 指数基金每年的市盈率变化率 + 指数基金每年的盈利变化率 3.3 如何买卖3.3.1 定投规则盈利收益率法 + 定投 博格公式法 + 定投 3.3.2 计算年复合收益率IRR 公式 3.3.3 提高收益率的小技巧定期不定额 + 盈利收益率法$$每个月的定投金额=首次低估时的定投资金*\\frac{当月的盈利收益率}{首次的盈利收益率}$$ 3.4 构建自己的定投计划 3.5 家庭资产配置短期资金管理—货币基金（余额宝） 中期资金管理—债券 四、结尾引用作者喜欢的一句话：“我相信，我终将富有！”","link":"/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"title":"14-KVO原理","text":"一、KVO简述KVO（Key-Value Observing）是一套事件观察 &amp; 通知机制，开发者可以使用它来监测对象属性的变化并做出响应。 在Documentation Archieve中提到一句想要理解KVO，必须先理解KVC，因为键值观察是建立在键值编码的基础上。 而KVO和NSNotificatioCenter都是 iOS 观察者模式的一种实现，两者的区别在于： 相对于被观察者和观察者之间的关系，KVO是一对一的，NSNotificatioCenter是一对多的 KVO对被监听对象无侵入性，不需要修改其内部代码即可实现监听 二、KVO使用及注意点2.1 基本使用KVO使用三部曲： 注册观察者 1[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld) context:NULL]; 实现回调 123- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { if ([keyPath isEqualToString:@&quot;name&quot;]) NSLog(@&quot;%@&quot;, change);} 移除观察者 123- (void)dealloc { [self.person removeObserver:self forKeyPath:@&quot;name&quot;];} 2.2 context 说明如果父类中有个name属性，子类中也有个name属性，两者都注册对name的观察，那么仅通过keyPath已经区分不了是哪个name发生变化了，现有两个解决办法： 多加一层判断：判断object，但是会出现很多 if…else… 使用context传递信息，更安全、更可扩展 context使用总结: 不使用context作为观察值 12// context是 void * 类型，应该填 NULL 而不是 nil[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 使用context传递信息 12345678910111213static void *PersonNameContext = &amp;PersonNameContext;static void *ChildNameContext = &amp;ChildNameContext;[self.person addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:PersonNameContext];[self.child addObserver:self forKeyPath:@&quot;name&quot; options:(NSKeyValueObservingOptionNew) context:ChildNameContext];- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { if (context == PersonNameContext) { NSLog(@&quot;%@&quot;, change); } else if (context == ChildNameContext) { NSLog(@&quot;%@&quot;, change); }} 2.3 移除观察的必要性不移除会带来潜在的隐患： 如果观察者对象 dealloc 的时候没有移除对目标属性的观察，当目标属性改变的时候，还是会通知该观察者，但是该观察者此时已经释放了，就会出现野指针的情况。 例如：LGPerson是一个单例对象，它有个属性name。然后在FirstViewController和SecondViewController中都对LGPerson对象的name属性进行了KVO观察。 操作顺序是从FirstViewControllerpush到SecondViewController，然后从SecondViewControllerpop 到FirstViewController。 假如SecondViewController在 dealloc 的时候没有移除观察者，但是这个LGPerson对象由于是单例所以没有销毁。然后在FirstViewController中name属性被改变了。此时就会通知它的观察者即SecondViewController，但是SecondViewController这个观察者已经释放了，再次访问它就会造成访问野指针的情况。 所以说，该移除观察的时候就要移除。 苹果官方推荐的方式是——在init的时候进行addObserver，在dealloc时removeObserver，这样可以保证add和remove是成对出现的，这是一种比较理想的使用方式 2.4 手动触发键值观察有时候业务需求需要观察某个属性值，一会儿要观察了，一会又不要观察了…如果把KVO三部曲整体去掉、再整体添上，必然又是一顿繁琐而又不必要的工作，好在KVO中有两种办法可以手动触发键值观察： 将被观察者的automaticallyNotifiesObserversForKey返回NO（可以只对某个属性设置），这样就不会自动观察属性的变化了，而是通过手动通知的方式去观察。 123456+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key { if ([key isEqualToString:@&quot;name&quot;]) { return NO; } return [super automaticallyNotifiesObserversForKey:key];} 使用willChangeValueForKey、didChangeValueForKey重写被观察者的属性的setter方法 这两个方法用于通知系统该 key 的属性值即将和已经变更了 12345- (void)setName:(NSString *)name { [self willChangeValueForKey:@&quot;name&quot;]; _name = name; [self didChangeValueForKey:@&quot;name&quot;];} 两种方式使用的排列组合如下，可以自由组合如何使用 情况 回调次数 正常情况 1 automaticallyNotifiesObserversForKey为NO 0 automaticallyNotifiesObserversForKey为NO且添加willChangeValueForKey、didChangeValueForKey 1 automaticallyNotifiesObserversForKey为YES且添加willChangeValueForKey、didChangeValueForKey 2 最近发现[self willChangeValueForKey:name]和[self willChangeValueForKey:”name”]两种写法是不同的结果：重写setter方法取属性值操作不会额外发送通知；而使用“name”会额外发送一次通知 2.5 Key 依赖情况比如有一个下载任务的需求，根据总下载量Total和当前已下载量Current来得到当前下载进度progress，这个需求就有两种实现： 分别观察总下载量Total和当前已下载量Current两个属性，其中一个属性发生变化时计算求值当前下载进度Process【太麻烦了】 实现keyPathsForValuesAffectingValueForKey方法，并观察progress属性【采用】 progress属性受到current和total属性变化的影响，如果我们想只监听progress，又保证current和total变化时能收到KVO中的回调告诉我们progress变化了，我们需要实现+keyPathsForValuesAffectingValueForKey:方法来关联两个属性到progress上： 12345678+ (NSSet&lt;NSString *&gt; *)keyPathsForValuesAffectingValueForKey:(NSString *)key { NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key]; if ([key isEqualToString:@&quot;progress&quot;]) { NSArray *affectingKeys = @[@&quot;current&quot;, @&quot;total&quot;]; keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys]; } return keyPaths;} Person 类中progess受到两个属性变化的影响 123- (CGFloat)progress { return self.current / self.total;} 添加监听： 123456Person *p = [Person new];self.person = p;p.current = 0;p.total = 100;[self.person addObserver:self forKeyPath:@&quot;progress&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 监听回调： 123- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { NSLog(@&quot;%@&quot;, change);} 这样，current和total变化时，就能监听到progress的变化了： 1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { self.person.current += 10; self.person.total += 1;} 2.6 可变数组首先添加对dataArray这个可变数组的观察： 1[self.person addObserver:self forKeyPath:@&quot;dateArray&quot; options:(NSKeyValueObservingOptionNew) context:NULL]; 然后调用下面代码，对dateArray数组添加元素 1[self.person.dateArray addObject:@&quot;hello&quot;]; 这样会不会触发KVO通知呢？答案是不会的，因为KVO是给予set方法的，这样不会触发set方法，所以就不会触发KVO通知。正确的做法应该是下面这样 1[[self.person mutableArrayValueForKey:@&quot;dateArray&quot;] addObject:@&quot;hello&quot;]; 三、KVO 底层原理—isa-swizzling3.1 官方解释 Key-Value Observing Programming Guide中有一段底层实现原理的叙述 KVO是使用isa-swizzling技术实现的 isa指针指向对象的类 在为对象的属性注册观察者时，将修改观察对象的isa指针，指向中间类而不是真实类。所以isa指针的值不一定反映对象的实际类。 您永远不应依靠isa指针来确定类成员身份。相反，您应该使用class方法来确定对象实例的类 3.2 代码探索 注册观察者之前：类对象为 FXPerson，实例对象isa指向FXPerson 注册观察者之后：类对象为 FXPerson，实例对象isa指向NSKVONotifying_FXPerson 从这两图中可以得出一个结论：观察者注册前后FXPerson类没发生变化，但实例对象的isa指向发生了变化 那么这个动态生成的中间类NSKVONotifying_FXPerson和FXPerson是什么关系呢？ 在注册观察者前后分别打印子类——发现NSKVONotifying_FXPerson是FXPerson的子类 3.3 动态子类探索①首先得明白动态子类观察的是什么？ 下面观察属性变量name和成员变量nickname来找区别：两个变量同时发生变化，但只有属性变量监听到回调——说明动态子类观察的是setter方法 ②通过runtime-API打印一下动态子类和观察类的方法 1234567891011- (void)printClassAllMethod:(Class)cls { unsigned int count = 0; Method *methodList = class_copyMethodList(cls, &amp;count); for (int i = 0; i&lt;count; i++) { Method method = methodList[i]; SEL sel = method_getName(method); IMP imp = class_getMethodImplementation(cls, sel); NSLog(@&quot;%@-%p&quot;,NSStringFromSelector(sel),imp); } free(methodList);} 通过打印可以看出： FXPerson类中的方法没有改变（imp实现地址没有变化） NSKVONotifying_FXPerson类中重写了父类FXPerson的dealloc方法 NSKVONotifying_FXPerson类中重写了基类NSObject的class方法和_isKVOA方法 重写的class方法可以指回FXPerson类 NSKVONotifying_FXPerson类中重写了父类FXPerson的setName方法 因为子类只继承、不重写是不会有方法imp的（那么调用方法时会问父类要方法实现） 且两个setName的地址指针不一样 每观察一个属性变量就重写一个setter方法（可自行论证） ③dealloc之后isa指向谁？——指回原类 ④dealloc之后动态子类会销毁吗？——不会 页面pop后再次push进来打印FXPerson类的子类，子类NSKVONotifying_FXPerson类依旧存在 ⑤automaticallyNotifiesObserversForKey是否会影响动态子类生成——会 动态子类会根据观察属性的automaticallyNotifiesObserversForKey的布尔值来决定是否生成 3.4 总结 automaticallyNotifiesObserversForKey为YES时注册观察属性会生成动态子类NSKVONotifying_XXX 动态子类观察的是setter方法 动态子类重写了观察属性的setter方法、dealloc、class、_isKVOA方法 setter方法用于观察键值 dealloc方法用于释放时将isa指向原来的类 class方法用于指回动态子类的父类 _isKVOA用来标识是否是在观察者状态的一个标志位 dealloc之后isa指向原来的类 dealloc之后动态子类不会销毁 3.5 原理图假设我们要观察的是 Person 实例对象的 age 属性。 添加观察者之前 添加观察者之后 四、自己实现KVO我的完整代码已放到 GitHub：Link🔗 4.1 前言下面我们根据系统 KVO 的原理，简单实现一下 KVO。 此过程中会有 runtime-API 的使用和接口设计思路的讲解，最终的自定义 KVO 能满足基本使用的需求但仍不完善，但此过程中最重要的是了解并模仿系统实现原理，以及加深对 runtime 的理解。 系统的 KVO 注册、回调、自动移除观察者在写法上都是分离的，使用起来稍显不简洁，所以我们自定义的 KVO 将使用 block 回调和自动释放来优化这一点不足。 自定义 KVO 的优化其实是参考了 FBKVOController 的实现，但 FBKVOController 是通过中间层对相应属性进行观察，然后回调到观察者，其在内存管理上更加安全；我们的自定义 KVO 是直接进行观察，逻辑上更简单易懂。 首先回顾系统 KVO 的逻辑： 1.automaticallyNotifiesObserversForKey为YES时，注册观察属性会生成动态子类NSKVONotifying_XXX 2.动态子类观察的是对应属性的setter方法 3.动态子类重写了观察属性的setter方法、dealloc、class、_isKVOA方法 setter方法用于观察键值 dealloc方法用于释放时将isa指向原来的类 class方法用于指回动态子类的父类 _isKVOA用来标识是否是在观察者状态的一个标志位【这个没实现】 4.dealloc之后isa指向原来的类 5.dealloc之后动态子类不会销毁 4.2 初始化创建NSObject的分类：NSObject+JYKVO，提供添加观察者的接口： 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGINtypedef void(^JYKVOBlock)(id observer, NSString *keyPath, id oldValue,id newValue);@interface NSObject (JYKVO)/// 对属性添加观察/// @param observer 观察者/// @param keyPath 观察的属性/// @param block 属性改变后的回调- (void)jy_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath block:(JYKVOBlock)block;@endNS_ASSUME_NONNULL_END 下面开始实现jy_addObserver:forKeyPath:block:方法： 4.3 验证是否存在setter方法，只观察属性12// 判断是否有对应的 setter if (![self isContainSetterMethodFromKeyPath:keyPath]) return; isContainSetterMethodFromKeyPath:方法的实现如下： 123456789101112/// 判断是否存在对应的 setter/// @param keyPath 属性名- (BOOL)isContainSetterMethodFromKeyPath:(NSString *)keyPath { Class class = object_getClass(self); SEL setterSeletor = NSSelectorFromString(setterForKeyPath(keyPath)); Method setterMethod = class_getInstanceMethod(class, setterSeletor); if (!setterMethod) { NSLog(@&quot;没找到属性:%@的setter方法&quot;, keyPath); return NO; } return YES;} 4.4 判断automaticallyNotifiesObserversForKey方法返回的布尔值12BOOL isAutomatically = [self jy_performSelectorWithMethodName:@&quot;automaticallyNotifiesObserversForKey:&quot; keyPath:keyPath];if (!isAutomatically) return; 为YES时才会继续 4.5 动态生成子类12// 动态生成子类Class newClass = [self createChildClassWithKeyPath:keyPath]; createChildClassWithKeyPath:方法是我们的核心方法，分步来看： ⑴ 根据 keyPath 拼接中间类的名称，然后如果不存在中间类的话，就创建，如果已经存在，不需要重复创建 123456789101112131415161718// 获取新类的类名 NSString *oldClassName = NSStringFromClass([self class]); NSString *newClassName = [NSString stringWithFormat:@&quot;%@%@&quot;, kJYKVOPrefix, oldClassName]; Class newClass = NSClassFromString(newClassName); // 防止重复创建新类 if (newClass) return newClass; /** * 申请类 * 如果内存中不存在, 创建生成 * 参数一: 父类 * 参数二: 新类的名字 * 参数三: 新类的开辟的额外空间 */ newClass = objc_allocateClassPair([self class], newClassName.UTF8String, 0); // 注册类 objc_registerClassPair(newClass); ⑵ 添加+class方法 12345// 添加 +class 方法SEL classSEL = NSSelectorFromString(@&quot;class&quot;);Method classMethod = class_getInstanceMethod([self class], classSEL);const char *classTypes = method_getTypeEncoding(classMethod);class_addMethod(newClass, classSEL, (IMP)jy_class, classTypes); ⑶ 添加对应属性的setter方法 12345// 添加 setterSEL setterSEL = NSSelectorFromString(setterForKeyPath(keyPath));Method setterMethod = class_getInstanceMethod([self class], setterSEL);const char *setterTypes = method_getTypeEncoding(setterMethod);class_addMethod(newClass, setterSEL, (IMP)jy_setter, setterTypes); 其中jy_setter是我们自己对setter方法的实现，思路如下： ① 因为我们使用KVO时候，是对操作的类(例如 LGPerson)的属性赋值，这里因为将 isa 指向了新创建的中间子类(NSKVONotifying_LGPerson)，所以这里需要调用父类(LGPerson)的setter 方法进行属性赋值。我们这里通过objc_msgSendSuper发送消息来实现。 1234567// 1️⃣转发给父类，改变父类的值void (*jy_msgSendSuper)(void *, SEL, id) = (void *)objc_msgSendSuper;struct objc_super superStruct = { .receiver = self, .super_class = class_getSuperclass(object_getClass(self)),};jy_msgSendSuper(&amp;superStruct, _cmd, newValue); ② 取原来的值，用于回调 123// 2️⃣取旧值NSString *keyPath = getterForSetter(NSStringFromSelector(_cmd));id oldValue = [self valueForKey:keyPath]; ③ 属性改变后我们还需要通过 block 的方式回调到添加观察的地方 12345678910// 3️⃣通知观察者// 1.拿到观察者，在添加观察者的时候通过关联对象将 observer 存储了起来。NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kJYKVOAssiociateKey));// 2.消息发送给观察者for (JYKVOInfo *info in mArray) { if ([info.keyPath isEqualToString:keyPath] &amp;&amp; info.handleBlock) { info.handleBlock(info.observer, keyPath, oldValue, newValue); }} ⑷ 然后为了实现自动移除观察者，我们还要交换一下 dealloc 方法的实现，在里面做一些事情 12345// 交换 dealloc 实现static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^{ [self JYMethodSwizzlingWithClass:[self class] oriSEL:NSSelectorFromString(@&quot;dealloc&quot;) swizzledSEL:@selector(jy_dealloc)];}); 123456// 当对象销毁的时候会调用 dealloc，在该方法中将 isa 指针重新指向原来的类- (void)jy_dealloc { Class superClass = [self class]; object_setClass(self, superClass); [self jy_dealloc];} 4.6 将isa指向创建好的动态子类12// isa指向修改-&gt;指向动态子类object_setClass(self, newClass); 4.7 保存observer信息，在setter方法中通知observer的时候需要用到该信息12345678// 保存信息JYKVOInfo *info = [[JYKVOInfo alloc] initWitObserver:observer forKeyPath:keyPath handleBlock:block];NSMutableArray *mArray = objc_getAssociatedObject(self, (__bridge const void * _Nonnull)(kJYKVOAssiociateKey));if (!mArray) { mArray = [NSMutableArray arrayWithCapacity:1]; objc_setAssociatedObject(self, (__bridge const void * _Nonnull)(kJYKVOAssiociateKey), mArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}[mArray addObject:info]; 其中使用JYKVOInfo这个model来存储observer信息，因为可能会还有多个observer，所以使用数组的形式进行存储。 现在可以给一个属性添加观察测试一下了。 4.8 测试依旧是Person类，有一个简单的name成员属性。 下面在控制器中添加对name属性的观察： 12345678self.person = [Person new];self.person.name = @&quot;旧名字&quot;;[self.person jy_addObserver:self forKeyPath:@&quot;name&quot; block:^(id _Nonnull observer, NSString * _Nonnull keyPath, id _Nonnull oldValue, id _Nonnull newValue) { NSLog(@&quot;旧值：%@&quot;, oldValue); NSLog(@&quot;新值：%@&quot;, newValue); NSLog(@&quot;path：%@&quot;, keyPath);}]; 点击屏幕的时候去改变这个对象的name的值： 123- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event { self.person.name = @&quot;新名字&quot;;} 然后将 demo 运行，点击这个控制器，查看打印： 1232021-03-30 14:48:14.483797+0800 OCTest[13317:272742] 旧值：旧名字2021-03-30 14:48:14.483927+0800 OCTest[13317:272742] 新值：新名字2021-03-30 14:48:14.483983+0800 OCTest[13317:272742] path：name 至此就完成了 KVO 的简单实现。 PS苹果开发文档- KVO 原理的介绍 FBKVOController 我的完整代码 参考facebookarchive/KVOController KVO原理分析 iOS探索 KVO原理及自定义 自定义KVO","link":"/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/"},{"title":"15-多线程基础原理","text":"一、进程、线程、队列1.1 进程进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 1.2 线程线程（Thread），是程序执行流的最小单位。 一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。通常一个进程由一个到多个线程组成，各个线程之间共享程序的内存空间（包括代码段、数据段、堆等）及一些进程级等资源（如打开文件和信号）。一个经典的线程与进程关系如图所示： 1.3 进程与线程的关系 地址空间： 同一进程的线程共享本进程的地址空间 进程之间是独立的地址空间 资源拥有： 同一进程内的线程共享本进程的资源如内存、I/O、cpu 等 进程之间的资源是独立的 健壮性： 一个进程崩溃后，在保护模式下不会对其他进程产生影响 但是一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮 资源消耗： 进程切换时，消耗的资源大。 线程无法切换，只能互相通信，消耗的资源较小 执行过程： 每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口。 但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 线程是处理器调度的基本单位，但进程不是 1.4 队列队列，是先进先出（FIFO： First-In-First-Out）的线性表，在具体应用中通常用链表或者数组来实现。装载线程任务的队形结构。队列只允许在后端进行插入操作，在前端进行删除操作。队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加 队列负责调度任务，线程执行任务 1.5 线程和 runloop 的关系 runloop 与线程是一一对应的：一个runloop对应一个核心的线程，为什么说是核心的，是因为 runloop 是可以嵌套的，但是核心的只能有一个，他们的关系保存在一个全局的字典里 runloop 是来管理线程的：当线程的runloop被开启后，线程会在执行完任务后进入休眠状态，有了任务就会被唤醒去执行任务 runloop在第一次获取时被创建，在线程结束时被销毁 对于主线程来说，runloop在程序一启动就默认创建好了 对于子线程来说，runloop是懒加载的——只有当我们使用的时候才会创建，所以在子线程用定时器要注意：确保子线程的runloop被创建，不然定时器不会回调 二、多线程2.1 多线程原理 同一时间，CPU 只能处理一条线程，只有一条线程在执行 多线程并发执行，其实就是 CPU 执行快速地在多条线程之间切换 2.2 多线程意义 优点 能适当提高程序的执行效率 能适当提高资源的利用率（CPU、内存） 线程上的任务执行完成后，线程会自动销毁 缺点 开启线程需要占用一定的内存空间（默认情况下，每一个线程都占512KB，创建线程大约需要90毫秒的创建时间） 如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，CPU在调用线程上的开销就越大 程序设计更加复杂，比如线程间的通信、多线程的数据共享 2.3 多线程生命周期 多线程的生命周期是：新建 - 就绪 - 运行 - 阻塞 - 死亡 新建：实例化线程对象 就绪：向线程对象发送 start 消息，线程对象被加入可调度线程池等待 CPU 调度。 运行：CPU 负责调度可调度线程池中线程的执行。线程执行完成之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由 CPU 负责，程序员不能干预。 阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行。sleepForTimeInterval（休眠指定时长），sleepUntilDate（休眠到指定日期），@synchronized(self)：（互斥锁）。 死亡：正常死亡，线程执行完毕。非正常死亡，当满足某个条件后，在线程内部中止执行/在主线程中止线程对象 2.4 线程池的原理 若线程池大小小于核心线程池大小时 创建线程执行任务 若线程池大小大于等于核心线程池大小时 先判断线程池工作队列是否已满 若没满就将任务push进队列 若已满时，且maximumPoolSize&gt;corePoolSize，将创建新的线程来执行任务 反之则交给饱和策略去处理 参数名 代表意义 corePoolSize 线程池的基本大小（核心线程池大小） maximumPool 线程池的最大大小 keepAliveTime 线程池中超过corePoolSize树木的空闲线程的最大存活时间 unit keepAliveTime参数的时间单位 workQueue 任务阻塞队列 threadFactory 新建线程的工厂 handler 当提交的任务数超过maxmumPoolSize与workQueue之和时， 任务会交给RejectedExecutionHandler来处理 饱和策略有如下四个： AbortPolicy直接抛出RejectedExecutionExeception异常来阻止系统正常运行 CallerRunsPolicy将任务回退到调用者 DisOldestPolicy丢掉等待最久的任务 DisCardPolicy直接丢弃任务 2.5 iOS 中的多线程方案 技术方案 简介 语言 线程生命周期 使用频率 pthread 一套通用的多线程API 适用于Unix/Linux/Windows等系统 跨平台/可移植 使用难度大 C 程序员管理 几乎不用 NSThread 使用更加面向对象 简单易用，可直接操作线程对象 OC 程序员管理 偶尔使用 GCD 旨在替代NSThread等线程技术 充分利用设备的多核 C 自动管理 经常使用 NSOperation 基于GCD（底层是GCD） 比GCD多了一些更简单实用的功能 使用更加面向对象 OC 自动管理 经常使用 常用的就是 GCD 和 NSOperation，区别： GCD仅仅支持FIFO队列，不支持异步操作之间的依赖关系设置。而NSOperation中的队列可以被重新设置优先级，从而实现不同操作的执行顺序调整 NSOperation支持KVO，可以观察任务的执行状态 GCD更接近底层，GCD在追求性能的底层操作来说，是速度最快的 从异步操作之间的事务性，顺序行，依赖关系。GCD需要自己写更多的代码来实现，而NSOperation已经内建了这些支持 如果异步操作的过程需要更多的被交互和UI呈现出来，NSOperation更好；底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD则更有优势 2.6 线程间通讯苹果官方 线程相关的文档是这样介绍的： 直接消息传递: 通过performSelector的一系列方法，可以实现由某一线程指定在另外的线程上执行任务。 全局变量、共享内存块和对象: 尽管共享变量既快速又简单，但是它们比直接消息传递更脆弱。但是必须使用锁或其他同步机制保护共享变量，否则可能会导致数据损坏或崩溃。 条件执行: 条件是一种同步工具，可用于控制线程何时执行代码的特定部分。 Runloop 资源: 一个自定义的 Runloop source 配置可以让一个线程上收到特定的应用程序消息。由于 Runloop source 是事件驱动的，因此在无事可做时，线程会自动进入睡眠状态，从而提高了线程的效率 端口和套接字:基于端口的通信是在两个线程之间进行通信的一种更为复杂的方法，但它也是一种非常可靠的技术。 消息队列: 传统的多处理服务定义了先进先出（FIFO）队列抽象，用于管理传入和传出数据。尽管消息队列既简单又方便，但是它们不如其他一些通信技术高效 对象分发: 对象分发是一种Cocoa 技术，提供了基于端口高级实现。尽管在线程内使用这门技术也能用，但鉴于使用它会带来的性能开支，高度不建议使用。分发对象更适合于进程间的通信，尤其是当进程消耗已经很高的情况下 2.7 线程的关闭建议在创建线程的时候，就设计好响应取消和退出线程的消息。如果确实有消息进来——要求线程退出，线程可能接下来可以实现一些必须的清理工作，然后优雅的退出。 响应取消消息的方法是使用Runloop，看看下面的代码： 12345678910111213141516171819202122232425- (void)threadMainRoutine{ BOOL moreWorkToDo = YES; BOOL exitNow = NO; NSRunLoop* runLoop = [NSRunLoop currentRunLoop]; // Add the exitNow BOOL to the thread dictionary. NSMutableDictionary* threadDict = [[NSThread currentThread] threadDictionary]; [threadDict setValue:[NSNumber numberWithBool:exitNow] forKey:@&quot;ThreadShouldExitNow&quot;]; // Install an input source. [self myInstallCustomInputSource]; while (moreWorkToDo &amp;&amp; !exitNow) { // Do one chunk of a larger body of work here. // Change the value of the moreWorkToDo Boolean when done. // Run the run loop but timeout immediately if the input source isn't waiting to fire. [runLoop runUntilDate:[NSDate date]]; // Check to see if an input source handler changed the exitNow value. exitNow = [[threadDict valueForKey:@&quot;ThreadShouldExitNow&quot;] boolValue]; }} 三、多线程方案脑图 补充atomic 与 nonatomic 的区别nonatomic：非原子性，非线程安全，适合内存小的移动设备 atomic：原子属性，针对多线程设计的，是属性的默认值，保证同一时间只有一个线程能够写入（但是同一时间能有多个线程取值），atomic本身就有一把锁（自旋锁），所以是线程安全的，但是需要消耗大量资源 开发建议： 所有属性都声明为 nonatomic 尽量避免多线程抢夺同一快资源 尽量将加锁、资源抢夺的业务逻辑交给服务器来处理，减小移动客户端的压力 参考iOS底层学习 - 多线程之基础原理篇 iOS探索 多线程原理 多线程","link":"/2021/04/06/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/15-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"},{"title":"UML 类图","text":"UML 类图 我们在阅读开源项目时，总是希望能比较高效的整理清楚项目中的各个类之间的关系，那么有没有相应的工具能高效、简洁的表示清楚类关系呢？UML 类图就是一个可以帮我们解决此类问题的工具或者方法。 一、类的格式在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示。 例：一个 Animal 类，它包含 name，age，state，isPet 这4个属性，以及 name 相关方法。 12345678910111213141516171819202122class Animal: NSObject { public var name: String? internal var isPet: Bool? fileprivate var state: String? private var age: Int? = 0 override init() { self.name = &quot;no name&quot; self.age = 0 self.isPet = true self.state = &quot;dead&quot; } public func getName() -&gt; String { return self.name! } internal func setName(name: String?) { self.name = name }} 对应UML类图： 类名：粗体，如果是类是抽象类则类名显示为斜体 属性：可见性 名称：类型[=默认值] 可见性一般为 public、private 和 protected，在类图分别用+、-和#表示，在Swift中没有与 protected 完全对应的可见控制，因此选用的是 internal 对应为# 名称为属性的名称；类型为数据类型 默认值如变量 age默认值为0 方法：可见性 名称（参数列表 参数1，参数2） ：返回类型 二、关系表达类图中类与类之间的关系主要由：继承、实现、依赖、关联、聚合、组合这六大类型。表示方式如下图： 2.1 同级关系继承关系 继承用实线空心箭头表示，由子类指向父类。 下面写两个子类，Fish和Cat分别继承自Animal。 12345678910111213class Fish: Animal { public var fishType: String? func swim() { }}class Cat: Animal { public var hasFeet: Bool? func playToy(doll:Doll) { doll.toyMoved() }} 实现关系 指的是一个 class 类实现 interface 接口（可以是多个）的功能；实现是类与接口之间最常见的关系；在 Java 中此类关系通过关键字 implements 明确标识，在iOS中我将其理解成代理的实现。 写一个洋娃娃类 Doll，该类遵循了 ToyAction 协议，实现了玩具移动的方法。 12345678910111213protocol ToyAction { func toyMoved() -&gt; Void}class Doll: NSObject,ToyAction { public var body: Body? public var cloth: Cloth? func toyMoved() { //洋娃娃玩具动作具体实现 }} 依赖关系【弱】 可以简单的理解，就是一个类 A 使用到了另一个类 B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A；比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖 表现在代码层面，为类 B 作为参数被类 A 在某个 method 方法中使用。 在我们的上述代码中 Cat 的 playToy 方法中参数引用了 Doll，因此他们是依赖关系。 关联关系【强】 他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系，比如我和我的朋友；这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的，关联可以是单向、双向的 表现在代码层面，为类 B 以类属性的形式出现在类 A 中，也可能是类 A 引用了一个类型为类 B 的全局变量； 写一个 Person 类，他拥有一个宠物猫，他们之间的关系是关联。 12345678class Head: NSObject { }class Person: NSObject { public var pet: Cat? public var head: Head?} 2.2 部分与整体聚合关系【弱】 聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即 has-a 的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享；比如计算机与CPU、公司与员工的关系等 表现在代码层面，和关联关系是一致的，只能从语义级别来区分 1234567class Cloth: NSObject { }class Body: NSObject { } 在上述代码中 Doll 由 Body 和 Cloth 组成，且即使失去 Cloth，Doll 也可以正常存在。 组合关系【强】 组合也是关联关系的一种特例，他体现的是一种 contains-a 的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑 表现在代码层面，和关联关系是一致的，只能从语义级别来区分 上述代码中的 Person 拥有 Head，并且这个整体和部分是不可分割的。 三、例子最后来看看这个例子中的整体关系： 其实理解了之后我们发现还是很简单的，学会了之后就可以投入实践中了，举一个简单第三方库的类图例子，下图是 Masonry 的类图整理，可以看到项目结构很清晰的展示了出来。","link":"/2021/04/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/UML-%E7%B1%BB%E5%9B%BE/"}],"tags":[],"categories":[{"name":"iOS·底层原理","slug":"iOS·底层原理","link":"/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"iOS·问题记录","slug":"iOS·问题记录","link":"/categories/iOS%C2%B7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"iOS·数据存储","slug":"iOS·数据存储","link":"/categories/iOS%C2%B7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}