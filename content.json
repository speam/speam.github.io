{"pages":[],"posts":[{"title":"+load 和 +initialize区别","text":"#+load 和 +initialize区别 一、网上的结论1.1 load函数调用特点:当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）就会调用。 与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要调用父类的load函数，否则父类的load函数会多次执行。 1.当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 2.当子类未实现load方法时,不会调用父类load方法 3.类中的load方法执行顺序要优先于分类(Category) 4.当有多个分类(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 5.有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 1.2 initialize函数调用特点:当前类或者他的子类第一次使用的时候调用。 即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要再调用 [super initialize] ，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 1.父类的initialize方法会比子类先执行 2.当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. 3.当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 1.3 什么情况下使用:+load由于调用load方法时的环境很不安全，我们应该尽量减少load方法的逻辑。 load很常见的一个使用场景,交换两个方法的实现 12345678910111213141516//摘自MJRefresh+ (void)load{ [self exchangeInstanceMethod1:@selector(reloadData) method2:@selector(mj_reloadData)]; [self exchangeInstanceMethod1:@selector(reloadRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_reloadRowsAtIndexPaths:withRowAnimation:)]; [self exchangeInstanceMethod1:@selector(deleteRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_deleteRowsAtIndexPaths:withRowAnimation:)]; [self exchangeInstanceMethod1:@selector(insertRowsAtIndexPaths:withRowAnimation:) method2:@selector(mj_insertRowsAtIndexPaths:withRowAnimation:)]; [self exchangeInstanceMethod1:@selector(reloadSections:withRowAnimation:) method2:@selector(mj_reloadSections:withRowAnimation:)]; [self exchangeInstanceMethod1:@selector(deleteSections:withRowAnimation:) method2:@selector(mj_deleteSections:withRowAnimation:)]; [self exchangeInstanceMethod1:@selector(insertSections:withRowAnimation:) method2:@selector(mj_insertSections:withRowAnimation:)];}+ (void)exchangeInstanceMethod1:(SEL)method1 method2:(SEL)method2{ method_exchangeImplementations(class_getInstanceMethod(self, method1), class_getInstanceMethod(self, method2));} +initialize在首次使用某个类之前，系统会向其发送initialize消息，通常应该在里面判断当前要初始化的类，防止子类未覆写initialize的情况下调用两次 initialize方法主要用来对一些不方便在编译期初始化的对象进行赋值。比如NSMutableArray这种类型的实例化依赖于runtime的消息发送，所以显然无法在编译器初始化： 12345678910// In Person.m// int类型可以在编译期赋值static int someNumber = 0; static NSMutableArray *someArray;+ (void)initialize { if (self == [Person class]) { // 不方便编译期复制的对象在这里赋值 someArray = [[NSMutableArray alloc] init]; }} 1.4 总结:load和initialize的共同点1.如果父类和子类都被调用,父类的调用一定在子类之前 +load方法要点当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要再调用[super load]，否则父类的load函数会多次执行。 1.当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 2.当一个类未实现load方法时,不会调用父类load方法 3.类中的load方法执行顺序要优先于分类(Category) 4.当有多个分类(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 5.当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 注意:load调用时机比较早,当load调用时,其他类可能还没加载完成,运行环境不安全.load方法是线程安全的，它使用了锁，我们应该避免线程阻塞在load方法. +initialize方法要点initialize在类或者其子类的第一个方法被调用前调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 1.父类的initialize方法会比子类先执行 2.当子类不实现initialize方法，会把父类的实现继承过来调用一遍。在此之前，父类的方法会被优先调用一次 3.当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 注意:在initialize方法收到调用时,运行环境基本健全。initialize内部也使用了锁，所以是线程安全的。但同时要避免阻塞线程，不要再使用锁 二、面试整理的1.1 load1234567891011121314151617load:调用时机 ：在类被引用进项目的时候（或者说程序启动的时候）, 在main函数之前，调用load方法调用次数 ：与这个类是否被用到无关,每个类的load函数只会自动调用一次。调用顺序 ：执行子类的load方法前，会先执行所有超类的load方法。顺序为父类-&gt;子类-&gt;分类。load函数是系统自动加载的，因此不需要[super load]，否则父类的load函数会多次执行。注意点：1.在load方法中使用其他类是不安全的。因为会调用其他类的load方法，而如果关系复杂的话，就无法判断出各个类的载入顺序，类只有初始化完成后，类实例才能进行正常使用2.load 方法不遵从继承规则，如果类本身没有实现load方法，那么系统就不会调用，不管父类有没有实现应用：load 方法中最常用的就是方法交换(method swizzling) 1.2 Initialize1234567891011121314151617initialize: 调用时机：当前类或者他的子类第一次使用的时候调用，且仅调用一次。通常应该在里面判断当前要初始化的类，防止多次调用。（惰性调用：用到才调用）调用次数：initialize 遵循继承规则初始化子类的的时候会先初始化父类，然后会调用父类的initialize方法，而子类没有覆写initialize方法，因此会再次调用父类的实现方法。所以，如果类未实现initialize方法，而其父类实现了，那么会运行父类的实现代码，而且会运行两次线程相关：运行期系统会确保initialize方法是在线程安全的环境中执行，即，只有执行initialize的那个线程可以操作类或类实例。其他线程都要先阻塞，等待initialize执行完使用注意：在首次使用某个类之前，会调用initialize方法，通常应该在里面判断当前要初始化的类，防止子类未覆写initialize的情况下调用两次","link":"/2020/03/10/+load%20%E5%92%8C%20+initialize%E5%8C%BA%E5%88%AB/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/14/hello-world/"}],"tags":[],"categories":[]}