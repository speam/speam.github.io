{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"02 - 内存对齐","text":"一、内存对齐原则三原则在 iOS 中，对象的属性需要进行内存对齐，而对象本身也需要进行内存对齐。内存对齐有三原则: 1.数据成员对齐原则: 结构体 / 联合体( union )的数据成员，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置要从该成员大小或者成员的子成员大小的整数倍开始）。 2.结构体作为成员: 如果一个结构里有某些结构体成员,则结构体成员要从其内部最大元素大小的整数倍地址开始存储 3.收尾工作: 结构体的总大小,也就是 sizeof 的结果，必须是其内部最大成员的整数倍，不足的要补⻬。 二、内存对齐在系统中的应用2.1 属性 8 字节对齐12345678910111213141516struct MyStruct { double a; char b; // char 在前 int 在后 int c; short d;} MyStr1; struct MyStruct2 { double a; int c; // int 在前 char 在后 char b; short d;} MyStr2; // 我们打印一下各自的所占空间NSLog(@&quot;%lu -- %lu&quot;,sizeof(MyStr1), sizeof(MyStr2)); 结果如下: 为何两者不一致? 我们来看第一个结构体对象的内部结构，排第一的属性double占8位，而char需要补齐7位成为8位，而剩余的int，short 则分别占4位，不需补齐，可以灵活堆在同一个内存区域。 12345678struct MyStruct { double a; // 8位 char b; // 1位 + 7 补齐 = 8 int c; // 4位 short d; // 2位 + 2 = 4} MyStr1; // 总计是 8 + 8 + 4 + 4 = 24； 而第二个结构体对象，排第一的属性double占8位，而剩余的int，short ，short 总计都，不需补齐，可以灵活堆在同一个内存区域。 12345678struct MyStruct2 { double a; // 8 int c; // 4 char b; // 1 补齐1位 short d; // 2 } MyStr2; // 8+4+2+2 = 16。 这里后3位，可以放到一个8位内存区间，即4 + 1 + 2，只需补齐1位至8位，可以灵活排列在一个内存空间内，所以本结构体对象总占内存为8+4+1+2 + 1（补齐1位） = 16。 跟踪源码去证实： 1.创建对象 alloc 2.alloc方法的实现——返回rootAlloc方法 3.返回callAlloc的实现 4.当缓存区没有对象时，创建对象 5.去内存区域创建对象 6.执行类的属性方法，确定创建的空间大小 7.对齐内存 8.内存对齐的返回：类的属性大小取决于指针大小 9.8字节对齐：实现方法 补充：对象属性的内存优化1234567891011121314151617181920// 声明属性@property (nonatomic, copy) NSString *name; // 8个字节@property (nonatomic, assign) int age; // 4个字节@property (nonatomic, assign) long height; // 8个字节@property (nonatomic, copy) NSString *hobby; // 8个字节@property (nonatomic, assign) int sex; // 4个字节@property (nonatomic) char ch1; // 1个字节@property (nonatomic) char ch2; // 1个字节// 对象创建赋值MRObject *obj = [MRObject alloc];obj.name = @&quot;testAlign&quot;;obj.age = 18;obj.height = 185;obj.hobby = @&quot;money&quot;;obj.sex = 2;obj.ch1 = 'a';obj.ch2 = 'b'; 然后打印对象的内存结构，查看对应属性的内存分配 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(lldb) x obj 对象的指针内存情况0x1019038d0: e9 25 00 00 01 80 1d 00 61 62 00 00 12 00 00 00 .%......ab......0x1019038e0: 02 00 00 00 00 00 00 00 48 20 00 00 01 00 00 00 ........H ...... (lldb) x/4gx obj 按照每段8字节打印内存情况，4gx 代表4段0x1019038d0: 0x001d8001000025e9 0x00000012000062610x1019038e0: 0x0000000000000002 0x0000000100002048 (lldb) x/6gx obj 按照每段8字节打印内存情况，6gx 代表6段0x1019038d0: 0x001d8001000025e9 0x00000012000062610x1019038e0: 0x0000000000000002 0x00000001000020480x1019038f0: 0x00000000000000b9 0x0000000100002068 (lldb) po 0x1019038d0 对象的首地址就是对象地址&lt;MRObject: 0x1019038d0&gt;(lldb) po 0x001d8001000025e9 打印第一个段的值，打印不出来，因为这里是 isa，但是 isa 指针要通过 mask 处理之后才能对应到具体的值8303516107941353(lldb) po 0x0000000000000002 对应 int sex 成员的值，占4字节；如果不对 sex 赋值，这里会是0x0000000000000000 代表默认的野地址，还没有赋值，但是也会有内存开辟2(lldb) po 0x0000000100002048 对应 NSString *hobby 的值，8字节testAlign(lldb) po 0x00000000000000b9 对应十进制的 long height 185，因为浮点型会系统底层优化成十进制存储185(lldb) po 0x0000000100002068 对应 NSString *nanme 的值，8字节money// 😳那么 age 和 18 到底存在哪儿呢？？// 仔细一看还有一段内存 0x0000001200006261 没有读取，但是直接读取读不出来；(lldb) po 0x000000120000626177309436513// 看这个内存的结构如果直接拆成两部分，4字节 + 4字节呢，我们单独打印尝试一下(lldb) po 0x00000012 18 // 直接打印出来了赋值的年纪 =&gt; 18 4个字节// 那么剩余的四个字节是否就是 ch1 和 ch2 呢(lldb) po 0x0000626125185// 打印不出来，这个时候我们想到 char 是占用一个字节，单独打印一半呢？？(lldb) po 0x006298(lldb) po 0x006197// 这个就很眼熟，我们恍然大悟，这不是 a 和 b 对应的 ASCII 码值么！a == 97, b = 98 从这里可以得出，在类的成员变量的内存大小分配的时候；系统会进行一次优化，将能进行对齐优化的成员变量放在一个段里面，节约内存空间，以空间换时间，加快 CPU 读取字节时候的偏移计算复杂度；而不是根据成员声明定义的顺序依次进行排布，这里就调整了顺序，然后直接最大化优化内存字节对齐。 2.2 对象 16 字节对齐2.2.1 抛出问题 这里我们看到通过class_getInstanceSize获取的内存大小8(默认属性 isa 的内存大小)；没有并没有按照之前alloc源码流程中的最少16的规则。 因为class_getInstanceSize方法没有走alloc流程中instanceSize方法的**if (size &lt; 16) size = 16**条件，这里直接调用了直接对齐alignedInstanceSize() -&gt; word_align(unalignedInstanceSize())返回的内存大小。 声明了几个属性之后发现就大于16了，因为 isa(8) + name(8) + age(4) + 补齐(4) + height(8) + hobby(8) = 5*8 = 40; 但是会发现 malloc_size 却不等于40，为48；这里就总结出 对象申请的内存大小 与 系统开辟的内存大小 不一致 2.2.2 跟踪 calloc 源码①系统开辟内存 - calloc 在objc源码中查看不了calloc源码的实现，需要在malloc源码中查看。 malloc源码：https://github.com/sunjinayushiwo/mallcoSource ②calloc =&gt; malloc_zone_calloc 这里发现是一个递归调用，跟断点会不知道递归的返回条件；然后这里直接打印 zone 的 calloc 成员，发现是一个函数default_zone_calloc; 全局搜搜函数名得到定义。 1234567static void *default_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size){ zone = runtime_default_zone(); return zone-&gt;calloc(zone, num_items, size); // 递归调用} 发现又是一个递归调用，断点打印zone的calloc成员属性； ③得到nano_calloc方法 1234567891011121314151617181920212223static void *nano_calloc(nanozone_t *nanozone, size_t num_items, size_t size){ size_t total_bytes; if (calloc_get_size(num_items, size, 0, &amp;total_bytes)) { return NULL; } if (total_bytes &lt;= NANO_MAX_SIZE) { // 分析到走这个逻辑，才是内存开辟过程 void *p = _nano_malloc_check_clear(nanozone, total_bytes, 1); if (p) { return p; } else { // 失败的情况，不是我们要找的内存开辟计算，跳过 /* FALLTHROUGH to helper zone */ } } // 失败的情况，不是我们要找的内存开辟计算，跳过 malloc_zone_t *zone = (malloc_zone_t *)(nanozone-&gt;helper_zone); return zone-&gt;calloc(zone, 1, total_bytes);} ④定位_nano_malloc_check_clear方法 得到计算系统开辟对象内存大小的具体方法segregated_size_to_fit，顾名思义：需要隔离填充的内存大小。 123456789101112131415161718192021#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey){ size_t k, slot_bytes; if (0 == size) { size = NANO_REGIME_QUANTA_SIZE; // Historical behavior } k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // round up and shift for number of quanta slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size *pKey = k - 1; // Zero-based! // 上面的定义翻译出来是: slot_bytes = (size + 2^4-1) &gt;&gt; 4 &lt;&lt; 4; // &gt;&gt; 4 &lt;&lt; 4; 右移4位，然后左移4位，得到的就是16的倍数。即2^4对齐。 // 类似于之前介绍的8字节对齐; 所以这里是16字节对齐的算法； return slot_bytes;} 由这里16进制对齐的算法可以得出结论，40的类成员属性字节总数传递进来进行16字节对齐之后返回16*3 = 48字节。 四、总结 对象的属性是按照8字节进行对齐的 对象本身则是按照16字节进行对齐的 因为内存是连续的，通过 16 字节对齐规避了风险和容错，有效的防止了访问溢出 同时，也提高了寻址访问效率，也就是通常我们所说的空间换时间","link":"/2020/10/20/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"},{"title":"01 - alloc &amp; init","text":"一、前言创建对象的例子： 二、如何探索？2.1 普通断点 + 跟踪调试 按住control + in 进入调试查看汇编调用信息；使用真机情况下能定位到 libobjc.A.dylib objc_alloc，所以是要探究的方法在 libobjc.A.dylib 这个库中。 2.2 符号断点设置 要探究alloc方法，所以我们添加一个alloc的符号断点，这时候会显示断到很多类的alloc方法，但是没有关系，因为我们断点了代码所在对象，所以我们直接调试就行；断点执行下一步，就能看到 libobjc.A.dylib + [NSObject alloc]，说明是调用了libobjc.A.dylib库中的NSObject 的 alloc 类方法。 2.3 汇编跟踪 Debug =&gt; Debug Workflow =&gt; Always Show Disassembly 开启汇跟踪设置。 可查看到代码[MRObject alloc]的汇编代码下一步是调用objc_alloc; 所以我们需要研究objc_alloc方法即为alloc的底层实现方法! 三、objc 源码 苹果开源源码地址 =&gt; opensource.apple.com/tarballs/ 搜索 objc 即可看到 objc 源码地址 当前 objc4-756.2 为最新版本! 我的 github 上传了objc4-756.2的源码：https://github.com/speam/OjbcSuorce.git 在objc源码中我们看到很多 old 和 new 的文件命名标识，这代表objc在迭代过程中过渡了两个版本，一个新版，一个旧版。 现在我们都是使用的新版本api，所以查看源码逻辑的时候只需要定位 objc2 或者 new标识的新版本~ 四、准备进行源码调试 前述方式不能直观的跟踪到底层的方法调用。 所以将objc源码集成到我们的调试工程中，通过断点跟踪才能一目了然。 如何集成objc源码 =&gt; iOS_objc4-756.2 最新源码编译调试 五、进行 objc 源码调试/查看/跟踪5.1 alloc =&gt; objc_rootAlloc入口： 5.2 callAlloc 首先看 __OBJC2__的分支，现在是使用的新版本；然后看第一个判断fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())，这里是判断该类是否有重写initWithZone；第二层判断 fastpath(cls-&gt;canAllocFast())，是否可以快速创建，这里会返回false，具体实现见下分析。 5.2.1 canAllocFast canAllocFast()最后会调 bits.canAllocFast() 跟踪bits.canAllocFast()中的canAllocFast 实现： 查看 FAST_ALLOC 宏定义 5.2.2 class_createInstance 打印obj的值，印证流程 5.3 init 六、alloc 流程图 七、lldb / gdb 命令调试 1.x/4gx obj:代表以十六进制打印obj的4段内存信息 2.p/t:代表打印二进制信息(还有p/o、p/d、p/x分别代表八进制、十进制和十六进制打印)","link":"/2020/10/19/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-alloc&init/"},{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"}],"tags":[],"categories":[{"name":"iOS·底层原理","slug":"iOS·底层原理","link":"/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"}]}