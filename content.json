{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"URL编码和解码","text":"一、URL含义1、URL定义URL 是Uniform Resource Locator 的缩写，统一资源定位符，互联网上的每个文件都有一个唯一的URL。 URL 与 URI 很多人会混淆这两个名词。 URL：(Uniform/Universal Resource Locator 的缩写，统一资源定位符)。 URI：(Uniform Resource Identifier 的缩写，统一资源标识符)。 URI 属于 URL 更低层次的抽象，一种字符串文本标准。URL 是 URI 的一个子集。 URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（http://）。 URI结构 1234567foo://example.com:8042/over/there?name=ferret#nose \\_/ \\______________/ \\________/\\_________/ \\__/ | | | | | scheme authority path query fragment 2、URL字符编码表1、URL 编码 - 从 %00 到 %ff 2、HTML特殊字符编码对照表 二、URL 编码1、为什么要编码转义推荐阅读：字符编码：ASCII、Unicode 和 UTF-8 的区别 世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，所以必须要统一字符编码。 Unicode规定了符号唯一的二进制代码值。 UTF-8是一种针对Unicode的可变长度字符编码，规定这个二进制代码应该如何存储。UTF-8用1到4个字节编码Unicode字符，在互联网上使用最广的一种 Unicode 的实现方式。 如 中 字: Unicode码值： \\u4e2d URL编码（UTF-8）： %e4%b8%ad 2、URL编码规则使用%加上两位的字符0123456789ABCDEF代表一个字节的十六进制形式。Url编码默认使用的字符集是US-ASCII。例如a在US-ASCII码中对应的字节是0x61，那么Url编码之后得到的就是%61，我们在地址栏上输入 http://g.cn/search?q=%61%62%63 ，实际上就等同于在google上搜索abc了。又如@符号在ASCII字符集中对应的字节为0x40，经过Url编码之后得到的是%40。 对于非ASCII字符，需要使用ASCII字符集的超集进行编码得到相应的字节，然后对每个字节执行百分号编码。对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。如”中文”使用UTF-8字符集得到的字节为0xE4 0xB8 0xAD 0xE6 0x96 0x87，经过Url编码之后得到”%E4%B8%AD%E6%96%87”。 3、URL不需要编码的字符1、英文字母（a-z A-Z） 2、数字（0-9） 3、 - _ . ~ 4个特殊字符 4、所有保留字符，RFC3986中指定了以下字符为保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ] 5、编码标记符号 % 4、URL需要编码的字符4.1、非URL定义的字符如中文字符、希腊文字符，拉丁文字符等。 4.2、会引起歧义的保留字符URL 拼接参数或路径设置时，拼接的普通字符串中含有保留字符，会引起歧义的情况。URL 参数字符串中使用 key=value 这样的键值对形式来传参，键值对之间以 &amp; 符号分隔，如宝洁公司的简称为P&amp;G，假设需要当做参数去传递，name=P&amp;G&amp;t=1450591802326，因为参数中多了一个&amp;势必会造成接收 URL 的服务器解析错误，因此必须将引起歧义的 &amp; 符号进行转义编码。 部分保留字符及其URL编码 字符 用法描述 编码 + 表示空格（在URL中不能使用空格） %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的URL和参数 %3F # 表示书签或锚点 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定的参数的值 %3D % 百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 %25 如果需要在URL中用到特殊字符或中文字符，需要将这些特殊字符换成相应的十六进制的值。 三、iOS端URL具体编码处理1、URL编码和解码是成对URL编码和解码必须是成对出现的。 这四种种字符后，URL编码后的值还是它本身： 1、英文字母（a-z A-Z） 2、数字（0-9） 3、特殊字符（ -_.） 4、部分保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? 说明：~ # [] 这四个字符是否被转码成百分号编码，因系统不同会有不同。 URL字符编码使用%百分号加上两位的字符——0123456789ABCDEF——代表一个字节的十六进制形式。因编码后的值含有 % 保留字符。再次编译% 会编译成 %25 。 例如： &amp; 第一次URL编码后：%26 第二次URL编码后：%2526 第三次URL编码后：%252526 正常解码逻辑： 第一次URL解码后：%2526 第二次URL解码后：%26 第三次URL解码后：&amp; 2、URL是怎么拆解的我们看一个常见的接口请求示例： 一般会根据 ://、: 、 / 、 ?、 &amp;、= 等拆分出请求的协议、服务器名称（或IP地址）、端口号、路径和文件名、参数名、参数值等。 3、在组装URL的什么阶段进行URL编码我们看一个常见的接口请求示例： 字符串 说明 :// 协议符号 / 分隔目录和子目录 测试 代表需要编译处理的路径 ？ 分隔实际的URL和参数 &amp; URL中指定的参数间的分隔符 = URL中指定的参数的值 搜&amp;索 搜索词含有中文，含有保留字段，需要编译 &amp;times 是key的一部分，不应该被编译，若多一次编译，会编译为 x 绿色字体是保留字符，都有特殊的含义，是不应该是被编码的。 红色字体必须要要编译的部分。 黄色背景的字符串，不应该被编译。 若以上操作不正确，会影响整个URL的解析。 常见的拼接过程： 1、先拼接实际的请求地址 https://www.baidu.com/s/测@试? 2、再拼接参数字符串 wd=搜&amp;索&amp;timestamp=32424242423 3、将1、2合并凭借成一个网址字符串。 4、将网址字符串转为NSURL 实例。 分析 1、因 测@试 含有中文和保留字符@，需要在步骤1之前，先将 测@试 编码为 %e6%b5%8b%40%e8%af%95 ，再拼接到https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95? 2、因 搜&amp;索 含有中文和保留字符&amp; ,&amp; 会影响参数解析。需要先搜&amp;索 编码为 %e6%90%9c%26%e7%b4%a2 ，再拼接到wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 3、因请求地址和参数列表已经编码过，拼接后的完整请求不应该再次编译。若再次编译 则会因含有 &amp;times 编译为 x 。 小结 上面我们分别编码特殊字符后，最后拼接到一起。也有部分写法是拼接后再统一编码处理的。但因请求路径、请求参数中都可能含有保留字符&amp;、=或中文等特殊字符，造成请求地址解析错误。建议在路径和参数拼接前对路径、参数名、参数值等先行统一编码处理，再行拼接。拼接好后不要再行编码，转为NSURL实例，发送请求。 4、可用的编码和解码APIiOS端生成NSURL实例 1NSURL *url = [NSURL URLWithString:urlString]; 注意： urlString 中含有中文字符等非定URL限定字符时，创建的NSURL对象会失败，url返回为nil。 URL编码123456789101112131415161718NSString *urlStr = @&quot;你好0123456789abcxyzABCXYZ-_.~&amp;!*'();:@&amp;=+$,/?#[]% &quot;;//方式一【推荐】NSString *encodingString = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@&quot;url编码1-1 = %@&quot;,encodingString);//方式二：NSString *encodeStr3 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url编码3-1 = %@&quot;,encodeStr3);//方式三：自定义字符集 ABC-_~.!*'();:@&amp;=+ $,/?%#[] 编码对比NSString *encodeStr2 = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)urlStr, NULL, (CFStringRef)@&quot;ABC-_~.!*'();:=+ $,/?%#[]&quot;, kCFStringEncodingUTF8)); NSLog(@&quot;url编码2-2 = %@&quot;,encodeStr2); //方式四：自定义字符不需要编译的字符集，为空字符集，将所有字符用百分号编码NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;&quot;];NSString *encodeStr4 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:characterSet]; NSLog(@&quot;url编码3-2 = %@&quot;,encodeStr4); 打印结果是 网上常见的字符集枚举说明（供参考）: 123456URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\\^`{|}URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^`{|}URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\\]^`{|}URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^` URL解码1234//上段代码的结果为encodeStr3入参NSString *decodedStr3 = [encodeStr3 stringByRemovingPercentEncoding];NSLog(@&quot;url编码3-1 = %@&quot;,decodedStr3); 打印结果是 四、总结1、在URL组装拼接前对各个部分的可能会引起歧义的字符串进行全量UTF-8编码。 2、在需要解码的地方，需要先分拆字符串，再分段解码使用。 3、在需要将已组装的数据，进行重组时，需要先拆解，分别解码后再编码，最后再重组。 4、服务端会对请求进行UTF-8解码一次，请确保请求中的字符只进行一次UTF-8编码。","link":"/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URL%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B/"},{"title":"","text":"一、类的结构1.1 解读类的本质从NSObject类的定义开始 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop} 注意：NSObject有个Class类型的isa成员变量 接下来用Clang编译main.m，输出.cpp文件，看一下NSObject类的底层定义 1clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 打开main.cpp文件，找到了NSObject 123456789#ifndef _REWRITER_typedef_NSObject#define _REWRITER_typedef_NSObjecttypedef struct objc_object NSObject;typedef struct {} _objc_exc_NSObject;#endifstruct NSObject_IMPL { Class isa;}; 发现NSObject类本质上是objc_object结构体，同时有定义一个NSObject_IMPL结构体（IMPL是implementation的缩写），里面有NSObject类的isa成员变量（对应于OC时的NSObject类定义中的isa成员变量）。 现在把我们自己定义的Person类用clang编译成c++看一下。我们定义的Person类：(有个age属性和run方法) 123456789101112131415@interface Person : NSObject@property (nonatomic) NSInteger age;- (void)run;@end@implementation Person- (void)run { NSLog(@&quot;I am running.&quot;);}@end 编译成c++后： 123456789101112131415161718#ifndef _REWRITER_typedef_Person#define _REWRITER_typedef_Persontypedef struct objc_object Person;typedef struct {} _objc_exc_Person;#endifextern &quot;C&quot; unsigned long OBJC_IVAR_$_Person$_age;struct Person_IMPL { struct NSObject_IMPL NSObject_IVARS; NSInteger _age;};static void _I_Person_run(Person * self, SEL _cmd) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mc_9fhhprrj4k92vxzqm3g127z40000gn_T_main_09fc70_mi_0);}static NSInteger _I_Person_age(Person * self, SEL _cmd) { return (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)); }static void _I_Person_setAge_(Person * self, SEL _cmd, NSInteger age) { (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)) = age; } 可见，Person类本质同样是objc_object结构体类型，Person_IMPL结构体内部多了个struct NSObject_IMPL类型的NSObject_IVARS成员变量——即继承自NSObject的类，都有个Class类型的isa成员变量。 1.2 objc_object结构源码： 12345678910111213141516171819202122struct objc_object {private: isa_t isa; public: ... // 一些函数};union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h };#endif}; 关于isa_t的分析见上篇文章 objc_object结构体内部的方法有五十个左右，大致可分为以下几类 一些关于isa的函数，如initIsa()、getIsa()、changeIsa()等 一些弱引用的函数，如isWeaklyReferenced()、setWeaklyReferenced_nolock()等 一些内存管理函数，如retain()、release()、autorelease()等 两个关联对象函数，分别是hasAssociatedObjects()和setHasAssociatedObjects 1.3 Class结构简介同样先上源码 1234567891011121314typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... // 一些函数}; 从源码可以看出，Class是objc_class结构体类型的指针变量，继承自objc_object结构体。也就是说，Class有4个成员变量，且它们在内存存储上是有序的，依次分别是： 1.isa：类型是isa_t，64位下长度为8字节，上篇已做过分析，这里略过 2.superclass：类型是Class，表示继承关系，指向当前类的父类，同样8字节 3.cache：类型是cache_t，表示缓存，用于缓存已调用的方法，加速方法的调用。其具体结构如下: 12345678910111213141516struct cache_t { struct bucket_t *_buckets; // 64位下是8字节 mask_t _mask; // 64位下是4字节 mask_t _occupied; // 64位下是4字节public: ... // 一些函数};#if __LP64__typedef uint32_t mask_t; // uint32_t 4字节 // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t; // uint16_t 2字节#endiftypedef unsigned int uint32_t; 可见，cache这个成员变量长度是16字节。 cache比较重要，关于它的分析可戳 OC源码分析之方法的缓存原理。 4.bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其结构如下 12345678struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; // unsigned longprivate: ... // 一些函数}; 其长度也是8字节。根据bits成员变量在objc_object结构体中的描述，它实质上是class_rw_t *加上自定义rr/alloc标志，最重要的是class_rw_t。 接下来将重点介绍它。 二、class_rw_t &amp; class_ro_t分析 rw是readwrite的意思，而ro则是readonly。 OC类中的属性、方法还有遵循的协议等信息都保存在class_rw_t中，首先看看class_rw_t的结构： 12345678910111213141516171819202122232425262728struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif ...// 一些函数};#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1 // armv7k or arm64_32#else# define SUPPORT_INDEXED_ISA 0#endif 发现class_rw_t中还有一个被const修饰的指针变量 ro，是class_ro_t结构体指针，其中存储了当前类在编译期确定的方法、成员变量、属性以及遵循的协议等信息。 1234567891011121314151617181920212223struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; ... // 一些函数}; 2.1 获取class_rw_t要想获取class_rw_t指针地址，需要知道objc_class的bits指针地址，通过对objc_class的结构分析得知，bits指针地址是objc_class首地址偏移32个字节（isa + superclass + cache = 8+8+16=32字节） 也可以从源码得知如何拿到class_rw_t指针 12345678910111213// objc_class结构体中class_rw_t *data() { return bits.data(); // bits是class_data_bits_t类型}// class_data_bits_t结构体中...class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}// 64位下#define FAST_DATA_MASK 0x00007ffffffffff8UL 在64位下，class_rw_t指针地址是在[3, 46]数据段，所以也可以用bits &amp; FAST_DATA_MASK计算出class_rw_t指针地址。 接着通过一个例子来验证class_rw_t和class_ro_t是否存储了类的信息 2.2 准备工作给Person类添加属性、方法和协议，代码如下 123456789101112131415161718192021222324252627282930313233@protocol PersonProtocol &lt;NSObject&gt;- (void)walk;@end@interface Person : NSObject &lt;PersonProtocol&gt; { NSInteger _gender;}@property (nonatomic) NSString *name;@property (nonatomic) NSInteger age;+ (void)printMyClassName;- (void)run;@end@implementation Person+ (void)printMyClassName { NSLog(@&quot;my class name is Person&quot;);}- (void)run { NSLog(@&quot;I am running.&quot;);}- (void)walk { NSLog(@&quot;I am walking.&quot;);}@end 然后打上断点 好了，准备工作完成，下面开始验证 2.3 class_rw_t验证过程1.打印Person类 1234(lldb) x/5gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x00000000000000000x100002840: 0x0000000102237404 说明： Person类首地址是0x100002820，因此，0x100002840是其bits地址（32字节就是0x20，0x100002840 = 0x100002820 + 0x20），bits内容是0x0000000102237404 0x001d8001000027f9是Person类的isa地址，指向Person元类 0x0000000100b39140是Person类的superclass地址，也就是NSObject类首地址 0x00000001003dc250 0x0000000000000000则是Person类的cache段 2.打印class_rw_t 12345678910111213141516171819202122232425262728293031323334353637// bits &amp; FAST_DATA_MASK(lldb) p (class_rw_t *)(0x0000000102237404 &amp; 0x00007ffffffffff8)(class_rw_t *) $1 = 0x0000000102237400(lldb) p *$1(class_rw_t) $2 = { flags = 2148139008 version = 0 ro = 0x0000000100002788 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002608 arrayAndFlag = 4294977032 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x0000000100002720 arrayAndFlag = 4294977312 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x00000001000025a8 arrayAndFlag = 4294976936 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000} 这里请大家留意一下class_rw_t的几个关键成员变量： ro地址是0x0000000100002788 methods的list地址是0x0000000100002608 properties的list地址是0x0000000100002720 protocols的list地址是0x0000000100002608 3.验证methods 目前来看，Person类至少有6个实例方法，分别是run、walk以及name和age的getter、setter，还有1个类方法，即printMyClassName，总计7个方法。 123456789101112131415(lldb) p (method_list_t *)0x0000000100002608 // rw的methods的list地址(method_list_t *) $7 = 0x0000000100002608(lldb) p *$7(method_list_t) $8 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 7 first = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45) } }} 正好是7个方法，让我们看看都是哪些（由于method_list_t继承自entsize_list_tt，可以通过entsize_list_tt的get()函数一一打印） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(lldb) p $8.get(0)(method_t) $9 = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45)}(lldb) p $8.get(1)(method_t) $10 = { name = &quot;.cxx_destruct&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001600 (CCTest`-[Person .cxx_destruct] at main.m:35)}(lldb) p $8.get(2)(method_t) $11 = { name = &quot;name&quot; types = 0x0000000100001eb1 &quot;@16@0:8&quot; imp = 0x0000000100001560 (CCTest`-[Person name] at main.m:27)}(lldb) p $8.get(3)(method_t) $12 = { name = &quot;setName:&quot; types = 0x0000000100001f4b &quot;v24@0:8@16&quot; imp = 0x0000000100001580 (CCTest`-[Person setName:] at main.m:27)}(lldb) p $8.get(4)(method_t) $13 = { name = &quot;age&quot; types = 0x0000000100001f56 &quot;q16@0:8&quot; imp = 0x00000001000015c0 (CCTest`-[Person age] at main.m:28)}(lldb) p $8.get(5)(method_t) $14 = { name = &quot;run&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001500 (CCTest`-[Person run] at main.m:41)}(lldb) p $8.get(6)(method_t) $15 = { name = &quot;setAge:&quot; types = 0x0000000100001f5e &quot;v24@0:8q16&quot; imp = 0x00000001000015e0 (CCTest`-[Person setAge:] at main.m:28)} 显然，class_rw_t的methods确实包含了Person类的全部实例方法，只是多了个.cxx_destruct方法。.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作，关于其原理这里略过不提。 思考：类方法printMyClassName哪里去了？ 4.验证properties 同理，Person类至少有name和age这两个属性，且看 1234567891011121314151617181920212223242526272829(lldb) p (property_list_t *)0x0000000100002720 // rw的properties的list地址(property_list_t *) $18 = 0x0000000100002720(lldb) p *$18(property_list_t) $19 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 6 first = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) }}(lldb) p $19.get(0)(property_t) $20 = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) (lldb) p $19.get(1)(property_t) $21 = (name = &quot;age&quot;, attributes = &quot;Tq,N,V_age&quot;) (lldb) p $19.get(2)(property_t) $22 = (name = &quot;hash&quot;, attributes = &quot;TQ,R&quot;) (lldb) p $19.get(3)(property_t) $23 = (name = &quot;superclass&quot;, attributes = &quot;T#,R&quot;) (lldb) p $19.get(4)(property_t) $24 = (name = &quot;description&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) (lldb) p $19.get(5)(property_t) $25 = (name = &quot;debugDescription&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) 显然name和age存储在properties中。 多余的属性也不作赘述。 5.验证protocols 在验证之前，先分析一下protocol_list_t，这个结构体并不是继承自entsize_list_tt的，其结构如下 1234567struct protocol_list_t { // count is 64-bit by accident. uintptr_t count; protocol_ref_t list[0]; // variable-size ... // 一些函数} 注意到variable-size这个注释部分（可变大小），仿佛看到了希望 123456789101112131415161718192021typedef uintptr_t protocol_ref_t; // protocol_t *, but unremappedstruct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); ... // 一些函数}; protocol_ref_t虽然未映射成protocol_t *，不过应该可以考虑一下强转，实验一下吧（这次是找到PersonProtocol协议） 1234567891011121314151617181920212223242526272829303132333435363738394041(lldb) p (protocol_list_t *)0x00000001000025a8 // rw的protocols的list地址(protocol_list_t *) $26 = 0x00000001000025a8 (lldb) p *$26(protocol_list_t) $27 = (count = 1, list = protocol_ref_t [] @ 0x00007fb5decb30f8)(lldb) p (protocol_t *)$26-&gt;list[0](protocol_t *) $32 = 0x00000001000028a8 (lldb) p *$32(protocol_t) $33 = { objc_object = { isa = { cls = Protocol bits = 4306735304 = { nonpointer = 0 has_assoc = 0 has_cxx_dtor = 0 shiftcls = 538341913 magic = 0 weakly_referenced = 0 deallocating = 0 has_sidetable_rc = 0 extra_rc = 0 } } } mangledName = 0x0000000100001d16 &quot;PersonProtocol&quot; // 出现了！！！ protocols = 0x0000000100002568 instanceMethods = 0x0000000100002580 classMethods = 0x0000000000000000 optionalInstanceMethods = 0x0000000000000000 optionalClassMethods = 0x0000000000000000 instanceProperties = 0x0000000000000000 size = 96 flags = 0 _extendedMethodTypes = 0x00000001000025a0 _demangledName = 0x0000000000000000 _classProperties = 0x0000000000000000} 功夫不负有心人，最终验证了class_rw_t的protocols中含有Person类所遵循的PersonProtocol协议。 到了这里，**class_rw_t确实存储了类的实例方法、属性和遵循的协议了。** 2.4 class_ro_t验证过程现在就剩下ro了 1.打印class_ro_t 123456789101112131415161718(lldb) p $1-&gt;ro(const class_ro_t *) $38 = 0x0000000100002788 (lldb) p *$38(const class_ro_t) $39 = { flags = 388 instanceStart = 8 instanceSize = 32 reserved = 0 ivarLayout = 0x0000000100001d2e &quot;\\x11&quot; name = 0x0000000100001d0f &quot;Person&quot; baseMethodList = 0x0000000100002608 baseProtocols = 0x00000001000025a8 ivars = 0x00000001000026b8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x0000000100002720 _swiftMetadataInitializer_NEVER_USE = {}} 有没有发现什么！**class_ro_t的方法、属性和协议的地址都与class_rw_t的一致，既然指向的是同一块内存空间，显然class_ro_t也存储了Person类的实例方法、属性和协议**。 与class_rw_t不同的是，class_ro_t多了一个ivars列表，里面存放的应该是Person类的成员变量。 2.验证ivars Person类的成员变量有：_gender、_name和_age 所幸ivar_list_t是继承自entsize_list_tt的，get()函数又可以用了。 12345678910111213141516171819202122232425262728293031323334353637383940(lldb) p $39.ivars(const ivar_list_t *const) $40 = 0x00000001000026b8(lldb) p *$40(const ivar_list_t) $41 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = { entsizeAndFlags = 32 count = 3 first = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8 } }}(lldb) p $41.get(0)(ivar_t) $42 = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(1)(ivar_t) $43 = { offset = 0x00000001000027e8 name = 0x0000000100001e8b &quot;_name&quot; type = 0x0000000100001f6b &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(2)(ivar_t) $44 = { offset = 0x00000001000027f0 name = 0x0000000100001e91 &quot;_age&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8} 完全符合预期，class_ro_t确实存储了Person类的成员变量。 2.5 rw和ro的联系【下面看不懂了】为什么class_rw_t、class_ro_t的方法、属性和协议的地址一致？ 在class_data_bits_t结构体中的safe_ro()函数中发现了端倪 12345678910const class_ro_t *safe_ro() { class_rw_t *maybe_rw = data(); if (maybe_rw-&gt;flags &amp; RW_REALIZED) { // maybe_rw is rw return maybe_rw-&gt;ro; } else { // maybe_rw is actually ro return (class_ro_t *)maybe_rw; }} 可见，rw不一定是rw，也可能是ro。实际上，在编译期间，类的class_data_bits_t *bits指针指向的是class_ro_t *，然后在OC运行时调用了realizeClassWithoutSwift()（苹果开源的objc4-756.2源码是realizeClassWithoutSwift()，在此之前的版本是realizeClass()方法），这个方法主要做的就是利用编译期确定的ro来初始化rw： 12345678910111213141516171819ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // 一般走这里 // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); // 给rw申请内存 rw-&gt;ro = ro; // 设置rw的ro rw-&gt;flags = RW_REALIZED|RW_REALIZING; // 设置flags cls-&gt;setData(rw); // 给cls设置正确的rw}... // 初始化 rw 的其他字段，更新superclass、meta class// Attach categoriesmethodizeClass(cls); 在代码的最后，还调用了methodizeClass()，其源码如下 1234567891011121314151617181920212223242526272829303132333435363738static void methodizeClass(Class cls){ runtimeLock.assertLocked(); bool isMeta = cls-&gt;isMetaClass(); auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; ... // 打印信息 // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); } property_list_t *proplist = ro-&gt;baseProperties; if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1); } if (cls-&gt;isRootMetaclass()) { addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); } category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); ... // 打印信息 if (cats) free(cats); ... // 打印信息} 在这个方法里，将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、properties 和 protocols 列表中。 这就完美解释了为什么运行时rw和ro的方法、属性和协议相同。 2.6 rw和ro在运行时的不同之处目前为止的验证都是基于Person类的现有结构，也就是在编译期就确定的，突出不了class_rw_t和class_ro_t的差异性。接下来会用runtime的api在运行时为Person动态添加一个fly()方法，再来一试。 1.添加方法 具体代码如下： 12345void fly(id obj, SEL sel) { NSLog(@&quot;I am flying&quot;);}class_addMethod([Person class], NSSelectorFromString(@&quot;fly&quot;), (IMP)fly, &quot;v@:&quot;); 再加一个打印方法，用于打印类的methods 123456789101112void printMethods(Class cls) { if (cls == nil) { return ; } CCNSLog(@&quot;------------ print %@ methods ------------&quot;, NSStringFromClass(cls)); uint32_t count; Method *methods = class_copyMethodList(cls, &amp;count); for (uint32_t i = 0; i &lt; count; i++) { Method method = methods[i]; CCNSLog(@&quot;名字：%@ -- 类型：%s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method)); }} 运行一下看效果，发现添加成功，如图 2.验证过程 先打印class_rw_t，即 还有class_ro_t 对比后发现，两者的属性、协议指针地址未发生变化，但是方法的指针地址不一样了。 由于class_rw_t是运行时才初始化的，而class_ro_t在编译期间就确定了，因此可以猜测新增的fly方法存储在class_rw_t的methods指针上，class_ro_t的baseMethodList指针从编译期之后就未发生改变。 下面继续验证，首先看class_ro_t的方法列表 OK，编译期就确定的方法都在，并且没有fly方法，也就是说class_ro_t的方法列表在运行时基本没变。 class_ro_t的属性列表、成员变量列表、协议在运行时都没有发生改变。感兴趣的同学可以自己尝试验证一下。 接着看class_rw_t的方法列表 class_rw_t的methods里面数据居然都没有了？ 没办法，这里暂时留个坑吧，暂时不知道原因。 3. 总结3.1 类的结构总结关于类的结构，我们了解到： 类本质上是objc_object结构体，也就是类也是对象，即万物是对象。 类都包含一个Class类型的成员变量isa Class是objc_class结构体类型的指针变量，内部有4个成员变量，即 isa：类型是isa_t superclass：类型是Class，表示继承关系，指向类的父类 cache：类型是cache_t，表示缓存，用于缓存指针和 vtable，加速方法的调用 bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其长度在64位CPU下为8字节，是个指针，指向class_rw_t * 3.2 class_rw_t和class_ro_t总结 class_ro_t存储了类在编译期确定的方法（包括其分类的）、成员变量、属性以及遵循的协议等信息，在运行时不会发生变化。编译期，类的bits指针指向的是class_ro_t指针（即此时class_rw_t 实际上是class_ro_t ）。 实例方法存储在类中 类方法存储在元类中（【4.1】将给出证明） 在realizeClassWithoutSwift()执行之后，class_rw_t才会被初始化，同时存储类的方法、属性以及遵循的协议，实际上，class_rw_t和class_ro_t两者的方法列表（或属性列表、协议列表）的指针是相同的。 运行时向类动态添加属性、方法时，会修改class_rw_t的属性列表、方法列表指针，但class_ro_t对应的属性列表、方法列表不会变。 一个待解决的坑：通过运行时添加方法（或属性、协议）改变了 class_rw_t 对应的方法列表（或属性列表、协议列表）的指针后，不知道为什么居然在 class_rw_t 的方法列表（或属性列表、协议列表）上找不到新增的方法（或属性、协议）了。 3.3 类方法的存储位置（Person类的类方法printMyClassName()） 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. 获取 Person元类(lldb) x/4gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x0000000000000000(lldb) p/x 0x001d8001000027f9 &amp; 0x00007ffffffffff8(long) $50 = 0x00000001000027f8(lldb) po 0x00000001000027f8Person // Person元类// 2. 获取 Person元类 的 bits(lldb) x/5gx 0x00000001000027f80x1000027f8: 0x001d800100b390f1 0x0000000100b390f00x100002808: 0x0000000102237440 0x00000001000000030x100002818: 0x00000001022373a0 // Person元类 的 bits// 3. 获取 Person元类 的 class_rw_t(lldb) p (class_rw_t *)(0x00000001022373a0 &amp; 0x00007ffffffffff8)(class_rw_t *) $52 = 0x00000001022373a0// 4. 验证 Person元类 的 methods(lldb) p $52-&gt;methods(method_array_t) $55 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002270 arrayAndFlag = 4294976112 } }}(lldb) p (method_list_t *)0x0000000100002270(method_list_t *) $56 = 0x0000000100002270(lldb) p *$56(method_list_t) $57 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 1 first = { name = &quot;printMyClassName&quot; // 成功找到 Person类的类方法 types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x00000001000014d0 (CCTest`+[Person printMyClassName] at main.m:37) } }} 结论：类方法 存储 在类的元类上，且位于元类的class_ro_t的baseMethodList指针上（或在class_rw_t的methods指针上）","link":"/2020/11/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03-%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84/"}],"tags":[],"categories":[{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}]}