{"pages":[{"title":"关于本站","text":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/about/index.html"}],"posts":[{"title":"01-对象的创建","text":"一、前言看一个简单的例子： 思考alloc和init底层到底做了什么？带着这些问题，我们从源码的角度探索。 二、分析 alloc 源码1.0 准备工作1.从 苹果官方开源代码列表 找到 objc4源码。 苹果于 2006 年发布 Objective-C 2.0 ，重写了 Objective-C 1.0 中类与对象的定义，命名为 objc4 2.下载到本地后，需要对工程进行一番编译调试，具体步骤可参考 Cooci 的博客 iOS_objc4-756.2 最新源码编译调试。 3.编译通过后，就可以新建个 target 调试了 我 Github 上的源码：https://github.com/speam/OjbcSuorce.git 4.常用的代码跟踪方式： Xcode 菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly control + step into 下符号断点，如alloc 1.1 objc_alloc—alloc的真正入口给[Person alloc]加断点 此时，在Xcode的菜单栏依次点击Debug-&gt;Debug Workflow-&gt;Always show Disassembly，得到汇编代码，发现调用了objc_alloc: 定位到objc_alloc()，发现内部调用callAlloc() 1.2 callAlloc分析objc_alloc()内部调用callAlloc()，其源码为： 123456789101112131415161718192021222324252627282930313233// Call [cls alloc] or [cls allocWithZone:nil], with appropriate // shortcutting optimizations.static ALWAYS_INLINE idcallAlloc(Class cls, bool checkNil, bool allocWithZone=false){ if (slowpath(checkNil &amp;&amp; !cls)) return nil;#if __OBJC2__ if (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) { // No alloc/allocWithZone implementation. Go straight to the allocator. // fixme store hasCustomAWZ in the non-meta class and // add it to canAllocFast's summary if (fastpath(cls-&gt;canAllocFast())) { // 永远不走这里 // No ctors, raw isa, etc. Go straight to the metal. bool dtor = cls-&gt;hasCxxDtor(); id obj = (id)calloc(1, cls-&gt;bits.fastInstanceSize()); if (slowpath(!obj)) return callBadAllocHandler(cls); obj-&gt;initInstanceIsa(cls, dtor); return obj; } else { // 永远走这里 // Has ctor or raw isa or something. Use the slower path. id obj = class_createInstance(cls, 0); if (slowpath(!obj)) return callBadAllocHandler(cls); return obj; } }#endif // No shortcuts available. if (allocWithZone) return [cls allocWithZone:nil]; return [cls alloc];} 对callAlloc()的分析如下： ①__OBJC2__在 OC2.0 以后为1，源码： 12345678// Define __OBJC2__ for the benefit of our asm files.#ifndef __OBJC2__# if TARGET_OS_OSX &amp;&amp; !TARGET_OS_IOSMAC &amp;&amp; __i386__ // old ABI# else# define __OBJC2__ 1 // 总之都是1# endif#endif ②slowpath(bool)与fastpath(bool)：常用于if-else，可以优化判断的速度。 12345// fastpath(x)：表示返回值为x，且x很有可能为1#define fastpath(x) (__builtin_expect(bool(x), 1))// slowpath(x)：表示返回值为x，且x很有可能为0#define slowpath(x) (__builtin_expect(bool(x), 0)) ③hasCustomAWZ()：意思是hasCustomAllocWithZone，即是否有重写类的+allocWithZone:方法，但是它的值并不能简单地这么判断！先看源码 123bool hasCustomAWZ() { return ! bits.hasDefaultAWZ();} 注意：hasCustomAWZ()的值问题【非常重要，设置初始化顺序，很多博客中根本没有提到！】 类的+initialize方法主要用于初始化静态变量。在其执行之前，hasDefaultAWZ()值为false，即hasCustomAWZ()为true；其执行之后，如果当前类重写了+allocWithZone:方法，hasCustomAWZ()为true，否则为false（一般情况下不会重写，即hasCustomAWZ为false）。 类的+initialize方法会在第一次初始化该类之前调用。当调用[cls alloc]时，会触发objc_msgSend，然后会执行+initialize:。（感兴趣的同学可以分别打印+alloc和+initialize:方法加以验证） 因此，当类第一次来到callAlloc()时，最终会执行[cls alloc]。 ④canAllocFast()源码如下： 1234bool canAllocFast() { assert(!isFuture()); return bits.canAllocFast();} 再往底层找bits.canAllocFast()，发现关键宏FAST_ALLOC 1234567891011#if FAST_ALLOC ... bool canAllocFast() { return bits &amp; FAST_ALLOC; }#else ... bool canAllocFast() { return false; }#endif 继续深入，来到了FAST_ALLOC宏定义之处 123456789#if !__LP64__ // 当前操作系统不是64位...#elif 1 // 当前操作系统是64位...#else ...#define FAST_ALLOC (1UL&lt;&lt;2) // 找到了...#endif 从上面宏代码可以得出这样的结论，即无论当前操作系统是不是64位，都没有定义FAST_ALLOC，也就是说，canAllocFast()永远是false! 因此，如果hasCustomAWZ()为false时，会直接去到class_createInstance()。 1.3 alloc-&gt;_objc_rootAlloc-&gt;callAlloc-&gt;class_createInstance通过对hasCustomAWZ()的分析，我们知道类的第一次初始化最终是走到callAlloc的最后，即return [cls alloc]; ①由于执行了[cls alloc]，这次真的来到alloc()方法了 123+ (id)alloc { return _objc_rootAlloc(self);} ②接着是_objc_rootAlloc() 1234567// Base class implementation of +alloc. cls is not nil.// Calls [cls allocWithZone:nil].id_objc_rootAlloc(Class cls){ return callAlloc(cls, false/*checkNil*/, true/*allocWithZone*/); // 注意这里的三个参数} ③再次来到callAlloc，此时hasCustomAWZ()的值取决于当前类是否重写了+allocWithZone:方法。 由于Person类没有重写，fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())为true，而canAllocFast()永远为false。 因此，接下来会走到class_createInstance()，其源码如下： 12345id class_createInstance(Class cls, size_t extraBytes){ return _class_createInstanceFromZone(cls, extraBytes, nil);} 1.4 _class_createInstanceFromZone顾名思义，这是要创建对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 对_class_createInstanceFromZone()的分析如下： ①cls-&gt;instanceSize(extraBytes)计算内存，此时的extraBytes是0，其源码是 1234567891011121314151617181920212223242526272829303132// 1.size_t instanceSize(size_t extraBytes) { size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size;}// 2.uint32_t alignedInstanceSize() { return word_align(unalignedInstanceSize());}// 3. 字节对齐static inline uint32_t word_align(uint32_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}static inline size_t word_align(size_t x) { return (x + WORD_MASK) &amp; ~WORD_MASK;}// 4.#ifdef __LP64__# define WORD_SHIFT 3UL# define WORD_MASK 7UL# define WORD_BITS 64#else# define WORD_SHIFT 2UL# define WORD_MASK 3UL# define WORD_BITS 32#endif 可见，WORD_MASK在64位系统下是7，否则是3，word_align()方法就是进行字节对齐的。 字节对齐算法：(x + WORD_MASK) &amp; ~WORD_MASK 12345678910111213141516假如： x = 9，已知 WORD_MASK = 7 x + WORD_MASK = 9 + 7 = 16 WORD_MASK 二进制 ：0000 0111 = 7 （4+2+1） ~WORD_MASK 二进制 : 1111 1000 16的二进制为 : 0001 0000 0001 0000 &amp; 1111 1000--------------- 0001 0000 = 16所以字节对齐后返回16 也就是8的倍数对齐，即8字节对齐 因此，word_align()在64位系统下是8字节对齐，否则是4字节对齐。 同时，instanceSize()函数又对内存大小又进行了最小16字节的限制。 ②canAllocNonpointer()是对isa的类型的区分，如果一个类使用isa_t类型的isa的话就返回true，我们不用太关心，OC 2.0以上基本上返回的都是true，所以fast就是true；而在__OBJC2__中，zone会被忽略，所以!zone也是true； 综上，接着就是calloc()和initInstanceIsa()。 ③size_t size = cls-&gt;instanceSize(extraBytes);这一步得到了计算后的size，传到calloc(1, size)中进行分配内存。 ④calloc()的底层源码是在苹果开源的libmalloc源码中(我Github中也准备了)，经过断点跟踪(中间过程比较复杂，略过先)，发现calloc()分配的内存大小受segregated_size_to_fit()影响，看下面源码： 123456789101112131415161718192021static MALLOC_INLINE size_tsegregated_size_to_fit(nanozone_t *nanozone, size_t size, size_t *pKey) // 这里的size就是calloc(1, size)中传过来的{ size_t k, slot_bytes; if (0 == size) { // Historical behavior size = NANO_REGIME_QUANTA_SIZE; } // round up and shift for number of quanta k = (size + NANO_REGIME_QUANTA_SIZE - 1) &gt;&gt; SHIFT_NANO_QUANTUM; // multiply by power of two quanta size slot_bytes = k &lt;&lt; SHIFT_NANO_QUANTUM; // Zero-based! *pKey = k - 1; return slot_bytes;}#define SHIFT_NANO_QUANTUM 4#define NANO_REGIME_QUANTA_SIZE (1 &lt;&lt; SHIFT_NANO_QUANTUM) // 16 从代码可以看出，slot_bytes等于(size + 16-1) &gt;&gt; 4 &lt;&lt; 4，是16字节对齐，所以就是将计算得到的size进行一次16字节对齐，因此calloc()分配的内存大小必然是16字节的整数倍，因此为对象分配的内存空间一定是16字节对齐的。 ⑤initInstanceIsa()就是初始化isa，并且关联cls。 从上面的代码可以看出，_class_createInstanceFromZone()做了很多事情，并且最终确实创建了对象，几乎干了所有事情，那么，init又到底做了什么呢？ 三、init和new1. init1234567891011- (id)init { return _objc_rootInit(self);}id_objc_rootInit(id obj){ // In practice, it will be hard to rely on this function. // Many classes do not properly chain -init calls. return obj;} 非常简单，init仅仅是将alloc创建的对象返回。是一种工厂设计方案，方便子类重写。 2. new我们再看看new 123+ (id)new { return [callAlloc(self, false/*checkNil*/) init];} 很明显，new相当于alloc+init。 四、总结关于alloc、init以及new的源码分析就到这了。在alloc的过程中，callAlloc和_class_createInstanceFromZone这两个函数是重点。 以上源码流程分析，是建立在objc4-756.2源码的基础上的，756.2是目前最新的版本。 下面用流程图总结一下alloc创建对象的过程：（这是我看过的博客中，最准确的图） 五、源码我的 malloc 源码 我的 libobjc 源码 苹果官方 objc4 源码 参考红酒牛排 https://juejin.im/post/6844904038467633160#heading-15","link":"/2020/10/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/01-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA/"},{"title":"URL编码和解码","text":"一、URL含义1.1 URL定义URL 与 URI URL：统一资源定位符 URI：统一资源标识符 URI结构 1234567foo://example.com:8042/over/there?name=ferret#nose \\_/ \\______________/ \\________/\\_________/ \\__/ | | | | | scheme authority path query fragment 1.2 URL字符编码表1、URL 编码 - 从 %00 到 %ff 2、HTML特殊字符编码对照表 二、URL 编码2.1 为什么要编码推荐阅读：字符编码：ASCII、Unicode 和 UTF-8 的区别 世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号，所以必须要统一字符编码。 Unicode规定了符号唯一的二进制代码值。(UTF-8是一种 Unicode 的实现方式。 ) 如 中 字: Unicode码值： \\u4e2d URL编码（UTF-8）： %e4%b8%ad 2.2 URL编码规则使用%加上两位的字符0123456789ABCDEF代表一个字节的十六进制形式。 2.3 URL不需要编码的字符1、英文字母（a-z A-Z） 2、数字（0-9） 3、 - _ . ~ 4个特殊字符 4、所有保留字符，RFC3986中指定了以下字符为保留字符（英文字符）: ! * ' ( ) ; : @ &amp; = + $ , / ? # [ ] 5、编码标记符号 % 2.4 URL需要编码的字符非URL定义的字符如中文字符、希腊文字符，拉丁文字符等。 会引起歧义的保留字符URL 拼接参数或路径设置时，拼接的普通字符串中含有保留字符，会引起歧义的情况。URL 参数字符串中使用 key=value 这样的键值对形式来传参，键值对之间以 &amp; 符号分隔，如宝洁公司的简称为P&amp;G，假设需要当做参数去传递，name=P&amp;G&amp;t=1450591802326，因为参数中多了一个&amp;势必会造成接收 URL 的服务器解析错误，因此必须将引起歧义的 &amp; 符号进行转义编码。 部分保留字符及其URL编码 字符 用法描述 编码 + 表示空格（在URL中不能使用空格） %2B 空格 URL中的空格可以用+号或者编码 %20 / 分隔目录和子目录 %2F ? 分隔实际的URL和参数 %3F # 表示书签或锚点 %23 &amp; URL中指定的参数间的分隔符 %26 = URL中指定的参数的值 %3D % 百分号本身用作对不安全字符进行编码时使用的特殊字符，因此本身需要编码 %25 如果需要在URL中用到特殊字符或中文字符，需要将这些特殊字符换成相应的十六进制的值。 三、iOS端URL具体编码处理3.1 URL编码和解码是成对出现的3.2 URL 拆解和编码 demo我们看一个常见的接口请求示例： 字符串 说明 :// 协议符号 / 分隔目录和子目录 测试 代表需要编译处理的路径 ？ 分隔实际的URL和参数 &amp; URL中指定的参数间的分隔符 = URL中指定的参数的值 搜&amp;索 搜索词含有中文，含有保留字段，需要编译 &amp;times 是key的一部分，不应该被编译，若多一次编译，会编译为 x 绿色字体是保留字符，都有特殊的含义，是不应该是被编码的。 红色字体必须要要编译的部分。 黄色背景的字符串，不应该被编译。 若以上操作不正确，会影响整个URL的解析。 URL 的拼接过程 1、先拼接实际的请求地址 https://www.baidu.com/s/测@试? 2、再拼接参数字符串 wd=搜&amp;索&amp;timestamp=32424242423 3、将1、2合并凭借成一个网址字符串。 4、将网址字符串转为NSURL 实例。 URL 的拆解和编码过程 因 测@试 含有中文和保留字符@，需要在步骤1之前，先将 测@试 编码为 %e6%b5%8b%40%e8%af%95 ，再拼接到https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95? 因 搜&amp;索 含有中文和保留字符&amp; ,&amp; 会影响参数解析。需要先搜&amp;索 编码为 %e6%90%9c%26%e7%b4%a2 ，再拼接为wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 经过以上步骤，现在的 URL 为： https://www.baidu.com/s/%e6%b5%8b%40%e8%af%95?wd=%e6%90%9c%26%e7%b4%a2&amp;timestamp=32424242423 已经编码完成了，所以不应该再次编码。否则会把&amp;timestamp中的&amp;给编码了，而这是分隔参数的重要标志。 小结 URL 编码有两种常见的做法，一种是先拼接再编码，一种是先编码再拼接。 先拼接再编码会有较大概率编码错误，所以建议使用先编码再拼接的方式，也是我们这里采用的方式。 3.3 iOS 常用APIiOS端生成NSURL实例 1NSURL *url = [NSURL URLWithString:urlString]; 注意： urlString 中含有中文字符等非定URL限定字符时，创建的NSURL对象会失败，url返回为nil。 URL编码123456789101112131415161718NSString *urlStr = @&quot;你好0123456789abcxyzABCXYZ-_.~&amp;!*'();:@&amp;=+$,/?#[]% &quot;;//方式一【推荐】NSString *encodingString = [urlStr stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSLog(@&quot;url编码1-1 = %@&quot;,encodingString);//方式二：NSString *encodeStr3 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];NSLog(@&quot;url编码3-1 = %@&quot;,encodeStr3);//方式三：自定义字符集 ABC-_~.!*'();:@&amp;=+ $,/?%#[] 编码对比NSString *encodeStr2 = (NSString *)CFBridgingRelease(CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault, (CFStringRef)urlStr, NULL, (CFStringRef)@&quot;ABC-_~.!*'();:=+ $,/?%#[]&quot;, kCFStringEncodingUTF8)); NSLog(@&quot;url编码2-2 = %@&quot;,encodeStr2); //方式四：自定义字符不需要编译的字符集，为空字符集，将所有字符用百分号编码NSCharacterSet *characterSet = [NSCharacterSet characterSetWithCharactersInString:@&quot;&quot;];NSString *encodeStr4 = [urlStr stringByAddingPercentEncodingWithAllowedCharacters:characterSet]; NSLog(@&quot;url编码3-2 = %@&quot;,encodeStr4); 打印结果是 网上常见的字符集枚举说明（供参考）: 123456URLFragmentAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLHostAllowedCharacterSet &quot;#%/&lt;&gt;?@\\^`{|}URLPasswordAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^`{|}URLPathAllowedCharacterSet &quot;#%;&lt;&gt;?[\\]^`{|}URLQueryAllowedCharacterSet &quot;#%&lt;&gt;[\\]^`{|}URLUserAllowedCharacterSet &quot;#%/:&lt;&gt;?@[\\]^` URL解码1234//上段代码的结果为encodeStr3入参NSString *decodedStr3 = [encodeStr3 stringByRemovingPercentEncoding];NSLog(@&quot;url编码3-1 = %@&quot;,decodedStr3); 打印结果是","link":"/2020/10/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/URL%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%E8%BF%87%E7%A8%8B/"},{"title":"百度移动统计错误报告的使用","text":"link： https://mtj.baidu.com/web/dashboard 终端命令： 1xcrun atos --arch arm64 -o +包路径 -l 基地址+回车+偏移地址+回车 包路径 基地址 &amp; 偏移地址","link":"/2020/10/19/iOS%C2%B7%E8%B4%A8%E9%87%8F&%E6%95%88%E7%8E%87/%E7%99%BE%E5%BA%A6%E7%A7%BB%E5%8A%A8%E7%BB%9F%E8%AE%A1%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"02-isa原理","text":"一、 前言 在arm64架构之前，isa仅仅是一个指针，保存着类对象或元类对象的内存地址 在arm64架构之后,苹果对isa进行了优化,变成了一个isa_t类型的联合体结构,同时使用位域来存储更多的信息: 对象的isa指针并不是直接指向类对象或者元类对象的内存地址，而是需要&amp; ISA_MASK才能获取类对象或者元类对象的地址。 二、 内容补充2.1 位运算符 位运算符用来对二进制位进行操作 操作数只能为整型和字符型数据。 C语言中六种位运算符：&amp;按位与、|按位或、^按位异或、~非、&lt;&lt;左移和&gt;&gt;右移。 1)按位与&amp; 有0出0,全1出1. A B &amp; 0 0 0 1 0 0 0 1 0 1 1 1 2)按位或 | 有1出1,全0出0. A B I 0 0 0 1 0 1 0 1 1 1 1 1 3)按位异或^ 相同为0,不同为1. A B ^ 0 0 0 1 0 1 0 1 1 1 1 0 4)非 ~ 非运算即取反运算，在二进制中 1 变 0 ，0 变 1。例如110101进行非运算后为001010，即1010. 5)左移 &lt;&lt; 左移运算就是把&lt;&lt;左边的运算数的各二进位全部左移若干位，移动的位数即&lt;&lt;右边的数的数值。 高位丢弃，低位补0。 左移n位就是乘以2的n次方。例如：a&lt;&lt;4是指把a的各二进位向左移动4位。如原来a=00000011(十进制3)，左移4位后为00110000(十进制48)。 6)右移 &gt;&gt; 右移运算就是把&gt;&gt;左边的运算数的各二进位全部右移若干位，&gt;&gt;右边的数指定移动的位数。例如：设 a=15，a&gt;&gt;2 表示把00001111右移为00000011(十进制3) 2.2 位运算符的运用1)取值 可以利用按位与 &amp;运算取出指定位的值 具体操作是想取出哪一位的值就将那一位置为1,其它位都为0,然后同原数据进行按位与计算,即可取出特定的位. 例: 0000 0011取出倒数第三位的值 123456// 想取出倒数第三位的值，就将倒数第三位的值置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0100 （掩码）------------ 0000 0000 // 得出按位与运算后的结果，即可拿到原数据中倒数第三位的值为0 上面的例子中,我们从0000 0011中取值,则有0000 0011被称之为源码.进行按位与操作设定的0000 0100称之为掩码. 例: 0000 0011取出后三位的值 123456// 想取出后三位的值，就将掩码后三位置为1，其它位为0，跟原数据按位与运算 0000 0011 (源码)&amp; 0000 0111 （掩码）------------ 0000 0011 // 得出按位与运算后的结果，即可拿到原数据中后三位的值为011 2)设值 可以通过按位或 |或者按位与 &amp;运算符将某一位的值设为1或0. 要将某一位的值置为1的话，那么就将掩码中对应位的值设为1，掩码其它位为0，将源码与掩码进行按位或|操作即可. 例: 将0000 0011倒数第三位的值改为1 12345// 改变倒数第三位的值，就将掩码倒数第三位的值置为1，其它位为0，跟源码按位或运算 0000 0011| 0000 0100------------ 0000 0111 // 即可将源码中倒数第三位的值改为1 要将某一位的值置为0的话，那么就将掩码中对应位的值设为0，掩码其它位为1，将源码与掩码进行按位与&amp;操作即可. 例: 将0000 0011倒数第二位的值改为0 12345// 改变倒数第二位的值，就将掩码倒数第二位的值置为0，其它位为1，跟源码`按位与&amp;`运算 0000 0011| 1111 1101------------ 0000 0001 // 即可将源码中倒数第二位的值改为0 3)实际应用 声明一个TCJCar类，类中有四个BOOL类型的属性,分别为front、back、left、right,通过这四个属性来判断这辆小车的行驶方向. 然后我们来查看一下这个TCJCar类对象所占据的内存大小: 我们看到,一个TCJCar类的对象占据16个字节.其中包括一个isa指针和四个BOOL类型的属性,8+1+1+1+1=12,根据内存对齐原则,所以一个TCJCar类的对象占16个字节. 我们知道,BOOL值只有两种情况:0或1，占据一个字节的内存空间.而一个字节的内存空间中又有8个二进制位，并且二进制同样只有0或1，那么我们完全可以使用1个二进制位来表示一个BOOL值。也就是说我们上面声明的四个BOOL值最终只使用4个二进制位就可以代替，这样就节省了内存空间。那我们如何实现呢？ 想要实现四个BOOL值存放在一个字节中，我们可以通过char类型的成员变量来实现。 char类型占一个字节内存空间，也就是8个二进制位.可以使用其中最后四个二进制位来存储4个BOOL值。 (当然不能把char类型写成属性,因为一旦写成属性,系统会自动帮我们添加成员变量,自动实现set和get方法) 123@interface TCJCar(){ char _frontBackLeftRight;} 如果我们赋值_frontBackLeftRight为1,即0b 0000 0001,只使用8个二进制位中的最后4个分别用0或者1来代表front、back、left、right的值.那么此时front、back、left、right的状态为: 结合我们上文讲的6种位运算符以及使用场景,我们可以分别声明front、back、left、right的掩码,来方便我们进行下一步的位运算取值和赋值: 1234#define TCJDirectionFrontMask 0b00001000 //此二进制数对应十进制数为 8#define TCJDirectionBackMask 0b00000100 //此二进制数对应十进制数为 4#define TCJDirectionLeftMask 0b00000010 //此二进制数对应十进制数为 2#define TCJDirectionRightMask 0b00000001 //此二进制数对应十进制数为 1 通过对位运算符的左移&lt;&lt;和右移&gt;&gt;的了解，我们可以将上面的代码优化成： 1234#define TCJDirectionFrontMask (1 &lt;&lt; 3)#define TCJDirectionBackMask (1 &lt;&lt; 2)#define TCJDirectionLeftMask (1 &lt;&lt; 1)#define TCJDirectionRightMask (1 &lt;&lt; 0) 自定义的set方法如下: 1234567891011121314151617181920212223242526272829303132- (void)setFront:(BOOL)front{ if (front) {// 如果需要将值置为1，将源码和掩码进行按位或运算 _frontBackLeftRight |= TCJDirectionFrontMask; } else {// 如果需要将值置为0 // 将源码和按位取反后的掩码进行按位与运算 _frontBackLeftRight &amp;= ~TCJDirectionFrontMask; }}- (void)setBack:(BOOL)back{ if (back) { _frontBackLeftRight |= TCJDirectionBackMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionBackMask; }}- (void)setLeft:(BOOL)left{ if (left) { _frontBackLeftRight |= TCJDirectionLeftMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionLeftMask; }}- (void)setRight:(BOOL)right{ if (right) { _frontBackLeftRight |= TCJDirectionRightMask; } else { _frontBackLeftRight &amp;= ~TCJDirectionRightMask; }} 自定义的get方法如下: 12345678910111213141516- (BOOL)isFront{ return !!(_frontBackLeftRight &amp; TCJDirectionFrontMask);}- (BOOL)isBack{ return !!(_frontBackLeftRight &amp; TCJDirectionBackMask);}- (BOOL)isLeft{ return !!(_frontBackLeftRight &amp; TCJDirectionLeftMask);}- (BOOL)isRight{ return !!(_frontBackLeftRight &amp; TCJDirectionRightMask);} 此处需要注意的是，代码中!为逻辑运算符非，因为_frontBackLeftRight &amp; TCJDirectionFrontMask代码执行后，返回的肯定是一个整型数，如当front为YES时，说明二进制数为0b 0000 1000，对应的十进制数为8，那么进行一次逻辑非运算后，!(8)的值为0，对0再进行一次逻辑非运算!(0)，结果就成了1，那么正好跟front为YES对应.所以此处进行两次逻辑非运算，!!. 当然,还要实现初始化方法: 12345678- (instancetype)init{ self = [super init]; if (self) { _frontBackLeftRight = 0b00001000; } return self;} 通过测试验证,我们完成了取值和赋值: 2.3 位域有些信息在存储时，并不需要占用一个完整的字节(8个二进制位)， 而只需占几个或一个二进制位。“位域”是把一个字节中的二进位划分为几个不同的区域， 并说明每个区域的位数。每个区域就可以存储一段信息，这样就可以把信息用一个字节来表示。 2.4 联合体这里通过与struct的对比来理解union: ①两者都可以包含多个不同类型的数据，如int、double、Class等。 ②在struct中各成员有各自的内存空间，一个struct变量的内存总长度大于等于各成员内存长度之和；而在union中，各成员共享一段内存空间，一个union的内存总长度等于各成员中内存最长的那个成员的内存长度。 ③对struct中的成员进行赋值，不会影响其他成员的值；对union中的成员赋值时，每次只能给一个成员赋值，同时其它成员的值也就不存在了。 写法： 123union 联合体名{ 成员列表} 2.5 oc 中的 GDB 调试2.5.1 简介GDB（GNU Debugger）是UNIX及UNIX-like下的强大调试工具，可以调试ada, c, c++, asm, minimal, d, fortran, Objective-c, go, java,pascal等语言。 2.5.2 在 iOS 开发中的作用① 普通变量查看 使用 p 变量名即可： 12(gdb) p a$1 = 10 ② 打印指针指向内容 如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如： 12(gdb) p d$1 = (int *) 0x602010 而如果想要打印指针指向的内容，需要解引用： 12(gdb) p *d$2 = 0 ③ 按照特定格式打印变量 对于简单的数据，p默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。使用格式控制字符来控制 正常方式打印字符数组c： 12(gdb) p c$18 = &quot;hello world&quot; 查看它的十六进制格式打印: 123(gdb) p/x c$19 = {0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x73, 0x68, 0x6f, 0x75, 0x77, 0x61, 0x6e, 0x67, 0x0} 但是如果我们想用这种方式查看浮点数的二进制格式是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8： 12345(gdb) p e$1 = 8.5(gdb) p/t e$2 = 1000 ④ 查看内存内容 examine(简写为x)可以用来查看内存地址中的值。语法如下： 1x/[n][f][u] addr 其中： n 表示要显示的内存单元数，默认值为1(想打多少段就写几) f 表示要打印的格式，通过格式控制字符控制 u 要打印的单元长度 addr 内存地址 格式控制字符： x 按十六进制格式显示变量【常用】 d 按十进制格式显示变量 u 按十六进制格式显示无符号整型 o 按八进制格式显示变量 t 按二进制格式显示变量 a 按十六进制格式显示变量 c 按字符格式显示变量 f 按浮点数格式显示变量 单元长度： g 八字节【常用】 b 字节 h 半字，即双字节 w 字，即四字节 举例： 1234x/4xg p // 打印 p 的内存内容 // 打4段内存内容 // 16进制打印 // 每段内存内容打印8字节 三、 isa 介绍3.1 前言回顾上篇文章中的代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static __attribute__((always_inline)) id_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone, bool cxxConstruct = true, size_t *outAllocatedSize = nil){ if (!cls) return nil; assert(cls-&gt;isRealized()); // 一次读取类的信息位以提高性能 bool hasCxxCtor = cls-&gt;hasCxxCtor(); // 是否有构造函数 bool hasCxxDtor = cls-&gt;hasCxxDtor(); // 是否有析构函数 bool fast = cls-&gt;canAllocNonpointer(); // OC 2.0以上基本上返回的都是true // 计算内存 size_t size = cls-&gt;instanceSize(extraBytes); if (outAllocatedSize) *outAllocatedSize = size; id obj; if (!zone &amp;&amp; fast) { // 分配1块大小为size的连续内存 obj = (id)calloc(1, size); if (!obj) return nil; // 初始化对象的isa obj-&gt;initInstanceIsa(cls, hasCxxDtor); } else { if (zone) { obj = (id)malloc_zone_calloc ((malloc_zone_t *)zone, 1, size); } else { obj = (id)calloc(1, size); } if (!obj) return nil; // Use raw pointer isa on the assumption that they might be // doing something weird with the zone or RR. obj-&gt;initIsa(cls); } if (cxxConstruct &amp;&amp; hasCxxCtor) { obj = _objc_constructOrFree(obj, cls); } return obj;} 在上文中我们知道alloc底层会调用calloc分配内存，接着就是initInstanceIsa(cls, hasCxxDtor)，顾名思义是初始化对象的isa，其关键代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor){ assert(!cls-&gt;instancesRequireRawIsa()); assert(hasCxxDtor == cls-&gt;hasCxxDtor()); // 留意这里的true initIsa(cls, true, hasCxxDtor);}inline void objc_object::initIsa(Class cls, bool nonpointer, bool hasCxxDtor) { assert(!isTaggedPointer()); if (!nonpointer) { isa.cls = cls; } else { assert(!DisableNonpointerIsa); assert(!cls-&gt;instancesRequireRawIsa()); isa_t newisa(0);#if SUPPORT_INDEXED_ISA assert(cls-&gt;classArrayIndex() &gt; 0); newisa.bits = ISA_INDEX_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.indexcls = (uintptr_t)cls-&gt;classArrayIndex();#else newisa.bits = ISA_MAGIC_VALUE; // isa.magic is part of ISA_MAGIC_VALUE // isa.nonpointer is part of ISA_MAGIC_VALUE newisa.has_cxx_dtor = hasCxxDtor; newisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;#endif isa = newisa; }} Tagged Pointer: 据说，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于 64 位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及 3倍 的访问速度提升，100倍 的创建、销毁速度提升。 Tagged Pointer首次应用于iPhone 5s设备上，现在几乎都应用Tagged Pointer了。想了解更多关于Tagged Pointer的内容可参考： 深入理解 Tagged Pointer。 3.2 isa 的结构点击objc_object::initIsa()中的isa，发现isa是isa_t类型 123456789101112union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // 位域 };#endif}; 而isa_t实际上是一个union，即联合体，占8个字节，它的特性就是共用内存，或者说是互斥，比如说如果cls赋值了就不在对bits进行赋值。 3.2.1 isa 的 bits 成员变量3.2.2 isa的 cls 成员变量它是Class类型，源码： 12345678910111213141516171819202122typedef struct objc_class *Class;// 顺便了解一下id的类型，显然id是个指针变量，它的值只有一个isa变量typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; class_data_bits_t bits; class_rw_t *data() { return bits.data(); } ... // 一些方法};struct objc_object {private: isa_t isa; ... // 一些公有、私有方法}; 从源码得知，Class实际上是objc_class结构体的指针变量，而objc_class又继承自objc_object（说明类本质上也是一个对象），因此Class这个结构体指针变量的值内部有一个isa成员变量（类型为isa_t），这个isa成员变量在64位CPU架构下是8字节，且排在objc_class结构体的前8字节。 3.2.3 isa 的位域查看ISA_BITFIELD： 模拟器： 12345678910111213141516# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 44; /*MACH_VM_MAX_ADDRESS 0x7fffffe00000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 8# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) 真机： 12345678910111213141516# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL# define ISA_BITFIELD \\ uintptr_t nonpointer : 1; \\ uintptr_t has_assoc : 1; \\ uintptr_t has_cxx_dtor : 1; \\ uintptr_t shiftcls : 33; /*MACH_VM_MAX_ADDRESS 0x1000000000*/ \\ uintptr_t magic : 6; \\ uintptr_t weakly_referenced : 1; \\ uintptr_t deallocating : 1; \\ uintptr_t has_sidetable_rc : 1; \\ uintptr_t extra_rc : 19# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) 首先明确一点，在64位CPU架构下isa指针的长度也是8字节，它可以存储足够多的内容，苹果为了优化性能，存储类地址只用了一部分位（x86_64下是44位，arm64下是33位），剩下的位用来存储一些其它信息。 具体分析一下ISA_BITFIELD位域各成员的表示意义： nonpointer：表示是否对isa指针开启指针优化。 0：不优化，是纯isa指针，当访问isa指针时，直接返回其成员变量cls 1：优化，即isa 指针内容不止是类地址，还包含了类的一些信息、对象的引用计数等。 has_assoc：是否有关联对象。 has_cxx_dtor：该对象是否有C++或Objc的析构器。 如果有析构函数，则需要做一些析构的逻辑处理； 如果没有，则可以更快的释放对象。 shiftcls：存储类地址。开启指针优化的情况下，在 x86_64 架构有 44位 用来存储类地址，arm64 架构中占 33位 。 magic：用于调试器判断当前对象是真的对象，还是一段没有初始化的空间。 weakly_referenced：用于标识对象是否被指向或者曾经被指向一个ARC的弱变量，没有弱引用的对象释放的更快。 deallocating：标识对象是否正在释放内存。 has_sidetable_rc：对象的引用计数值是否有进位。 extra_rc：表示该对象的引用计数值。 extra_rc只是存储了额外的引用计数，实际的引用计数公式：实际引用计数 = extra_rc + 1。这里占了8位，所以理论上可以存储的最大引用计数是：2^8 - 1 + 1 = 256（arm64CPU架构下的extra_rc占19位，可存储的最大引用计数为2^19 - 1 + 1 = 524288）。 与has_sidetable_rc的关联：当对象的最大引用计数超过界限后，has_sidetable_rc的值为1，否则为0 3.5 isa的作用从objc_object的结构可以说明，当系统为一个对象分配好内存，并初始化实例变量后，在这些对象的实例变量的结构体中的第一个就是isa。 同时，通过对isa的位域说明，我们知道shiftcls存储的是类地址。在arm64 架构中占 33位。 我们将ISA_MASK的值0x0000000ffffffff8ULL转化为二进制数分析一下: 从图中可以看到ISA_MASK的值转化为二进制后中间有33位都为1，那么isa指针同ISA_MASK进行按位与运算就可以取出中间33位的值，这正是中间占33位的shiftcls，所以就取出了类对象和元类对象的内存地址信息。 例： 此时通过lldb命令调试 说明： 0x001d800100001129是对象p的isa值，通过isa &amp; ISA_MASK运算得到的0x0000000100001128就是Person类的地址 证明【1】：通过p/x Person.class直接打印Person类地址，显然得到的是0x0000000100001128，如此【1】证明成立！ 结论：isa将对象和类关联起来，起到了中间桥梁的作用。 3.6 isa的初始化补充最后补充一下isa的初始化。还记得初始化isa的入口吗？是initIsa(cls, true, hasCxxDtor);，此时nonpointer的值是true，再看SUPPORT_INDEXED_ISA的定义 12345#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1#else# define SUPPORT_INDEXED_ISA 0#endif 在x86_64下，SUPPORT_INDEXED_ISA是0，所以isa的初始化最终会来到 1234567891011isa_t newisa(0);// 使用ISA_MAGIC_VALUE(0x001d800000000001ULL)赋值给bits// nonpointer为1，magic为1d，其他变量为零newisa.bits = ISA_MAGIC_VALUE;// hasCxxDtor是从类的isa中取出的newisa.has_cxx_dtor = hasCxxDtor;// 将cls右移3位后赋值给shiftclsnewisa.shiftcls = (uintptr_t)cls &gt;&gt; 3;isa = newisa; 碍于篇幅，这里不继续深入hasCxxDtor。 四、isa 指向图在OC中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。 当对象的实例方法被调用时，它通过自己的isa来查找对应的类，然后在所属类的 class_data_bits_t结构体中查找对应方法的实现。同时，每一个objc_class 也有一个指向自己的父类的指针superclass用来查找继承的方法。 而当调用 类方法 时，它的查找流程是怎样的呢？对此OC的解决方案就是引入元类，来保证类方法也能通过相同的机制查找到。也就是说，类的isa指向的是元类。 苹果官方isa指向图： 接下来我们来验证一下吧。 4.1 准备工作创建Teacher类、Person类，其中Person类继承于NSObject，Teacher类继承于Person类。 4.2 验证过程1.获取teacher对象的类（结果是Teacher类，地址为0x0000000100001230） 123456789(lldb) x/4gx teacher0x100f59400: 0x001d800100001231 0x00000000000000000x100f59410: 0x636f72504b575b2d 0x70756f7247737365 (lldb) p/x 0x001d800100001231 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $3 = 0x0000000100001230 // 对象teacher的类地址 (lldb) po $3Teacher // 对象teacher的类 2.获取Teacher类的元类（结果是Teacher元类，地址为0x0000000100001208） 123456789(lldb) x/4gx Teacher.class0x100001230: 0x001d800100001209 0x00000001000011e00x100001240: 0x0000000100f61150 0x0000000100000003(lldb) p/x 0x001d800100001209 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $5 = 0x0000000100001208 // Teacher类的元类地址 (lldb) po $5Teacher // Teacher类的元类 Teacher类 和 Teacher元类 地址不一样 3.获取person对象的类（结果是Person类，地址为0x00000001000011e0），以及类的元类（结果是Person元类，地址为0x00000001000011b8） 12345678910111213141516171819(lldb) x/4gx person0x100f60a30: 0x001d8001000011e1 0x00000000000000000x100f60a40: 0x0000000000000002 0x00007fff9b855588 (lldb) p/x 0x001d8001000011e1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $8 = 0x00000001000011e0 // 对象person的类地址 (lldb) po $8Person // 对象person的类(lldb) x/4gx Person.class0x1000011e0: 0x001d8001000011b9 0x0000000100b381400x1000011f0: 0x0000000100f61030 0x0000000100000003 (lldb) p/x 0x001d8001000011b9 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $10 = 0x00000001000011b8 // Person类的元类地址 (lldb) po $10Person // Person类的元类 4.获取object对象的类（结果是NSObject类，地址为0x0000000100b38140），以及类的元类（结果是NSObject元类，地址为0x0000000100b380f0） 123456789101112131415161718192021(lldb) x/4gx object0x100f5cc50: 0x001d800100b38141 0x00000000000000000x100f5cc60: 0x70736e494b575b2d 0x574b57726f746365 (lldb) p/x 0x001d800100b38141 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $12 = 0x0000000100b38140 // 对象object的类地址 (lldb) po $12 NSObject // 对象object的类 (lldb) x/4gx NSObject.class0x100b38140: 0x001d800100b380f1 0x00000000000000000x100b38150: 0x0000000101913060 0x0000000200000003 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $14 = 0x0000000100b380f0 // NSObject类的元类地址 (lldb) po $14NSObject // NSObject类的元类 5.获取Teacher元类的元类，Person元类的元类，以及NSObject元类的元类 123456789101112131415161718192021222324252627282930313233(lldb) x/4gx 0x0000000100001208 // Teacher元类0x100001208: 0x001d800100b380f1 0x00000001000011b80x100001218: 0x000000010186f950 0x0000000400000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $16 = 0x0000000100b380f0 // NSObject元类 (lldb) po $16NSObject // NSObject元类 (lldb) x/4gx 0x00000001000011b8 // Person元类0x1000011b8: 0x001d800100b380f1 0x0000000100b380f00x1000011c8: 0x0000000101905a50 0x0000000300000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $17 = 0x0000000100b380f0 // NSObject元类 (lldb) po $17NSObject // NSObject元类 (lldb) x/4gx 0x0000000100b380f0 // NSObject元类0x100b380f0: 0x001d800100b380f1 0x0000000100b381400x100b38100: 0x0000000101903820 0x0000000500000007 (lldb) p/x 0x001d800100b380f1 &amp; 0x00007ffffffffff8 // isa &amp; ISA_MASK(long) $18 = 0x0000000100b380f0 // NSObject元类 (lldb) po $18NSObject // NSObject元类 4.3 isa指向结论 基于【4.2】的验证过程，可以得出结论： 对象的isa指针指向对象的所属类 类的isa指针指向类的元类 元类的isa指针指向根元类 根元类的isa指针指向他自己(形成闭环) 4.4 继承关系的证明类的继承关系证明过程：（以 -&gt; 表示 继承自） 12345678(lldb) p class_getSuperclass(Teacher.class)(Class) $19 = Person // Teacher类 -&gt; Person类(lldb) p class_getSuperclass(Person.class)(Class) $20 = NSObject // Person类 -&gt; NSObject类(lldb) p class_getSuperclass(NSObject.class)(Class) $21 = nil // NSObject类 -&gt; nil 元类的继承关系证明过程：（以 -&gt; 表示 继承自） 1234567891011121314151617// 0x0000000100001208 是 Teacher元类(lldb) p/x class_getSuperclass((Class)0x0000000100001208)(Class) $17 = 0x00000001000011b8 // Person元类(lldb) po $17Person // Teacher元类 -&gt; Person元类// 0x00000001000011b8 是 Person元类(lldb) p/x class_getSuperclass((Class)0x00000001000011b8)(Class) $22 = 0x0000000100b380f0 // NSObject元类（根元类）(lldb) po $22NSObject // Person元类 -&gt; 根元类// 0x0000000100b380f0 是 根元类(lldb) p/x class_getSuperclass((Class)0x0000000100b380f0)(Class) $23 = 0x0000000100b38140 NSObject // NSObject类（根类）(lldb) po $23NSObject // 根元类 -&gt; 根类 根元类继承自根类（NSObject元类 -&gt; NSObject类），根类继承自nil（NSObject类 -&gt; nil） 五、总结1.isa是isa_t结构，采用 联合体+位域 的搭配来设计：在不同的位上显示不同的内容，以此来节省储存空间，进而优化内存。 2.isa包含了cls和bits两个成员变量，这两个成员变量在64位CPU架构下的长度都是8字节，所以isa在64位CPU架构下的长度也是8字节。 3.isa的位域上存储了一些对象与类的信息，并将对象与类关联起来，起到中间桥梁的作用。 4.指向图相关结论： 继承 子类 -&gt; 父类 -&gt; 根类(NSObject) 子元类 -&gt; 父元类 -&gt; 根元类 !!! 根元类 -&gt; 根类 (NSObject) 形成闭环 isa 指向 实例对象 isa -&gt; 类对象 类对象 isa -&gt; 元类对象 元类对象 isa -&gt; 根元类对象 根元类对象 isa -&gt; 他自己(形成闭环) 六、源码我的 malloc 源码 我的 libobjc 源码 参考资料OC源码分析之isa GDB调试指南","link":"/2020/11/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/02-isa%E5%8E%9F%E7%90%86/"},{"title":"Hexo 配置","text":"一、升级主题1.使用 1sudo npm install -g npm-upgrade 和 123ncu -u // 自动更新所有插件或者 npm-upgrade // 手动选择插件更新 来升级Hexo中的插件 2.保存 1npm update -g 1npm update --save 3.安装配置主题 1npm install hexo-theme-icarus 1hexo config theme icarus 4.根据提示安装缺少或者需要更新的东西 5.再次配置主题 1hexo config theme icarus 这个时候应该提示配置成功了 6.本地启动看看 1hexo s 二、Icarus 配置2.1 基础配置修改通过修改主题的全局配置文件_config.icarus.yml 2.2 修改博客为：主页三栏，文章页两栏找到hexo-theme-icarus文件夹，在此目录下添加_config.post.yml文件并配置： 123456789101112widgets: - # Where should the widget be placed, left sidebar or right sidebar position: left type: toc # Whether to show the index of each heading index: false # Whether to collapse sub-headings when they are out-of-view collapsed: true # Maximum level of headings to show (1-6) depth: 6 2.3 主题进行 cdn 加速搜索并找到cdn.js文件，并修改： 123456789101112131415161718192021222324252627282930313233343536373839/** * @private */// 原来的// const PROVIDERS = {// LIBRARY: {// cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }',// loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }',// jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }',// unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }'// },// FONT: {// google: 'https://fonts.googleapis.com/${ type }?family=${ fontname }',// loli: 'https://fonts.loli.net/${ type }?family=${ fontname }'// },// ICON: {// loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css',// fontawesome: 'https://use.fontawesome.com/releases/v5.12.0/css/all.css'// }// };// 改为：const PROVIDERS = { LIBRARY: { // cdnjs: '[cdnjs]https://cdnjs.cloudflare.com/ajax/libs/${ package }/${ version }/${ filename }', cdnjs: 'https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', loli: '[cdnjs]https://cdnjs.loli.net/ajax/libs/${ package }/${ version }/${ filename }', jsdelivr: 'https://cdn.jsdelivr.net/npm/${ package }@${ version }/${ filename }', unpkg: 'https://unpkg.com/${ package }@${ version }/${ filename }' }, FONT: { google: 'https://fonts.loli.net/${ type }?family=${ fontname }', loli: 'https://fonts.loli.net/${ type }?family=${ fontname }' }, ICON: { loli: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css', fontawesome: 'https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css' }}; 2.4 修改文章页的宽度找到layout.jsx文件 is-9-widescreen 中的 9 就是宽度比例，默认为 8 12'is-8-tablet is-8-desktop is-9-widescreen': columnCount === 2, 'is-8-tablet is-8-desktop is-6-widescreen': columnCount === 3","link":"/2020/12/16/%E5%8D%9A%E5%AE%A2/Hexo%20%E9%85%8D%E7%BD%AE/"},{"title":"04-方法的缓存原理","text":"前言一、 cache_t源码分析当OC项目编译完成后，类的实例方法（方法编号SEL 和 函数地址IMP）就保存在类的方法列表中。我们知道 OC 为了实现其动态性，将 方法的调用包装成了 SEL 寻找 IMP 的过程。试想一下，如果每次调用方法，都要去类的方法列表（甚至父类、根类的方法列表）中查询其函数地址，势必会对性能造成极大的损耗。 为了解决这一问题，OC 采用了方法缓存的机制来提高调用效率，也就是cache_t，其作用就是缓存已调用的方法。当调用方法时，objc_msgSend会先去缓存中查找，如果找到就执行该方法；如果不在缓存中，则去类的方法列表（包括父类、根类的方法列表）查找，找到后会将方法的SEL和IMP缓存到cache_t中，以便下次调用时能够快速执行。 1.1 cache_t结构源码： 12345678910111213141516171819202122232425struct cache_t { struct bucket_t *_buckets; // 缓存数组，即哈希桶 mask_t _mask; // 缓存数组的容量临界值 mask_t _occupied; // 缓存数组中已缓存方法数量 ... // 一些函数};#if __LP64__typedef uint32_t mask_t;#elsetypedef uint16_t mask_t;#endifstruct bucket_t {private:#if __arm64__ uintptr_t _imp; SEL _sel;#else SEL _sel; uintptr_t _imp;#endif ... // 一些方法}; 从上面源码不难看出，在64位CPU架构下，cache_t长度是16字节。单从结构来看，方法是缓存在bucket_t（又称哈希桶）中，接下来用个例子验证一下cache_t是否缓存了已调用的方法。 1.2 方法缓存的验证1.创建一个简单的Person类，代码如下 1234567891011121314151617181920212223@interface Person : NSObject- (void)methodFirst;- (void)methodSecond;- (void)methodThird;@end@implementation Person- (void)methodFirst { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodSecond { NSLog(@&quot;%s&quot;, __FUNCTION__);}- (void)methodThird { NSLog(@&quot;%s&quot;, __FUNCTION__);}@end 2.方法调用前的cache_t 在方法调用前打个断点，看看cache_t的缓存情况 说明： objc_class结构中ISA占8字节，superClass占8字节，由于我们是按照8字节为一段打印的，所以刚好0x1000011d8就是cache_t首地址。 由于还没有任何方法调用，所以_mask和_occupied都是0，即还没有方法缓存。 为什么调用了alloc和class，但是这两个方法怎么没有缓存，这里要提到我们之前探索类的方法存储中说到的，对象的方法存在类中，类的类方法以实例方法的形式存在元类中，我们这里探索的是类的cache缓存，所以只能找到实例方法。下面直接给大家看一下元类里的cache以及bucket，也找到了alloc方法的缓存，这也说明，我们的思路是正确的： 123456789101112131415161718192021(lldb) p/x 0x001d8001000012b9 &amp; 0x00007ffffffffff8ULL(unsigned long long) $5 = 0x00000001000012b8// 0x00000001000012b8这个玩意就是元类的地址了。之前的isa原理，里面介绍到了如何从类查找到元类(lldb) x/4gx 0x00000001000012b80x1000012b8: 0x001d800100b360f1 0x0000000100b360f00x1000012c8: 0x0000000101e236c0 0x0000000200000003(lldb) p (cache_t *)0x1000012c8(cache_t *) $6 = 0x00000001000012c8(lldb) p *$6(cache_t) $7 = { _buckets = 0x0000000101e236c0 _mask = 3 _occupied = 2}(lldb) p $7._buckets(bucket_t *) $8 = 0x0000000101e236c0(lldb) p *$8(bucket_t) $9 = { _key = 4298994200 _imp = 0x00000001003cc3b0 (libobjc.A.dylib`::+[NSObject alloc]() at NSObject.mm:2294)} 3.方法调用后的cache_t 执行alloc和init这两个方法后，cache_t变化如下 从上图可知，调用init后，_mask的值是3，_occupied则是1。_buckets指针的值（数组首地址）发生了变化（从0x1003db250变成0x101700090），同时缓存了init方法的SEL和IMP。 思考： 1. alloc 方法调用后，缓存在哪里？ 2. 为什么 init 方法不在 _buckets 第一个位置？ 继续执行methodFirst，再看cache_t 此时，_mask的值是3（没发生变化），_occupied则变成了2，_buckets指针地址没变，增加缓存了methodFirst方法的SEL和IMP。 接着是执行methodSecond，且看 显然，_occupied变成了3，而_buckets指针地址不改变，同时新增methodSecond的方法缓存。 最后执行methodThird后，再看cache_t变化 这次的结果就完全不同了。_mask的值变成7，_occupied则重新变成了1，而_buckets不仅首地址变了，之前缓存的init、methodFirst和methodSecond方法也没了，仅存在的只有新增的methodThird方法。看来，cache_t并非是如我们所愿的那样——调用一个方法就缓存一个方法。 思考：之前缓存的方法（init、methodFirst 和 methodSecond）哪去了？ 1.3 cache_t小结让我们梳理一下上面的例子。在依次执行Person的实例方法init、methodFirst、methodSecond、methodThird后，cache_t变化如下 调用的方法 _buckets _mask _occupied 未调用方法 空 0 0 init init 3 1 init、methodFirst init、methodFirst 3 2 init、methodFirst、methodSecond init、methodFirst、methodSecond 3 3 init、methodFirst、methodSecond、methodThird methodThird 7 1 可见，**cache_t的确能实时缓存已调用的方法**。 上面的验证过程也可以帮助我们理解cache_t三个成员变量的意义。 bucket可译为桶（即哈希桶），用于装方法； occupied可译为已占有，表示已缓存的方法数量； mask可译为面具、掩饰物，乍看无头绪，但是注意到cache_t中有获取容量的函数（capacity），其源码如下 12345678910111213141516struct cache_t { ... mask_t mask(); mask_t capacity(); ...}mask_t cache_t::mask() { return _mask; }mask_t cache_t::capacity() { return mask() ? mask()+1 : 0; } 从capacity方法看出：当_mask不等于0的时候，意味着已经调用过实例方法，此时桶的容量为_mask + 1，如果_mask是0，说明未调用实例方法，即桶的容量为0。故，_mask从侧面反映了桶的容量。 二、cache_t的方法缓存原理接下来，从方法的调用过程开始分析cache_t的方法缓存原理。 2.1 cache_fillOC方法的本质是 **消息发送（即objc_msgSend），底层是通过方法的 SEL 查找 IMP**。 简要流程： 1.调用方法时，objc_msgSend会去cache_t即缓存中查询方法的函数实现（这部分是由汇编代码实现的，非常高效），在缓存中找的过程暂且不表 2.当缓存中没有的时候，则去类的方法列表中查找，直至找到后，再调用cache_fill，目的是为了将方法缓存到cache_t中，其源码如下 12345678910void cache_fill(Class cls, SEL sel, IMP imp, id receiver){#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif} objc_msgSend的具体流程将另起一文分析，这里不作赘述。 2.2 cache_fill_nolockcache_fill又会来到cache_fill_nolock，这个函数的作用是将方法的SEL和IMP写入_buckets，同时更新_mask和_occupied。 其源码以及详细分析如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver){ cacheUpdateLock.assertLocked(); // 如果类未初始化 if (!cls-&gt;isInitialized()) return; // 在获取cacheUpdateLock之前，确保其他线程没有将该方法写入缓存 if (cache_getImp(cls, sel)) return; // 获取 cls 的 cache_t指针 cache_t *cache = getCache(cls); // newOccupied为新的方法缓存数，等于 当前方法缓存数+1 mask_t newOccupied = cache-&gt;occupied() + 1; // 获取当前cache_t的总容量，即 mask+1 mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) { // 当第一次调用类的实例方法时（如本文的【1.2】例中的`init`） cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); } else if (newOccupied &lt;= capacity / 4 * 3) { // 新的方法缓存数 不大于 总容量的3/4，按原样使用，无需扩容 } else { // 新的方法缓存数 大于 总容量的3/4，需要扩容 cache-&gt;expand(); } // 根据sel获取bucket，此bucket的sel一般为0（说明这个位置还没缓存方法）， // 也可能与实参sel相等（hash冲突，可能性很低） bucket_t *bucket = cache-&gt;find(sel, receiver); // 当且仅当bucket的sel为0时，执行_occupied++ if (bucket-&gt;sel() == 0) cache-&gt;incrementOccupied(); // 更新bucket的sel和imp bucket-&gt;set&lt;Atomic&gt;(sel, imp);}// INIT_CACHE_SIZE 即为4enum { INIT_CACHE_SIZE_LOG2 = 2, INIT_CACHE_SIZE = (1 &lt;&lt; INIT_CACHE_SIZE_LOG2)}; 从上面的源码不难看出，cache_fill_nolock主要是cache_t缓存方法的调度中心，在这里会： 1.决定执行_buckets的哪一种缓存策略（初始化后缓存、直接缓存、扩容后缓存，三者取一）； 2.然后通过方法的sel找到一个bucket，并更新这个bucket的sel和imp。（如果这个bucket的sel为0，说明是个空桶，正好可以缓存方法，于是执行_occupied++）。 思考：为什么扩容临界点是 3/4？ 2.3 reallocate在下面这两种情况下会执行reallocate： 一是第一次初始化_buckets的时候 另一种则是_buckets扩容的时候 我们来看一下reallocate做了哪些事情 1234567891011121314151617181920212223242526void cache_t::reallocate(mask_t oldCapacity, mask_t newCapacity){ // 当且仅当`_buckets`中有缓存方法时，feeOld为true bool freeOld = canBeFreed(); // 获取当前buckets指针，即_buckets bucket_t *oldBuckets = buckets(); // 开辟新的buckets指针 bucket_t *newBuckets = allocateBuckets(newCapacity); // Cache's old contents are not propagated. // This is thought to save cache memory at the cost of extra cache fills. // fixme re-measure this assert(newCapacity &gt; 0); assert((uintptr_t)(mask_t)(newCapacity-1) == newCapacity-1); // 将新buckets、新mask（newCapacity-1）分别赋值跟当前的 _buckets 和 _mask setBucketsAndMask(newBuckets, newCapacity - 1); if (freeOld) { // 释放旧的buckets内存空间 cache_collect_free(oldBuckets, oldCapacity); cache_collect(false); }} reallocate完美解释了在例【1.2】中的几个情况： init执行完后，_buckets指针地址变了，_mask变成了3； methodThird执行完后，_buckets不仅指针地址变了，同时之前缓存的init、methodFirst和methodSecond方法也都不在了 注意，_occupied的变化是在回到cache_fill_nolock后发生的。 思考：扩容后，为什么不直接把之前缓存的方法加入新的buckets中？ 2.4 expand从cache_fill_nolock源码来看，当新的方法缓存数（_occupied+1）大于总容量（_mask+1）时，会对_buckets进行扩容，也就是执行expand函数，其源码如下 1234567891011121314151617void cache_t::expand(){ cacheUpdateLock.assertLocked(); // 获取当前总容量，即_mask+1 uint32_t oldCapacity = capacity(); // 新的容量 = 旧容量 * 2 uint32_t newCapacity = oldCapacity ? oldCapacity*2 : INIT_CACHE_SIZE; if ((uint32_t)(mask_t)newCapacity != newCapacity) { // mask overflow - can't grow further // fixme this wastes one bit of mask newCapacity = oldCapacity; } reallocate(oldCapacity, newCapacity);} 这个函数非常简单，仅仅是计算好新的容量后，就去调用reallocate函数。需要注意的是： 在不超过uint32_t大小（4字节）时，每次扩容为原来的2倍 如果超过了uint32_t，则重新申请跟原来一样大小的buckets 2.5 find在执行完相应的buckets策略后，接下来就需要找到合适的位置（bucket），以存储 方法的SEL和IMP。find具体做的事情就是根据方法的SEL，返回一个符合要求的bucket，同样上源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bucket_t * cache_t::find(SEL s, id receiver){ assert(s != 0); // 获取当前buckets，即_buckets bucket_t *b = buckets(); // 获取当前mask，即_mask mask_t m = mask(); // 由 sel &amp; mask 得出起始索引值 mask_t begin = cache_hash(s, m); mask_t i = begin; do { // sel为0：说明 i 这个位置尚未缓存方法； // sel等于s：命中缓存，说明 i 这个位置已缓存方法，可能是hash冲突 if (b[i].sel() == 0 || b[i].sel() == s) { return &amp;b[i]; } } while ((i = cache_next(i, m)) != begin); // hack // 找不到多余的哈希桶（出错的处理，打印问题）。一般不会走到这里！ Class cls = (Class)((uintptr_t)this - offsetof(objc_class, cache)); cache_t::bad_cache(receiver, (SEL)s, cls);}static inline mask_t cache_hash(SEL sel, mask_t mask) { return (mask_t)(uintptr_t)sel &amp; mask;}#if __arm__ || __x86_64__ || __i386__// objc_msgSend has few registers available.// Cache scan increments and wraps at special end-marking bucket.#define CACHE_END_MARKER 1static inline mask_t cache_next(mask_t i, mask_t mask) { return (i+1) &amp; mask;}#elif __arm64__// objc_msgSend has lots of registers available.// Cache scan decrements. No end marker needed.#define CACHE_END_MARKER 0static inline mask_t cache_next(mask_t i, mask_t mask) { return i ? i-1 : mask;}#else#error unknown architecture#endif 从源码可以发现，find找bucket的方式用到了hash的思想：以_buckets作为哈希桶，以cache_hash作为哈希函数，进行哈希运算后得出索引值index（本质是xx &amp; mask，所以index最大值就是_mask的值）。 由于索引值是通过哈希运算得出的，其结果自然是无序的，这也是为什么上例中init方法不在_buckets第一个位置的原因。 三、多线程对方法缓存的影响既然哈希桶的数量是在运行时动态增加的，那么在多线程环境下调用方法时，对方法的缓存有没有什么影响呢？看下面的分析。 3.1 多线程同时读取缓存在整个objc_msgSend函数中，为了达到最佳的性能，对方法缓存的读取操作是没有添加任何锁的。而多个线程同时调用已缓存的方法，并不会引发_buckets和_mask的变化，因此多个线程同时读取方法缓存的操作是不会有安全隐患的。 3.2 多线程同时写缓存从写缓存的cache_fill_nolock方法中我们知道在桶数量扩容和写桶数据之前，系统使用了一个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证写入的同步处理，并且在锁住的范围内部还做了一次查缓存的操作（if (cache_getImp(cls, sel)) return;），这样就 保证了哪怕多个线程同时写同一个方法的缓存也只会产生写一次的效果，即多线程同时写缓存的操作也不会有安全隐患。 3.3 多线程同时读写缓存这个情况就比较复杂了，我们先看一下objc_msgSend读缓存的代码（以 arm64架构汇编 为例） 12345678910111213141516171819202122232425262728293031323334353637383940.macro CacheLookup // x1 = SEL, x16 = isa ldp x10, x11, [x16, #CACHE] // x10 = buckets, x11 = occupied|mask and w12, w1, w11 // x12 = _cmd &amp; mask add x12, x10, x12, LSL #4 // x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4) ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // wrap: x12 = first bucket, w11 = mask add x12, x12, w11, UXTW #4 // x12 = buckets+(mask&lt;&lt;4) // Clone scanning loop to miss instead of hang when cache is corrupt. // The slow path may detect any corruption and halt later. ldp x9, x17, [x12] // {x9, x17} = *bucket1: cmp x9, x1 // if (bucket-&gt;sel != _cmd) b.ne 2f // scan more CacheHit $0 // call or return imp 2: // not hit: x12 = not-hit bucket CheckMiss $0 // miss if bucket-&gt;sel == 0 cmp x12, x10 // wrap if bucket == buckets b.eq 3f ldp x9, x17, [x12, #-16]! // {x9, x17} = *--bucket b 1b // loop3: // double wrap JumpMiss $0 .endmacro 其中，ldp指令的作用是将数据从内存读取出来存到寄存器，第一个ldp代码会 把cache_t中的_buckets 和 _occupied | _mask整个结构体成员分别读取到x10和x11两个寄存器中，并且CacheLookup的后续代码没有再次读取cache_t的成员数据，而是一直使用x10和x11中的值进行哈希查找。由于CPU能保证单条指令执行的原子性，所以 只要保证ldp x10, x11, [x16, #CACHE]这段代码读取到的_buckets与_mask是互相匹配的（即要么同时是扩容前的数据，要么同时是扩容后的数据），那么多个线程同时读写方法缓存也是没有安全隐患的。 3.3.1 编译内存屏障这里有个疑问，即系统是如何确保_buckets与_mask的这种一致性的呢？让我们看一下这两个变量的写入源码 1234567891011121314151617181920void cache_t::setBucketsAndMask(struct bucket_t *newBuckets, mask_t newMask){ // objc_msgSend uses mask and buckets with no locks. // It is safe for objc_msgSend to see new buckets but old mask. // (It will get a cache miss but not overrun the buckets' bounds). // It is unsafe for objc_msgSend to see old buckets and new mask. // Therefore we write new buckets, wait a lot, then write new mask. // objc_msgSend reads mask first, then buckets. // ensure other threads see buckets contents before buckets pointer mega_barrier(); _buckets = newBuckets; // ensure other threads see new buckets before new mask mega_barrier(); _mask = newMask; _occupied = 0;} 这段C++代码先修改_buckets，然后再更新_mask的值，为了确保这个顺序不被编译器优化，这里使用了mega_baerrier()来实现 编译内存屏障（Compiler Memory Barrier）。 如果不设置 编译内存屏障 的话，编译器有可能会优化代码先赋值_mask，然后才是赋值_buckets，两者的赋值之间，如果另一个线程执行ldp x10, x11, [x16, #0x10]指令，得到的就是旧_buckets和新_mask，进而出现内存数组越界引发程序崩溃。 而加入了编译内存屏障后，就算得到的是新_buckets和旧_mask，也不会导致程序崩溃。 编译内存屏障仅仅是确保_buckets的赋值会优先于_mask的赋值，也就是说，在任何场景下当指令ldp x10, x11, [x16, #CACHE]执行后，得到的_buckets数组的长度一定是大于或等于_mask+1的，如此就保证了不会出现内存数组越界导致的程序崩溃。可见，借助编译内存屏障的技巧在一定的程度上可以实现无锁读写技术。 对内存屏障感兴趣的同学可戳 理解 Memory barrier（内存屏障） 3.3.2 内存垃圾回收我们知道，在多线程读写方法缓存时，写线程可能会扩容_buckets（开辟新的_buckets内存，同时销毁旧的_buckets），此时，如果其他线程读取到的_buckets是旧的内存，就有可能会发生读内存异常而系统崩溃。为了解决这个问题，OC使用了两个全局数组objc_entryPoints、objc_exitPoints，分别保存所有会访问到cache的函数的起始地址、结束地址 12extern &quot;C&quot; uintptr_t objc_entryPoints[];extern &quot;C&quot; uintptr_t objc_exitPoints[]; 下面列出这些函数（同样以 arm64架构汇编 为例） 12345678910111213141516171819.private_extern _objc_entryPoints_objc_entryPoints: .quad _cache_getImp .quad _objc_msgSend .quad _objc_msgSendSuper .quad _objc_msgSendSuper2 .quad _objc_msgLookup .quad _objc_msgLookupSuper2 .quad 0.private_extern _objc_exitPoints_objc_exitPoints: .quad LExit_cache_getImp .quad LExit_objc_msgSend .quad LExit_objc_msgSendSuper .quad LExit_objc_msgSendSuper2 .quad LExit_objc_msgLookup .quad LExit_objc_msgLookupSuper2 .quad 0 当线程扩容哈希桶时，会先把旧的桶内存保存在一个全局的垃圾回收数组变量garbage_refs中，然后再遍历当前进程（在iOS中，一个进程就是一个应用程序）中的所有线程，查看是否有线程正在执行objc_entryPoints列表中的函数（原理是PC寄存器中的值是否在objc_entryPoints和objc_exitPoints这个范围内），如果没有则说明没有任何线程访问cache，可以放心地对garbage_refs中的所有待销毁的哈希桶内存块执行真正的销毁操作；如果有则说明有线程访问cache，这次就不做处理，下次再检查并在适当的时候进行销毁。 以上，**OC 2.0的runtime巧妙的利用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。** 深入解构objc_msgSend函数的实现 这篇博文会帮助你进一步了解Runtime的实现，尤其在多线程读写方法缓存方面 四、问题讨论来到这里，相信大家对cache_t缓存方法的原理已经有了一定的理解。现在请看下面的几个问题： 4.1 类方法的缓存位置Q：Person类调用alloc方法后，缓存在哪里？ A：缓存在 Person元类 的 cache_t 中。证明如下图 4.2 _mask的作用Q：请说明cache_t中_mask的作用 A：_mask从侧面反映了cache_t中哈希桶的数量（哈希桶的数量 = _mask + 1），保证了查找哈希桶时不会出现越界的情况。 题解：从上面的源码分析，我们知道cache_t在任何一次缓存方法的时候，哈希桶的数量一定是 &gt;=4且能被 4整除的，_mask则等于哈希桶的数量-1，也就是说，缓存方法的时候，_mask的二进制位上全都是1。当循环查询哈希桶的时候，索引值是由xx &amp; _mask运算得出的，因此索引值是小于哈希桶的数量的（index &lt;= _mask，故index &lt; capacity），也就不会出现越界的情况。 4.3 关于扩容临界点3/4的讨论Q：为什么扩容临界点是3/4？ A：一般设定临界点就不得不权衡 空间利用率 和 时间利用率 。在 3/4 这个临界点的时候，空间利用率比较高，同时又避免了相当多的哈希冲突，时间利用率也比较高。 题解：扩容临界点直接影响循环查找哈希桶的效率。设想两个极端情况： 当临界点是1的时候，也就是说当全部的哈希桶都缓存有方法时，才会扩容。这虽然让开辟出来的内存空间的利用率达到100%，但是会造成大量的哈希冲突，加剧了查找索引的时间成本，导致时间利用率低下，这与高速缓存的目的相悖； 当临界点是0.5的时候，意味着哈希桶的占用量达到总数一半的时候，就会扩容。这虽然极大避免了哈希冲突，时间利用率非常高，却浪费了一半的空间，使得空间利用率低下。这种以空间换取时间的做法同样不可取； 两相权衡下，当扩容临界点是3/4的时候，空间利用率 和 时间利用率 都相对比较高。 4.4 缓存循环查找的死循环情况Q：缓存循环查找哈希桶是否会出现死循环的情况？ A：不会出现。 题解：当哈希桶的利用率达到3/4的时候，下次缓存的时候就会进行扩容，即空桶的数量最少也会有总数的1/4，因此循环查询索引的时候，一定会出现命中缓存或者空桶的情况，从而结束循环。 五、总结通过以上例子的验证、源码的分析以及问题的讨论，现在总结一下cache_t的几个结论： 1.cache_t能缓存调用过的方法。 2.cache_t的三个成员变量中， _buckets的类型是struct bucket_t *，也就是指针数组，它表示一系列的哈希桶（已调用的方法的SEL和IMP就缓存在哈希桶中），一个桶可以缓存一个方法。 _mask的类型是mask_t（mask_t在64位架构下就是uint32_t，长度为4个字节），它的值等于哈希桶的总数-1（capacity - 1），侧面反映了哈希桶的总数。 _occupied的类型也是mask_t，它代表的是当前_buckets已缓存的方法数。 3.当缓存的方法数到达临界点（桶总数的3/4）时，下次再缓存新的方法时，首先会丢弃旧的桶，同时开辟新的内存，也就是扩容（扩容后都是全新的桶，以后每个方法都要重新缓存的），然后再把新的方法缓存下来，此时_occupied为1。 4.当多个线程同时调用一个方法时，可分以下几种情况： 多线程读缓存：读缓存由汇编实现，无锁且高效，由于并没有改变_buckets和_mask，所以并无安全隐患。 多线程写缓存：OC用了个全局的互斥锁（cacheUpdateLock.assertLocked()）来保证不会出现写两次缓存的情况。 多线程读写缓存：OC使用了ldp汇编指令、编译内存屏障技术、内存垃圾回收技术等多种手段来解决多线程读写的无锁处理方案，既保证了安全，又提升了系统的性能。 参考https://juejin.cn/post/6844904070596001806","link":"/2020/12/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/04-%E6%96%B9%E6%B3%95%E7%9A%84%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"},{"title":"03-对象&amp;类的结构","text":"一、对象&amp;类的结构1.1 解读类的本质从NSObject类的定义开始 123456789OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0, 2.0)OBJC_ROOT_CLASSOBJC_EXPORT@interface NSObject &lt;NSObject&gt; {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop} 注意：NSObject有个Class类型的isa成员变量 接下来用Clang编译main.m，输出.cpp文件，看一下NSObject类的底层定义 1clang -x objective-c -rewrite-objc -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk main.m 打开main.cpp文件，找到了NSObject 123456789#ifndef _REWRITER_typedef_NSObject#define _REWRITER_typedef_NSObjecttypedef struct objc_object NSObject;typedef struct {} _objc_exc_NSObject;#endifstruct NSObject_IMPL { Class isa;}; 发现NSObject类本质上是objc_object结构体，同时有定义一个NSObject_IMPL结构体（IMPL是implementation的缩写），里面有NSObject类的isa成员变量。 现在把我们自己定义的Person类用clang编译成c++看一下。我们定义的Person类：(有个age属性和run方法) 123456789101112131415@interface Person : NSObject@property (nonatomic) NSInteger age;- (void)run;@end@implementation Person- (void)run { NSLog(@&quot;I am running.&quot;);}@end 编译成c++后： 123456789101112131415161718#ifndef _REWRITER_typedef_Person#define _REWRITER_typedef_Persontypedef struct objc_object Person;typedef struct {} _objc_exc_Person;#endifextern &quot;C&quot; unsigned long OBJC_IVAR_$_Person$_age;struct Person_IMPL { struct NSObject_IMPL NSObject_IVARS; NSInteger _age;};static void _I_Person_run(Person * self, SEL _cmd) { NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_mc_9fhhprrj4k92vxzqm3g127z40000gn_T_main_09fc70_mi_0);}static NSInteger _I_Person_age(Person * self, SEL _cmd) { return (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)); }static void _I_Person_setAge_(Person * self, SEL _cmd, NSInteger age) { (*(NSInteger *)((char *)self + OBJC_IVAR_$_Person$_age)) = age; } 可见，Person类本质同样是objc_object结构体类型，Person_IMPL结构体内部多了个struct NSObject_IMPL类型的NSObject_IVARS成员变量——即继承自NSObject的类，都有个Class类型的isa成员变量。 1.2 objc_object结构源码： 12345678910111213141516171819202122struct objc_object {private: isa_t isa; public: ... // 一些函数};union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits;#if defined(ISA_BITFIELD) struct { ISA_BITFIELD; // defined in isa.h };#endif}; 关于isa_t的分析见上篇文章 objc_object结构体内部的方法有五十个左右，大致可分为以下几类 一些关于isa的函数，如initIsa()、getIsa()、changeIsa()等 一些弱引用的函数，如isWeaklyReferenced()、setWeaklyReferenced_nolock()等 一些内存管理函数，如retain()、release()、autorelease()等 两个关联对象函数，分别是hasAssociatedObjects()和setHasAssociatedObjects 1.3 objc_class结构同样先上源码 1234567891011121314typedef struct objc_class *Class;typedef struct objc_object *id;struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } ... // 一些函数}; 从源码可以看出，Class是objc_class结构体类型的指针变量，继承自objc_object结构体。Class有4个成员变量，且它们在内存存储上是有序的，依次分别是： 1.isa：类型是isa_t，64位下长度为8字节，上篇已做过分析，这里略过 2.superclass：类型是Class，表示继承关系，指向当前类的父类，同样8字节 3.cache：类型是cache_t，表示缓存，用于缓存已调用的方法，加速方法的调用。其具体结构如下: 12345678910111213141516struct cache_t { struct bucket_t *_buckets; // 64位下是8字节 mask_t _mask; // 64位下是4字节 mask_t _occupied; // 64位下是4字节public: ... // 一些函数};#if __LP64__typedef uint32_t mask_t; // uint32_t 4字节 // x86_64 &amp; arm64 asm are less efficient with 16-bits#elsetypedef uint16_t mask_t; // uint16_t 2字节#endiftypedef unsigned int uint32_t; 可见，cache这个成员变量长度是16字节。 cache比较重要，关于它的分析可戳 OC源码分析之方法的缓存原理。 4.bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其结构如下 12345678struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; // unsigned longprivate: ... // 一些函数}; 其长度也是8字节。根据bits成员变量在objc_object结构体中注释的描述，它实质上是class_rw_t *加上自定义rr/alloc标志，最重要的是class_rw_t。 接下来将重点介绍它。 二、class_rw_t &amp; class_ro_t分析 rw是readwrite的意思，而ro则是readonly。 OC类中的属性、方法还有遵循的协议等信息都保存在class_rw_t中，首先看看class_rw_t的结构： 12345678910111213141516171819202122232425262728struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;#if SUPPORT_INDEXED_ISA uint32_t index;#endif ...// 一些函数};#if __ARM_ARCH_7K__ &gt;= 2 || (__arm64__ &amp;&amp; !__LP64__)# define SUPPORT_INDEXED_ISA 1 // armv7k or arm64_32#else# define SUPPORT_INDEXED_ISA 0#endif 发现class_rw_t中还有一个被const修饰的指针变量 ro，是class_ro_t结构体指针，其中存储了当前类在编译期确定的方法、成员变量、属性以及遵循的协议等信息。 1234567891011121314151617181920212223struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 // This field exists only when RO_HAS_SWIFT_INITIALIZER is set. _objc_swiftMetadataInitializer __ptrauth_objc_method_list_imp _swiftMetadataInitializer_NEVER_USE[0]; ... // 一些函数}; 2.1 获取class_rw_t要想获取class_rw_t指针地址，需要知道objc_class的bits指针地址，通过对objc_class的结构分析得知，bits指针地址是objc_class首地址偏移32个字节（isa + superclass + cache = 8+8+16=32字节） 也可以从源码得知如何拿到class_rw_t指针 12345678910111213// objc_class结构体中class_rw_t *data() { return bits.data(); // bits是class_data_bits_t类型}// class_data_bits_t结构体中...class_rw_t* data() { return (class_rw_t *)(bits &amp; FAST_DATA_MASK);}// 64位下#define FAST_DATA_MASK 0x00007ffffffffff8UL 在64位下，class_rw_t指针地址是在[3, 46]数据段，所以也可以用bits &amp; FAST_DATA_MASK计算出class_rw_t指针地址。 接着通过一个例子来验证class_rw_t和class_ro_t是否存储了类的信息 2.2 准备工作给Person类添加属性、方法和协议，代码如下 123456789101112131415161718192021222324252627282930313233@protocol PersonProtocol &lt;NSObject&gt;- (void)walk;@end@interface Person : NSObject &lt;PersonProtocol&gt; { NSInteger _gender;}@property (nonatomic) NSString *name;@property (nonatomic) NSInteger age;+ (void)printMyClassName;- (void)run;@end@implementation Person+ (void)printMyClassName { NSLog(@&quot;my class name is Person&quot;);}- (void)run { NSLog(@&quot;I am running.&quot;);}- (void)walk { NSLog(@&quot;I am walking.&quot;);}@end 然后打上断点 好了，准备工作完成，下面开始验证 2.3 class_rw_t验证过程1.打印Person类 1234(lldb) x/5gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x00000000000000000x100002840: 0x0000000102237404 说明： Person类首地址是0x100002820，因此，0x100002840是其bits地址（32字节就是0x20，0x100002840 = 0x100002820 + 0x20），bits内容是0x0000000102237404 0x001d8001000027f9是Person类的isa地址，指向Person元类 0x0000000100b39140是Person类的superclass地址，也就是NSObject类首地址 0x00000001003dc250 0x0000000000000000则是Person类的cache段 2.打印class_rw_t 12345678910111213141516171819202122232425262728293031323334353637// bits &amp; FAST_DATA_MASK(lldb) p (class_rw_t *)(0x0000000102237404 &amp; 0x00007ffffffffff8)(class_rw_t *) $1 = 0x0000000102237400(lldb) p *$1(class_rw_t) $2 = { flags = 2148139008 version = 0 ro = 0x0000000100002788 methods = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002608 arrayAndFlag = 4294977032 } } } properties = { list_array_tt&lt;property_t, property_list_t&gt; = { = { list = 0x0000000100002720 arrayAndFlag = 4294977312 } } } protocols = { list_array_tt&lt;unsigned long, protocol_list_t&gt; = { = { list = 0x00000001000025a8 arrayAndFlag = 4294976936 } } } firstSubclass = nil nextSiblingClass = NSUUID demangledName = 0x0000000000000000} 这里请大家留意一下class_rw_t的几个关键成员变量： ro地址是0x0000000100002788 methods的list地址是0x0000000100002608 properties的list地址是0x0000000100002720 protocols的list地址是0x0000000100002608 3.验证methods 目前来看，Person类至少有6个实例方法，分别是run、walk以及name和age的getter、setter，还有1个类方法，即printMyClassName，总计7个方法。 123456789101112131415(lldb) p (method_list_t *)0x0000000100002608 // rw的methods的list地址(method_list_t *) $7 = 0x0000000100002608(lldb) p *$7(method_list_t) $8 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 7 first = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45) } }} 正好是7个方法，让我们看看都是哪些（由于method_list_t继承自entsize_list_tt，可以通过entsize_list_tt的get()函数一一打印） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748(lldb) p $8.get(0)(method_t) $9 = { name = &quot;walk&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001530 (CCTest`-[Person walk] at main.m:45)}(lldb) p $8.get(1)(method_t) $10 = { name = &quot;.cxx_destruct&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001600 (CCTest`-[Person .cxx_destruct] at main.m:35)}(lldb) p $8.get(2)(method_t) $11 = { name = &quot;name&quot; types = 0x0000000100001eb1 &quot;@16@0:8&quot; imp = 0x0000000100001560 (CCTest`-[Person name] at main.m:27)}(lldb) p $8.get(3)(method_t) $12 = { name = &quot;setName:&quot; types = 0x0000000100001f4b &quot;v24@0:8@16&quot; imp = 0x0000000100001580 (CCTest`-[Person setName:] at main.m:27)}(lldb) p $8.get(4)(method_t) $13 = { name = &quot;age&quot; types = 0x0000000100001f56 &quot;q16@0:8&quot; imp = 0x00000001000015c0 (CCTest`-[Person age] at main.m:28)}(lldb) p $8.get(5)(method_t) $14 = { name = &quot;run&quot; types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x0000000100001500 (CCTest`-[Person run] at main.m:41)}(lldb) p $8.get(6)(method_t) $15 = { name = &quot;setAge:&quot; types = 0x0000000100001f5e &quot;v24@0:8q16&quot; imp = 0x00000001000015e0 (CCTest`-[Person setAge:] at main.m:28)} 显然，class_rw_t的methods确实包含了Person类的全部实例方法，只是多了个.cxx_destruct方法。.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作，关于其原理这里略过不提。 思考：类方法printMyClassName哪里去了？ 4.验证properties 同理，Person类至少有name和age这两个属性，且看 1234567891011121314151617181920212223242526272829(lldb) p (property_list_t *)0x0000000100002720 // rw的properties的list地址(property_list_t *) $18 = 0x0000000100002720(lldb) p *$18(property_list_t) $19 = { entsize_list_tt&lt;property_t, property_list_t, 0&gt; = { entsizeAndFlags = 16 count = 6 first = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) }}(lldb) p $19.get(0)(property_t) $20 = (name = &quot;name&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,&amp;,N,V_name&quot;) (lldb) p $19.get(1)(property_t) $21 = (name = &quot;age&quot;, attributes = &quot;Tq,N,V_age&quot;) (lldb) p $19.get(2)(property_t) $22 = (name = &quot;hash&quot;, attributes = &quot;TQ,R&quot;) (lldb) p $19.get(3)(property_t) $23 = (name = &quot;superclass&quot;, attributes = &quot;T#,R&quot;) (lldb) p $19.get(4)(property_t) $24 = (name = &quot;description&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) (lldb) p $19.get(5)(property_t) $25 = (name = &quot;debugDescription&quot;, attributes = &quot;T@\\&quot;NSString\\&quot;,R,C&quot;) 显然name和age存储在properties中。 多余的属性也不作赘述。 5.验证protocols 在验证之前，先分析一下protocol_list_t，这个结构体并不是继承自entsize_list_tt的，其结构如下 1234567struct protocol_list_t { // count is 64-bit by accident. uintptr_t count; protocol_ref_t list[0]; // variable-size ... // 一些函数} 注意到variable-size这个注释部分（可变大小），仿佛看到了希望 123456789101112131415161718192021typedef uintptr_t protocol_ref_t; // protocol_t *, but unremappedstruct protocol_t : objc_object { const char *mangledName; struct protocol_list_t *protocols; method_list_t *instanceMethods; method_list_t *classMethods; method_list_t *optionalInstanceMethods; method_list_t *optionalClassMethods; property_list_t *instanceProperties; uint32_t size; // sizeof(protocol_t) uint32_t flags; // Fields below this point are not always present on disk. const char **_extendedMethodTypes; const char *_demangledName; property_list_t *_classProperties; const char *demangledName(); ... // 一些函数}; protocol_ref_t虽然未映射成protocol_t *，不过应该可以考虑一下强转，实验一下吧（这次是找到PersonProtocol协议） 1234567891011121314151617181920212223242526272829303132333435363738394041(lldb) p (protocol_list_t *)0x00000001000025a8 // rw的protocols的list地址(protocol_list_t *) $26 = 0x00000001000025a8 (lldb) p *$26(protocol_list_t) $27 = (count = 1, list = protocol_ref_t [] @ 0x00007fb5decb30f8)(lldb) p (protocol_t *)$26-&gt;list[0](protocol_t *) $32 = 0x00000001000028a8 (lldb) p *$32(protocol_t) $33 = { objc_object = { isa = { cls = Protocol bits = 4306735304 = { nonpointer = 0 has_assoc = 0 has_cxx_dtor = 0 shiftcls = 538341913 magic = 0 weakly_referenced = 0 deallocating = 0 has_sidetable_rc = 0 extra_rc = 0 } } } mangledName = 0x0000000100001d16 &quot;PersonProtocol&quot; // 出现了！！！ protocols = 0x0000000100002568 instanceMethods = 0x0000000100002580 classMethods = 0x0000000000000000 optionalInstanceMethods = 0x0000000000000000 optionalClassMethods = 0x0000000000000000 instanceProperties = 0x0000000000000000 size = 96 flags = 0 _extendedMethodTypes = 0x00000001000025a0 _demangledName = 0x0000000000000000 _classProperties = 0x0000000000000000} 功夫不负有心人，最终验证了class_rw_t的protocols中含有Person类所遵循的PersonProtocol协议。 到了这里，**class_rw_t确实存储了类的实例方法、属性和遵循的协议了。** 2.4 class_ro_t验证过程现在就剩下ro了 1.打印class_ro_t 123456789101112131415161718(lldb) p $1-&gt;ro(const class_ro_t *) $38 = 0x0000000100002788 (lldb) p *$38(const class_ro_t) $39 = { flags = 388 instanceStart = 8 instanceSize = 32 reserved = 0 ivarLayout = 0x0000000100001d2e &quot;\\x11&quot; name = 0x0000000100001d0f &quot;Person&quot; baseMethodList = 0x0000000100002608 baseProtocols = 0x00000001000025a8 ivars = 0x00000001000026b8 weakIvarLayout = 0x0000000000000000 baseProperties = 0x0000000100002720 _swiftMetadataInitializer_NEVER_USE = {}} 有没有发现什么！**class_ro_t的方法、属性和协议的地址都与class_rw_t的一致，既然指向的是同一块内存空间，显然class_ro_t也存储了Person类的实例方法、属性和协议**。 与class_rw_t不同的是，class_ro_t多了一个ivars列表，里面存放的应该是Person类的成员变量。 2.验证ivars Person类的成员变量有：_gender、_name和_age 所幸ivar_list_t是继承自entsize_list_tt的，get()函数又可以用了。 12345678910111213141516171819202122232425262728293031323334353637383940(lldb) p $39.ivars(const ivar_list_t *const) $40 = 0x00000001000026b8(lldb) p *$40(const ivar_list_t) $41 = { entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt; = { entsizeAndFlags = 32 count = 3 first = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8 } }}(lldb) p $41.get(0)(ivar_t) $42 = { offset = 0x00000001000027e0 name = 0x0000000100001e83 &quot;_gender&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(1)(ivar_t) $43 = { offset = 0x00000001000027e8 name = 0x0000000100001e8b &quot;_name&quot; type = 0x0000000100001f6b &quot;@\\&quot;NSString\\&quot;&quot; alignment_raw = 3 size = 8}(lldb) p $41.get(2)(ivar_t) $44 = { offset = 0x00000001000027f0 name = 0x0000000100001e91 &quot;_age&quot; type = 0x0000000100001f69 &quot;q&quot; alignment_raw = 3 size = 8} 完全符合预期，class_ro_t确实存储了Person类的成员变量。 2.5 rw和ro的联系为什么class_rw_t、class_ro_t的方法、属性和协议的地址一致？ 在class_data_bits_t结构体中的safe_ro()函数中发现了端倪 12345678910const class_ro_t *safe_ro() { class_rw_t *maybe_rw = data(); if (maybe_rw-&gt;flags &amp; RW_REALIZED) { // maybe_rw is rw return maybe_rw-&gt;ro; } else { // maybe_rw is actually ro return (class_ro_t *)maybe_rw; }} 可见，rw不一定是rw，也可能是ro。实际上，在编译期间，类的class_data_bits_t *bits指针指向的是class_ro_t *，然后在OC运行时调用了realizeClassWithoutSwift()（苹果开源的objc4-756.2源码是realizeClassWithoutSwift()，在此之前的版本是realizeClass()方法），这个方法主要做的就是利用编译期确定的ro来初始化rw： 12345678910111213141516171819ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // 一般走这里 // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); // 给rw申请内存 rw-&gt;ro = ro; // 设置rw的ro rw-&gt;flags = RW_REALIZED|RW_REALIZING; // 设置flags cls-&gt;setData(rw); // 给cls设置正确的rw}... // 初始化 rw 的其他字段，更新superclass、meta class// Attach categoriesmethodizeClass(cls); 在代码的最后，还调用了methodizeClass()，其源码如下 1234567891011121314151617181920212223242526272829303132333435363738static void methodizeClass(Class cls){ runtimeLock.assertLocked(); bool isMeta = cls-&gt;isMetaClass(); auto rw = cls-&gt;data(); auto ro = rw-&gt;ro; ... // 打印信息 // Install methods and properties that the class implements itself. method_list_t *list = ro-&gt;baseMethods(); if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); } property_list_t *proplist = ro-&gt;baseProperties; if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1); } protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1); } if (cls-&gt;isRootMetaclass()) { addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO); } category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/); attachCategories(cls, cats, false /*don't flush caches*/); ... // 打印信息 if (cats) free(cats); ... // 打印信息} 在这个方法里，将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、properties 和 protocols 列表中。 这就完美解释了为什么运行时rw和ro的方法、属性和协议相同。 2.6 rw和ro在运行时的不同之处目前为止的验证都是基于Person类的现有结构，也就是在编译期就确定的，突出不了class_rw_t和class_ro_t的差异性。接下来会用runtime的api在运行时为Person动态添加一个fly()方法，再来一试。 1.添加方法 具体代码如下： 12345void fly(id obj, SEL sel) { NSLog(@&quot;I am flying&quot;);}class_addMethod([Person class], NSSelectorFromString(@&quot;fly&quot;), (IMP)fly, &quot;v@:&quot;); 再加一个打印方法，用于打印类的methods 123456789101112void printMethods(Class cls) { if (cls == nil) { return ; } CCNSLog(@&quot;------------ print %@ methods ------------&quot;, NSStringFromClass(cls)); uint32_t count; Method *methods = class_copyMethodList(cls, &amp;count); for (uint32_t i = 0; i &lt; count; i++) { Method method = methods[i]; CCNSLog(@&quot;名字：%@ -- 类型：%s&quot;, NSStringFromSelector(method_getName(method)), method_getTypeEncoding(method)); }} 运行一下看效果，发现添加成功，如图 2.验证过程 先打印class_rw_t，即 还有class_ro_t 对比后发现，两者的属性、协议指针地址未发生变化，但是方法的指针地址不一样了。 由于class_rw_t是运行时才初始化的，而class_ro_t在编译期间就确定了，因此可以猜测新增的fly方法存储在class_rw_t的methods指针上，class_ro_t的baseMethodList指针从编译期之后就未发生改变。 下面继续验证，首先看class_ro_t的方法列表 OK，编译期就确定的方法都在，并且没有fly方法，也就是说class_ro_t的方法列表在运行时基本没变。 class_ro_t的属性列表、成员变量列表、协议在运行时都没有发生改变。感兴趣的同学可以自己尝试验证一下。 接着看class_rw_t的方法列表 class_rw_t的methods里面数据居然都没有了？ 没办法，这里暂时留个坑吧，暂时不知道原因。 三、总结3.1 类的结构总结关于类的结构，我们了解到： 类本质上是objc_object结构体，也就是类也是对象，即万物是对象。 类都包含一个Class类型的成员变量isa Class是objc_class结构体类型的指针变量，内部有4个成员变量，即 isa：类型是isa_t superclass：类型是Class，表示继承关系，指向类的父类 cache：类型是cache_t，表示缓存，用于缓存指针和 vtable，加速方法的调用 bits：类型是class_data_bits_t，用于存储类的数据（类的方法、属性、遵循的协议等信息），其长度在64位CPU下为8字节，是个指针，指向class_rw_t * 3.2 class_rw_t和class_ro_t总结 class_ro_t存储了类在编译期确定的方法（包括其分类的）、成员变量、属性以及遵循的协议等信息，在运行时不会发生变化。编译期，类的bits指针指向的是class_ro_t指针（即此时class_rw_t 实际上是class_ro_t ）。 实例方法存储在类中 类方法存储在元类中 在realizeClassWithoutSwift()执行之后，class_rw_t才会被初始化，同时存储类的方法、属性以及遵循的协议，实际上，class_rw_t和class_ro_t两者的方法列表（或属性列表、协议列表）的指针是相同的。 运行时向类动态添加属性、方法时，会修改class_rw_t的属性列表、方法列表指针，但class_ro_t对应的属性列表、方法列表不会变。 一个待解决的坑：通过运行时添加方法（或属性、协议）改变了 class_rw_t 对应的方法列表（或属性列表、协议列表）的指针后，不知道为什么居然在 class_rw_t 的方法列表（或属性列表、协议列表）上找不到新增的方法（或属性、协议）了。 3.3 类方法的存储位置（Person类的类方法printMyClassName()） 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1. 获取 Person元类(lldb) x/4gx pcls0x100002820: 0x001d8001000027f9 0x0000000100b391400x100002830: 0x00000001003dc250 0x0000000000000000(lldb) p/x 0x001d8001000027f9 &amp; 0x00007ffffffffff8(long) $50 = 0x00000001000027f8(lldb) po 0x00000001000027f8Person // Person元类// 2. 获取 Person元类 的 bits(lldb) x/5gx 0x00000001000027f80x1000027f8: 0x001d800100b390f1 0x0000000100b390f00x100002808: 0x0000000102237440 0x00000001000000030x100002818: 0x00000001022373a0 // Person元类 的 bits// 3. 获取 Person元类 的 class_rw_t(lldb) p (class_rw_t *)(0x00000001022373a0 &amp; 0x00007ffffffffff8)(class_rw_t *) $52 = 0x00000001022373a0// 4. 验证 Person元类 的 methods(lldb) p $52-&gt;methods(method_array_t) $55 = { list_array_tt&lt;method_t, method_list_t&gt; = { = { list = 0x0000000100002270 arrayAndFlag = 4294976112 } }}(lldb) p (method_list_t *)0x0000000100002270(method_list_t *) $56 = 0x0000000100002270(lldb) p *$56(method_list_t) $57 = { entsize_list_tt&lt;method_t, method_list_t, 3&gt; = { entsizeAndFlags = 26 count = 1 first = { name = &quot;printMyClassName&quot; // 成功找到 Person类的类方法 types = 0x0000000100001e96 &quot;v16@0:8&quot; imp = 0x00000001000014d0 (CCTest`+[Person printMyClassName] at main.m:37) } }} 结论：类方法 存储 在类的元类上，且位于元类的class_ro_t的baseMethodList指针上（或在class_rw_t的methods指针上）","link":"/2020/11/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/03-%E5%AF%B9%E8%B1%A1&%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84/"},{"title":"05-方法的本质和消息查找流程","text":"前言 在Objective-C中，当编译器遇到一个方法调用时，它会将方法的调用变成以下函数中的一个：objc_msgSend、objc_msgSend_stret、objc_msgSendSuper和objc_msgSendSuper_stret。 发送给对象的父类的消息（使用super关键字时）是使用objc_msgSendSuper发送的，其他消息是使用objc_msgSend发送的。如果是以数据结构体作为返回值的方法，则是使用objc_msgSendSuper_stret或objc_msgSend_stret发送的。 然而这一切，都要从Runtime开始说起 一、Runtime1.1 什么是RuntimeRuntime是一套API，由c、c++、汇编一起写成的，为OC提供了运行时的特性 运行时：代码跑起来，将可执行文件装载到内存 编译时：正在编译的时间——翻译源代码将高级语言（OC、Swift）翻译成机器语言（汇编等），最后变成二进制 1.2 Runtime版本Runtime有两个版本——Legacy和Modern，苹果开发者文档都写得清清楚楚 源码中-old、__OBJC__代表Legacy版本 -new、__OBJC2__代表Modern版本，以此做兼容 1.3 Runtime的作用及调用Runtime底层经过编译会提供一套API和供FrameWork、Service使用 1.4 Runtime 调用方式 Runtime API，如 sel_registerName() NSObject API，如 isKindOf() OC上层方式，如 @selector() 原来平常在用的这么多方法都是Runtime啊，那么方法究竟是什么呢？ 二、方法的本质2.1 研究方法通过clang编译成cpp文件可以看到底层代码，得到方法的本质 兼容编译（代码少）： 1clang -rewrite-objc main.m -o main.cpp 完整编译（不报错）： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main.cpp 2.2 代码转换12FXPerson *p = [FXPerson alloc];[p fly]; 转为： 12FXPerson *p = ((FXPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(&quot;FXPerson&quot;), sel_registerName(&quot;alloc&quot;));((void (*)(id, SEL))(void *)objc_msgSend)((id)p, sel_registerName(&quot;fly&quot;)); ((FXPerson *(*)(id, SEL))(void *)是类型强转 (id)objc_getClass(&quot;FXPerson&quot;)获取FXPerson类对象 sel_registerName(&quot;alloc&quot;)等同于@selector() 那么可以理解为((类型强转)objc_msgSend)(对象, 方法调用) 去除强转后就容易分辨多了 12Person *person = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;));objc_msgSend(person, sel_registerName(&quot;personInstanceMethod1&quot;)); 发现+alloc和personInstanceMethod1这两个方法的调用，实际上就是调用objc_msgSend函数。 2.3方法的本质可以在arm64.s文件中找到objc_msgSend函数的说明 1id objc_msgSend(id self, SEL _cmd, ...) 其中，第一个参数self是调用者本身，它也是接收者；第二个参数_cmd是方法编号；剩下的可变参数列表是方法自己的参数。 简单说明一下： id指的是OC对象，每个对象在内存的结构都是不确定的，但其首地址指向的是对象的isa，通过isa，在运行时就能获取到objc_class objc_class表示对象的Class，它的结构在编译后就确定了 SEL表示选择器，通常可理解为一个字符串。OC在运行时维护着一张SEL表，将字符串相同的方法名映射到唯一一个SEL上 任意类的相同方法名映射的SEL都相同（可以把SEL近似地等同于方法名） 可以通过sel_registerName(char *name)这个C函数得到SEL，OC也提供了一个语法糖@selector用来方便的调用该函数 IMP是一个函数指针。OC中的方法最终都会转换成纯C的函数，IMP表示的就是这些函数的地址。 如果外部定义了C函数并调用如void fly() {}，在clang编译之后还是fly()而不是通过objc_msgSend去调用。因为发送消息就是找函数实现的过程，而C函数可以通过函数名——指针就可以找到 从上面的例子可以得出一个结论：方法调用的本质是通过objc_msgSend函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 也就是说，下面的两段代码实际上效果是相同的 要想使用 objc_msgSend 函数，需要改一处设置。如下图： 2.4向不同对象发送消息1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/message.h&gt;@interface FXFather: NSObject- (void)walk;+ (void)run;@end@implementation FXFather- (void)walk { NSLog(@&quot;%s&quot;,__func__); }+ (void)run { NSLog(@&quot;%s&quot;,__func__); }@end@interface FXSon: FXFather- (void)jump;+ (void)swim;@end 子类FXSon有实例方法jump、类方法swim 父类FXFather有实例方法walk、类方法run ①发送实例方法 消息接收者——实例对象 12FXSon *s = [FXSon new];objc_msgSend(s, sel_registerName(&quot;jump&quot;)); ②发送类方法 消息接收者——类对象 1objc_msgSend(objc_getClass(&quot;FXSon&quot;), sel_registerName(&quot;swim&quot;)); ③向父类发送实例方法 objc_msgSend不能向父类发送消息，需要使用objc_msgSendSuper，并给objc_super结构体赋值（在objc2中只需要赋值receiver、super_class） 123456789101112131415/// Specifies the superclass of an instance. struct objc_super { /// Specifies an instance of a class. __unsafe_unretained _Nonnull id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained _Nonnull Class class;#else __unsafe_unretained _Nonnull Class super_class;#endif /* super_class is the first class to search */};#endif receiver——实例对象；super_class——父类类对象 1234struct objc_super superInstanceMethod;superInstanceMethod.receiver = s;superInstanceMethod.super_class = objc_getClass(&quot;FXFather&quot;);objc_msgSendSuper(&amp;superInstanceMethod, sel_registerName(&quot;walk&quot;)); ④向父类发送类方法 receiver——类对象；super_class——父类元类对象 1234struct objc_super superClassMethod;superClassMethod.receiver = [s class];superClassMethod.super_class = class_getSuperclass(object_getClass([s class]));objc_msgSendSuper(&amp;superClassMethod, sel_registerName(&quot;run&quot;)); 三、消息查找流程方法的查找，也叫消息的查找，它的准备工作是从objc_msgSend开始，准备就绪后，才会展开查找。 3.1开始查找打开objc源码，由于主要研究arm64结构的汇编实现，来到objc-msg-arm64.s： 找到objc_msgSend的源码： 1id objc_msgSend(id self, SEL _cmd, ...); p0表示0寄存器的指针，x0表示它的值，w0表示低32位的值（不用过多在意） ①开始objc_msgSend ②判断消息接收者是否为空，为空直接返回 ③判断tagged_pointers（之后会讲到） ④取得对象中的isa存一份到p13中（寄存器指令在逆向篇中会讲到） ⑤根据isa进行mask地址偏移得到对应的上级对象（类、元类） 查看GetClassFromIsa_p16源码： 1.macro GetClassFromIsa_p16 主要就是进行isa &amp; mask得到class操作 ⑥开始在缓存中查找imp——开启快速流程 3.2快速流程从CacheLookup开始快速查找流程（此时x0是sel，x16是class），模式是NORMAL。 1.macro CacheLookup ①#CACHE是个宏定义表示16个字节，[x16, #CACHE]表示类对象内存地址偏移16字节得到cache。 cache一分为二：8字节的buckets存放在p10，两个4字节的occupied和mask存放在p11 12#define CLASS __SIZEOF_POINTER__#define CACHE (2 * __SIZEOF_POINTER__) ②x1是sel即cmd，取出p11中的低32位（w11）：mask，两者进行与运算得到hash下标 存放在x12 ③p12先左移动(1+PTRSHIFT)，再与p10buckets相加得到新的p12——bucket ④拿出p12bucket地址所在的值，放在p17imp和p9sel中，这点可以从bucket_t的结构中看出（sel强转成key）用bucket中的sel与x1cmd作对比，如果相同则缓存命中CacheHit得到其中的imp；如果不等就跳转 12345678910111213struct bucket_t {private: // IMP-first is better for arm64e ptrauth and no worse for arm64. // SEL-first is better for armv7* and i386 and x86_64.#if __arm64__ MethodCacheIMP _imp; cache_key_t _key;#else cache_key_t _key; MethodCacheIMP _imp;#endif ...} ⑤如果bucket-&gt;sel == 0则CheckMiss；比较p12bucket和p10buckets，如果不相等就将x12bucket的值进行自减操作（查找上一个bucket），跳转回④重新循环，直到bucket == buckets遍历结束跳转⑥ 123456789101112.macro CheckMiss // miss if bucket-&gt;sel == 0.if $0 == GETIMP cbz p9, LGetImpMiss.elseif $0 == NORMAL cbz p9, __objc_msgSend_uncached.elseif $0 == LOOKUP cbz p9, __objc_msgLookup_uncached.else.abort oops.endif.endmacro ⑥平移哈希使得p12 = first bucket，再重复进行一下类似④⑤⑥的操作： 防止不断循环的过程中多线程并发的时候正好缓存更新了。 如果bucket-&gt;sel == 0走CheckMiss，如果bucket == buckets走JumpMiss，本质是一样的 1234567891011.macro JumpMiss.if $0 == GETIMP b LGetImpMiss.elseif $0 == NORMAL b __objc_msgSend_uncached.elseif $0 == LOOKUP b __objc_msgLookup_uncached.else.abort oops.endif.endmacro 当NORMAL时，CheckMiss和JumpMiss都走__objc_msgSend_uncached ⑦__objc_msgSend_uncached调用MethodTableLookup ⑧保存参数调用c++方法进入慢速流程 1.macro MethodTableLookup 快速查找的过程简要总结: 快速查找完整流程图： 3.3慢速查找汇编__class_lookupMethodAndLoadCache3与c++中_class_lookupMethodAndLoadCache3相对应 12345IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls){ return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128// initialize = YES , cache = NO , resolver = YESIMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = nil; bool triedResolver = NO; runtimeLock.assertUnlocked(); // 缓存查找，cache为NO直接跳过 if (cache) { imp = cache_getImp(cls, sel); if (imp) return imp; } // runtimeLock is held during isRealized and isInitialized checking // to prevent races against concurrent realization. // runtimeLock is held during method search to make // method-lookup + cache-fill atomic with respect to method addition. // Otherwise, a category could be added but ignored indefinitely because // the cache was re-filled with the old value after the cache flush on // behalf of the category. // lock是为了防止多线程操作； 类是否被编译 runtimeLock.lock(); checkIsKnownClass(cls); // 为查找方法做准备条件，如果类没有初始化时，初始化类和父类、元类等 if (!cls-&gt;isRealized()) { realizeClass(cls); } if (initialize &amp;&amp; !cls-&gt;isInitialized()) { runtimeLock.unlock(); _class_initialize (_class_getNonMetaClass(cls, inst)); runtimeLock.lock(); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 } retry: runtimeLock.assertLocked(); // Try this class's cache. // 从缓存里面查找一遍，若有直接goto done imp = cache_getImp(cls, sel); if (imp) goto done; // Try this class's method lists. // 形成局部作用域，避免局部变量命名重复 { // 在类的方法列表中查找方法，若有直接cache_fill Method meth = getMethodNoSuper_nolock(cls, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done; } } // Try superclass caches and method lists. { unsigned attempts = unreasonableClassCount(); // 遍历父类进行查找 for (Class curClass = cls-&gt;superclass; curClass != nil; curClass = curClass-&gt;superclass) { // Halt if there is a cycle in the superclass chain. if (--attempts == 0) { _objc_fatal(&quot;Memory corruption in class list.&quot;); } // Superclass cache. // 在父类缓存中查找，若有直接cache_fill imp = cache_getImp(curClass, sel); if (imp) { if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; } } // Superclass method list. // 在父类的方法列表中查找方法，若有直接cache_fill Method meth = getMethodNoSuper_nolock(curClass, sel); if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; } } } // No implementation found. Try method resolver once. // 如果方法仍然没找到，就开始做动态方法解析 if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); _class_resolveMethod(cls, sel, inst); // ✅ runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; } // No implementation found, and method resolver didn't help. // Use forwarding. // 开始消息转发 imp = (IMP)_objc_msgForward_impcache; cache_fill(cls, sel, imp, inst); done: runtimeLock.unlock(); return imp;} 慢速流程主要分为几个步骤： ①_class_lookupMethodAndLoadCache3调用lookUpImpOrForward，此时参数initialize=YES cache=NO resolver=YES ②runtimeLock.lock()为了防止多线程操作 ③realizeClass(cls)为查找方法做准备条件，如果类没有初始化时，初始化类和父类、元类等 ④imp = cache_getImp(cls, sel)为了容错从缓存中再找一遍，若有goto done⑨ ⑤// Try this class's method lists局部作用域中，在类的方法列表中查找方法，若有直接log_and_fill_cache并goto done⑨ ⑥// Try superclass caches and method lists局部作用域中，遍历父类：先在父类缓存中查找，若有直接log_and_fill_cache并goto done；没有再去父类的方法列表中查找方法，若有直接log_and_fill_cache并goto done⑨ ⑦如果还没找到就动态方法解析resolveMethod，标记为triedResolver = YES（已自我拯救过）。动态方法解析结束后跳转慢速流程④ ⑧如果动态方法解析完成后再找一遍仍然没找到imp，就抛出错误_objc_msgForward_impcache得到imp并cache_fill ⑨done：多线程解锁，返回imp 接下来拆解步骤进行说明： cache_getImp这个方法后续会解释 getMethodNoSuper_nolock遍历调用search_method_list查找方法列表 12345678910111213141516171819getMethodNoSuper_nolock(Class cls, SEL sel){ runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) { method_t *m = search_method_list(*mlists, sel); if (m) return m; } return nil;} search_method_list利用二分查找寻找方法 1234567891011121314151617181920212223242526272829static method_t *search_method_list(const method_list_t *mlist, SEL sel){ int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) { // 如果方法列表已经排序好了，则通过二分查找法查找方法，以节省时间 return findMethodInSortedMethodList(sel, mlist); } else { // Linear search of unsorted method list // 如果方法列表没有排序好就遍历查找 for (auto&amp; meth : *mlist) { if (meth.name == sel) return &amp;meth; } }#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) { for (auto&amp; meth : *mlist) { if (meth.name == sel) { _objc_fatal(&quot;linear search worked when binary search did not&quot;); } } }#endif return nil;} findMethodInSortedMethodList二分查找算法的具体实现（了解即可） 12345678910111213141516171819202122232425262728293031323334353637static method_t *findMethodInSortedMethodList(SEL key, const method_list_t *list){ assert(list); const method_t * const first = &amp;list-&gt;first; const method_t *base = first; const method_t *probe; uintptr_t keyValue = (uintptr_t)key; uint32_t count; // &gt;&gt;1 表示将变量n的各个二进制位顺序右移1位，最高位补二进制0 // count &gt;&gt;= 1 如果count为偶数则值变为(count / 2)；如果count为奇数则值变为(count-1) / 2 for (count = list-&gt;count; count != 0; count &gt;&gt;= 1) { probe = base + (count &gt;&gt; 1); // 取出中间method_t的name，也就是SEL uintptr_t probeValue = (uintptr_t)probe-&gt;name; if (keyValue == probeValue) { // `probe` is a match. // Rewind looking for the *first* occurrence of this value. // This is required for correct category overrides. // 继续向前二分查询 while (probe &gt; first &amp;&amp; keyValue == (uintptr_t)probe[-1].name) { probe--; } // 取出 probe return (method_t *)probe; } // 如果keyValue &gt; probeValue 则折半向后查询 if (keyValue &gt; probeValue) { base = probe + 1; count--; } } return nil;} log_and_fill_cache-&gt;cache_fill-&gt;cache_fill_nolock进行缓存 12345678910111213log_and_fill_cache(Class cls, IMP imp, SEL sel, id receiver, Class implementer){#if SUPPORT_MESSAGE_LOGGING if (objcMsgLogEnabled) { bool cacheIt = logMessageSend(implementer-&gt;isMetaClass(), cls-&gt;nameForLogging(), implementer-&gt;nameForLogging(), sel); if (!cacheIt) return; }#endif cache_fill (cls, sel, imp, receiver);} resolveMethod动态方法解析——在找不到imp时的自我拯救操作 主要逻辑是是objc_msgSend函数发送SEL_resolveInstanceMethod消息，系统调用resolveInstanceMethod 发送消息后，系统会再查找一下sel方法 123456789101112131415161718void _class_resolveMethod(Class cls, SEL sel, id inst){ if (! cls-&gt;isMetaClass()) { // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); } else { // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { _class_resolveInstanceMethod(cls, sel, inst); } }} _objc_msgForward_impcache在汇编中调用了_objc_msgForward，然后又进入_objc_forward_handler，它在c++调用了objc_defaultForwardHandler 123456789void *_objc_forward_handler = (void*)objc_defaultForwardHandler;objc_defaultForwardHandler(id self, SEL sel){ _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);} 原来unrecognized selector sent to instance xxx是这么来的啊… 慢速查找的过程简要总结: 慢速查找完整流程图： 四、总结来到这里，已经把消息的查找介绍完毕，是时候总结一下了。 4.1方法调用的本质 方法的调用会被编译器翻译成objc_msgSend、objc_msgSendSuper、objc_msgSend_stret和objc_msgSendSuper_stret这四个函数之一，这四个函数都是由汇编代码实现的。 如果是以数据结构体作为返回值的方法，最终会转换成相应的objc_msgSend_stret或objc_msgSendSuper_stret函数 使用super关键字调用方法时，是使用objc_msgSendSuper发送的 其他的方法调用是使用objc_msgSend函数发送消息的。 方法的调用是通过objc_msgSend（或objc_msgSendSuper，或objc_msgSend_stret，或objc_msgSendSuper_stret）函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 4.2方法的查找方法的查找流程如下： 1.从objc_msgSend源码开始，会先去 类（实例方法）/元类（类方法） 的缓存中查找，如果找到IMP则返回并调用，否则会去 类/元类 的方法列表中查找 2.“步骤1”中的“缓存+方法列表”的查找方案，会遍历类的继承体系（类、类的父类、…、根类），分别进行查找，直至找到IMP为止。 如果在当前类的缓存中没找到，但是在其方法列表（或其“父类…根类”的缓存或方法列表）中找到了IMP，需要进行一次是否是消息转发的判断，如果不是消息转发，那么就对当前类的缓存进行填充操作，方便下次调用时的查找；如果是消息转发，则不会缓存到当前类中 3.如果遍历结束后依然未找到IMP，则会启动消息的解析或转发。 五、问题讨论5.1objc_msgSend为什么要用汇编编写？A：原因大致有以下几点 C语言是静态语言，无法实现参数个数、类型未知的情况下跳转到另一个任意的函数实现的功能；而汇编的寄存器可以做到这一点 汇编执行效率比C语言的高 使用汇编可以有效防止系统函数被hook，因此更为安全。 5.2为什么索引值要左移1 + PTRSHIFT位？A：在objc4-756.2源码中找到答案，但是在objc4-779.1源码版本的cache_t结构中，存在关于这个问题的解释。其部分源码如下： 12345678910111213// How much the mask is shifted by.static constexpr uintptr_t maskShift = 48; // Additional bits after the mask which must be zero. msgSend// takes advantage of these additional bits to construct the value// `mask &lt;&lt; 4` from `_maskAndBuckets` in a single instruction.static constexpr uintptr_t maskZeroBits = 4; // The largest mask value we can store.static constexpr uintptr_t maxMask = ((uintptr_t)1 &lt;&lt; (64 - maskShift)) - 1; // The mask applied to `_maskAndBuckets` to retrieve the buckets pointer.static constexpr uintptr_t bucketsMask = ((uintptr_t)1 &lt;&lt; (maskShift - maskZeroBits)) - 1; 总的来说，在64位中，mask的偏移值为48，也就是最高的16位存储mask；接着的44位是buckets指针地址，最低的4位是附加位，即 buckets的有效指针地址仅仅是64位中的[4, 47]位。在CacheLookup源码中，由_cmd &amp; mask哈希运算可以得到索引值（索引值 &lt; ((1 &lt;&lt; 16) - 1)），如果想得到这个位置的bucket，其索引值必须左移4位后，才能与buckets指针地址相加得到正确的bucket地址。 参考 Objective-C 中的消息与消息转发 Objective-C底层汇总 https://juejin.cn/post/6844904118973104135#heading-0 OC源码分析之方法的查找原理 消息查找流程 iOS探索 方法的本质和消息查找流程","link":"/2020/12/29/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/05-%20%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%92%8C%E6%B6%88%E6%81%AF%E6%9F%A5%E6%89%BE%E6%B5%81%E7%A8%8B/"},{"title":"06-动态方法解析和消息转发机制","text":"前言OC中方法的调用是通过objc_msgSend（或objc_msgSendSuper，或objc_msgSend_stret，或objc_msgSendSuper_stret）函数，向调用者发送名为SEL的消息，找到具体的函数地址IMP，进而执行该函数。 找IMP时先快速查找，然后慢速查找。如果慢速查找后找不到IMP，会进行方法的解析，这相当于提供一次容错处理；方法解析之后，如果依然找不到IMP，还有最后一次机会，那就是消息的转发。 我用的源码是 objc4-756.2 一、消息查找流程消息查找流程部分不再展开详述，消息慢速查找主要经过以下流程： 先查找本类缓存，再找本类方法列表 遍历父类：查找父类缓存，再找父类方法列表 遍历父类无果后就来到动态方法解析。 二、动态方法解析动态方法解析，即method resolver（又名消息的解析，也叫方法决议），方法查找失败之后就会进行，源码如下： 12345678910// 在【类...根类】的【缓存+方法列表】中都没找到IMP，进行方法解析if (resolver &amp;&amp; !triedResolver) { runtimeLock.unlock(); resolveMethod(cls, sel, inst); // ✅ runtimeLock.lock(); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry;} 它主要是调用了resolveMethod函数。resolveMethod函数处理完毕之后，还要重新执行一次retry（再走一遍方法的查找流程）。其中，triedResolver这个变量使得消息的解析只进行一次。 2.1 resolveMethod 入口源码： 1234567891011121314151617181920212223static void resolveMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 判断当前是否是元类 if (! cls-&gt;isMetaClass()) { // 类，尝试找实例方法 // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); } else { // 是元类，先找类方法 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { resolveInstanceMethod(cls, sel, inst); } }} 这里有两个分支： 非元类的话说明是类，调用实例方法，走_class_resolveInstanceMethod cls是元类的话说明调用类方法，走_class_resolveClassMethod 2.2 实例方法解析resolveInstanceMethod源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void resolveInstanceMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 去 cls 找是否实现了 resolveInstanceMethod 方法 // 如果没有实现，则直接返回，就不会给 cls 发送 resolveInstanceMethod 消息，就不会报找不到 resolveInstanceMethod if (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. // NSObject中默认有实现，所以一般不会走这里。 return; } // 本类实现了类方法 resolveInstanceMethod // 当对象找不到需要调用的方法时，系统就会主动响应 resolveInstanceMethod 方法，可以在 resolveInstanceMethod 进行自定义处理 // 向本类发送SEL_resolveInstanceMethod消息，即调用这个方法 BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; bool resolved = msg(cls, SEL_resolveInstanceMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveInstanceMethod adds to self a.k.a. cls // 再次去查找方法，找到就缓存并且返回，找不到就直接返回 IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); // 一些报错信息代码 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveInstanceMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 流程分析： ①调用lookUpImpOrNil方法检查cls中是否有SEL_resolveInstanceMethod(resolveInstanceMethod)方法。NSObject类中有实现这个类方法，所以一般会接着往下走。 lookUpImpOrNil函数源码： 1234567IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;} NSObject类中实现了resolveInstanceMethod方法： 12345678// 具体搜索 NSObject.mm+ (BOOL)resolveClassMethod:(SEL)sel { return NO;}+ (BOOL)resolveInstanceMethod:(SEL)sel { return NO;} ②向本类发送SEL_resolveInstanceMethod消息，即调用这个方法。resolveInstanceMethod 是系统给我们的一次机会，让我们可以针对没有实现的 sel 进行自定义操作。 ③lookUpImpOrNil再次查找当前实例方法IMP，找到就缓存并返回，找不到就直接返回。 假如你在+(BOOL)resolveInstanceMethod:(SEL)sel中添加了sel的函数地址IMP，此时再次去查找这个IMP就能找到。 注意到两次调用lookUpImpOrNil中，resolver都是NO，因此在其调用lookUpImpOrForward时不会触发 动态方法解析，仅仅是从“类、父类、…、根类”的缓存中和方法列表中找IMP。 ④结束动态方法解析，回到lookUpImpOrForward方法将triedResolver置YES并goto retry重新查找缓存和方法列表 实例方法解析流程图： 2.3 类方法解析resolveClassMethod 和 resolveInstanceMethod 逻辑差不多，只不过类方法是去元类里处理，源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 这里的cls是元类，因为类方法存储在元类static void resolveClassMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); assert(cls-&gt;isMetaClass()); if (! lookUpImpOrNil(cls, SEL_resolveClassMethod, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // Resolver not implemented. // 如果你没有实现类方法 +(BOOL)resolveClassMethod:(SEL)sel， // NSObject中也有实现，所以一般不会走这里 // 注意这里的第一个参数是cls，是元类 return; } Class nonmeta; { mutex_locker_t lock(runtimeLock); // 获取 元类的对象，即类。 nonmeta = getMaybeUnrealizedNonMetaClass(cls, inst); // +initialize path should have realized nonmeta already if (!nonmeta-&gt;isRealized()) { _objc_fatal(&quot;nonmeta class %s (%p) unexpectedly not realized&quot;, nonmeta-&gt;nameForLogging(), nonmeta); } } BOOL (*msg)(Class, SEL, SEL) = (typeof(msg))objc_msgSend; // 调用类方法： +(BOOL)resolveClassMethod:(SEL)sel bool resolved = msg(nonmeta, SEL_resolveClassMethod, sel); // Cache the result (good or bad) so the resolver doesn't fire next time. // +resolveClassMethod adds to self-&gt;ISA() a.k.a. cls // 再找一次imp IMP imp = lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/); // 一些打印 if (resolved &amp;&amp; PrintResolving) { if (imp) { _objc_inform(&quot;RESOLVE: method %c[%s %s] &quot; &quot;dynamically resolved to %p&quot;, cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel), imp); } else { // Method resolver didn't add anything? _objc_inform(&quot;RESOLVE: +[%s resolveClassMethod:%s] returned YES&quot; &quot;, but no new implementation of %c[%s %s] was found&quot;, cls-&gt;nameForLogging(), sel_getName(sel), cls-&gt;isMetaClass() ? '+' : '-', cls-&gt;nameForLogging(), sel_getName(sel)); } }} 流程如下： ①lookUpImpOrNil查找SEL_resolveClassMethod(resolveClassMethod)是否实现 ②调用类方法： +(BOOL)resolveClassMethod:(SEL)sel ③lookUpImpOrNil再次查找当前实例方法imp，找到就填充缓存并返回，找不到就直接返回 ④结束resolveClassMethod，返回到resolveMethod方法。此时lookUpImpOrNil再次查找sel的imp，若有imp则退出动态方法解析，若无则进入_class_resolveInstanceMethod开始实例方法解析，跟之前的流程一样。 ⑤ 检查cls中是否有SEL_resolveInstanceMethod(resolveInstanceMethod)方法 ⑥向本类发送SEL_resolveInstanceMethod消息 ⑦lookUpImpOrNil再次查找当前实例方法IMP，找到就缓存并返回，找不到就直接返回。 ⑧结束动态方法解析，回到lookUpImpOrForward方法将triedResolver置否并goto retry重新查找缓存和方法列表 类方法解析流程图： 2.4 动态方法决议resolveMethod中进行类方法解析之后还要在进行一次实例方法解析，这是为什么呢？ 123456789101112131415161718192021222324static void resolveMethod(Class cls, SEL sel, id inst){ runtimeLock.assertUnlocked(); assert(cls-&gt;isRealized()); // 判断当前是否是元类 if (! cls-&gt;isMetaClass()) { // 类，尝试找实例方法 // try [cls resolveInstanceMethod:sel] resolveInstanceMethod(cls, sel, inst); } else { // 是元类，先找类方法 // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) { // ✅为什么这里还要查找一次呢？ resolveInstanceMethod(cls, sel, inst); } }} 既然上面的对象方法决议和类方法解析都会走 _class_resolveInstanceMethod，而最终都会找到父类 NSObject里面去，那我们不就可以在 NSObject 分类里面重写 resolveInstanceMethod 方法，在这个方法里面对没有实现的方法(不管是类方法还是对象方法)进行动态添加 imp，然后就可以进行自定义处理，比如弹个框说网络不佳，或者做bug收集等。 这其实就是Objective-C提供了一种名为动态方法决议的手段，使得我们可以在运行时动态地为一个selector 提供实现。 举个例子看看： 12345678910@interface Person : NSObject+ (void)personClassMethod1;- (void)personInstanceMethod1;@end@implementation Person@end 一个简单的Person类，里面分别有一个类方法和一个实例方法，但是都没有实现。 接着添加对这两个方法的解析： 12345678910111213141516171819202122232425- (void)unimplementedMethod:(SEL)sel { NSLog(@&quot;没实现？没关系，绝不崩溃&quot;);}+ (BOOL)resolveInstanceMethod:(SEL)sel { NSLog(@&quot;动态实例方法解析：%@&quot;, NSStringFromSelector(sel)); if (sel == @selector(personInstanceMethod1)) { IMP methodIMP = class_getMethodImplementation(self, @selector(unimplementedMethod:)); Method method = class_getInstanceMethod(Person.class, @selector(unimplementedMethod:)); const char *methodType = method_getTypeEncoding(method); return class_addMethod(Person.class, sel, methodIMP, methodType); } return [super resolveInstanceMethod:sel];}+ (BOOL)resolveClassMethod:(SEL)sel { NSLog(@&quot;动态类方法解析：%@&quot;, NSStringFromSelector(sel)); if (sel == @selector(personClassMethod1)) { IMP methodIMP = class_getMethodImplementation(self, @selector(unimplementedMethod:)); Method method = class_getInstanceMethod(Person.class, @selector(unimplementedMethod:)); const char *methodType = method_getTypeEncoding(method); return class_addMethod(objc_getMetaClass(&quot;Person&quot;), sel, methodIMP, methodType); } return [super resolveClassMethod:sel];} 调用并打印： 动态方法决议总结： 实例方法可以重写resolveInstanceMethod添加imp 类方法可以在本类重写resolveClassMethod往元类添加imp，或者在NSObject分类重写resolveInstanceMethod添加imp 动态方法解析只要在任意一步lookUpImpOrNil查找到imp就不会查找下去——即本类做了动态方法决议，不会走到NSObjct分类的动态方法决议 所有方法都可以通过在NSObject分类重写resolveInstanceMethod添加imp解决崩溃 那么把所有崩溃都在NSObjct分类中处理，加以前缀区分业务逻辑，岂不是美滋滋？错！ 统一处理起来耦合度高 逻辑判断多 可能在NSObjct分类动态方法决议之前已经做了处理 SDK封装的时候需要给一个容错空间 这也不行，那也不行，那该怎么办？放心，苹果已经给我们准备好后路了！ 三、消息转发方法的调用经过了查找、解析，如果还是没有找到IMP，就会来到消息转发流程。它的入口在lookUpImpOrForward函数靠后的位置： 12345// No implementation found, and method resolver didn't help. // Use forwarding.// 开始消息转发imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst); 继续跟进，来到objc-msg-arm64.s文件中： __objc_msgForward_impcache方法中调用__objc_msgForward，最后会来到c++中_objc_forward_handler： 123456789void *_objc_forward_handler = (void*)objc_defaultForwardHandler;objc_defaultForwardHandler(id self, SEL sel){ _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);} 当我们调用一个没实现的方法时，报的错就是unrecognized selector sent to ... 但是到这里并没有结束，我们创造一个崩溃，然后看打印信息： 崩溃之前底层还调用了___forwarding___和_CF_forwarding_prep_0等方法，但是CoreFoundation库不开源，在无从下手之际，只能根据前辈们的经验开始着手——然后在logMessageSend方法中找到了探索方向(lookUpImpOrForward-&gt;log_and_fill_cache-&gt;logMessageSend) 通过logMessageSend方法我们可以看到，日志会记录在/tmp/msgSends目录下，并且通过objcMsgLogEnabled变量来控制是否存储日志： 123456789101112131415161718192021222324252627282930313233343536bool logMessageSend(bool isClassMethod, const char *objectsClass, const char *implementingClass, SEL selector){ char buf[ 1024 ]; // Create/open the log file if (objcMsgLogFD == (-1)) { // 日志会记录在/tmp/msgSends目录下 snprintf (buf, sizeof(buf), &quot;/tmp/msgSends-%d&quot;, (int) getpid ()); objcMsgLogFD = secure_open (buf, O_WRONLY | O_CREAT, geteuid()); if (objcMsgLogFD &lt; 0) { // no log file - disable logging // 通过objcMsgLogEnabled变量来控制是否存储日志 objcMsgLogEnabled = false; objcMsgLogFD = -1; return true; } } // Make the log entry snprintf(buf, sizeof(buf), &quot;%c %s %s %s\\n&quot;, isClassMethod ? '+' : '-', objectsClass, implementingClass, sel_getName(selector)); objcMsgLogLock.lock(); write (objcMsgLogFD, buf, strlen(buf)); objcMsgLogLock.unlock(); // Tell caller to not cache the method return false;} 紧接着他下面的instrumentObjcMessageSends方法可以改变objcMsgLogEnabled的值： 123456789101112131415161718void instrumentObjcMessageSends(BOOL flag){ bool enable = flag; // Shortcut NOP if (objcMsgLogEnabled == enable) return; // If enabling, flush all method caches so we get some traces if (enable) _objc_flush_caches(Nil); // Sync our log file if (objcMsgLogFD != -1) fsync (objcMsgLogFD); objcMsgLogEnabled = enable;} 所以，虽然我们到这里就不能查看CoreFoundation库的源代码了，但是我们可以根据以下代码来记录并查看崩溃日志（仿佛不能在源码工程中操作）： 1234567891011extern void instrumentObjcMessageSends(BOOL flag);int main(int argc, const char * argv[]) { @autoreleasepool { FXSon *son = [[FXSon alloc] init]; instrumentObjcMessageSends(true); [son doInstanceNoImplementation]; // 调用一个声明了但是没实现的方法 instrumentObjcMessageSends(false); }} 崩溃后，在访达中command+shift+G前往/tmp/msgSends，找到最新的一份日志文件（数字最大）： 打开查看后发现，在动态方法解析和doesNotRecognizeSelector崩溃之间，就是消息转发流程，分为： 快速转发forwardingTargetForSelector 慢速转发methodSignatureForSelector 3.1 消息的快速转发forwardingTargetForSelector:对应的就是消息的快速转发流程，它在源码中只是简单的返回nil（可在子类或分类中重写） 1234567+ (id)forwardingTargetForSelector:(SEL)sel { return nil;}- (id)forwardingTargetForSelector:(SEL)sel { return nil;} 不过我们可以在开发文档中找到说明（cmd + shift + 0） 概括地说，forwardingTargetForSelector:主要是返回一个新的receiver，去处理sel这个当前类无法处理的消息，如果处理不了，会转到效率低下的forwardInvocation:。 在效率方面，forwardingTargetForSelector:领先forwardInvocation:一个数量级，因此，最好不要用后者的方式处理消息的转发逻辑。 关于forwardingTargetForSelector:返回的新的receiver，需要注意一下几点： 绝对不能返回self，否则会陷入无限循环； 不处理的话，可以返回nil，或者[super forwardingTargetForSelector:sel]（非根类的情况），此时会走methodSignatureForSelector:慢速转发流程； 如果有这个receiver，此时相当于执行objc_msgSend(newReceiver, sel, ...)，那么它必须拥有和被调用的方法相同方法签名的方法（方法名、参数列表、返回值类型都必须一致）。 举例说明： Person类中： 1234567891011121314151617181920@interface Person : NSObject+ (void)personClassMethod1;- (void)personInstanceMethod1;@end@implementation Person- (id)forwardingTargetForSelector:(SEL)aSelector { NSLog(@&quot;实例方法开始转发&quot;); return [ForwardObject alloc];}+ (id)forwardingTargetForSelector:(SEL)sel { NSLog(@&quot;类方法开始转发&quot;); return [ForwardObject class];}@end ForwardObject类中： 123456789101112131415@interface ForwardObject : NSObject@end@implementation ForwardObject+ (void)personClassMethod1 { NSLog(@&quot;类方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}- (void)personInstanceMethod1 { NSLog(@&quot;实例方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}@end 显然，ForwardObject作为消息转发后的处理类，拥有Person类的同名类方法和实例方法。现在开始验证，结果如下： 事实证明确实有效！接下来看消息的慢速转发流程。 3.2 消息的慢速转发如果forwardingTargetForSelector:没有处理消息（如返回nil），就会启动慢速转发流程，也就是methodSignatureForSelector:方法，同样需要在子类或分类中重写 1234567891011// Replaced by CF (returns an NSMethodSignature)+ (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { _objc_fatal(&quot;+[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);}// Replaced by CF (returns an NSMethodSignature)- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { _objc_fatal(&quot;-[NSObject methodSignatureForSelector:] &quot; &quot;not available without CoreFoundation&quot;);} 通过阅读官方文档，我们得出以下结论： methodSignatureForSelector:方法是跟forwardInvocation:方法搭配使用的，前者需要我们根据sel返回一个方法签名，后者会把这个方法签名封装成一个NSInvocation对象，并将其作为形参。 如果有目标对象能处理Invocation中的sel，Invocation可以指派这个对象处理；否则不处理。 Invocation可以指派多个对象处理 注意：消息的慢速转发流程性能较低，如果可以的话，你应该尽可能早地处理掉消息（如在方法解析时，或在消息的快速转发流程时，除非有特殊需求）。 举例说明: 这里把快速转发例子中的Person类修改一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation Person// MARK: 慢速转发--类方法+ (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSLog(@&quot;类方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); if (aSelector == @selector(personClassMethod1)) { return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; } return [super methodSignatureForSelector:aSelector];}+ (void)forwardInvocation:(NSInvocation *)anInvocation { SEL aSelector = [anInvocation selector]; NSLog(@&quot;类方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); id target = [ForwardObject class]; if ([target respondsToSelector:aSelector]) { [anInvocation invokeWithTarget:target]; } { else [super forwardInvocation:anInvocation]; }}// MARK: 慢速转发--实例方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector { NSLog(@&quot;实例方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); if (aSelector == @selector(personInstanceMethod1)) { return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; } return [super methodSignatureForSelector:aSelector];}- (void)forwardInvocation:(NSInvocation *)anInvocation { SEL aSelector = [anInvocation selector]; NSLog(@&quot;实例方法慢速转发：%s, sel：%@&quot;, __FUNCTION__, NSStringFromSelector(aSelector)); ForwardObject *obj = [ForwardObject alloc]; if ([obj respondsToSelector:aSelector]) { [anInvocation invokeWithTarget:obj]; } else { [super forwardInvocation:anInvocation]; } }@end ForwardObject类中： 123456789101112131415@interface ForwardObject : NSObject@end@implementation ForwardObject+ (void)personClassMethod1 { NSLog(@&quot;类方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}- (void)personInstanceMethod1 { NSLog(@&quot;实例方法转发给%@，执行%s&quot;, [self className], __FUNCTION__);}@end 其结果如下图所示，显然也没有崩溃: 对方法签名类型编码不熟悉的可以查看 苹果官方的类型编码介绍 3.3 消息转发的应用 - NSProxy3.3.1 模拟实现多继承【学习使用】TestProxy继承自NSProxy，TestProxy.h文件： 123456789101112#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface TestProxy : NSProxy- (instancetype)initWithObject:(id)object;- (void)transformToObject:(id)object;@endNS_ASSUME_NONNULL_END TestProxy.m： 1234567891011121314151617181920212223242526272829303132333435363738#import &quot;TestProxy.h&quot;@interface TestProxy ()// 为这个对象转发消息@property (nonatomic, weak) id object;@end@implementation TestProxy- (instancetype)initWithObject:(id)object { self.object = object; return self;}- (void)transformToObject:(id)object { self.object = object;}// 重写-methodSignatureForSelector:方法获得方法签名- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { if (self.object &amp;&amp; [self.object respondsToSelector:sel]) { return [self.object methodSignatureForSelector:sel]; } return [super methodSignatureForSelector:sel];}// 重写-forwardInvocation:为调用设置目标- (void)forwardInvocation:(NSInvocation *)invocation { SEL sel = [invocation selector]; if (self.object &amp;&amp; [self.object respondsToSelector:sel]) { [invocation invokeWithTarget:self.object]; } else { [super forwardInvocation:invocation]; }}@end ClassA类中有funcA方法，ClassB类中有funcB方法： 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ClassA : NSObject- (void)funcA;@endNS_ASSUME_NONNULL_END #import &quot;ClassA.h&quot;@implementation ClassA- (void)funcA { NSLog(@&quot;调用了funcA*************&quot;);}@end 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ClassB : NSObject- (void)funcB;@endNS_ASSUME_NONNULL_END #import &quot;ClassB.h&quot;@implementation ClassB- (void)funcB { NSLog(@&quot;调用了funcB*************&quot;);}@end 使用一下： 123456789101112131415- (void)test2 { // 变为clsA的代理，即proxy把消息转发给了clsA ClassA *clsA = [ClassA new];// TestProxy *proxy = [[TestProxy alloc] initWithObject:clsA];// [proxy performSelector:@selector(funcA)]; // 变为clsB的代理，即proxy1把消息转发给了clsB ClassB *clsB = [ClassB new]; TestProxy *proxy1 = [[TestProxy alloc] initWithObject:clsB]; [proxy1 performSelector:@selector(funcB)]; // 又把消息转发给了clsA [proxy1 transformToObject:clsA]; [proxy1 performSelector:@selector(funcA)];} 打印： 122021-01-04 17:51:33.533056+0800 Demo[62114:6062041] 调用了funcB*************2021-01-04 17:51:33.533094+0800 Demo[62114:6062041] 调用了funcA************* 结果： 就是proxy1这个对象既能调用ClassA中的方法，又能调用ClassB中的方法，看起来就像是继承自这两个类一样。 但实际上proxy1只是消息转发的中间站，实际上还是ClassA和ClassB的实例去调用各自的方法。 3.3.2 拦截方法的调用，从中实现一些我们自己需要的功能比如埋点SDK中需要实现的UITableView点击事件全埋点，就可以把NSProxy类作为UITableView的中间代理，以实现在中间拦截代理方法并在其中添加埋点事件的功能。 这里我们使用慢速消息转发，原因是苹果在官方文档中写道： 12DiscussionThis method is used in the implementation of protocols. This method is also used in situations where an NSInvocation object must be created, such as during message forwarding. If your object maintains a delegate or is capable of handling messages that it does not directly implement, you should override this method to return an appropriate method signature. 1该方法用于协议的实现。在必须创建NSInvocation对象的情况下，例如在消息转发期间，也可以使用此方法。如果对象管理代理或能够处理它没有直接实现的消息，则应重写此方法以返回适当的方法签名。 我们在这里需要管理代理，所以使用慢速消息转发。 步骤： 1.自定一个XWTrackingAnalyticsDelegateProxy类，继承自NSProxy，并在其中进行拦截和消息转发。 XWTrackingAnalyticsDelegateProxy.h： 1234567891011#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface XWTrackingAnalyticsDelegateProxy : NSProxy &lt;UITableViewDelegate&gt;+ (instancetype)proxyWithTableViewDelegate:(id&lt;UITableViewDelegate&gt;)delegate;@endNS_ASSUME_NONNULL_END XWTrackingAnalyticsDelegateProxy.m： 12345678910111213141516171819202122232425262728293031323334353637383940#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;#import &quot;XWTrackingAnalysisSDK.h&quot;@interface XWTrackingAnalyticsDelegateProxy ()@property (nonatomic, weak) id delegate;@end@implementation XWTrackingAnalyticsDelegateProxy+ (instancetype)proxyWithTableViewDelegate:(id&lt;UITableViewDelegate&gt;)delegate { XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy alloc]; proxy.delegate = delegate; return proxy;}- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { // 返回 delegate 对象中对应的方法签名 return [(NSObject *)self.delegate methodSignatureForSelector:sel];}- (void)forwardInvocation:(NSInvocation *)invocation { // 先执行 delegate 对象中的方法 [invocation invokeWithTarget:self.delegate]; // 判断是否是 cell 的点击事件的代理方法 if (invocation.selector == @selector(tableView:didSelectRowAtIndexPath:)) { // 将方法修改为进行数据采集的方法 invocation.selector = NSSelectorFromString(@&quot;xwtracking_tableView:didSelectRowAtIndexPath:&quot;); // 执行数据采集相关的方法 [invocation invokeWithTarget:self]; }}- (void)xwtracking_tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath { // 数据采集相关 [XWTrackingAnalysisSDK.shareInstance trackAppClickWithTableView:tableView didSelectRowAtIndexPath:indexPath properties:nil];}@end 2.使用方法交换把代理设置为proxy UITableView+XWTracking.m： 123456789101112131415161718192021222324252627282930313233343536#import &quot;UITableView+XWTracking.h&quot;#import &quot;NSObject+XWSwizzler.h&quot;#import &lt;objc/message.h&gt;#import &quot;XWTrackingAnalysisSDK.h&quot;#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;#import &quot;UIScrollView+XWTracking.h&quot;@implementation UITableView (XWTracking)+ (void)load { [UITableView xwtracking_swizzleMethod:@selector(setDelegate:) withMethod:@selector(xwtracking_setDelegate:)];}- (void)xwtracking_setDelegate:(id&lt;UITableViewDelegate&gt;)delegate {// [self xwtracking_setDelegate:delegate]; // // 方案一：交换方法// // 交换 delegate 中的 tableView:didSelectRowAtIndexPath: 方法// [self xwtracking_swizzleDidSelectRowAtIndexPathMethodWithDelegate:delegate]; // 方案三：NSProxy 消息转发 // 销毁保存的委托对象 self.xwtracking_delegateProxy = nil; if (delegate) { XWTrackingAnalyticsDelegateProxy *proxy = [XWTrackingAnalyticsDelegateProxy proxyWithTableViewDelegate:delegate]; // 保存委托对象 self.xwtracking_delegateProxy = proxy; // 调用原始方法，将代理设置为委托对象 [self xwtracking_setDelegate:proxy]; } else { // 调用原始方法，将代理设置为nil [self xwtracking_setDelegate:nil]; }}... 3.为了解决proxy这个局部变量出代码块被释放，然后proxy这个中间代理不存在的情况下还去调用代理方法时的崩溃，需要加一个对这个委托对象加一个强引用。 为了可以同时支持UICollectionView控件，直接在UIScrollView中扩展xwtracking_delegateProxy这个属性： UIScrollView+XWTracking.h： 12345678#import &lt;UIKit/UIKit.h&gt;#import &quot;XWTrackingAnalyticsDelegateProxy.h&quot;@interface UIScrollView (XWTracking)@property (nonatomic, strong) XWTrackingAnalyticsDelegateProxy *xwtracking_delegateProxy;@end UIScrollView+XWTracking.m： 1234567891011121314#import &quot;UIScrollView+XWTracking.h&quot;#include &lt;objc/runtime.h&gt;@implementation UIScrollView (XWTracking)- (void)setXwtracking_delegateProxy:(XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy { objc_setAssociatedObject(self, @selector(setXwtracking_delegateProxy:), xwtracking_delegateProxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (XWTrackingAnalyticsDelegateProxy *)xwtracking_delegateProxy { return objc_getAssociatedObject(self, @selector(xwtracking_delegateProxy));}@end 至此就已经能够拦截到tableView:didSelectRowAtIndexPath:方法并且在其中埋点了。 原理图： 四、总结综上所述，当我们调用方法时： ①首先进行方法的查找 ②如果查找失败，会进行动态方法解析，此时OC会给我们一次对sel的处理机会，你可以在resolveInstanceMethod:（类方法对应resolveClassMethod:）中添加一个IMP ③如果你没把握住这次机会，也就是解析失败时，会来到消息转发阶段，这个阶段有两个机会去处理sel，分别是快速转发的forwardingTargetForSelector:，以及慢速转发的methodSignatureForSelector:。 消息快速转发阶段forwardingTargedForSelector，如果有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。 消息慢速转发阶段methodSignatureForSelector，进行方法签名，把方法丢出去，forwardInvocation来对消息处理。 ④当然，如果这些机会你都放弃了，那OC只好让程序崩溃，就进入到了doesNotRecognizeSelector报错。 下面用一副图总结方法的解析和转发流程： 五、问题讨论为什么引入消息转发机制？在一个方法被调用之前，我们是没办法确定它的实现地址的，直到运行时，这个方法被调用的时候，我们才能真正知道它是否有实现，以及其具体的实现地址。这也就是所谓的“动态绑定”。 在编译期，如果编译器发现方法不存在，会直接报错；同样，在运行时，也有doesNotRecognizeSelector的处理。 在抛出doesNotRecognizeSelector这个异常信息之前，OC利用其动态绑定的特性，引入了消息转发机制，给予了我们额外的机会处理消息（解析 or 转发），这样的做法显然更加周全合理。 参考OC源码分析之方法的解析与转发原理-红酒牛排 iOS探索 动态方法解析和消息转发机制-我是好宝宝 iOS 底层探索篇 —— 方法的转发流程-Eating iOS 带你走进消息转发流程及防崩溃处理-流年匆匆i 《iOS全埋点解决方案》","link":"/2021/01/03/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/06-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90%E5%92%8C%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"title":"07上-通用二进制文件和Mach-O文件","text":"前言要研究dyld的加载流程，首先要了解通用二进制文件和Mach-O文件。 一、通用二进制文件1.1 简介Universal Binary将多种架构的 Mach-O 文件合并而成。它通过 header 来记录不同架构在文件中的偏移量。系统在加载运行该程序时，会根据Universal Binary中提供的多个架构来与当前系统平台做匹配，运行适合当前系统的那个版本。 1.2 种类通用二进制的”通用”不止针对可以直接运行的可执行程序。包含以下几种： Mach-O Object 目标文件 .o Mach-O ececutable可执行文件 Mach-O dynamically 动态库文件 .a .dylib Framework Mach-O dynamic linker 动态链接器文件 dyld Mach-O dSYM companion 符号表文件.dsym，等 插一句，有动态库就有静态库，那么它们的区别是什么？看图： 静态库： 动态库： 通过上面两幅图我们可以知道： 静态库表现为：在链接阶段会将汇编生成的目标文件与引用的库一起链接打包进可执行文件中。 动态库表现为：程序编译并不会链接到目标代码中，在程序可执行文件里面会保留对动态库的引用。其中，动态库分为动态链接库和动态加载库。 动态链接库：在没有被加载到内存的前提下，当可执行文件被加载，动态库也随着被加载到内存中。在 Linked Framework and Libraries 设置的一些 share libraries。【随着程序启动而启动】 动态加载库：当需要的时候再使用 dlopen 等通过代码或者命令的方式来加载。【在程序启动之后，用到再去启动】 1.3 操作通用二进制文件1.3.1 查看苹果自家系统中存在着很多通用二进制文件。比如/usr/bin/python，在终端中执行file命令可以查看它的信息： 1234$ file /usr/bin/python/usr/bin/python: Mach-O universal binary with 2 architectures/usr/bin/python (for architecture x86_64): Mach-O 64-bit executable x86_64/usr/bin/python (for architecture i386): Mach-O executable i386 1.3.2 提取系统提供了一个命令行工具lipo来操作通用二进制文件。可以添加、提取、删除以及替换通用二进制文件中特定架构的二进制版本。 例如提取python中x86_64版本的二进制文件可以执行： 1$ lipo /usr/bin/python -extract x86_64 -output ~/Desktop/python.x64 1.3.3 删除删除x86版本的二进制文件可以执行： 1$ lipo /usr/bin/python -remove i386 -output ~/Desktop/python.x64 1.3.4 瘦身或者直接瘦身为x86_64版本： 1$ lipo /usr/bin/python -thin x86_64 -output ~/Desktop/python.x64 1.4 源码分析下载** MachOView**，搜索fat.h，查看源码： 12345678910111213141516171819#include &lt;stdint.h&gt;#include &lt;mach/machine.h&gt;#include &lt;architecture/byte_order.h&gt;#define FAT_MAGIC 0xcafebabe#define FAT_CIGAM 0xbebafeca /* NXSwapLong(FAT_MAGIC) */struct fat_header { uint32_t magic; /* FAT_MAGIC */ uint32_t nfat_arch; /* number of structs that follow */};struct fat_arch { cpu_type_t cputype; /* cpu specifier (int) */ cpu_subtype_t cpusubtype; /* machine specifier (int) */ uint32_t offset; /* file offset to this object file */ uint32_t size; /* size of this object file */ uint32_t align; /* alignment as a power of 2 */}; fat_header结构体中： magic字段就是我们常说的魔数（例如通常判断png文件格式，还有快速求平方根的[0x5f3759df），加载器通过这个魔数值来判断这是什么样的文件，胖二进制文件的魔数值是定值0xcafebabe nfat_arch字段是指当前的胖二进制文件包含了多少个不同架构的Mach-O文件。fat_header后会跟着一个或多个连续的fat_arch，有多少个不同架构的Mach-O文件，就有多少个fat_arch。 fat_arch结构体中： cputype指定了具体的cpu类型，它的类型是cpu_type_t，定义位于mach/machine.h中。cpu的常用类型主要有如下几种： 123456789101112#define CPU_TYPE_X86 ((cpu_type_t) 7)#define CPU_TYPE_I386 CPU_TYPE_X86 #define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)#define CPU_TYPE_MC98000 ((cpu_type_t) 10)#define CPU_TYPE_HPPA ((cpu_type_t) 11)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)#define CPU_TYPE_MC88000 ((cpu_type_t) 13)#define CPU_TYPE_SPARC ((cpu_type_t) 14)#define CPU_TYPE_I860 ((cpu_type_t) 15)#define CPU_TYPE_POWERPC ((cpu_type_t) 18)#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64 macOS平台上的CPU类型一般为CPU_TYPE_X86_64。 cpusubtype指定了cpu的子类型。它的类型是cpu_subtype_t。cpu子类型主要有如下几种： 1234567#define CPU_SUBTYPE_MASK 0xff000000#define CPU_SUBTYPE_LIB64 0x80000000#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_64_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_ARCH1 ((cpu_subtype_t)4)#define CPU_SUBTYPE_X86_64_H ((cpu_subtype_t)8)...... cpu子类型一般CPU_SUBTYPE_LIB64与CPU_SUBTYPE_X86_64_ALL比较常见。 offset字段指明了当前cpu架构数据相对于当前文件开头的偏移值。 size字段指明了数据的大小。 align字段指明了数据的内存对齐边界，取值必须是2的次方，它确保了当前cpu架构的目标文件加载到内存中时，数据是经过内存优化对齐的。 可以使用otool工具打印本机安装的python程序的fat_header信息。如下： 123456789101112131415161718$ otool -f -V /usr/bin/pythonFat headersfat_magic FAT_MAGICnfat_arch 2architecture i386 cputype CPU_TYPE_I386 cpusubtype CPU_SUBTYPE_I386_ALL capabilities 0x0 offset 4096 size 29632 align 2^12 (4096)architecture x86_64 cputype CPU_TYPE_X86_64 cpusubtype CPU_SUBTYPE_X86_64_ALL capabilities CPU_SUBTYPE_LIB64 offset 36864 size 29872 align 2^12 (4096) 在fat_arch结构体往下就是具体的Mach-O文件格式了。 二、Mach-O文件2.1 简介Mach-O是Mach Object文件格式的缩写，是mac以及iOS上可执行文件的格式。 2.2 分类Mach-O 有三种文件类型: Executable、Dylib、Bundle。 Executable 类型 executable 是 app 的二进制主文件，同时也是 app extension 的二进制主文件 我们一般可以在 Xcode 项目中的 Products 文件夹中找到它： Dylib 类型 dylib 是动态库，在其他平台也叫 DSO 或者 DLL。 Bundle 类型 现阶段 Bundle 是一种特殊类型的 dylib，你是无法对其进行链接的。你所能做的是在 Runtime 运行时去通过 dlopen 来加载它，它可以在 macOS 上用于插件。 Image 和 Framework 镜像文件包含了上述的三种文件类型。有很多东西都叫做 Framework，但在本文中，Framework 指的是一个 dylib，它周围有一个特殊的目录结构来保存该 dylib 所需的文件。 2.3 结构 通过上图，可以看出Mach-O主要由以下三部分组成： Header 描述了Mach-O的cpu架构、文件类型以及加载命令等信息 Load commands 包含区域位置、符号表、动态符号表，加载Mach-O文件时使用这里的数据确定内存分布 Data 数据段segement，包含具体代码、常量、类、方法等，有多个segment，每个segment有0到多个section，每个段有一个虚拟地址映射到进程的地址空间 2.3.1 Header** MachOView**源码中搜索loader.h并查看： 12345678910111213141516171819struct mach_header { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */};struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */}; magic：魔数，确定是64位还是32位 cputype：cpu类型 cpusubtype：cpu子类型 filetype：Mach-O支持多种文件类型，使用filetype来标注具体文件类型 ncmds：加载命令的数量 sizeofcmds：命令区域（load commands）总的字节大小 flags：标识二进制文件所支持的功能，主要与系统的加载、链接有关 2.3.2 Load commandsHeader之后是load commands加载命令段，用于解析加载命令。 1234struct load_command { uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */}; cmd：命令类型，针对不同架构有不同的结构（32位、64位） cmdsize：命令所占字节大小（32位size必须为4字节的倍数，64位size必须为8字节的倍数）。 在文件中有两个结构体segment_command和segment_command_64针对不同架构的结构体，内部设置字段相同。以segment_command_64为例： 12345678910111213struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */}; cmd：加载命令类型 LC_SEGMENT：表示这好似一个段加载命令，需要将它加载到对应的进程空间上 LC_LOAD_DYLIB：这是一个需要动态加载的链接库，它使用dylib_command结构体表示 LC_MAIN：记录了可执行文件的主函数main()的位置，它使用entry_point_command结构体表示 LC_CODE_SIGNATURE：代码签名的加载命令，描述了Mach-O的代码签名信息，它属于链接信息，使用linkedit_data_command结构体表示 cmdsize：加载命令所占内存大小 segname：存放16字节大小的段名字，当前是__PAGEZERO。 vmaddr：段的虚拟内存起始地址 vmsize：段的虚拟内存大小 fileoff：段在文件中偏移量 filesize：段在文件大小 maxprot：段页面所需要的最高内存保护（4=r,2=w,1=x） initprot：段页面初始的内存保护 nsects：段中包含section的数量 flags：其他杂项标志位 看MachOView中的loadcommands： 以上为是应用程序所有加载命令，通过上面流程能够看到对系统库的加载顺序。对比项目中引入的库文件，顺序是一致的，如下图： 以上加载命令含义如下： LC_SEGMENT_64：将文件中的段映射到进程地址空间中 LC_DYLD_INFO_ONLY：动态链接相关信息 LC_SYMTAB：符号表信息，位置、偏移、数据个数，供dyld使用 LC_DYSYMTAB：动态符号表信息，供dyld使用 LC_LOAD_DYLINKER：链接器信息，记录使用那些链接器完成内核后序的加载工作 LC_UUID：Mach-O文件的唯一标识 LC_VERSION_MIN_MACOSX：支持最低操作系统版本 LC_SOURCE_VERSION：源代码的版本号 LC_MAIN：设置主线程的入口即栈大小 LC_LOAD_DYLIB：依赖库信息，dyld通过该命令去加载依赖库 LC_FUNCTION_STARTS：函数的起始地址表 LC_CODE_SIGNATURE：代码签名 2.3.3 DataData区域由Segment段和Section节组成： segment主要有__TEXT和__DATA组成 __text：是主程序代码 __stubs、__stub_helper：是动态链接的桩 __cstring：程序中c语言字符串 __const：常量 Section含义： Section64(__TEXT,__objc_methname)：OC类名 Section64(__DATA,__objc_classlist)：OC类列表 Section64(__DATA,__objc_protollist)：OC原型列表 Section64(__DATA,__objc_imageinfo)：OC镜像信息 Section64(__DATA,__objc_selfrefs)：OC类自引用 Section64(__DATA,__objc_superrefs)：OC类超类的引用 Section64(__DATA,__ivar)：OC类成员变量 等等，都是通过section来对OC中的具体类别做加载的。 segment段分32位和64位，字段相同，以64为例如下： 1234567891011121314struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */}; sectname：是__text ,就是主程序代码 segname：该section所属的segment名，第一个是__TEXT addr：当前section在内存中的起始位置 size：当前section所占内存大小 offset：当前section的文件偏移 align：字节大小对齐 reloff：重定位入口的文件偏移，0 nreloc：需要重定位的入口数量，0 flags：包含section的type和attributes reserved1、reserved2预留字段 参考Mach-O Mach-O可执行文件 iOS 底层探索 - 应用加载","link":"/2021/01/15/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8A-%E9%80%9A%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8CMach-O%E6%96%87%E4%BB%B6/"},{"title":"07下-dyld分析","text":"前言我们平时编写的程序的入口函数都是main.m文件里面的main函数，但是这就是App的生命起点了吗？ +load方法先于main函数执行，那么main函数之前都发生了哪些有趣的事呢？ 一、静态库与动态库1.编译过程在日常开发过程中，开发者会使用成千上万次的Command + B/R进行开发调试，但可能很少有人关注过这个过程中 Xcode帮我们做了哪些事情 事实上，这个过程分解为4个步骤，分别是预处理(Prepressing)、编译(Compilation)、汇编(Assembly)和链接(Linking)——摘自《程序员的自我修养– 链接、装载与库》 在以上4个步骤中，IDE主要做了以下几件事: **预编译**：处理代码中的# 开头的预编译指令。比如删除#define并展开宏定义，将#include包含的文件插入到该指令位置等 **编译**：对预编译处理过的文件进行词法分析、语法分析和语义分析，并进行源代码优化，然后生成汇编代码 **汇编**：通过汇编器将汇编代码转换为机器可以执行的指令，并生成目标文件.o文件 **链接**：将目标文件链接成可执行文件。这一过程中，链接器将不同的目标文件链接起来，因为不同的目标文件之间可能有相互引用的变量或调用的函数，如我们经常调用Foundation框架和UIKit框架中的方法和变量，但是这些框架跟我们的代码并不在一个目标文件中，这就需要链接器将它们与我们自己的代码链接起来 Foundation和UIKit这种可以共享代码、实现代码的复用统称为库——是可执行代码的二进制文件，可以被操作系统写入内存，它又分为静态库和动态库 2.静态库静态库是指链接时完整的拷贝到可执行文件，多次使用多次拷贝，造成冗余，使包变的更大 如.a、.lib都是静态库 3.动态库动态库是指链接时不复制，程序运行时由系统加在到内存中，供系统调用，系统只需加载一次，多次使用，共用节省内存。 如.dylib、.framework都是动态库 系统的framework是动态的，开发者创建的framework是静态的 那么链接器又是什么呢？它是怎么链接不同的目标文件的呢？ 二、dyld1.dyld简介dyld(dynamic link editor / dynamic loader)是苹果的动态链接器，负责程序的链接及加载工作，是苹果操作系统的重要组成部分，存在于MacOS系统的(/usr/lib/dyld)目录下。 在应用被编译打包成可执行文件格式的Mach-O文件之后 ，交由dyld负责链接，加载程序。 2.dyld_shared_cache由于不止一个程序需要使用UIKit系统动态库，所以不可能在每个程序加载时都去加载所有的系统动态库。 为了优化程序启动速度和利用动态库缓存，苹果从iOS3.1之后，将所有系统库（私有与公有）编译成一个大的缓存文件，这就是dyld_shared_cache，该缓存文件存在iOS系统下的/System/Library/Caches/com.apple.dyld/目录下 三、dyld加载流程新建空工程，写下load方法，并在main方法和load方法分别下断点 点击函数调用栈/使用LLVM——bt指令打印，都能看到最初的起点_dyld_start 接下来通过dyld源码(版本：dyld-635.2)展开分析_dyld_start： 1._dyld_start在源码中全局搜索_dyld_start，会发现它是由汇编实现的 在arm64中，_dyld_start调用了一个看不懂的方法 从注释中得出可能是dyldbootstrap::start方法（其实在“函数调用栈”那张图中汇编代码已经把这个方法暴露出来了） 2.dyldbootstrap::start全局搜索dyldbootstrap::start并没有任何有意义结果，那么只能根据经验来瞎蒙一下了——全局搜索空格start(“侥幸”得到了结果 其实dyldbootstrap::start是指dyldbootstrap这个命名空间作用域里的 start函数 1234567891011121314151617181920212223242526272829303132333435363738uintptr_t start(const struct macho_header* appsMachHeader, int argc, const char* argv[], intptr_t slide, const struct macho_header* dyldsMachHeader, uintptr_t* startGlue){ // if kernel had to slide dyld, we need to fix up load sensitive locations // we have to do this before using any global variables slide = slideOfMainExecutable(dyldsMachHeader); bool shouldRebase = slide != 0;#if __has_feature(ptrauth_calls) shouldRebase = true;#endif if ( shouldRebase ) { rebaseDyld(dyldsMachHeader, slide); } // allow dyld to use mach messaging mach_init(); // kernel sets up env pointer to be just past end of agv array const char** envp = &amp;argv[argc+1]; // kernel sets up apple pointer to be just past end of envp array const char** apple = envp; while(*apple != NULL) { ++apple; } ++apple; // set up random value for stack canary __guard_setup(apple);#if DYLD_INITIALIZER_SUPPORT // run all C++ initializers inside dyld runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);#endif // now that we are done bootstrapping dyld, call dyld's main uintptr_t appsSlide = slideOfMainExecutable(appsMachHeader); return dyld::_main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);} 在start()函数中主要做了一下几件事： 根据dyldsMachHeader计算出slide， 通过slide判定是否需要重定位；这里的slide是根据ASLR技术 计算出的一个随机值，使得程序每一次运行的偏移值都不一样，防止攻击者通过固定地址发起恶意攻击 mach_init()初始化（允许dyld使用mach消息传递） 栈溢出保护 计算appsMachHeader的偏移，调用dyld::_main()函数 3.dyld::_main()点击进入dyld::_main()函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514uintptr_t_main(const macho_header* mainExecutableMH, uintptr_t mainExecutableSlide, int argc, const char* argv[], const char* envp[], const char* apple[], uintptr_t* startGlue){ if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { launchTraceID = dyld3::kdebug_trace_dyld_duration_start(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, (uint64_t)mainExecutableMH, 0, 0); } // Grab the cdHash of the main executable from the environment uint8_t mainExecutableCDHashBuffer[20]; const uint8_t* mainExecutableCDHash = nullptr; // 获取主程序hash if ( hexToBytes(_simple_getenv(apple, &quot;executable_cdhash&quot;), 40, mainExecutableCDHashBuffer) ) mainExecutableCDHash = mainExecutableCDHashBuffer; // Trace dyld's load // 通知kernal内核dyld文件已加载 notifyKernelAboutImage((macho_header*)&amp;__dso_handle, _simple_getenv(apple, &quot;dyld_file&quot;));#if !TARGET_IPHONE_SIMULATOR // Trace the main executable's load // 通知kernal内核mach-o文件已加载 notifyKernelAboutImage(mainExecutableMH, _simple_getenv(apple, &quot;executable_file&quot;));#endif uintptr_t result = 0; // 保存传入的可执行文件的头部（是一个struct macho_header结构体），后面根据头部访问信息 sMainExecutableMachHeader = mainExecutableMH; sMainExecutableSlide = mainExecutableSlide;#if __MAC_OS_X_VERSION_MIN_REQUIRED // if this is host dyld, check to see if iOS simulator is being run const char* rootPath = _simple_getenv(envp, &quot;DYLD_ROOT_PATH&quot;); if ( (rootPath != NULL) ) { // look to see if simulator has its own dyld char simDyldPath[PATH_MAX]; strlcpy(simDyldPath, rootPath, PATH_MAX); strlcat(simDyldPath, &quot;/usr/lib/dyld_sim&quot;, PATH_MAX); int fd = my_open(simDyldPath, O_RDONLY, 0); if ( fd != -1 ) { const char* errMessage = useSimulatorDyld(fd, mainExecutableMH, simDyldPath, argc, argv, envp, apple, startGlue, &amp;result); if ( errMessage != NULL ) halt(errMessage); return result; } }#endif CRSetCrashLogMessage(&quot;dyld: launch started&quot;); // 主要功能1⃣️：根据可执行文件头部，参数等设置上下文信息 setContext(mainExecutableMH, argc, argv, envp, apple); // Pickup the pointer to the exec path. // 获取可执行文件路径 sExecPath = _simple_getenv(apple, &quot;executable_path&quot;); // &lt;rdar://problem/13868260&gt; Remove interim apple[0] transition code from dyld if (!sExecPath) sExecPath = apple[0]; // mach-o 绝对路径 if ( sExecPath[0] != '/' ) { // have relative path, use cwd to make absolute char cwdbuff[MAXPATHLEN]; if ( getcwd(cwdbuff, MAXPATHLEN) != NULL ) { // maybe use static buffer to avoid calling malloc so early... char* s = new char[strlen(cwdbuff) + strlen(sExecPath) + 2]; strcpy(s, cwdbuff); strcat(s, &quot;/&quot;); strcat(s, sExecPath); sExecPath = s; } } // Remember short name of process for later logging // 获取可执行文件的名字 sExecShortName = ::strrchr(sExecPath, '/'); if ( sExecShortName != NULL ) ++sExecShortName; else sExecShortName = sExecPath; // 主要功能1⃣️：检测进程是否受限 configureProcessRestrictions(mainExecutableMH);#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( !gLinkContext.allowEnvVarsPrint &amp;&amp; !gLinkContext.allowEnvVarsPath &amp;&amp; !gLinkContext.allowEnvVarsSharedCache ) { pruneEnvironmentVariables(envp, &amp;apple); // set again because envp and apple may have changed or moved setContext(mainExecutableMH, argc, argv, envp, apple); } else#endif { // 主要功能2⃣️：检查设置环境变量 checkEnvironmentVariables(envp); // 如果DYLD_FALLBACK为nil，将其设置为默认值 defaultUninitializedFallbackPaths(envp); }#if __MAC_OS_X_VERSION_MIN_REQUIRED if ( ((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::iOSMac) &amp;&amp; !((dyld3::MachOFile*)mainExecutableMH)-&gt;supportsPlatform(dyld3::Platform::macOS)) { gLinkContext.rootPaths = parseColonList(&quot;/System/iOSSupport&quot;, NULL); gLinkContext.marzipan = true; if ( sEnv.DYLD_FALLBACK_LIBRARY_PATH == sLibraryFallbackPaths ) sEnv.DYLD_FALLBACK_LIBRARY_PATH = sRestrictedLibraryFallbackPaths; if ( sEnv.DYLD_FALLBACK_FRAMEWORK_PATH == sFrameworkFallbackPaths ) sEnv.DYLD_FALLBACK_FRAMEWORK_PATH = sRestrictedFrameworkFallbackPaths; }#endif // 如果设置了DYLD_PRINT_OPTS环境变量，则打印参数 if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv); // 如果设置了DYLD_PRINT_ENV环境变量，则打印环境变量 if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); // 主要功能2⃣️：根据Mach-O头部获取当前运行架构信息 getHostInfo(mainExecutableMH, mainExecutableSlide); // load shared cache // 主要功能3⃣️：检查共享缓存是否开启，iOS中必须开启 checkSharedRegionDisable((dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide);#if TARGET_IPHONE_SIMULATOR // &lt;HACK&gt; until &lt;rdar://30773711&gt; is fixed gLinkContext.sharedRegionMode = ImageLoader::kUsePrivateSharedRegion; // &lt;/HACK&gt;#endif if ( gLinkContext.sharedRegionMode != ImageLoader::kDontUseSharedRegion ) { // 主要功能3⃣️：加载共享缓存库 mapSharedCache(); } bool cacheCompatible = (sSharedCacheLoadInfo.loadAddress == nullptr) || (sSharedCacheLoadInfo.loadAddress-&gt;header.formatVersion == dyld3::closure::kFormatVersion); if ( cacheCompatible &amp;&amp; (sEnableClosures || inWhiteList(sExecPath)) ) { const dyld3::closure::LaunchClosure* mainClosure = nullptr; dyld3::closure::LoadedFileInfo mainFileInfo; mainFileInfo.fileContent = mainExecutableMH; mainFileInfo.path = sExecPath; // FIXME: If we are saving this closure, this slice offset/length is probably wrong in the case of FAT files. mainFileInfo.sliceOffset = 0; mainFileInfo.sliceLen = std::numeric_limits&lt;__typeof(mainFileInfo.sliceLen)&gt;::max(); struct stat mainExeStatBuf; if ( ::stat(sExecPath, &amp;mainExeStatBuf) == 0 ) { mainFileInfo.inode = mainExeStatBuf.st_ino; mainFileInfo.mtime = mainExeStatBuf.st_mtime; } // check for closure in cache first if ( sSharedCacheLoadInfo.loadAddress != nullptr ) { mainClosure = sSharedCacheLoadInfo.loadAddress-&gt;findClosure(sExecPath); if ( gLinkContext.verboseWarnings &amp;&amp; (mainClosure != nullptr) ) dyld::log(&quot;dyld: found closure %p (size=%lu) in dyld shared cache\\n&quot;, mainClosure, mainClosure-&gt;size()); } #if !TARGET_IPHONE_SIMULATOR if ( (mainClosure == nullptr) || !closureValid(mainClosure, mainFileInfo, mainExecutableCDHash, true, envp) ) { mainClosure = nullptr; if ( sEnableClosures || isStagedApp((dyld3::MachOFile*)mainExecutableMH, sExecPath) ) { // if forcing closures, and no closure in cache, or it is invalid, check for cached closure mainClosure = findCachedLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); if ( mainClosure == nullptr ) { // if no cached closure found, build new one mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); } } } #endif // try using launch closure if ( mainClosure != nullptr ) { CRSetCrashLogMessage(&quot;dyld3: launch started&quot;); bool launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide, argc, argv, envp, apple, &amp;result, startGlue); #if !TARGET_IPHONE_SIMULATOR if ( !launched ) { // closure is out of date, build new one mainClosure = buildLaunchClosure(mainExecutableCDHash, mainFileInfo, envp); if ( mainClosure != nullptr ) { launched = launchWithClosure(mainClosure, sSharedCacheLoadInfo.loadAddress, (dyld3::MachOLoaded*)mainExecutableMH, mainExecutableSlide, argc, argv, envp, apple, &amp;result, startGlue); } } #endif if ( launched ) {#if __has_feature(ptrauth_calls) // start() calls the result pointer as a function pointer so we need to sign it. result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);#endif if (sSkipMain) result = (uintptr_t)&amp;fake_main; return result; } else { if ( gLinkContext.verboseWarnings ) dyld::log(&quot;dyld: unable to use closure %p\\n&quot;, mainClosure); } } } else { if ( gLinkContext.verboseWarnings ) dyld::log(&quot;dyld: not using closure because shared cache format version does not match dyld's\\n&quot;); } // could not use closure info, launch old way // install gdb notifier stateToHandlers(dyld_image_state_dependents_mapped, sBatchHandlers)-&gt;push_back(notifyGDB); stateToHandlers(dyld_image_state_mapped, sSingleHandlers)-&gt;push_back(updateAllImages); // make initial allocations large enough that it is unlikely to need to be re-alloced sImageRoots.reserve(16); sAddImageCallbacks.reserve(4); sRemoveImageCallbacks.reserve(4); sAddLoadImageCallbacks.reserve(4); sImageFilesNeedingTermination.reserve(16); sImageFilesNeedingDOFUnregistration.reserve(8);#if !TARGET_IPHONE_SIMULATOR#ifdef WAIT_FOR_SYSTEM_ORDER_HANDSHAKE // &lt;rdar://problem/6849505&gt; Add gating mechanism to dyld support system order file generation process WAIT_FOR_SYSTEM_ORDER_HANDSHAKE(dyld::gProcessInfo-&gt;systemOrderFlag);#endif#endif try { // add dyld itself to UUID list // 主要功能4⃣️：将dyld本身添加到UUID列表 addDyldImageToUUIDList();#if SUPPORT_ACCELERATE_TABLES#if __arm64e__ // Disable accelerator tables when we have threaded rebase/bind, which is arm64e executables only for now. if (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) sDisableAcceleratorTables = true;#endif bool mainExcutableAlreadyRebased = false; if ( (sSharedCacheLoadInfo.loadAddress != nullptr) &amp;&amp; !dylibsCanOverrideCache() &amp;&amp; !sDisableAcceleratorTables &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.accelerateInfoAddr != 0) ) { struct stat statBuf; if ( ::stat(IPHONE_DYLD_SHARED_CACHE_DIR &quot;no-dyld2-accelerator-tables&quot;, &amp;statBuf) != 0 ) sAllCacheImagesProxy = ImageLoaderMegaDylib::makeImageLoaderMegaDylib(&amp;sSharedCacheLoadInfo.loadAddress-&gt;header, sSharedCacheLoadInfo.slide, mainExecutableMH, gLinkContext); }reloadAllImages:#endif CRSetCrashLogMessage(sLoadingCrashMessage); // instantiate ImageLoader for main executable // 主要功能5⃣️：实例化主程序 // 加载可执行文件并生成一个ImageLoader实例对象 // 这里调用比较深,后续再看 sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); gLinkContext.mainExecutable = sMainExecutable; gLinkContext.mainExecutableCodeSigned = hasCodeSignatureLoadCommand(mainExecutableMH);#if TARGET_IPHONE_SIMULATOR // check main executable is not too new for this OS { if ( ! isSimulatorBinary((uint8_t*)mainExecutableMH, sExecPath) ) { throwf(&quot;program was built for a platform that is not supported by this runtime&quot;); } uint32_t mainMinOS = sMainExecutable-&gt;minOSVersion(); // dyld is always built for the current OS, so we can get the current OS version // from the load command in dyld itself. uint32_t dyldMinOS = ImageLoaderMachO::minOSVersion((const mach_header*)&amp;__dso_handle); if ( mainMinOS &gt; dyldMinOS ) { #if TARGET_OS_WATCH throwf(&quot;app was built for watchOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #elif TARGET_OS_TV throwf(&quot;app was built for tvOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #else throwf(&quot;app was built for iOS %d.%d which is newer than this simulator %d.%d&quot;, mainMinOS &gt;&gt; 16, ((mainMinOS &gt;&gt; 8) &amp; 0xFF), dyldMinOS &gt;&gt; 16, ((dyldMinOS &gt;&gt; 8) &amp; 0xFF)); #endif } }#endif #if __MAC_OS_X_VERSION_MIN_REQUIRED // &lt;rdar://problem/22805519&gt; be less strict about old mach-o binaries uint32_t mainSDK = sMainExecutable-&gt;sdkVersion(); gLinkContext.strictMachORequired = (mainSDK &gt;= DYLD_MACOSX_VERSION_10_12) || gLinkContext.allowInsertFailures; #else // simulators, iOS, tvOS, and watchOS are always strict gLinkContext.strictMachORequired = true; #endif #if SUPPORT_ACCELERATE_TABLES sAllImages.reserve((sAllCacheImagesProxy != NULL) ? 16 : INITIAL_IMAGE_COUNT); #else sAllImages.reserve(INITIAL_IMAGE_COUNT); #endif // Now that shared cache is loaded, setup an versioned dylib overrides #if SUPPORT_VERSIONED_PATHS //检查库的版本是否有更新，有则覆盖原有的 checkVersionedPaths(); #endif // dyld_all_image_infos image list does not contain dyld // add it as dyldPath field in dyld_all_image_infos // for simulator, dyld_sim is in image list, need host dyld added#if TARGET_IPHONE_SIMULATOR // get path of host dyld from table of syscall vectors in host dyld void* addressInDyld = gSyscallHelpers;#else // get path of dyld itself void* addressInDyld = (void*)&amp;__dso_handle;#endif char dyldPathBuffer[MAXPATHLEN+1]; int len = proc_regionfilename(getpid(), (uint64_t)(long)addressInDyld, dyldPathBuffer, MAXPATHLEN); if ( len &gt; 0 ) { dyldPathBuffer[len] = '\\0'; // proc_regionfilename() does not zero terminate returned string if ( strcmp(dyldPathBuffer, gProcessInfo-&gt;dyldPath) != 0 ) gProcessInfo-&gt;dyldPath = strdup(dyldPathBuffer); } // load any inserted libraries // 主要功能6⃣️：插入动态库:加载所有 DYLD_INSERT_LIBRARIES 指定的库 if ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib); } // record count of inserted libraries so that a flat search will look at // inserted libraries, then main, then others. sInsertedDylibCount = sAllImages.size()-1; // link main executable gLinkContext.linkingMainExecutable = true;#if SUPPORT_ACCELERATE_TABLES if ( mainExcutableAlreadyRebased ) { // previous link() on main executable has already adjusted its internal pointers for ASLR // work around that by rebasing by inverse amount sMainExecutable-&gt;rebase(gLinkContext, -mainExecutableSlide); }#endif // 主要功能7⃣️：链接主程序 // link调用比较深,后续来看 link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); sMainExecutable-&gt;setNeverUnloadRecursive(); if ( sMainExecutable-&gt;forceFlat() ) { gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding; } // link any inserted libraries // do this after linking main executable so that any dylibs pulled in by inserted // dylibs (e.g. libSystem) will not be in front of dylibs the program uses // 主要功能7⃣️：链接主程序和所有插入的动态库 if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); } // only INSERTED libraries can interpose // register interposing info after all inserted libraries are bound so chaining works for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; // 注册符号插入 image-&gt;registerInterposing(gLinkContext); } } // &lt;rdar://problem/19315404&gt; dyld should support interposition even without DYLD_INSERT_LIBRARIES for (long i=sInsertedDylibCount+1; i &lt; sAllImages.size(); ++i) { ImageLoader* image = sAllImages[i]; if ( image-&gt;inSharedCache() ) continue; image-&gt;registerInterposing(gLinkContext); } #if SUPPORT_ACCELERATE_TABLES if ( (sAllCacheImagesProxy != NULL) &amp;&amp; ImageLoader::haveInterposingTuples() ) { // Accelerator tables cannot be used with implicit interposing, so relaunch with accelerator tables disabled ImageLoader::clearInterposingTuples(); // unmap all loaded dylibs (but not main executable) for (long i=1; i &lt; sAllImages.size(); ++i) { ImageLoader* image = sAllImages[i]; if ( image == sMainExecutable ) continue; if ( image == sAllCacheImagesProxy ) continue; image-&gt;setCanUnload(); ImageLoader::deleteImage(image); } // note: we don't need to worry about inserted images because if DYLD_INSERT_LIBRARIES was set we would not be using the accelerator table sAllImages.clear(); sImageRoots.clear(); sImageFilesNeedingTermination.clear(); sImageFilesNeedingDOFUnregistration.clear(); sAddImageCallbacks.clear(); sRemoveImageCallbacks.clear(); sAddLoadImageCallbacks.clear(); sDisableAcceleratorTables = true; sAllCacheImagesProxy = NULL; sMappedRangesStart = NULL; mainExcutableAlreadyRebased = true; gLinkContext.linkingMainExecutable = false; resetAllImages(); goto reloadAllImages; } #endif // apply interposing to initial set of images for(int i=0; i &lt; sImageRoots.size(); ++i) { //应用符号插入 sImageRoots[i]-&gt;applyInterposing(gLinkContext); } ImageLoader::applyInterposingToDyldCache(gLinkContext); gLinkContext.linkingMainExecutable = false; // Bind and notify for the main executable now that interposing has been registered uint64_t bindMainExecutableStartTime = mach_absolute_time(); sMainExecutable-&gt;recursiveBindWithAccounting(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); uint64_t bindMainExecutableEndTime = mach_absolute_time(); ImageLoaderMachO::fgTotalBindTime += bindMainExecutableEndTime - bindMainExecutableStartTime; gLinkContext.notifyBatch(dyld_image_state_bound, false); // Bind and notify for the inserted images now interposing has been registered if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; // 递归绑定符号表 image-&gt;recursiveBind(gLinkContext, sEnv.DYLD_BIND_AT_LAUNCH, true); } } // &lt;rdar://problem/12186933&gt; do weak binding only after all inserted images linked // 弱符号绑定 sMainExecutable-&gt;weakBind(gLinkContext); // If cache has branch island dylibs, tell debugger about them if ( (sSharedCacheLoadInfo.loadAddress != NULL) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.mappingOffset &gt;= 0x78) &amp;&amp; (sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset != 0) ) { uint32_t count = sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsCount; dyld_image_info info[count]; const uint64_t* poolAddress = (uint64_t*)((char*)sSharedCacheLoadInfo.loadAddress + sSharedCacheLoadInfo.loadAddress-&gt;header.branchPoolsOffset); // &lt;rdar://problem/20799203&gt; empty branch pools can be in development cache if ( ((mach_header*)poolAddress)-&gt;magic == sMainExecutableMachHeader-&gt;magic ) { for (int poolIndex=0; poolIndex &lt; count; ++poolIndex) { uint64_t poolAddr = poolAddress[poolIndex] + sSharedCacheLoadInfo.slide; info[poolIndex].imageLoadAddress = (mach_header*)(long)poolAddr; info[poolIndex].imageFilePath = &quot;dyld_shared_cache_branch_islands&quot;; info[poolIndex].imageFileModDate = 0; } // add to all_images list addImagesToAllImages(count, info); // tell gdb about new branch island images gProcessInfo-&gt;notification(dyld_image_adding, count, info); } } CRSetCrashLogMessage(&quot;dyld: launch, running initializers&quot;); // 初始化主程序 #if SUPPORT_OLD_CRT_INITIALIZATION // Old way is to run initializers via a callback from crt1.o if ( ! gRunInitializersOldWay ) initializeMainExecutable(); #else // run all initializers // 主要功能8⃣️：执行初始化方法！！ initializeMainExecutable(); #endif // notify any montoring proccesses that this process is about to enter main() if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); } notifyMonitoringDyldMain(); // find entry point for main executable // 主要功能9⃣️：寻找目标可执行文件入口并执行 // 从 mach-o 中读取程序入口, 主程序则读取LC_UNIXTHREAD, 就是 main.m result = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN(); if ( result != 0 ) { // main executable uses LC_MAIN, we need to use helper in libdyld to call into main() if ( (gLibSystemHelpers != NULL) &amp;&amp; (gLibSystemHelpers-&gt;version &gt;= 9) ) *startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit; else halt(&quot;libdyld.dylib support not present for LC_MAIN&quot;); } else { // main executable uses LC_UNIXTHREAD, dyld needs to let &quot;start&quot; in program set up for main() // 找到真正 main 函数入口 result = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_UNIXTHREAD(); *startGlue = 0; }#if __has_feature(ptrauth_calls) // start() calls the result pointer as a function pointer so we need to sign it. result = (uintptr_t)__builtin_ptrauth_sign_unauthenticated((void*)result, 0, 0);#endif } catch(const char* message) { syncAllImages(); halt(message); } catch(...) { dyld::log(&quot;dyld: launch failed\\n&quot;); } CRSetCrashLogMessage(&quot;dyld2 mode&quot;); if (sSkipMain) { if (dyld3::kdebug_trace_dyld_enabled(DBG_DYLD_TIMING_LAUNCH_EXECUTABLE)) { dyld3::kdebug_trace_dyld_duration_end(launchTraceID, DBG_DYLD_TIMING_LAUNCH_EXECUTABLE, 0, 0, 2); } result = (uintptr_t)&amp;fake_main; *startGlue = (uintptr_t)gLibSystemHelpers-&gt;startGlueToCallExit; } // 找到真正 main 函数入口后返回 return result;} dyld::_main()主要流程为： 设置上下文信息，检测进程是否受限 配置环境变量，获取当前运行架构 检查是否开启共享缓存，并加载共享缓存库 将 dyld 本身添加到 UUID 列表 实例化主程序 加载插入动态库 链接主程序和插入的库，执行符号替换 执行初始化方法 寻找主程序入口 3.1 设置上下文信息，检测进程是否受限 调用setContext函数，传入Mach-O头部以及一些参数设置上下文 configureProcessRestrictions检测进程是否受限，在上下文中做出对应处理 1234/// _main函数中setContext(mainExecutableMH, argc, argv, envp, apple);...configureProcessRestrictions(mainExecutableMH); 3.2 配置环境变量，获取当前运行架构 从环境变量中获取主要可执行文件的cdHash checkEnvironmentVariables(envp)检查设置环境变量 defaultUninitializedFallbackPaths(envp)在DYLD_FALLBACK为空时设置默认值 getHostInfo(mainExecutableMH, mainExecutableSlide)获取程序架构 1234567/// _main函数中//如果设置了DYLD_PRINT_OPTS环境变量，则打印参数if ( sEnv.DYLD_PRINT_OPTS ) printOptions(argv);//如果设置了DYLD_PRINT_ENV环境变量，则打印环境变量if ( sEnv.DYLD_PRINT_ENV ) printEnvironmentVariables(envp); 只要设置了这两个环境变量参数，在App启动时就会打印相关参数、环境变量信息（自行尝试） 3.3 检查是否开启共享缓存，并加载共享缓存库 checkSharedRegionDisable检查是否开启共享缓存（iOS 下不会被禁用） mapSharedCache加载共享缓存库，其中调用loadDyldCache函数有这么几种情况： 仅加载到当前进程mapCachePrivate（模拟器仅支持加载到当前进程） 共享缓存是第一次被加载，就去做加载操作mapCacheSystemWide 共享缓存不是第一次被加载，那么就不做任何处理 3.4 将dyld本身添加到UUID列表addDyldImageToUUIDList将dyld本身添加到UUID列表 3.5 实例化主程序1sMainExecutable = instantiateFromLoadedImage(mainExecutableMH, mainExecutableSlide, sExecPath); 实例化主程序 , 检测可执行程序格式 . 1234567891011static ImageLoaderMachO* instantiateFromLoadedImage(const macho_header* mh, uintptr_t slide, const char* path){ // try mach-o loader if ( isCompatibleMachO((const uint8_t*)mh, path) ) { ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext); addImage(image); return (ImageLoaderMachO*)image; } throw &quot;main executable not a known format&quot;;} isCompatibleMachO 里就会通过 header 里的 magic , cputype , cpusubtype 去检测是否兼容 instantiateMainExecutable中调用ImageLoaderMachO::sniffLoadCommands，这才是真正实例化主程序的函数 1234567891011121314151617181920212223242526// determine if this mach-o file has classic or compressed LINKEDIT and number of segments it hasvoid ImageLoaderMachO::sniffLoadCommands(const macho_header* mh, const char* path, bool inCache, bool* compressed, unsigned int* segCount, unsigned int* libCount, const LinkContext&amp; context, const linkedit_data_command** codeSigCmd, const encryption_info_command** encryptCmd){ *compressed = false; *segCount = 0; *libCount = 0; *codeSigCmd = NULL; *encryptCmd = NULL; /* ... */ // fSegmentsArrayCount is only 8-bits if ( *segCount &gt; 255 ) dyld::throwf(&quot;malformed mach-o image: more than 255 segments in %s&quot;, path); // fSegmentsArrayCount is only 8-bits if ( *libCount &gt; 4095 ) dyld::throwf(&quot;malformed mach-o image: more than 4095 dependent libraries in %s&quot;, path); if ( needsAddedLibSystemDepency(*libCount, mh) ) *libCount = 1; ...} 这里几个字段都与MachO有关： compressed：根据LC_DYLD_INFO_ONYL来决定 segCount: MachO文件中segment数量，最多不超过255个 libCount: MachO文件中依赖的动态库的数量 codeSigCmd: 签名信息 encryptCmd: 加密信息，如cryptid等 经过以上步骤 , 主程序的实例化就已经完成了 3.6 加载插入动态库123456/// _main函数中// load any inserted librariesif ( sEnv.DYLD_INSERT_LIBRARIES != NULL ) { for (const char* const* lib = sEnv.DYLD_INSERT_LIBRARIES; *lib != NULL; ++lib) loadInsertedDylib(*lib);} 遍历DYLD_INSERT_LIBRARIES环境变量，调用loadInsertedDylib加载，通过该环境变量我们可以注入自定义的一些动态库代码从而完成安全攻防，loadInsertedDylib内部会从DYLD_ROOT_PATH、LD_LIBRARY_PATH、DYLD_FRAMEWORK_PATH等路径查找dylib并且检查代码签名，无效则直接抛出异常 3.7 链接主程序和插入的库，执行符号替换123456789101112131415161718192021// link main executablegLinkContext.linkingMainExecutable = true;link(sMainExecutable, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1);sMainExecutable-&gt;setNeverUnloadRecursive();if ( sMainExecutable-&gt;forceFlat() ) { gLinkContext.bindFlat = true; gLinkContext.prebindUsage = ImageLoader::kUseNoPrebinding;}if ( sInsertedDylibCount &gt; 0 ) { for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; link(image, sEnv.DYLD_BIND_AT_LAUNCH, true, ImageLoader::RPathChain(NULL, NULL), -1); image-&gt;setNeverUnloadRecursive(); } for(unsigned int i=0; i &lt; sInsertedDylibCount; ++i) { ImageLoader* image = sAllImages[i+1]; image-&gt;registerInterposing(gLinkContext); }} 点击进入 link 函数 , link 函数中有一系列 recursiveLoadLibraries , recursiveBindWithAccounting -&gt; recursiveBind , 也就是递归进行符号绑定的过程 . link 函数执行完毕之后 , dyld :: main 会调用 sMainExecutable-&gt;weakBind(gLinkContext); 进行弱绑定 , 懒加载绑定 , 也就是说弱绑定一定发生在 其他库链接绑定完成之后 . 绑定的过程就是我们之前分析的共享缓存绑定的过程 . 走到了这里 , 主程序已经实例化完毕 , 但还没有加载 , framework 已经加载完毕了 , 那讲到这插一句题外话 , 不同 framework , 谁先会被加载 ? 其实根据二进制顺序有关 , Xcode 中可以自由调整 : 拖动就可以自己调整顺序了 , 编译顺序就会根据这个顺序来 , 同样你可以使用 MachOView 来查看二进制顺序 . 至此 , 配置环境变量 -&gt; 加载共享缓存 -&gt; 实例化主程序 -&gt; 加载动态库 -&gt; 链接动态库 就已经完成了 . 接下来是重中之重 3.8 执行初始化方法回顾一下函数调用栈： ①initializeMainExecutable方法调用runInitializers 12345678910111213141516171819202122232425262728void initializeMainExecutable(){ // record that we've reached this step gLinkContext.startedInitializingMainExecutable = true; // run initialzers for any inserted dylibs ImageLoader::InitializerTimingList initializerTimes[allImagesCount()]; initializerTimes[0].count = 0; const size_t rootCount = sImageRoots.size(); if ( rootCount &gt; 1 ) { for(size_t i=1; i &lt; rootCount; ++i) { sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[0]); } } // run initializers for main executable and everything it brings up sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[0]); // register cxa_atexit() handler to run static terminators in all loaded images when this process exits if ( gLibSystemHelpers != NULL ) (*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, NULL, NULL); // dump info if requested if ( sEnv.DYLD_PRINT_STATISTICS ) ImageLoader::printStatistics((unsigned int)allImagesCount(), initializerTimes[0]); if ( sEnv.DYLD_PRINT_STATISTICS_DETAILS ) ImageLoaderMachO::printStatisticsDetails((unsigned int)allImagesCount(), initializerTimes[0]);} ②runInitializers调用processInitializers为初始化做准备 12345678910111213void ImageLoader::runInitializers(const LinkContext&amp; context, InitializerTimingList&amp; timingInfo){ uint64_t t1 = mach_absolute_time(); mach_port_t thisThread = mach_thread_self(); ImageLoader::UninitedUpwards up; up.count = 1; up.images[0] = this; processInitializers(context, thisThread, timingInfo, up); context.notifyBatch(dyld_image_state_initialized, false); mach_port_deallocate(mach_task_self(), thisThread); uint64_t t2 = mach_absolute_time(); fgTotalInitTime += (t2 - t1);} ③processInitializers中遍历image，recursiveInitialization递归初始化镜像 12345678910111213141516void ImageLoader::processInitializers(const LinkContext&amp; context, mach_port_t thisThread, InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images){ uint32_t maxImageCount = context.imageCount()+2; ImageLoader::UninitedUpwards upsBuffer[maxImageCount]; ImageLoader::UninitedUpwards&amp; ups = upsBuffer[0]; ups.count = 0; // Calling recursive init on all images in images list, building a new list of // uninitialized upward dependencies. for (uintptr_t i=0; i &lt; images.count; ++i) { images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups); } // If any upward dependencies remain, init them. if ( ups.count &gt; 0 ) processInitializers(context, thisThread, timingInfo, ups);} 点进去却只有声明，shift+cmd+O搜索recursiveInitialization ④recursiveInitialization获取到镜像的初始化 1234567891011121314151617void ImageLoader::recursiveInitialization(const LinkContext&amp; context, mach_port_t this_thread, const char* pathToInitialize, InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps){ ... uint64_t t1 = mach_absolute_time(); fState = dyld_image_state_dependents_initialized; oldState = fState; context.notifySingle(dyld_image_state_dependents_initialized, this, &amp;timingInfo); // initialize this image bool hasInitializers = this-&gt;doInitialization(context); // let anyone know we finished initializing this image fState = dyld_image_state_initialized; oldState = fState; context.notifySingle(dyld_image_state_initialized, this, NULL); ...} ⑤notifySingle获取到镜像的回调 1234567891011121314151617static void notifySingle(dyld_image_states state, const ImageLoader* image, ImageLoader::InitializerTimingList* timingInfo){ ... if ( (state == dyld_image_state_dependents_initialized) &amp;&amp; (sNotifyObjCInit != NULL) &amp;&amp; image-&gt;notifyObjC() ) { uint64_t t0 = mach_absolute_time(); dyld3::ScopedTimer timer(DBG_DYLD_TIMING_OBJC_INIT, (uint64_t)image-&gt;machHeader(), 0, 0); (*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader()); uint64_t t1 = mach_absolute_time(); uint64_t t2 = mach_absolute_time(); uint64_t timeInObjC = t1-t0; uint64_t emptyTime = (t2-t1)*100; if ( (timeInObjC &gt; emptyTime) &amp;&amp; (timingInfo != NULL) ) { timingInfo-&gt;addTime(image-&gt;getShortName(), timeInObjC); } } ...} notifySingle中并没有找到函数调用栈中的load_images，其实这是一个回调函数的调用 【⑥】sNotifyObjCInit在registerObjCNotifiers函数中赋值 1234567void registerObjCNotifiers(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped){ // record functions to call sNotifyObjCMapped = mapped; sNotifyObjCInit = init; sNotifyObjCUnmapped = unmapped;} ⑦registerObjCNotifiers在_dyld_objc_notify_register函数中被调用，这个函数只在运行时提供给objc使用 1234567891011121314151617181920212223void _dyld_objc_notify_register(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped){ dyld::registerObjCNotifiers(mapped, init, unmapped);}// _objc_init 调用`_dyld_objc_notify_register`，并调用`load_image`void _objc_init(void){ static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} ⑧context.notifySingle之后，调用ImageLoaderMachO::doInitialization，内部调用 doImageInit ImageLoaderMachO::doModInitFunctions ⑨doImageInit-&gt;libSystemInitialized-&gt;【根据libObjc源码分析得到】libdispatch_init-&gt;_os_object_init，内部调用_objc_init 验证： 我们直接通过 LLDB 大法来断点调试 libObjc 源码中的 _objc_init，然后通过 bt 命令打印出当前的调用堆栈，此刻一切的一切都是那么的清晰明了： ⑩doModInitFunctions内部调用__mod_init_funcs section，也就是constructor方法——C++构造方法 initializeMainExecutable总结： runInitializers-&gt;processInitializers中，遍历recursiveInitialization 第一次执行时，进行libsystem初始化——doInitialization-&gt;doImageInit-&gt; libSystemInitialized libsystem的初始化，会调用起libdispatch_init，libdispatch初始化会调用_os_object_init， 内部调用了_objc_init _objc_init中注册并保存了map_images、load_images、unmap_image函数地址 注册完毕继续回到recursiveInitialization递归下一次调用 3.9 寻找主程序入口12// find entry point for main executableresult = (uintptr_t)sMainExecutable-&gt;getEntryFromLC_MAIN(); 四、dyld加载过程示意图 dyld加载流程代码较多，第一次看大概了解这个过程即可 五、总结 PS我的dyld源码(版本：dyld-635.2) 参考iOS探索 浅尝辄止dyld加载流程 更深入：iOS 底层 - 从头梳理 dyld 加载流程 iOS 底层探索 - 应用加载","link":"/2021/01/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/07%E4%B8%8B-dyld%E5%88%86%E6%9E%90/"},{"title":"08-类的加载过程","text":"前言：dyld加载流程（精简）由于dyld流程加载是一个比较复杂的过程，这里我们只做简单的分析。 下面是main函数之前调用堆栈的信息： 通过上面的堆栈信息我们可以简单分析出来一个流程 _dyld_start函数，是整个加载的入口。 经过dyldbooststrap::start-&gt;dyld::start-&gt;ImageLoad::-&gt;ImageLoadMackO::这些流程把MachO里面的信息读取到。 libSystem_initializer，初始化系统库。 libdispatch_init，初始化libdispatch库。 _os_object_init-&gt;::_objc_init，初始化objc库。 dyld主要的步骤都在读取MachO段里面的数据 接下来使用objc4-756.2源码进行分析 一、_objc_init流程123456789101112131415void _objc_init(void){ static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);} 1.1 environ_init 函数初始化环境变量。这里我们的重点不是看源码，主要看下面： 我们可以通过在终端进行：export OBJC_HELP=1然后： ls，查看相关的环境变量，留意下面两个变量： …省略中间的部分… 我们可以在Xcode中调整这两个环境变量玩一下： 1.1.1 修改环境变量OBJC_PRINT_LOAD_METHOD为YES后 修改该环境变量之后观察控制台打印输出的结果 系统的load方法会全部打印出来。 自己定义的load方法也会打印出来，所以我们可以从这里入手，在做启动优化的时候可以快速定位调整这些load方法。 1.1.2 修改OBJC_PRINT_NONPOINTER_ISA为YES后 修改该环境变量之后观察控制台打印输出的结果 优化过的isa指针则需要&amp;上ISA_MASK才能的到类的内存地址。 关闭nonpointer之后，isa指针就不做内存优化了，所以类的内存地址和isa的内存地址就相同了。 这里也验证了02-isa原理中isa的初始化的时候，直接将类赋值isa的cls成员。 1.2 tls_init 函数tls_init()方法是关于线程key的绑定 123456789void tls_init(void){#if SUPPORT_DIRECT_THREAD_KEYS _objc_pthread_key = TLS_DIRECT_KEY; pthread_key_init_np(TLS_DIRECT_KEY, &amp;_objc_pthread_destroyspecific);#else _objc_pthread_key = tls_create(&amp;_objc_pthread_destroyspecific);#endif} 1.3 static_init 函数static_init()方法注释中提到：该方法会运行C++静态构造函数（只会运行系统级别的构造函数），在dyld调用静态构造函数之前libc会调用_objc_init，所以必须自己去实现 1234567891011121314/************************************************************************ static_init* Run C++ static constructor functions.* libc calls _objc_init() before dyld would call our static constructors, * so we have to do it ourselves.**********************************************************************/static void static_init(){ size_t count; auto inits = getLibobjcInitializers(&amp;_mh_dylib_header, &amp;count); for (size_t i = 0; i &lt; count; i++) { inits[i](); }} 1.4 lock_init 函数lock_init()方法是个空函数，OC的锁机制完全采用C、C++那一套 123void lock_init(void){} 1.5 exception_init 函数exception_init()初始化libobjc的异常处理系统，注册异常处理的回调，从而监控异常的处理 1234void exception_init(void){ old_terminate = std::set_terminate(&amp;_objc_terminate);} 调用只声明不实现不作任何处理的方法，就会报错，来到_objc_terminate 1.6 _dyld_objc_notify_register 函数 通过三个函数指针直接发起回调。这里分析_dyld_objc_notify_mapped这个函数，在dyld里面通过注册函数的内存地址，然后通过函数指针又回调到了map_images这个函数。 记录保存注册函数的内存地址。 通过函数指针的形式回调这个函数即map_images,下面进入到map_images分析。 二、map_images 函数当镜像加载到内存时会触发map_image 1234567891011121314/************************************************************************ map_images* Process the given images which are being mapped in by dyld.* Calls ABI-agnostic code after taking ABI-specific locks.** Locking: write-locks runtimeLock**********************************************************************/voidmap_images(unsigned count, const char * const paths[], const struct mach_header * const mhdrs[]){ mutex_locker_t lock(runtimeLock); return map_images_nolock(count, paths, mhdrs);} map_images_nolock函数： map_image调用map_images_nolock，由于代码比较多，我们去掉一些无关紧要的代码，比如打印日志信息、代码的注释、iOS系统用到的，精简之后如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void map_images_nolock(unsigned mhCount, const char * const mhPaths[], const struct mach_header * const mhdrs[]){ static bool firstTime = YES; header_info *hList[mhCount]; uint32_t hCount; size_t selrefCount = 0; if (firstTime) { preopt_init(); } // Find all images with Objective-C metadata. hCount = 0; // Count classes. Size various table based on the total. int totalClasses = 0; int unoptimizedTotalClasses = 0; { uint32_t i = mhCount; while (i--) { const headerType *mhdr = (const headerType *)mhdrs[i]; auto hi = addHeader(mhdr, mhPaths[i], totalClasses, unoptimizedTotalClasses); if (!hi) { // no objc data in this entry continue; } if (mhdr-&gt;filetype == MH_EXECUTE) { // Size some data structures based on main executable is size#if __OBJC2__ size_t count; _getObjc2SelectorRefs(hi, &amp;count); selrefCount += count; _getObjc2MessageRefs(hi, &amp;count); selrefCount += count;#else _getObjcSelectorRefs(hi, &amp;selrefCount);#endif } hList[hCount++] = hi; } } // Perform one-time runtime initialization that must be deferred until // the executable itself is found. This needs to be done before // further initialization. // (The executable may not be present in this infoList if the // executable does not contain Objective-C code but Objective-C // is dynamically loaded later. if (firstTime) { sel_init(selrefCount); arr_init(); } if (hCount &gt; 0) { _read_images(hList, hCount, totalClasses, unoptimizedTotalClasses); } firstTime = NO;} 现在开始分析精简之后的代码 firstTime一个用static修饰的局部成员变量，记录第一次需要做的事。 _getObjc2SelectorRefs函数，从mach_o读取__objc_selrefs段的信息。 _getObjc2MessageRefs函数，从mach_o读取__objc_msgrefs段的信息。 第一次需要执行的函数preopt_init()、sel_init()、arr_init()。 _read_images()函数，读取镜像文件。 2.1 preopt_init()注释描述这里会延迟初始化，主要是共享缓存有了之后的处理。 2.2 sel_init() 去掉其他信息之后，我们可以看到是注册了一些系统提供的API。 2.3 arr_init() 这一块也是比较重要的信息，让我们知道了AutorereleasePoolPage和SideTable的初始化在这里是有执行的。 2.4 _read_images()前面的三个函数不是我们目前探索的重点，只是简单的分析了一下。下面我们开始深入_read_images()，请看接下来的类加载部分。 三、类加载入口：_read_images() 函数读取镜像文件。由于这个函数的代码比较多，我们把其中的代码先用伪代码的信息展示出来，然后再来讲解每一步。 1234567891011121314151617181920212223242526272829303132333435void _read_images(header_info **hList, uint32_t hCount, int totalClasses, int unoptimizedTotalClasses){ 1. 定义局部变量，处理第一次要做的事情。 if (!doneOnce){ ... } 2. 类的重映射 for (EACH_HEADER) { ... } 3. 修复重映射 if (!noClassesRemapped()) { ... } 4. 添加SEL到namedSelectors表 { ... } 5. 修复旧的函数指针调用遗留 for (EACH_HEADER) { ... } 6. 添加Protocol到协议表 for (EACH_HEADER) { ... } 7. 修复协议列表引用 for (EACH_HEADER) { ... } 8. 实现非懒加载的类 for (EACH_HEADER) { ... } 9. Realize newly-resolved future classes if (resolvedFutureClasses) { ... } 10. 发现和处理所有Category for (EACH_HEADER) { ... } 11. +load handled by prepare_load_methods() if (DebugNonFragileIvars) { ... }} 重要的有第1步、第2步、第11步。 3.1 第一次要做的事情 - doneOnce【重要】去掉打印部分的代码、与iOS操作系统不相干的代码。 123456789101112131415161718192021222324252627282930313233343536if (!doneOnce) { doneOnce = YES;#if SUPPORT_NONPOINTER_ISA# if SUPPORT_INDEXED_ISA# endif# if TARGET_OS_OSX# endif#endif if (DisableTaggedPointers) { disableTaggedPointers(); } initializeTaggedPointerObfuscator(); if (PrintConnecting) { _objc_inform(&quot;CLASS: found %d classes during launch&quot;, totalClasses); } // namedClasses // Preoptimized classes do not go in this table. // 4/3 is NXMapTable is load factor int namedClassesSize = (isPreoptimized() ? unoptimizedTotalClasses : totalClasses) * 4 / 3; gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); allocatedClasses = NXCreateHashTable(NXPtrPrototype, 0, nil); ts.log(&quot;IMAGE TIMES: first time tasks&quot;); } disableTaggedPointers()函数，条件允许的时候，禁用taggedPointers。 initializeTaggedPointerObfuscator函数，初始化taggedPointer。 gdb_objc_realized_classes通过NX技术创建的mapTable，这张表里面包含的所有类的信息，我们称之为总表。 allocatedClasses通过NX技术创建的HashTable，这张表只包含已经开辟的类的信息，我们称之为已开辟类的表。 3.2 对所有类做重映射【重要】从列表中取出所有类，遍历进行处理 123456789101112131415161718192021222324252627282930313233for (EACH_HEADER) { // 从编译后的类列表中取出所有类，获取到的是一个classref_t类型的指针 classref_t *classlist = _getObjc2ClassList(hi, &amp;count); if (! mustReadClasses(hi)) { // Image is sufficiently optimized that we need not call readClass() continue; } bool headerIsBundle = hi-&gt;isBundle(); bool headerIsPreoptimized = hi-&gt;isPreoptimized(); for (i = 0; i &lt; count; i++) { // 数组中会取出OS_dispatch_queue_concurrent、OS_xpc_object、NSRunloop等系统类，例如CF、Fundation、libdispatch中的类。以及自己创建的类 Class cls = (Class)classlist[i]; // 通过readClass函数获取处理后的新类， Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); // 初始化所有懒加载的类需要的内存空间 - 现在数据没有加载到的 - 连类都没有初始化的 if (newCls != cls &amp;&amp; newCls) { // Class was moved but not deleted. Currently this occurs // only when the new class resolved a future class. // Non-lazily realize the class below. // 将懒加载的类添加到数组中 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); resolvedFutureClasses[resolvedFutureClassCount++] = newCls; } }} readClass方法会返回Class，跟进去看看具体实现 当前类的父类中若有丢失的weak-linked类，则返回nil 正常情况下不会走进popFutureNamedClass判断，这是专门针对未来的待处理的类的特殊操作，因此也不会对ro、rw进行操作（可打断点调试，创建类和系统类都不会进入） 在调用addNamedClass，addClassTableEntry方法后返回cls 将当前类添加到已创建好的gdb_objc_realized_classes哈希表（总表） 12345678910111213141516171819static void addNamedClass(Class cls, const char *name, Class replacing = nil){ runtimeLock.assertLocked(); Class old; if ((old = getClassExceptSomeSwift(name)) &amp;&amp; old != replacing) { inform_duplicate(name, old, cls); // getMaybeUnrealizedNonMetaClass uses name lookups. // Classes not found by name lookup must be in the // secondary meta-&gt;nonmeta table. addNonMetaClass(cls); } else { NXMapInsert(gdb_objc_realized_classes, name, cls); } assert(!(cls-&gt;data()-&gt;flags &amp; RO_META)); // wrong: constructed classes are already realized when they get here // assert(!cls-&gt;isRealized());} 当前类已经初始化，所以要添加到allocatedClasses哈希表(已开辟类的表) 123456789101112static void addClassTableEntry(Class cls, bool addMeta = true) { runtimeLock.assertLocked(); // This class is allowed to be a known class via the shared cache or via // data segments, but it is not allowed to be in the dynamic table already. assert(!NXHashMember(allocatedClasses, cls)); if (!isKnownClass(cls)) NXHashInsert(allocatedClasses, cls); if (addMeta) addClassTableEntry(cls-&gt;ISA(), false);} 3.3 修复重映射将未映射Class和Super Class重映射，调用_getObjc2ClassRefs获取类的引用，调用_getObjc2SuperRefs获取父类的引用，通过remapClassRef进行重映射 123456789101112131415// 将未映射Class和Super Class重映射，被remap的类都是非懒加载的类if (!noClassesRemapped()) { for (EACH_HEADER) { // 重映射Class，注意是从_getObjc2ClassRefs函数中取出类的引用 Class *classrefs = _getObjc2ClassRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } // fixme why doesn't test future1 catch the absence of this? classrefs = _getObjc2SuperRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapClassRef(&amp;classrefs[i]); } }} 3.4 添加SEL到namedSelectors表通过_getObjc2SelectorRefs拿到MachO中的静态段__objc_selrefs，遍历列表调用sel_registerNameNoLock将SEL添加到namedSelectors哈希表 123456789101112131415161718// 将所有SEL都注册到哈希表中，是另外一张哈希表// Fix up @selector referencesstatic size_t UnfixedSelectors;{ mutex_locker_t lock(selLock); for (EACH_HEADER) { if (hi-&gt;isPreoptimized()) continue; bool isBundle = hi-&gt;isBundle(); SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; for (i = 0; i &lt; count; i++) { const char *name = sel_cname(sels[i]); // 注册SEL的操作 sels[i] = sel_registerNameNoLock(name, isBundle); } }} 3.5 修复旧的函数指针调用遗留通过_getObjc2MessageRefs获取到静态段__objc_selrefs，fixupMessageRef遍历将函数指针进行注册，并fix为新的函数指针 123456789101112131415// Fix up old objc_msgSend_fixup call sites// 修复旧的函数指针调用遗留for (EACH_HEADER) { message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) { _objc_inform(&quot;VTABLES: repairing %zu unsupported vtable dispatch &quot; &quot;call sites in %s&quot;, count, hi-&gt;fname()); } for (i = 0; i &lt; count; i++) { // 内部将常用的alloc、objc_msgSend等函数指针进行注册，并fix为新的函数指针 fixupMessageRef(refs+i); }} 3.6 将所有Protocol都添加到protocol_map表中调用_getObjc2ProtocolList获取到__objc_protolist协议列表，readProtocol遍历添加Protocol到protocol_map哈希表 12345678910111213141516171819// Discover protocols. Fix up protocol refs.// 遍历所有协议列表，并且将协议列表加载到Protocol的哈希表中for (EACH_HEADER) { extern objc_class OBJC_CLASS_$_Protocol; // cls = Protocol类，所有协议和对象的结构体都类似，isa都对应Protocol类 Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; assert(cls); // 获取protocol哈希表 NXMapTable *protocol_map = protocols(); bool isPreoptimized = hi-&gt;isPreoptimized(); bool isBundle = hi-&gt;isBundle(); // 从编译器中读取并初始化Protocol protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) { readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); }} 3.7 对所有Protocol做重映射通过_getObjc2ProtocolRefs获取到__objc_protorefs（与__objc_protolist不是同一个东西）遍历remapProtocolRef修复协议，remapProtocolRef比较当前协议和协议列表中同一内存地址的协议是否相同，如果不同则替换 1234567891011// Fix up @protocol references// Preoptimized images may have the right // answer already but we don't know for sure.// 修复协议列表引用，优化后的images可能是正确的，但是并不确定for (EACH_HEADER) { // 需要注意到是，下面的函数是_getObjc2ProtocolRefs，和上面的_getObjc2ProtocolList不一样 protocol_t **protolist = _getObjc2ProtocolRefs(hi, &amp;count); for (i = 0; i &lt; count; i++) { remapProtocolRef(&amp;protolist[i]); }} 3.8 初始化所有非懒加载的类，进行rw、ro等操作【重要】苹果官方对于非懒加载类的定义是：实现了+load方法的类是非懒加载类，否则就是懒加载类 下面是非懒加载类的加载流程: _getObjc2NonlazyClassList获取到__objc_nlclslist，取出非懒加载类 addClassTableEntry再加载一遍——如果已添加就不会添加进去，确保整个结构都被添加 realizeClassWithoutSwift是接下来要关注的地方 123456789101112131415161718192021222324252627282930313233343536373839404142// Realize non-lazy classes (for +load methods and static instances)// 实现非懒加载的类，对于load方法和静态实例变量for (EACH_HEADER) { classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); // printf(&quot;non-lazy Class:%s\\n&quot;,cls-&gt;mangledName()); if (!cls) continue; // hack for class __ARCLite__, which didn't get this above#if TARGET_OS_SIMULATOR if (cls-&gt;cache._buckets == (void*)&amp;_objc_empty_cache &amp;&amp; (cls-&gt;cache._mask || cls-&gt;cache._occupied)) { cls-&gt;cache._mask = 0; cls-&gt;cache._occupied = 0; } if (cls-&gt;ISA()-&gt;cache._buckets == (void*)&amp;_objc_empty_cache &amp;&amp; (cls-&gt;ISA()-&gt;cache._mask || cls-&gt;ISA()-&gt;cache._occupied)) { cls-&gt;ISA()-&gt;cache._mask = 0; cls-&gt;ISA()-&gt;cache._occupied = 0; }#endif addClassTableEntry(cls); if (cls-&gt;isSwiftStable()) { if (cls-&gt;swiftMetadataInitializer()) { _objc_fatal(&quot;Swift class %s with a metadata initializer &quot; &quot;is not allowed to be non-lazy&quot;, cls-&gt;nameForLogging()); } // fixme also disallow relocatable classes // We can't disallow all Swift classes because of // classes like Swift.__EmptyArrayStorage } // 实现所有非懒加载的类(实例化类对象的一些信息，例如rw) realizeClassWithoutSwift(cls); }} realizeClassWithoutSwift分析： ①rw初始化并将ro拷贝一份到rw中的ro rw表示readWrite，由于动态性，可能会往类中添加属性、方法、添加协议 ro表示readOnly，在编译时已经确定了内存 12345678910111213ro = (const class_ro_t *)cls-&gt;data();if (ro-&gt;flags &amp; RO_FUTURE) { // This was a future class. rw data is already allocated. rw = cls-&gt;data(); ro = cls-&gt;data()-&gt;ro; cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE);} else { // Normal class. Allocate writeable class data. rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; rw-&gt;flags = RW_REALIZED|RW_REALIZING; cls-&gt;setData(rw);} ②递归调用realizeClassWithoutSwift完善继承链并处理当前类的父类、元类；如果有父类，就通过addSubclass把当前类放到父类的子类列表中去 123456789101112131415if (!cls) return nil;...supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));...// Update superclass and metaclass in case of remappingcls-&gt;superclass = supercls;cls-&gt;initClassIsa(metacls);...// Connect this class to its superclass's subclass listsif (supercls) { addSubclass(supercls, cls);} else { addRootClass(cls);} supercls = realizeClassWithoutSwift(remapClass(cls-&gt;superclass));递归父类的信息初始化，出口是父类为nil。 metacls = realizeClassWithoutSwift(remapClass(cls-&gt;ISA()));递归元类的信息初始化，出口是元类的元类为自己。 if (supercls) {addSubclass(supercls, cls);} else { addRootClass(cls);}，处理class_data_bits_t成员双向绑定父类，子类。 ③remapClass中对类在表中进行查找，如果表中已有该类，则返回一个空值；如果没有则返回当前类，这样保证了类只加载一次并结束递归 123456789101112131415static Class remapClass(Class cls){ runtimeLock.assertLocked(); Class c2; if (!cls) return nil; NXMapTable *map = remappedClasses(NO); if (!map || NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) { return cls; } else { return c2; }} ④最后调用了methodizeClass 123// Attach categoriesmethodizeClass(cls);return cls; ⑤在methodizeClass中，从ro中读取方法列表（包括分类中的方法）、属性列表、协议列表写到rw中，同时也会加载分类的信息到类里面。 1234567891011121314151617181920212223242526272829...// Install methods and properties that the class implements itself.method_list_t *list = ro-&gt;baseMethods();if (list) { prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1);}property_list_t *proplist = ro-&gt;baseProperties;if (proplist) { rw-&gt;properties.attachLists(&amp;proplist, 1);}protocol_list_t *protolist = ro-&gt;baseProtocols;if (protolist) { rw-&gt;protocols.attachLists(&amp;protolist, 1);}// Root classes get bonus method implementations if they don't have // them already. These apply before category replacements.if (cls-&gt;isRootMetaclass()) { // root metaclass addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, &quot;&quot;, NO);}// Attach categories.category_list *cats = unattachedCategoriesForClass(cls, true /*realizing*/);attachCategories(cls, cats, false /*don't flush caches*/);... 为什么要区分ro和rw？ ro的特性就是在编译时就确定了。我们不希望这些原始数据被污染，所以把这些数据存到ro中 rw的特性是可变的。因为runtime的存在，所以我们会动态的添加属性、方法、协议等，所以我们把这些数据存到可更改的rw当中 前面已经提到了实现+load方法的类就是非懒加载类，那么没有实现的类就是懒加载类。 打印非懒加载类： 可以通过printf(&quot;non-lazy Class:%s\\n&quot;,cls-&gt;mangledName())去打印获取到所有非懒加载类【只有实现了+load的类才会走到这里然后被打印（FXPerson内部实现了+load，其他都是系统内置的类）】 那么懒加载类是何时加到内存中的呢？需要看下文分析。 3.9 处理所有的分类，包括Class和Metal Class将在下一篇文章中具体介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Discover categories.// 发现和处理所有Categoryfor (EACH_HEADER) { // 外部循环遍历找到当前类，查找类对应的Category数组 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) { // 内部循环遍历当前类的所有Category category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 首先，通过其所属的类注册Category。如果这个类已经被实现，则重新构造类的方法列表。 bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { // 将Category添加到对应Class的value中，value是Class对应的所有category数组 addUnattachedCategoryForClass(cat, cls, hi); // 将Category的method、protocol、property添加到Class if (cls-&gt;isRealized()) { remethodizeClass(cls); classExists = YES; } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, cls-&gt;nameForLogging(), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); } } // 这块和上面逻辑一样，区别在于这块是对Meta Class做操作，而上面则是对Class做操作 // 根据下面的逻辑，从代码的角度来说，是可以对原类添加Category的 if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) { addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) { remethodizeClass(cls-&gt;ISA()); } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, cls-&gt;nameForLogging(), cat-&gt;name); } } }} 3.10 初始化所有未初始化的类【重要】实现所有的类。包括Swift和OC，同时会初始化其他objc_class结构体相关的信息 123456789static void realizeAllClasses(void){ runtimeLock.assertLocked(); header_info *hi; for (hi = FirstHeader; hi; hi = hi-&gt;getNext()) { realizeAllClassesInImage(hi); // may drop and re-acquire runtimeLock }} 循环处理header_info，调用realizedAllClassesInImage()。 1234567891011121314151617181920static void realizeAllClassesInImage(header_info *hi){ runtimeLock.assertLocked(); size_t count, i; classref_t *classlist; if (hi-&gt;areAllClassesRealized()) return; classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) { Class cls = remapClass(classlist[i]); // 重新映射类 if (cls) { realizeClassMaybeSwiftAndLeaveLocked(cls, runtimeLock); } } hi-&gt;setAllClassesRealized(YES);} 循环调用realizeClassMaybeSwiftAndLeaveLocked函数 12345static ClassrealizeClassMaybeSwiftAndLeaveLocked(Class cls, mutex_t&amp; lock){ return realizeClassMaybeSwiftMaybeRelock(cls, lock, true);} realizeClassMaybeSwiftMaybeRelock函数真正调用的总入口 123456789101112131415161718192021static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) { // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls); // 非swift类 if (!leaveLocked) lock.unlock(); } else { // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); // swift类 assert(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); } return cls;} 通过判断是否Swift class来区分Swift和OC类的实现入口。 然后realizeClassWithoutSwift在3.8中分析过一次了。 PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS 底层探索篇·Easting iOS探索 类的加载过程","link":"/2021/01/21/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/08-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"title":"09-分类、类拓展的加载过程 &amp; load、initialize分析","text":"前言在开始正文前，先看一下runtime相关知识的运用 ro和rw衍生出来的问题1.动态创建类的时候，能否先注册到内存然后再添加成员变量？即下面2、3两步能否调换顺序？ 1234567// 这是正确顺序：// 1: 动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2: 添加成员变量 class_addIvar(LGPerson, &quot;lgName&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;);// 3: 注册到内存objc_registerClassPair(LGPerson); 答：不可以 原因： 成员变量存储在ro当中，ro在编译后就不能改了。跟属性不一样 可以通过跑源码断点调试看一下： 注册到内存的objc_registerClassPair方法中会调用changeInfo方法，改变了信息。如果在这之后调用class_addIvar方法，会走到分支中，直接返回NO，导致添加失败。因此顺序不能调换。 2.注意点：动态添加property(成员属性)后，记得要添加相应的getter和setter方法，否则给属性设值会不成功。 123456789101112131415// 1.动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2.注册到内存objc_registerClassPair(LGPerson);// 3.添加propertylg_class_addProperty(LGPerson, &quot;subject&quot;);// 4.添加setter + getter 方法class_addMethod(LGPerson, @selector(setSubject:), (IMP)lgSetter, &quot;v@:@&quot;);class_addMethod(LGPerson, @selector(subject), (IMP)lgName, &quot;@@:&quot;);// 开始使用id person = [LGPerson alloc];[person setValue:@&quot;master&quot; forKey:@&quot;subject&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;subject&quot;]); 留意这里的2、3两步，先注册到内存，然后再添加的成员属性，为什么这里就可以了？ 因为properties存储在rw当中，是可以动态改变的。 3.练习使用api-用runtime动态创建类 12345678910111213141516171819202122232425// 1: 动态创建类Class LGPerson = objc_allocateClassPair([NSObject class], &quot;LGPerson&quot;, 0);// 2: 添加成员变量 class_addIvar(LGPerson, &quot;lgName&quot;, sizeof(NSString *), log2(sizeof(NSString *)), &quot;@&quot;);// 3: 注册到内存objc_registerClassPair(LGPerson); // 3.1 添加property - rwlg_class_addProperty(LGPerson, &quot;subject&quot;);lg_printerProperty(LGPerson);// 3.2 添加setter + getter 方法class_addMethod(LGPerson, @selector(setSubject:), (IMP)lgSetter, &quot;v@:@&quot;);class_addMethod(LGPerson, @selector(subject), (IMP)lgName, &quot;@@:&quot;);// 开始使用id person = [LGPerson alloc];[person setValue:@&quot;KC&quot; forKey:@&quot;lgName&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;lgName&quot;]);[person setValue:@&quot;master&quot; forKey:@&quot;subject&quot;];NSLog(@&quot;%@&quot;,[person valueForKey:@&quot;subject&quot;]); 带注释的相关api 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 创建类对 *superClass: 父类，传Nil会创建一个新的根类 *name: 类名 *extraBytes: 0 *return:返回新类，创建失败返回Nil，如果类名已经存在，则创建失败 objc_allocateClassPair(&lt;#Class _Nullable __unsafe_unretained superclass#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t extraBytes#&gt;) *//** *添加成员变量 * *cls 往哪个类添加 *name 添加的名字 *size 大小 *alignment 对齐处理方式 *types 签名 * *这个函数只能在objc_allocateClassPair和objc_registerClassPair之前调用。不支持向现有类添加一个实例变量。 *这个类不能是元类。不支持在元类中添加一个实例变量。 *实例变量的最小对齐为1 &lt;&lt; align。实例变量的最小对齐依赖于ivar的类型和机器架构。对于任何指针类型的变量，请通过log2(sizeof(pointer_type))。 class_addIvar(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#size_t size#&gt;, &lt;#uint8_t alignment#&gt;, &lt;#const char * _Nullable types#&gt;) *//** *往内存注册类 * * cls 要注册的类 * * objc_registerClassPair(&lt;#Class _Nonnull __unsafe_unretained cls#&gt;) *//** *往类里面添加方法 * *cls 要添加方法的类 *sel 方法编号 *imp 函数实现指针 *types 签名 * *class_addMethod(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#SEL _Nonnull name#&gt;, &lt;#IMP _Nonnull imp#&gt;, &lt;#const char * _Nullable types#&gt;) *//** *往类里面添加属性 * *cls 要添加属性的类 *name 属性名字 *attributes 属性的属性数组。 *attriCount 属性中属性的数量。 * *class_addProperty(&lt;#Class _Nullable __unsafe_unretained cls#&gt;, &lt;#const char * _Nonnull name#&gt;, &lt;#const objc_property_attribute_t * _Nullable attributes#&gt;, &lt;#unsigned int attributeCount#&gt;) */ 一、初探懒加载类上一章我们探索了 iOS 中类的加载，让我们简单回顾一下大概的流程。 1.1 类的加载回顾 libObjc 向 dyld 注册了回调 _dyld_objc_notify_register，当 dyld 把 App 以及 App 所依赖的一系列 Mach-O 镜像加载到当前 App 被分配的内存空间之后，dyld 会通过 _dyld_objc_notify_mapped 也就是 map_images来通知 libObjc 来完成具体的加载工作，map_images 被调用之后会来到 _read_images _read_images 主要会进行类的加载工作，会插入 所有的类 到 gdb_objc_realized_classes 哈希表中（插入方式为 类名为 key，类对象为value, 不包括通过 共享缓存 里面的类），这个表的类型为 NXMapTable，可以类比为 NSDictionary；同时还会把类插入到 allocatedClasses 这个集合里面，集合的类型为 NXHashTable，可以类比为 NSSet。 对所有的类进行重映射 将所有的 SEL 插入到 namedSelectors 哈希表中(插入方式为：SEL 名称为 key，SEL 为value) 修复函数指针遗留 将所有的 Protocol 插入到 readProtocol 哈希表中(插入方式为：Protocol 名称为 key，Protocol 为 value) 对所有的 Protocol 做重映射 初始化所有的非懒加载类，包括 rw 和 ro 的初始化操作 处理所有的分类(包括类的分类和元类的分类) 1.2 验证类的加载流程我们大致明白了类的加载流程，接下来，让我们在 _read_images 源码中打印一下类加载之后的结果验证一下是否加载了我们自己创建的类。 准备代码：有三个非常纯净的类： LGPerson 、 LGStudent 、 LGTeacher 其中 LGStudent 和 LGTeacher 内部实现了 +load 方法。而 LGPerson 没有实现 +load 方法。 如上图所示，我们增加一行代码: 1printf(&quot;_getObjc2NonlazyClassList Class:%s\\n&quot;,cls-&gt;mangledName()); 接着我们观察打印结果: 1.3 懒加载类的发现我们这个时候观察 _read_images 源码这部分的注释: Realize non-lazy classes (for +load methods and static instances) 实现非懒加载类(实现了 +load 方法和静态实例) 意思就是没有实现 +load 方法的类就是**懒加载类，这种类并不会在 **_read_images 环节被加载。我们自己实现了 +load 方法的两个类和其他系统内置的类由于是非懒加载类，所以会在这里打印。 那么懒加载类应该是在哪里加载呢？我们稍微思考一下，我们一般第一次操作一个类是不是在初始化这个类的时候，而初始化类不就是发送 alloc 消息吗，而根据我们前面探索消息查找的知识，在第一次发送某个消息的时候，是没有缓存的，所以会走消息的慢速查找过程，然后就来到一个非常重要的方法：lookUpImpOrForward ，我们在 main.m 中 LGPerson 类初始化的地方和 lookUpImpOrForward 入口处打上断点: Tips: 这里有个小技巧，我们先打开 main.m 文件中lookUpImpOrForward 处的断点的断点，等断点来到了我们想要探索的 LGPerson 初始化的位置的时候，我们再打开 lookUpImpOrForward 处的断点，这样才能确保当前执行 lookUpImpOrForward 的是我们的研究对象 LGPerson 因为我们断点的位置是 LGPerson 类发送 alloc 消息，而显然 alloc 作为类方法是存储在元类上的，也就是说 lookUpImpOrForward 的 cls 其实是 LGPerson 元类。那么 inst 就应该是真正的LGPerson类对象，可实际如下图所示：（未初始化所以看不出是哪个类） 此时的 inst 只是一个地址，说明还没有初始化。我们让程序接着下面走，会来到这样一行代码: 这里的 if 判断通过方法名我们不难看出是只有当 cls 未实现的时候才会走里面的realizeClassMaybeSwiftAndLeaveLocked 方法，那也就是说 LGPerson 元类没有被实现，也就是 LGPerson 类没有实现或者说没有被加载。 我们就顺着 realizeClassMaybeSwiftAndLeaveLocked 方法往下面走走看，看到底是在哪把我们这个懒加载类给加载出来的: 123456789101112131415161718192021static ClassrealizeClassMaybeSwiftMaybeRelock(Class cls, mutex_t&amp; lock, bool leaveLocked){ lock.assertLocked(); if (!cls-&gt;isSwiftStable_ButAllowLegacyForNow()) { // Non-Swift class. Realize it now with the lock still held. // fixme wrong in the future for objc subclasses of swift classes realizeClassWithoutSwift(cls); if (!leaveLocked) lock.unlock(); } else { // Swift class. We need to drop locks and call the Swift // runtime to initialize it. lock.unlock(); cls = realizeSwiftClass(cls); assert(cls-&gt;isRealized()); // callback must have provoked realization if (leaveLocked) lock.lock(); } return cls;} 我们一路跟随断点来到了 realizeClassMaybeSwiftMaybeRelock 方法，然后我们看到了我们熟悉的一个方法 realizeClassWithoutSwift ，这个方法内部会进行 ro/rw 的赋值操作以及 category 的 attatch ，关于这个方法更多内容可以查看上一篇文章。 接着我们返回到 lookUpImpOrForward 方法中来，然后进行一下 LLDB 打印，看一下当前这个 inst 也就是 LGPerson 对象是否已经被加载了。 通过上面的打印，我们可以看到 rw 已经有值了，也就是说 LGPerson 类被加载了。 总结： 如果类没有实现 load 方法，那么这个类就是懒加载类（用到再加载） 如果类实现了 load 方法，那么这个类就是非懒加载类（提前加载）。 调用堆栈如下图所示： 1.4 懒加载类的流程关于非懒加载类的加载流程我们已经很熟悉了，我们总结下懒加载类的流程： 类第一次发送消息的时候是没有缓存的，所以会来到 _class_lookupMethodAndLoadCache3 （这个方法在05-方法的本质和消息查找流程已经分析过了） _class_lookupMethodAndLoadCache3 会调用 lookUpImpOrForward ，这个方法在学习 Runtime 的过程中非常重要！ lookUpImpOrForward 内部会进行一下判断，如果 cls 没有被实现，会调用 realizeClassMaybeSwiftAndLeaveLocked 方法 realizeClassMaybeSwiftAndLeaveLocked 方法又会调用 realizeClassMaybeSwiftMaybeRelock 方法 realizeClassMaybeSwiftMaybeRelock 方法内部会进行一下是否是 Swift 的判断，如果不是 Swift 环境的话，就会来到 realizeClassWithoutSwift ，最终懒加载的类就在这里加载 二、分类的底层实现类分为懒加载类和非懒加载类，分类同样分为懒加载分类和非懒加载分类。在研究分类之前，我们首先需要了解下分类的底层实现。 2.1 重写分类源文件首先准备一份LGTeacher+test.m文件： 在终端中用 clang 命令重写这个分类文件为c++文件： 1clang -rewrite-objc LGTeacher+test.m -o category.cpp 然后查看 category.cpp 这个文件，来到文件尾部可以看到: 123456789static struct _category_t _OBJC_$_CATEGORY_LGTeacher_$_test __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = { &quot;LGTeacher&quot;, 0, // &amp;OBJC_CLASS_$_LGTeacher, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_LGTeacher_$_test, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_LGTeacher_$_test, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_LGTeacher_$_test,}; 可以看到 LGTeacher+test 分类在底层的实现是一个结构体，其名字为 _OBJC_$_CATEGORY_LGTeacher_$_test ，很明显这是一个按规则生成的符号，中间的 LGTeacher 是类名，后面的 test 是分类的名字。 同时，我们在后面可以看到如下的代码： 123static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= { &amp;_OBJC_$_CATEGORY_LGTeacher_$_test,}; 这表明分类是存储在 __DATA 段的 __objc_catlist section 里面的。 2.2 分类的定义我们根据 _category_t 来到 libObjc 源码中进行查找，不过我们需要去掉一下 _category_t 的下划线，然后不难找到分类真正的定义所在： 1234567891011121314151617struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);}; 根据刚才 clang 重写之后的内容，我们不难看出 name : 是分类所关联的类，也就是类的名字，而不是分类的名字 cls : 我们在前面可以看到 clang 重写后这个值为 0，但是后面有注释为 &amp;OBJC_CLASS_$_LGTeacher ，也就是我们的类对象的定义，所以这里其实就是我们要扩展的类对象，只是在编译期这个值并不存在 instanceMethods : 分类上存储的实例方法 classMethods ：分类上存储的类方法 protocols ：分类所实现的协议 instanceProperties ：分类所定义的实例属性，不过我们一般在分类中添加属性都是通过关联对象来实现的 _classProperties ：分类所定义的类属性。 三、分类的加载我们现在知道了类分为了 懒加载类 和 非懒加载类 ，它们的加载时机是不一样的，分类同样分为懒加载分类和非懒加载分类。 分类必须依附于类而存在，如果只有分类，没有类，那么从逻辑上是说不通的，就算实现了，编译器也会忽略掉。 接下来开始研究： 3.1 懒加载分类没有实现 load 的分类-&gt;没有提前加载，所以是懒加载分类。 3.1.1 懒加载分类 + 懒加载类也就是类和分类都不实现 load 方法的情况。 懒加载类前面分析过了，在向类第一次发送消息的时候，懒加载类才会开始加载。 懒加载分类探索：在 realizeClassWithoutSwift 方法的最后有一个 methodizeClass 方法，在这个方法里面会有一个 Attach categories 的地方，猜测懒加载分类是不是在这里加载了？ 但是我们断点之后发现这个时候通过 unattachedCategoriesForClass 方法并没有取到分类。此时通过 LLDB 打印一下当前类里面是否已经把分类的内容附加上了。前面的流程大家都很熟悉了，我们直接看 cls 的 rw 中的 methods 是否有内容： 此时 LGTeacher 类里面是没有方法的，这里读取 rw 却有一个结果，我们不难看出这是位于 LGTeacher+test 分类中的一个 initialize 方法，这个方法是我手动加到这个分类的。 这样进一步证明了，如果是懒加载类，并且分类也是懒加载，那么分类的加载并不会来到 unattachedCategoriesForClass ，而是直接在编译时加载到了类的 ro 里面，然后在运行时被拷贝到了类的 rw 里面。这一点可以通过下面的 LLDB 打印来证明。 突然想起来，不是在 _read_images 的最后那块有一个 Discover categories 吗，万一懒加载分类是在这里加载的呢？我们一试便知： 这里在 Discover categories 内部做了一下判断，如果是 LGTeacher 类进来了，就打印一下，结果发现并没有打印，说明分类也不是在这里被加载的，是在编译时直接加载的。 3.1.2 懒加载分类+非懒加载类非懒加载类当类为非懒加载类的时候，同样是走 _read_images =&gt;Realize non-lazy classes=&gt;realizeClassWithoutSwift=&gt;methodizeClass。 懒加载分类我们直接在 methodizeClass 方法中打上断点，并做了一下简单的判断: 12345const char *cname = ro-&gt;name;const char *oname = &quot;LGTeacher&quot;;if (strcmp(cname, oname) == 0) { printf(&quot;methodizeClass :%s \\n&quot;,cname);} 结果可以看到cats为空，所以分类不在这进行添加。 同时通过 LLDB 打印，发现分类的方法已经在类的 ro 里面了，说明懒加载的分类在编译时期就被加载了。 3.1.3 懒加载分类总结 懒加载分类的初始化其实跟类的懒加载与否并没有关系，也就是说懒加载的分类都是在编译时期被加载的。 懒加载类和非懒加载类还是1.3中所述的流程。 3.2 非懒加载分类实现了 load 的分类-&gt;提前加载，所以是非懒加载分类 他和类配合加载分下面两种情况： 非懒加载分类与懒加载类 非懒加载分类和非懒加载类 3.2.1 非懒加载分类 + 懒加载类懒加载的类我们前面已经知道了，是在第一次发送消息的时候才会被加载的，那我们直接在lookupImpOrForward =&gt;realizeClassMaybeSwiftAndLeaveLocked =&gt; realizeClassMaybeSwiftMaybeRelock =&gt; realizeClassWithoutSwift =&gt; methodizeClass 流程中的 methodizeClass 打上断点，看下在这里分类会不会被加载： 这一次通过 unattachedCategoriesForClass 取出来值了，并且在这之前 cls 的 ro 中并没有分类的 initialize 方法： 但是我们注意观察此时的调用堆栈： 为什么走的是 load_images 里面的 prepare_load_methods 方法呢？我们来到 prepare_load_methods 方法处： 可以看到，其实在这里调用了 realizeClassWithoutSwift 方法来提前加载类。 而上面的 _getObjc2NonlazyCategoryList 方法显示就是获取到所有的非懒加载分类，然后遍历这些非懒加载分类，然后去加载这些分类所依赖的类。 这个逻辑很好理解，非懒加载分类让我们的懒加载类实现提前了，所以说懒加载类并不一定只会在第一次消息发送的时候加载，还要取决于有没有非懒加载的分类，如果有非懒加载的分类，那么类就是在 load_images =&gt; prepare_load_methods =&gt; realizeClassWithoutSwift 加载的。 分类的加载在类加载之后的 methodizeClass。 3.2.2 非懒加载分类 + 非懒加载类非懒加载类的流程我们也十分熟悉了，在 _read_images 里面进行加载。而此时，分类也是非懒加载。我们还是在 methodizeClass 里面进行断点： 结果如上图所示，这次从 unattachedCategoriesForClass 方法取出来的是 NULL 值，显然分类不是在这个地方被加载的，我们回到 _read_images 方法，还记得那个 Discover categories 流程吗，我们打开里面的断点： 因为当前类已经在前面的非懒加载类加载流程中被加载完成，所以这里会来到 remethodizeClass 方法，我们进入其内部实现： 1234567891011121314151617181920static void remethodizeClass(Class cls){ category_list *cats; bool isMeta; runtimeLock.assertLocked(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) { if (PrintConnecting) { _objc_inform(&quot;CLASS: attaching categories to class '%s' %s&quot;, cls-&gt;nameForLogging(), isMeta ? &quot;(meta)&quot; : &quot;&quot;); } attachCategories(cls, cats, true /*flush caches*/); free(cats); }} 可以看到有一个 attachCategories 方法，断点也确实来到了这个地方，所以非懒加载分类在这里加载。 3.2.3 非懒加载分类总结 非懒加载分类 + 懒加载类 类的加载在 load_images 处 ，分类的加载在类加载之后的 methodizeClass 非懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载在类加载之后的 reMethodizeClass 3.3 总结分类的加载其实可以笼统的分为实现 load 方法和没有实现 load 方法： 没有实现 load 方法的分类（不需提前加载-懒加载分类）由编译时确定 实现了 load 方法的分类（需提前加载-非懒加载分类）由运行时去确定 这也说明分类的加载和类的加载是不一样的，而结合着类的懒加载与否，我们有以下的结论： 懒加载分类 + 懒加载类 类的加载在第一次消息发送的时候，而分类的加载则在编译时 懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载还是在编译时 非懒加载分类 + 懒加载类 类的加载在 load_images 内部，分类的加载在类加载之后的 methodizeClass 非懒加载分类 + 非懒加载类 类的加载在 _read_images 处，分类的加载在类加载之后的 reMethodizeClass 四、类拓展的加载类拓展extension又称作匿名的分类，为了给当前类增加属性和方法 具体有两种形式： 直接在.m文件中新增类拓展 新建类拓展的.h文件 4.1 类拓展的加载数据很早的时候都会来到_read_image，在这里断点分析一下： 但是仔细一想不对呀，已经在类中有了方法实现了，此时的do_hExtension不足以说明问题 那么可以通过查看属性的setter和getter方法来验证 在来到_read_image方法之前就有了相应的getter和setter，说明 类拓展在编译时便作为类的一部分进行编译，存到类的ro中 4.2 类拓展的细节点如果类拓展没有被引用（#import）-在代码中没有被用到，就不会编译到到内存中 五、load_image分析上篇文章讲到dyld初始化image会触发load_image，本文又提到了懒加载类和非懒加载分类情况下，分类加载到内存时的调用栈中有load_image，那么我们在该种情况下进行探索。 在load_image实现处打下断点，发现类和分类都没有打印+load方法——load_image先于+load方法 接着把目光移向两条注释： Discover load methods——prepare_load_methods Call +load methods——call_load_methods 5.1 prepare_load_methods发现并准备+load方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void prepare_load_methods(const headerType *mhdr){ size_t count, i; runtimeLock.assertLocked(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { schedule_class_load(remapClass(classlist[i])); } category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) { category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class if (cls-&gt;isSwiftStable()) { _objc_fatal(&quot;Swift class extensions and categories on Swift &quot; &quot;classes are not allowed to have +load methods&quot;); } realizeClassWithoutSwift(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); }}/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls){ if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); }/************************************************************************ add_class_to_loadable_list* Class cls has just become connected. Schedule it for +load if* it implements a +load method.**********************************************************************/void add_class_to_loadable_list(Class cls){ IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; // Don't bother if cls has no +load method if (PrintLoading) { _objc_inform(&quot;LOAD: class '%s' scheduled for +load&quot;, cls-&gt;nameForLogging()); } if (loadable_classes_used == loadable_classes_allocated) { loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); } loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;} prepare_load_methods分析： 通过_getObjc2NonlazyClassList获取非懒加载类列表 通过schedule_class_load遍历这些类 递归调用遍历父类的+load方法，确保父类的+load方法顺序排在子类的前面 调用add_class_to_loadable_list把类的+load方法存在loadable_classes里面 调用_getObjc2NonlazyCategoryList取出非懒加载分类列表 遍历分类列表 通过realizeClassWithoutSwift来防止类没有初始化（若已经初始化了则不影响） 调用add_category_to_loadable_list加载分类中的+load方法到loadable_categories 此时就能看懂之前懒加载类和非懒加载分类的函数调用栈了 5.2 call_load_methods唤醒+load方法 1234567891011121314151617181920212223242526272829void call_load_methods(void){ static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do { // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) { call_class_loads(); } // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories } while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;} 通过objc_autoreleasePoolPush压栈一个自动释放池 do-while循环开始 循环调用类的+load方法直到找不到为止 调用一次分类中的+load方法 通过objc_autoreleasePoolPop出栈一个自动释放池 5.3 关于load方法我们需要知道的 load方法在main函数前调用 如果一个类实现了load方法，在调用这个方法前会先调用父类的load方法 因为加载时间特别早，所以可以利用这个特性进行一些特殊处理 六、initalize分析关于initalize苹果文档是这么描述的 1.在类或者其子类的第一个方法被调用前（发送消息前）调用2.父类的调用在子类之前补充：通常应该在里面判断当前要初始化的类，防止多次调用 然后我们在objc源码中lookUpImpOrForward找到了它的踪迹 lookUpImpOrForward-&gt;initializeAndLeaveLocked-&gt;initializeAndMaybeRelock-&gt;initializeNonMetaClass 1234567891011121314151617181920212223IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver){ ... if (initialize &amp;&amp; !cls-&gt;isInitialized()) { cls = initializeAndLeaveLocked(cls, inst, runtimeLock); ... } ...}static Class initializeAndLeaveLocked(Class cls, id obj, mutex_t&amp; lock){ return initializeAndMaybeRelock(cls, obj, lock, true);}static Class initializeAndMaybeRelock(Class cls, id inst, mutex_t&amp; lock, bool leaveLocked){ ··· initializeNonMetaClass(nonmeta); ···} 在initializeNonMetaClass递归调用父类的initialize，然后调用callInitialize 12345678910111213141516171819202122/************************************************************************ class_initialize. Send the '+initialize' message on demand to any* uninitialized class. Force initialization of superclasses first.**********************************************************************/void initializeNonMetaClass(Class cls){ ... supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) { initializeNonMetaClass(supercls); } ... { callInitialize(cls); if (PrintInitializing) { _objc_inform(&quot;INITIALIZE: thread %p: finished +[%s initialize]&quot;, pthread_self(), cls-&gt;nameForLogging()); } } ...} callInitialize是一个普通的消息发送 12345void callInitialize(Class cls){ ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); asm(&quot;&quot;);} 总结 initialize在类或者其子类的第一个方法被调用前（发送消息前）调用 只在类中添加initialize但不使用的情况下，是不会调用initialize 父类的initialize方法会比子类先执行 当子类未实现initialize方法时，会调用父类initialize方法；子类实现initialize方法时，会覆盖父类initialize方法 当有多个分类都实现了initialize方法，会覆盖类中的方法，只执行一个(会执行最后被加载到内存中的分类的方法) 七、相关面试题7.1 类拓展和分类的区别①区别： 类拓展可以添加属性(编译器会帮助我们生成属性对应的get和set方法)，方法 分类只能添加方法，通常不能添加属性（添加的话需要使用关联对象） 原因： 类拓展在编译时完成加载，数据写入到ro中； 而分类在运行时加载，所以数据写入到rw中，没有实现对应的set和get方法，所以无法将属性的值赋值进去，也无法取到。 ②类拓展在代码实现形式有2种方式，第一种写到所在本类的.m文件中，第二种另一个单写一个.h文件。 常用第一种： 第二种： **③加载时机的区别： ** 在类的加载过程中—read_images处设置断点，运行进入断点，打印发现ro中包含类拓展的属性和相应的get，set方法，可以判断出类拓展在编译时就加载了。而此时类加载后没有分类的信息，由此可以判断分类是在运行时加载进来的。 下图断点信息图： 下图ro中查找信息图： ④类拓展和分类的区别 研究对象 加载时机 操作对象 能否通过@property声明属性生成 getter 和 setter 分类(实现了load方法) 运行时 rw 不能，需要借助关联对象来实现 分类(没有实现load方法) 编译时 ro 不能，需要借助关联对象来实现 类拓展 编译时 ro 可以 7.2 分类中可以通过关联对象添加属性7.2.1 关联对象的定义和基本使用 通过使用关联引用，你可以在不修改类声明的前提下为对象添加内容。如果你无权访问该类的源代码，或者由于二进制兼容性原因而无法更改该对象的布局，则这可能很有用。 关联引用机制基于 key。对于任何对象，你都可以根据需要添加任意数量的关联引用，每个关联都使用不同的 key。 从苹果官方文档可以看到，关联引用其实不是只能在分类中使用，只不过对于我们日常开发来说，分类中使用关联引用还是更常用的场景。关联对象使用起来很简单，不外乎两个方法： 12345// 设置关联对象objc_setAssociatedObject()// 获取关联对象objc_getAssociatedObject() 我们如果要给一个分类中的属性设置关联对象，需要重写属性的 setter 方法，然后使用 objc_setAssociatedObject： 123- (void)setXXX:(关联值数据类型)关联值 objc_setAssociatedObject(self, 关联的key, 关联值, 关联对象内存管理策略);} 然后还需要重写 getter 方法，然后使用 objc_getAssociatedObject： 123- (关联值数据类型)关联值{ return objc_getAssociatedObject(self, 关联的key);} 这其中的关联对象内存管理策略如下表所示： 关联策略 等同的 @property 描述 OBJC_ASSOCIATION_ASSIGN @property (assign) 或 @property (unsafe_unretained) 指定一个关联对象的弱引用。 指定一个关联对象的弱引用。 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (nonatomic, strong) 指定一个关联对象的强引用，不能被原子化使用。 OBJC_ASSOCIATION_COPY_NONATOMIC @property (nonatomic, copy) 指定一个关联对象的copy引用，不能被原子化使用。 OBJC_ASSOCIATION_RETAIN @property (atomic, strong) 指定一个关联对象的强引用，能被原子化使用。 OBJC_ASSOCIATION_COPY @property (atomic, copy) 指定一个关联对象的copy引用，能被原子化使用。 7.2.3 关联对象的底层原理总结图： objc_setAssociatedObject1234// objc-runtime.mmvoid objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) { _object_set_associative_reference(object, (void *)key, value, policy);} objc_setAssociatedObject 方法的实现又包裹了一层，其实现为 _object_set_associative_reference 分析_object_set_associative_reference方法，直接看添加注释后的代码就能明白： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // This code used to work when nil was passed for object and key. Some code // probably relies on that to not crash. Check and handle it explicitly. // rdar://problem/44094390 // 容错处理 if (!object &amp;&amp; !value) return; assert(object); // 判断要进行关联的对象是否禁用掉了关联引用 if (object-&gt;getIsa()-&gt;forbidsAssociatedObjects()) _objc_fatal(&quot;objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects&quot;, object, object_getClassName(object)); // retain the new value (if any) outside the lock. // 初始化一个 ObjcAssociation 对象，用于持有原有的关联对象 ObjcAssociation old_association(0, nil); // 判断传入的关联对象值是否存在 id new_value = value ? acquireValue(value, policy) : nil; { // 关联对象的管理类 AssociationsManager manager; // 获取关联的 HashMap -&gt; 存储当前关联对象 AssociationsHashMap &amp;associations(manager.associations()); // 对当前对象的地址做按位取反操作 - 就是 HashMap 的key (哈希函数) disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; // 根据key去获取关联属性的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; // 替换设置新值 j-&gt;second = ObjcAssociation(policy, new_value); } else { // 到最后了——直接设置新值 (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). // 如果AssocistionsHashMap没有对象的关联信息表 // 那么就创建一个map并通过传入的key把value存进去 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); } } else { // setting the association to nil breaks the association. // 如果传入的value是nil，并且之前使用相同的key存储过关联对象， // 那么就把这个关联的value移除（这也是为什么传入nil对象能够把对象的关联value移除） AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). // 最后把之前使用传入的这个key存储的关联的value释放（OBJC_ASSOCIATION_SETTER_RETAIN策略存储的） if (old_association.hasValue()) ReleaseValue()(old_association);} objc_getAssociatedObject123id objc_getAssociatedObject(id object, const void *key) { return _object_get_associative_reference(object, (void *)key);} 同样也是包装了一层，分析_object_get_associative_reference方法： 1234567891011121314151617181920212223242526272829303132id _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { // 关联对象的管理类 AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); // 生成伪装地址。处理参数 object 地址 disguised_ptr_t disguised_object = DISGUISE(object); // 所有对象的额迭代器 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // 还没到最后就找到了 ObjectAssociationMap *refs = i-&gt;second; // 内部对象的迭代器 ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { // 找到 - 把值和策略读取出来 ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); // 如果策略是 OBJC_ASSOCIATION_GETTER_RETAIN - 就会持有一下 if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) { objc_retain(value); } } } } if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { objc_autorelease(value); } return value;} objc_removeAssociatedObjectsobjc_removeAssociatedObjects 方法我们平时可能用的不多，这个方法是用来删除关联对象。我们来到它的定义处： 123456void objc_removeAssociatedObjects(id object) { if (object &amp;&amp; object-&gt;hasAssociatedObjects()) { _object_remove_assocations(object); }} 分析_object_remove_assocations方法： 123456789101112131415161718192021222324252627void _object_remove_assocations(id object) { vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; { // 关联对象的管理类 AssociationsManager manager; // 获取关联的 HashMap -&gt; 存储当前关联对象 AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; // 对当前对象的地址做按位取反操作 disguised_ptr_t disguised_object = DISGUISE(object); // 获取 AssociationsHashMap 的迭代器 - (对象的) 进行遍历 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // 还没到最后找到了 // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) { elements.push_back(j-&gt;second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. // 这里会将对象包含的所有关联对象加入到一个 `vector` 中，然后对所有的 `ObjcAssociation` 对象调用 `ReleaseValue()` 方法，释放不再被需要的值 for_each(elements.begin(), elements.end(), ReleaseValue());} PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS 底层探索 - 分类的加载 iOS探索 分类、类拓展的加载过程 iOS 底层探索 - 类拓展和关联对象","link":"/2021/01/25/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/09-%E5%88%86%E7%B1%BB%E3%80%81%E7%B1%BB%E6%8B%93%E5%B1%95%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"},{"title":"10-底层面试答疑","text":"一、什么是 Runtime答：用 C、C++、汇编实现的一套 API，为 OC 语言加入了面向对象和运行时的功能。 应用举例： 类的 ro 和 rw 属性，ro(read-only)在编译期就确定好了，而 rw(read-write)是在运行时才完全赋值。 二、方法的本质是什么答：方法的本质就是消息的发送，就是在底层调用_objc_msgSennd方法寻找方法IMP的过程，主要经历了以下几个步骤： 快速查找流程：通过汇编（objc_msgSend）查找cache_t中缓存的消息，找到就返回imp，找不到就进行慢速查找。 慢速查找流程：通过函数lookUpImpOrForward递归查找当前类和父类的缓存和方法列表，如果找到了就会缓存方法方便快速查找，找不到就会进行动态方法解析 动态方法解析：此时OC会给我们一次对sel的处理机会，你可以在resolveInstanceMethod:（类方法对应resolveClassMethod:）中添加一个IMP 如果你没把握住这次机会，也就是解析失败时，会来到消息转发阶段，这个阶段有两个机会去处理sel，分别是快速转发的forwardingTargetForSelector:，以及慢速转发的methodSignatureForSelector:。 消息快速转发：forwardingTargedForSelector，如果有处理，就交给处理的对象来实现，没有就交给其他对象处理，进入慢速转发阶段。 消息慢速转发：methodSignatureForSelector，进行方法签名，把方法丢出去，forwardInvocation来对消息处理。 未找到消息：无法找到IMP，就进入到了doesNotRecognizeSelector报错，打印log 三、sel 是什么？IMP 是什么？两者之间的关系？答： SEL是方法编号，也是方法名，在dyld加载镜像带内存时，通过_read_image方法加载到内存的表中了 IMP 就是我们函数实现指针 ，找IMP就是找函数的过程 函数就是对应的实现内容 四、能否向运⾏时创建的类中添加成员变量？答：不能。 原因： 1234567891011121314151617181920struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 ...} 12345678910111213struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; // 方法列表 property_array_t properties; // 属性列表 protocol_array_t protocols; // 协议列表 ...} 因为我们编译好的成员变量存储的位置在类的ro中，⼀旦编译完成，内存结构就完全确定⽆法修改，只能修改类的rw中的方法或者可以通过关联对象的方式来添加属性。 关联对象添加的主要步骤如下： objc_setAssociatedObject设置set方法：找到关联对象的总哈希表，然后通过指针地址找到该类的哈希表，然后通过key值进行存储 objc_getAssociatedObject设置get方法：和set方法一样查询表，找到值 在类的dealloc会清除关联对象的哈希表 五、isKindOfClass 和 isMemberOfClass的区别答：当调用者对象是实例对象时：【常用】 -isKindOfClass：判断调用者对象是否是xx类以及他的子类的实例-isMemberOfClass：判断调用者对象是否是xx类的实例 当调用者对象是类对象时：【可忽略】 +isKindOfClass：判断当前类对象的元类对象及其父类的元类对象是否等于传入的对象 +isMemberOfClass：判断当前类对象的元类对象是否等于传入的这个对象 原理探究：举例： 1.消息接收者是实力对象-&gt;调用对象方法 12345BOOL re5 = [(id)[NSObject alloc] isKindOfClass:[NSObject class]]; // 1BOOL re6 = [(id)[NSObject alloc] isMemberOfClass:[NSObject class]]; // 1BOOL re7 = [(id)[LGPerson alloc] isKindOfClass:[LGPerson class]]; // 1BOOL re8 = [(id)[LGPerson alloc] isMemberOfClass:[LGPerson class]]; // 1NSLog(@&quot; re5 :%hhd\\n re6 :%hhd\\n re7 :%hhd\\n re8 :%hhd\\n&quot;,re5,re6,re7,re8); 上述Log的打印结果为1，0，0，0 2.消息接收者是类对象-&gt;调用类方法 12345BOOL re1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; // 1BOOL re2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; // 0BOOL re3 = [(id)[LGPerson class] isKindOfClass:[LGPerson class]]; // 0BOOL re4 = [(id)[LGPerson class] isMemberOfClass:[LGPerson class]]; // 0NSLog(@&quot; re1 :%hhd\\n re2 :%hhd\\n re3 :%hhd\\n re4 :%hhd\\n&quot;,re1,re2,re3,re4); 上述Log的打印结果为1，1，1，1 对于第1个例子，大家都使用的非常熟练，但是对于第2个例子的打印结果就有些纳闷了。我们发现两个例子的主要区别在于消息接受者是实例对象还是类对象。 其实这两个方法是有对应的类方法和实例方法的，只不过我们平时不使用类方法而已，查看源码： 123456789101112/************************************************************************ object_getClass.* Locking: None. If you add locking, tell gdb (rdar://7516456).**********************************************************************/// object_getClass()方法取得的是对象的isa指针指向的对象// 对于对象来说就是获取到他的类// 对于类对象来说就是获取到他的元类Class object_getClass(id obj){ if (obj) return obj-&gt;getIsa(); else return Nil;} 12345678910111213141516171819202122232425// 判断当前类对象的元类对象是否与传入的这个对象相等，所以这个cls应该是元类对象才有可能为 true+ (BOOL)isMemberOfClass:(Class)cls {return object_getClass((id)self) == cls;}// 判断当前实例对象的类对象是否与传入的对象相等，所以cls只有可能是类对象才有可能相等- (BOOL)isMemberOfClass:(Class)cls {return [self class] == cls;}// 循环判断当前类对象的元类对象及其父类的元类对象是否等于传入的cls+ (BOOL)isKindOfClass:(Class)cls { for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;}// 循环判断当前实例对象的父类的类对象是否等于传入的对象cls，也就是判断实例对象是否是cls及其子类的一种- (BOOL)isKindOfClass:(Class)cls { for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO;} 所以，如果方法调用者是实例对象，那么传入的就应该是类对象；如果方法调用者是类对象，那么传入的就应该是元类对象。 六、[self class]、[super class]、[self superclass]的区别以及原理分析结论 class:获取当前方法调用者的类 superclass:获取当前方法调用者的父类 super:是一个结构体，结构体中消息接收者还是当前对象，所以就会让当前对象去调用父类方法，本质还是当前对象在调用 例创建一个Student类继承子Person类，查看打印： 1234NSLog(@&quot;[self class] = %@&quot;, [self class]); // [self class] = StudentNSLog(@&quot;[super class] = %@&quot;, [super class]); // [super class] = StudentNSLog(@&quot;[self superclass] = %@&quot;, [self superclass]); // [self superclass] = PersonNSLog(@&quot;[super superclass] = %@&quot;, [super superclass]);// [super superclass] = Person 原理先上源码看一下第一个和第三个的理解 1234567891011121314151617181920212223242526272829303132 // object_getClass()方法取得的是对象的isa指针指向的对象 // 对于对象来说就是获取到他的类 // 对于类对象来说就是获取到他的元类 Class object_getClass(id obj) { if (obj) return obj-&gt;getIsa(); else return Nil; } + (Class)class { return self; } - (Class)class { return object_getClass(self); } + (Class)superclass { return self-&gt;superclass; } - (Class)superclass { return [self class]-&gt;superclass; }Class class_getSuperclass(Class cls){ if (!cls) return nil; return cls-&gt;superclass;} 我们知道，这里方法中的self都是指消息的接受者，在这里就表示Student类，根据以上源码，第一个和第三个没啥疑问，都是寻找Student的isa和父类。 那么super调用时，有啥不同，我们需要先知道super的本质 通过clang编译代码，我们可以发现，底层调用时super调用的方法不是msgSend,而是objc_msgSendSuper(object ,superclass, @selector(class))，传入了一个super的结构体和方法。 我们知道消息发送的时候，慢速查找流程是需要从自身递归查找到NSObject的，而objc_msgSendSuper就表示直接从消息接受者的父类开始递归查找，跳过了本身的方法列表，这样查找的速度可以更快。 super的结构体如下 1234struct objc_super { __unsafe_unretained _Nonnull id receiver; __unsafe_unretained _Nonnull Class super_class;}; 两个参数分别为消息的接受者和父类，在这里Student即为消息接受者,Person为父类. 所以调用[super class]和[super superclass]本质上消息的接受者还是self，即Student类。所以就跟第一个和第三个结果没有区别。 小结[self class] 就是发送消息objc_msgSend，消息接受者是 self,⽅法编号：class [super class] 本质就是objc_msgSendSuper, 消息的接受者还是 self ⽅法编号：class(父类的) 只是objc_msgSendSuper 会更快 直接跳过 self 的查找,但是都会走到NSObject基类的实现方法中，但是都是以self为接受者 七、Runtime 是如何实现 weak 的，为什么可以⾃动置 nil？主要总结如下： 通过SideTable找到我们的weak_table weak_table 根据referent 找到或者创建 weak_entry_t 然后append_referrer(entry, referrer)将新弱引⽤的对象加进去entry 最后weak_entry_insert 把entry加⼊到我们的weak_table 在类dealloc时，会根据插入的步骤找到对应的弱引用，并置为nil 关于weak的相关知识做了单独的总结，详情可以看下方文章👇 11-weak原理探究 八、Method Swizzling 的坑与应⽤详情可以看下面的文章： 12-Method Swizzling的坑与应用 参考iOS底层学习 - Runtime之砖厂面试答疑","link":"/2021/02/16/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/10-%E5%BA%95%E5%B1%82%E9%9D%A2%E8%AF%95%E7%AD%94%E7%96%91/"},{"title":"12-Method Swizzling的坑与应用","text":"一、方法的本质Objective-C中，方法是由SEL和IMP组成的，前者叫做方法编号，后者叫方法实现。OC中调用方法叫做发送消息，发送消息前会先查找消息，查找过程就是通过SEL查找IMP的过程，另外，我们经常在代码中使用@selector(someMethod)这样的语法，@selector()叫做方法选择器，其返回的就是SEL，真正执行时会根据这个SEL查找对应的IMP。 二、MethodSwizzling 原理比如有方法sel1对应imp1，sel2对应imp2，经过方法交换，使得runtime在方法查找时将sel1的查找结果变为imp2： ￼ 三、Method Swizzling 相关函数 API1234567891011121314151617// 通过SEL获取一个方法class_getInstanceMethod// 获取一个方法的实现method_getImplementation// 获取一个OC实现的编码类型method_getTypeEncoding// 给方法添加实现class_addMethod// 用一个方法的实现替换另一个方法的实现class_replaceMethod// 交换两个方法的实现method_exchangeImplementations 四、简单示例新建一个iOS工程，新建一个Person类，并为Person添加两个方法-walk和-run： 123456789101112131415161718192021// Person.h@interface Person : NSObject- (void)walk;- (void)run;@end// Person.m@implementation Person- (void)walk { NSLog(@&quot;walk&quot;);}- (void)run { NSLog(@&quot;run&quot;);}@end 新建一个NSObject的分类MethodSwizzling如下： 12345678910111213141516171819// NSObject+MethodSwizzling.h@interface NSObject (MethodSwizzling)+ (void)methodswizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL;@end// NSObject+MethodSwizzling.m#import &lt;objc/runtime.h&gt;@implementation NSObject (MethodSwizzling)+ (void)methodswizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL { Method orgMethod = class_getInstanceMethod(cls, orgSEL); Method tgtMethod = class_getInstanceMethod(cls, targetSEL); method_exchangeImplementations(orgMethod, tgtMethod);}@end 在Person.m中重写+load方法： 12345678+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self methodswizzlingWithClass:self orgSEL:@selector(walk) targetSEL:@selector(run)]; });} 在ViewController的-viewDidLoad中调用-walk： 12345- (void)viewDidLoad { [super viewDidLoad]; Person *person = [[Person alloc] init]; [person walk];} 运行程序，控制台输出如下： 12020-02-09 21:26:07.613230+0800 TestObjC[1716:74628] run 调用的是-walk，实际执行的是-run，完成了方法交换。 五、坑点5.1 交换方法后再调用 load 方法第一个坑点比较简单，就是我们在load中交换完方法后，不做处理的话，如果再去调用load，方法IMP会又被交换回来，导致交换不成功。 解决的方法也比较简单：使用单例模式来交换方法，保证方法的交换只执行一次 5.2 在继承的类中进行方法交换导致交换的结果和预期不一致具体描述是：在子类中交换它独有的方法和继承自父类的方法，子类交换是成功了，但是父类中的方法也被交换了。 使用的时候多注意一下。 例： 123456789101112131415161718Person.h @interface Person : NSObject- (void)walk;@end Person.m@implementation Person- (void)walk { NSLog(@&quot;walk&quot;);}@end 123456789101112131415161718192021222324252627282930313233Student.h@interface Student : Person- (void)study;@end Student.m@implementation Student- (void)study { NSLog(@&quot;study&quot;);}+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ [self methodSwizzlingWithClass:self orgSEL:@selector(walk) targetSEL:@selector(study)]; });}+ (void)methodSwizzlingWithClass:(Class)cls orgSEL:(SEL)orgSEL targetSEL:(SEL)targetSEL { Method orgMethod = class_getInstanceMethod(cls, orgSEL); Method tgtMethod = class_getInstanceMethod(cls, targetSEL); method_exchangeImplementations(orgMethod, tgtMethod);}@end 123456789// Student 类中方法交换成功了Student *s = [Student new];[s walk]; // study[s study]; // walk// 但是顺便也把父类给交换了（这是我们不需要的，多注意）Person *p = [Person new];[p walk]; // study 5.3 要交换的方法未实现时会交换失败还是上面的例子，如果 Student 类中，只声明了 -study 方法，但是未实现，再交换 -walk 方法和 -study 方法就会交换失败，还是之前的老样子，这点也要注意（不过正常人写不出这种代码） 六、常见应用6.1 埋点统计6.1.1 页面浏览事件在 iOS 开发中最常见的三种埋点，就是对页面进入次数、页面停留时间、点击事件的埋点。这些都可以通过Method Swizzling来实现。 通过交换UIViewController中viewWillAppear和viewWillDisappear的方法，来实现了进入界面和退出界面的统计，并记录了相关的类名，通过映射的关系，就可以清楚的知道用户的行为了。 12345678910111213141516171819202122232425262728293031323334353637383940414243@implementation UIViewController (logger)+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ // 通过 @selector 获得被替换和替换方法的 SEL，作为 SMHook:hookClass:fromeSelector:toSelector 的参数传入 SEL fromSelectorAppear = @selector(viewWillAppear:); SEL toSelectorAppear = @selector(hook_viewWillAppear:); [SMHook hookClass:self fromSelector:fromSelectorAppear toSelector:toSelectorAppear]; SEL fromSelectorDisappear = @selector(viewWillDisappear:); SEL toSelectorDisappear = @selector(hook_viewWillDisappear:); [SMHook hookClass:self fromSelector:fromSelectorDisappear toSelector:toSelectorDisappear]; });}- (void)hook_viewWillAppear:(BOOL)animated { // 先执行插入代码，再执行原 viewWillAppear 方法 [self insertToViewWillAppear]; [self hook_viewWillAppear:animated];}- (void)hook_viewWillDisappear:(BOOL)animated { // 执行插入代码，再执行原 viewWillDisappear 方法 [self insertToViewWillDisappear]; [self hook_viewWillDisappear:animated];}- (void)insertToViewWillAppear { // 在 ViewWillAppear 时进行日志的埋点 [[[[SMLogger create] message:[NSString stringWithFormat:@&quot;%@ Appear&quot;,NSStringFromClass([self class])]] classify:ProjectClassifyOperation] save];}- (void)insertToViewWillDisappear { ✅/ 在 ViewWillDisappear 时进行日志的埋点 [[[[SMLogger create] message:[NSString stringWithFormat:@&quot;%@ Disappear&quot;,NSStringFromClass([self class])]] classify:ProjectClassifyOperation] save];}@end 6.1.2 控件点击事件那么点击方法，我们也可以通过运行时进行方法替换实现无侵入埋点。 原理： 当我们为一个控件添加 Target-Action 后，用户操作控件（比如点击）时，首先会调用-sendAction:to:forEvent:方法，并将事件转发给应用程序的 UIApplication 对象。（UIApplication 类中对应的是-sendAction:from:forEvent:方法） 如果 Target 不为空，应用程序会让该对象调用对应的方法响应事件；如果 Target 为空，应用程序会在响应链中搜索定义了该方法的对象，然后执行该方法。 因此我们可以通过 Method Swizzling 交换 UIApplication 类中的-sendAction:from:forEvent:方法，然后在交换后的方法中触发采集事件。 完整代码： 123456789101112131415161718192021222324#import &quot;UIApplication+XWTracking.h&quot;#import &quot;XWTrackingAnalysisSDK.h&quot;#import &quot;NSObject+XWSwizzler.h&quot;#import &quot;UIView+XWTracking.h&quot;@implementation UIApplication (XWTracking)+ (void)load { [UIApplication xwtracking_swizzleMethod:@selector(sendAction:to:from:forEvent:) withMethod:@selector(xwtracking_sendAction:to:from:forEvent:)];}- (BOOL)xwtracking_sendAction:(SEL)action to:(nullable id)target from:(nullable id)sender forEvent:(nullable UIEvent *)event { // UITabBarItem继承自NSObject，不过滤会崩溃 BOOL condition = ((event.allTouches.anyObject.phase == UITouchPhaseEnded) || [sender isKindOfClass:UISwitch.class] || [sender isKindOfClass:UISegmentedControl.class] || [sender isKindOfClass:UIStepper.class]) &amp;&amp; !([sender isKindOfClass:UITabBarItem.class] || [sender isKindOfClass:UIBarButtonItem.class]); if (condition) { // 触发$AppClick事件 [XWTrackingAnalysisSDK.shareInstance trackAppClickWithView:sender properties:nil]; } // 调用原有实现 return [self xwtracking_sendAction:action to:target from:sender forEvent:event];}@end 和 UIViewController生命周期埋点不同的是，UIButton在一个视图类中可能有多个不同的继承类，相同 UIButton的子类在不同视图类的埋点也要区别开： 123456789101112131415- (void)trackAppClickWithView:(UIView *)view properties:(NSDictionary&lt;NSString *,id&gt; *)properties { NSMutableDictionary *eventProperties = [NSMutableDictionary dictionary]; // 获取控件类型 eventProperties[@&quot;$element_type&quot;] = view.xwtracking_elementType; // 获取控件显示文本 eventProperties[@&quot;$element_content&quot;] = view.xwtracking_elementContent; // 获取控件所在的 UIViewController UIViewController *vc = view.xwtracking_viewController; // 设置页面相关属性 eventProperties[@&quot;$screen_name&quot;] = NSStringFromClass(vc.class); // 添加自定义属性 [eventProperties addEntriesFromDictionary:properties]; // 触发$AppClick事件 [XWTrackingAnalysisSDK.shareInstance track:@&quot;$AppClick&quot; properties:eventProperties];} 除了 UIViewController、UIButton 控件以外，Cocoa 框架的其他控件都可以使用这种方法来进行无侵入埋点。以 Cocoa 框架中最复杂的 UITableView 控件为例，你可以使用 hook setDelegate 方法来实现无侵入埋点。另外，对于 Cocoa 框架中的手势事件（Gesture Event），我们也可以通过 hook initWithTarget:action:方法来实现无侵入埋点。 6.2 防止数组，字典等越界崩溃数组越界等是最容易造成crash的一种方式，而且一般崩溃起来比较严重，所以我们要尽量避免。 在iOS中NSNumber、NSArray、NSDictionary等这些类都是类簇(Class Clusters)，一个NSArray的实现可能由多个类组成。所以如果想对NSArray进行Swizzling，必须获取到其真身进行Swizzling，直接对NSArray进行操作是无效的。这是因为Method Swizzling对NSArray这些的类簇是不起作用的。 因为这些类簇类，其实是一种抽象工厂的设计模式。抽象工厂内部有很多其它继承自当前类的子类，抽象工厂类会根据不同情况，创建不同的抽象对象来进行使用。例如我们调用NSArray的objectAtIndex:方法，这个类会在方法内部判断，内部创建不同抽象类进行操作。 所以如果我们对NSArray类进行Swizzling操作其实只是对父类进行了操作，在NSArray内部会创建其他子类来执行操作，真正执行Swizzling操作的并不是NSArray自身，所以我们应该对其“真身”进行操作。 下面列举了NSArray和NSDictionary本类的类名，可以通过Runtime函数取出本类： 类名 真身 NSArray __NSArrayI NSMutableArray __NSArrayM NSDictionary __NSDictionaryI NSMutableDictionary __NSDictionaryM 6.2.1 处理 NSArrayNSArray+CrashHandle.h 1234567891011121314151617//// NSArray+CrashHandle.h// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSArray (CrashHandle)@endNS_ASSUME_NONNULL_END NSArray+CrashHandle.m 123456789101112131415161718192021222324252627282930313233343536//// NSArray+CrashHandle.m// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &quot;NSArray+CrashHandle.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSArray (CrashHandle)// 如果下面代码不起作用，造成这个问题的原因大多都是其调用了super load方法。在下面的load方法中，不应该调用父类的load方法。这样会导致方法交换无效+ (void)load { Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(xw_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);}- (id)xw_objectAtIndex:(NSUInteger)index { if (index &gt; self.count - 1) { // 数组越界 @try { return [self xw_objectAtIndex:index]; } @catch (NSException *exception) { // 在崩溃后会打印崩溃信息。如果是线上，可以在这里将崩溃信息发送到服务器 NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; } @finally {} } else { // 如果没有问题，则正常进行方法调用 return [self xw_objectAtIndex:index]; }}@end 12345678910**************************调用******************************- (void)viewDidLoad { [super viewDidLoad]; // 测试代码 NSArray *array = @[@0, @1, @2, @3]; [array objectAtIndex:3]; //本来要奔溃的，但是没有，打印出了信息 [array objectAtIndex:4];} 6.2.2 处理 NSMutableArrayNSMutableArray+CrashHandle.h 1234567891011121314151617//// NSMutableArray+CrashHandle.h// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSMutableArray (CrashHandle)@endNS_ASSUME_NONNULL_END NSMutableArray+CrashHandle.m 12345678910111213141516171819202122232425262728293031323334//// NSMutableArray+CrashHandle.m// Test14//// Created by IMO on 2020/10/10.// Copyright © 2020 IMO. All rights reserved.//#import &quot;NSMutableArray+CrashHandle.h&quot;#import &lt;objc/runtime.h&gt;@implementation NSMutableArray (CrashHandle)+ (void)load { Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(xw_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);}- (id)xw_objectAtIndex:(NSUInteger)index { if (index &gt; self.count - 1) { // 数组越界 @try { return [self xw_objectAtIndex:index]; } @catch (NSException *exception) { NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; } @finally {} } else { return [self xw_objectAtIndex:index]; }}@end 以上的两个例子，只是开发中常用的，还有很多其他的应用，就需要根据需求来不断调整了。这些都属于 AOP 面向切面编程的一个实际应用，Method Swizzling 也是其在 iOS 开发中应用的最常用的一种 AOP 思想 参考iOS底层学习 - Runtime之Method Swizzling黑魔法 Objective-C 的 MethodSwizzling","link":"/2021/02/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/12-Method%20Swizzling%E7%9A%84%E5%9D%91%E4%B8%8E%E5%BA%94%E7%94%A8/"},{"title":"11-weak原理探究","text":"内存管理在APP开发过程中占据着一个很重要的地位，在iOS中，系统为我们提供了ARC的开发环境，帮助我们做了很多内存管理的内容。本章我们先来看一下，平时开发中使用最多的weak在底层是如何进行实现的 一、__strong、__weak、__unsafe_unretained的区别我们通过例子来看一下__strong、__weak、__unsafe_unretained的区别。 首先是看如下例子，可以知道在临时作用域结束之后，生成的对象就会进行销毁，我们在作用域外部用修饰符来持有对象，再来看一下对象的销毁情况 123456789101112NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person);}NSLog(@&quot;临时作用域结束&quot;);***************************打印结果******************************2020-01-19 10:57:13.910542+0800 objc-debug[74175:19740208] 临时作用域开始2020-01-19 10:57:13.911181+0800 objc-debug[74175:19740208] person对象：&lt;LGPerson: 0x10221c900&gt;2020-01-19 10:57:13.911277+0800 objc-debug[74175:19740208] LGPerson -[LGPerson dealloc]2020-01-19 10:57:13.911367+0800 objc-debug[74175:19740208] 临时作用域结束 __strong先来看一下用__strong修饰的结果。可以发现修饰的对象在作用域结束之后并没有销毁，说明该对象的引用计数增加了 123456789101112131415__strong LGPerson *strongPerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); strongPerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;strongPerson：%@&quot;, strongPerson);***************************打印结果******************************2020-01-19 11:54:44.079292+0800 objc-debug[74452:19777011] 临时作用域开始2020-01-19 11:54:44.080060+0800 objc-debug[74452:19777011] person对象：&lt;LGPerson: 0x101945ae0&gt;2020-01-19 11:54:44.080172+0800 objc-debug[74452:19777011] 临时作用域结束2020-01-19 11:54:44.080292+0800 objc-debug[74452:19777011] strongPerson：&lt;LGPerson: 0x101945ae0&gt; __weak再来看一下__weak修饰的结果。通过下面的运行我们可以发现，用__weak修饰后，并没有增加引用计数，并且作用域结束，对象释放后，修饰的对象为nil，没有造成野指针的崩溃，可以说是一种安全的方案 12345678910111213141516__weak LGPerson *weakPerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); weakPerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;weakPerson：%@&quot;, weakPerson);***************************打印结果******************************2020-01-19 11:58:08.842409+0800 objc-debug[74479:19780263] 临时作用域开始2020-01-19 11:58:08.843151+0800 objc-debug[74479:19780263] person对象：&lt;LGPerson: 0x101712030&gt;2020-01-19 11:58:08.843382+0800 objc-debug[74479:19780263] LGPerson -[LGPerson dealloc]2020-01-19 11:58:08.843572+0800 objc-debug[74479:19780263] 临时作用域结束2020-01-19 11:58:08.843762+0800 objc-debug[74479:19780263] weakPerson：(null) __unsafe_unretained最后我们来看一下，平时开发使用较少的__unsafe_unretained和上面两个的区别在哪。我们通过结果可以发现，在作用域消失，对象就进行了销毁，并且在出作用域打印修饰对象时，出现了野指针的崩溃EXC_BAD_ACCESS 所以这样就看出了__weak和__unsafe_unretained的区别就是前者会在对象被释放的时候自动置为nil，而后者却不行。 123456789101112131415__unsafe_unretained LGPerson *unsafePerson;NSLog(@&quot;临时作用域开始&quot;);{ LGPerson *person = [[LGPerson alloc] init]; NSLog(@&quot;person对象：%@&quot;, person); unsafePerson = person;}NSLog(@&quot;临时作用域结束&quot;);NSLog(@&quot;unsafePerson：%@&quot;, unsafePerson);***************************打印结果******************************2020-01-19 12:02:34.428120+0800 objc-debug[74513:19785153] 临时作用域开始2020-01-19 12:02:34.428813+0800 objc-debug[74513:19785153] person对象：&lt;LGPerson: 0x1019159f0&gt;2020-01-19 12:02:34.428901+0800 objc-debug[74513:19785153] LGPerson -[LGPerson dealloc]2020-01-19 12:02:34.429015+0800 objc-debug[74513:19785153] 临时作用域结束 小结 __strong修饰后，对象的引用计数会增加，在作用域外不会销毁 __weak修饰后，对象引用计数不会增加，在作用域外会自动置为nil __unsafe_unretained修饰后，引用计数不会增加，在作用域外不会置空，会造成野指针崩溃 通过上面例子基本了解了__weak的作用，那么__weak是如何进行创建和销毁的呢，下面通过源码进行深度探索 二、weak 代码定位打断点查看汇编 在汇编中发现weak底层调用的是objc_initWeak 我们给objc_initWeak打上符号断点重新运行，发现objc_initWeak存在于libobjc.A.dylib的动态库中。 三、weak 的保存逻辑通过上面的分析我们把 weak 的创建定位到了objc_initWeak这个方法，下面开始进行源码分析 objc_initWeak其中两个参数location和newObj的含义如下 location：表示__weak 指针的地址。之所以要存储指针的地址，是因为最后我们要讲__weak指针指向的内容置为nil，如果仅存储指针的话，是不能够完成这个功能的。 newObj：所引用的对象。 1234567891011idobjc_initWeak(id *location, id newObj){ if (!newObj) { *location = nil; return nil; } return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);} storeWeak查看storeWeak源码，根据注释，可以知道如下几点 HaveOld：weak指针之前是否已经指向了一个弱引用 HaveNew：weak指针是否需要指向一个新引用 CrashIfDeallocating：如果被弱引用的对象正在析构，此时再弱引用该对象，是否应该crash。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111// Update a weak variable.// If HaveOld is true, the variable has an existing value // that needs to be cleaned up. This value might be nil.// If HaveNew is true, there is a new value that needs to be // assigned into the variable. This value might be nil.// If CrashIfDeallocating is true, the process is halted if newObj is // deallocating or newObj's class does not support weak references. // If CrashIfDeallocating is false, nil is stored instead.enum CrashIfDeallocating { DontCrashIfDeallocating = false, DoCrashIfDeallocating = true};template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj){ assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: // ✅如果weak指针之前弱引用过一个obj，则将这个obj所对应的SideTable取出，赋值给oldTable if (haveOld) { oldObj = *location; oldTable = &amp;SideTables()[oldObj]; } else { // 没有弱引用过，则oldTable = nil oldTable = nil; } // ✅如果weak指针要弱引用一个新的obj，则将该obj对应的SideTable取出，赋值给newTable if (haveNew) { newTable = &amp;SideTables()[newObj]; } else { newTable = nil; } // ✅加锁操作，防止多线程中竞争冲突 SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); // ✅多线程安全：location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (haveOld &amp;&amp; *location != oldObj) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; } // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) { Class cls = newObj-&gt;getIsa(); // ✅如果cls还没有初始化，先初始化，再尝试设置弱引用 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) { SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); class_initialize(cls, (id)newObj); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. // ✅完成初始化后进行标记 previouslyInitializedClass = cls; // ✅newObj 初始化后，重新获取一遍newObj goto retry; } } // Clean up old value, if any. // ✅ 如果weak指针之前弱引用过别的对象oldObj，则调用weak_unregister_no_lock，在oldObj的weak_entry_t中移除该weak指针地址 if (haveOld) { weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); } // Assign new value, if any. // ✅如果weak指针需要弱引用新的对象newObj if (haveNew) { // ✅调用weak_register_no_lock方法，将weak指针的地址记录到newObj对应的weak_entry_t中 newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. // ✅更新newObj的isa指针的weakly_referenced bit标志位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) { newObj-&gt;setWeaklyReferenced_nolock(); } // Do not set *location anywhere else. That would introduce a race. // ✅*location 赋值，也就是将weak指针直接指向了newObj，而且没有将newObj的引用计数+1 *location = (id)newObj; } else { // No new value. The storage is not changed. } SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;} 因为我们这里是第一次调用，所以是一个新的对象，也就是haveNew的情况，获取到的是新的散列表SideTable，主要执行了weak_register_no_lock方法来进行插入。 weak_register_no_lock接着我们来分析weak_register_no_lock函数是怎么注册弱引用的。 我们发现函数内部主要进行了isTaggedPointer和deallocating的判断等前置条件，这些都是不能进行弱引用的情况。 如果可以被弱引用，则将被弱引用对象所在的weak_table中的weak_entry_t哈希数组中取出对应的weak_entry_t，如果weak_entry_t不存在，则会新建一个。然后将指向被弱引用对象地址的指针referrer通过函数append_referrer插入到对应的weak_entry_t引用数组。至此就完成了弱引用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * Registers a new (object, weak pointer) pair. Creates a new weak * object entry if it does not exist. * * @param weak_table The global weak table. * @param referent The object pointed to by the weak reference. * @param referrer The weak pointer address. */id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating){ // ✅首先获取需要弱引用对象 objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; // ✅如果被弱引用对象referent为nil 或者被弱引用对象采用了TaggedPointer计数方式，则直接返回 if (!referent || referent-&gt;isTaggedPointer()) return referent_id; // ensure that the referenced object is viable // ✅确保被引用的对象可用（没有在销毁，同时应该支持weak弱引用） bool deallocating; if (!referent-&gt;ISA()-&gt;hasCustomRR()) { deallocating = referent-&gt;rootIsDeallocating(); } else { BOOL (*allowsWeakReference)(objc_object *, SEL) = (BOOL(*)(objc_object *, SEL)) object_getMethodImplementation((id)referent, SEL_allowsWeakReference); if ((IMP)allowsWeakReference == _objc_msgForward) { return nil; } deallocating = ! (*allowsWeakReference)(referent, SEL_allowsWeakReference); } // ✅如果是正在销毁的对象，那么不能够被弱引用 if (deallocating) { if (crashIfDeallocating) { _objc_fatal(&quot;Cannot form weak reference to instance (%p) of &quot; &quot;class %s. It is possible that this object was &quot; &quot;over-released, or is in the process of deallocation.&quot;, (void*)referent, object_getClassName((id)referent)); } else { return nil; } } // now remember it and where it is being stored // ✅在 weak_table 中找到被弱引用对象 referent 对应的 weak_entry,并将 referrer 加入到 weak_entry 中 weak_entry_t *entry; if ((entry = weak_entry_for_referent(weak_table, referent))) { // ✅如果能找到 weak_entry,则讲 referrer 插入到 weak_entry 中 append_referrer(entry, referrer); } else { // ✅如果找不到 weak_entry，就新建一个 weak_entry_t new_entry(referent, referrer); weak_grow_maybe(weak_table); weak_entry_insert(weak_table, &amp;new_entry); } // Do not set *referrer. objc_storeWeak() requires that the // value not change. return referent_id;} append_referrer这一步主要是找到弱引用对象的对应的weak_entry哈希数组中，基本就是个遍历插入的过程，原理比较简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152static void append_referrer(weak_entry_t *entry, objc_object **new_referrer){ // ✅如果weak_entry 使用静态数组 inline_referrers if (! entry-&gt;out_of_line()) { // Try to insert inline. // ✅尝试将 referrer 插入数组 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i] == nil) { entry-&gt;inline_referrers[i] = new_referrer; return; } } // Couldn't insert inline. Allocate out of line. // ✅如果inline_referrers的位置已经存满了，则要转型为 referrers，动态数组 weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // This constructed table is invalid, but grow_refs_and_insert // will fix it and rehash it. for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { new_referrers[i] = entry-&gt;inline_referrers[i]; } entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; } assert(entry-&gt;out_of_line()); // ✅如果动态数组中元素个数大于或等于数组总空间的3/4，则扩展数组空间为当前长度的一倍，然后将 referrer 插入数组 if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) { return grow_refs_and_insert(entry, new_referrer); } // ✅如果不需要扩容，直接插入到weak_entry中 // ✅&amp; (entry-&gt;mask) 保证 begin 的位置只能大于或等于数组的长度 size_t begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t index = begin; size_t hash_displacement = 0; while (entry-&gt;referrers[index] != nil) { hash_displacement++; index = (index+1) &amp; entry-&gt;mask; if (index == begin) bad_weak_table(entry); } if (hash_displacement &gt; entry-&gt;max_hash_displacement) { entry-&gt;max_hash_displacement = hash_displacement; } weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; entry-&gt;num_refs++;} weak_unregister_no_lock如果weak指针在指向obj之前，已经弱引用了其他的对象，则需要先将weak指针从其他对象的weak_entry_t的hash数组中移除。在storeWeak方法中会调用weak_unregister_no_lock函数来做移除操作。 weak_unregister_no_lock函数首先会在weak_table中找出以前被弱引用的对象referent对应的weak_entry_t，在weak_entry_t中移除被弱引用的对象referrer。移除元素后，判断此时weak_entry_t中是否还有元素。如果此时weak_entry_t已经没有元素了，则需要将weak_entry_t从weak_table中移除。 12345678910111213141516171819202122232425262728293031323334353637383940voidweak_unregister_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id){ // 拿到以前弱引用的对象和对象的地址 objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; if (!referent) return; // 查找到以前弱引用的对象 referent 所对应的 weak_entry_t if ((entry = weak_entry_for_referent(weak_table, referent))) { // 在以前弱引用的对象 referent 所对应的 weak_entry_t 的 hash 数组中，移除弱引用 referrer remove_referrer(entry, referrer); // 移除元素之后， 要检查一下 weak_entry_t 的 hash 数组是否已经空了 bool empty = true; if (entry-&gt;out_of_line() &amp;&amp; entry-&gt;num_refs != 0) { empty = false; } else { for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) { if (entry-&gt;inline_referrers[i]) { empty = false; break; } } } // 如果 weak_entry_t 的hash数组已经空了，则需要将 weak_entry_t 从 weak_table 中移除 if (empty) { weak_entry_remove(weak_table, entry); } } // Do not set *referrer = nil. objc_storeWeak() requires that the // value not change.} 至此，一个对象的弱引用过程已经结束 四、weak 的销毁逻辑通过开头的例子，我们知道，出作用域，对象dealloc后，会自动把弱引用对象置空，那么他是怎么实现的，我们可以简单查看下类的dealloc的源码： _objc_rootDealloc123456789101112131415161718192021222324252627282930313233343536373839- (void)dealloc { _objc_rootDealloc(self);}**********************************void _objc_rootDealloc(id obj){ assert(obj); obj-&gt;rootDealloc();}***********************************inline voidobjc_object::rootDealloc(){ // ✅如果是Tagged Pointer，就直接返回 if (isTaggedPointer()) return; // fixme necessary? /* ✅如果同时满足 1. 是优化过的isa、 2. 没有被weak指针引用过、 3. 没有关联对象、 4. 没有C++析构函数、 5. 没有sideTable， 就可以直接释放内存free() */ if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; !isa.has_assoc &amp;&amp; !isa.has_cxx_dtor &amp;&amp; !isa.has_sidetable_rc)) { assert(!sidetable_present()); free(this); } else { //否则的话就需要通过下面的函数处理 object_dispose((id)this); }} 我们这里显然不满足上述条件，因为我们弱引用过，继续跟进object_dispose object_disposeobject_dispose函数中调用了objc_destructInstance 1234567891011id object_dispose(id obj){ if (!obj) return nil; objc_destructInstance(obj); free(obj); return nil;} objc_destructInstance我们可以看到内部会做销毁C++析构函数以及移除关联对象的操作，看来弱引用要在clearDeallocating中了 123456789101112131415161718void *objc_destructInstance(id obj) { if (obj) { // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. // 如果有C++析构函数，则运行相关函数 if (cxx) object_cxxDestruct(obj); // 如果有关联对象，则移除所有的关联对象，并将其自身从Association Manager的map中移除 if (assoc) _object_remove_assocations(obj); // 继续清理其它相关的引用 obj-&gt;clearDeallocating(); } return obj;} clearDeallocating12345678910111213141516inline void objc_object::clearDeallocating(){ if (slowpath(!isa.nonpointer)) { // Slow path for raw pointer isa. // 如果要释放的对象没有采用了优化过的isa引用计数 sidetable_clearDeallocating(); } else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) { // Slow path for non-pointer isa with weak refs and/or side table data. // ✅ 如果要释放的对象采用了优化过的isa引用计数，并且有弱引用或者使用了sideTable的辅助引用计数（现在一般都是优化过的 isa） clearDeallocating_slow(); } assert(!sidetable_present());} clearDeallocating_slow我们现在一般都是使用优化的 isa ，所以走clearDeallocating_slow函数。 我们通过源码可以看到主要操作是找到对应的SideTable，然后在SideTable的weak_table中，将弱引用对象置空，主要的方法为weak_clear_no_lock 123456789101112131415161718NEVER_INLINE voidobjc_object::clearDeallocating_slow(){ assert(isa.nonpointer &amp;&amp; (isa.weakly_referenced || isa.has_sidetable_rc)); // 在全局的SideTables中，以this指针(要释放的对象)为key，找到对应的SideTable SideTable&amp; table = SideTables()[this]; table.lock(); if (isa.weakly_referenced) { // ✅ 要释放的对象被弱引用了，通过weak_clear_no_lock函数将指向该对象的弱引用指针置为nil weak_clear_no_lock(&amp;table.weak_table, (id)this); } // 使用了sideTable的辅助引用计数,直接在SideTable中擦除该对象的引用计数 if (isa.has_sidetable_rc) { table.refcnts.erase(this); } table.unlock();} weak_clear_no_lock我们通过源码可以看到，这个方法和插入时的方法比较类似，都是找到对应的weak_entry_t数组，然后通过遍历找到对应的指针地址，然后置为nil，防止了野指针的报错 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { // 获取被弱引用对象的地址 objc_object *referent = (objc_object *)referent_id; // 根据对象地址找到被弱引用对象 referent 在 weak_table 中对应的 weak_entry_t weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { /// XXX shouldn't happen, but does with mismatched CF/objc //printf(&quot;XXX no entry for clear deallocating %p\\n&quot;, referent); return; } // zero out references weak_referrer_t *referrers; size_t count; // 找出弱引用该对象的所有 weak 指针地址数组 if (entry-&gt;out_of_line()) { referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); } else { referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; } // 遍历取出每个 weak 指针的地址 for (size_t i = 0; i &lt; count; ++i) { objc_object **referrer = referrers[i]; if (referrer) { // 如果weak指针确实弱引用了对象 referent，则将weak指针设置为nil if (*referrer == referent) { *referrer = nil; } // 如果所存储的weak指针没有弱引用对象 referent，这可能是由于runtime代码的逻辑错误引起的，报错 else if (*referrer) { _objc_inform(&quot;__weak variable at %p holds %p instead of %p. &quot; &quot;This is probably incorrect use of &quot; &quot;objc_storeWeak() and objc_loadWeak(). &quot; &quot;Break on objc_weak_error to debug.\\n&quot;, referrer, (void*)*referrer, (void*)referent); objc_weak_error(); } } } weak_entry_remove(weak_table, entry);} 至此，一个弱引用的销毁也完成了，并自动置为nil 五、总结 当一个对象obj被weak指针指向时，这个weak指针会以obj作为key，被存储到sideTable类的weak_table这个散列表上对应的一个weak指针数组里面。 当一个对象obj的dealloc方法被调用时，Runtime会以obj为key，从sideTable的weak_table散列表中，找出对应的weak指针列表，然后将里面的weak指针逐个置为nil。 创建流程简图 创建流程小结Runtime维护了一个弱引用表，将所有弱引用obj的指针地址都保存在obj对应的weak_entry_t中。 创建时，先从找到全局散列表SideTables中对应的弱引用表weak_table 在weak_table中被弱引用对象的referent中创建或者插入对应的weak_entry_t 然后append_referrer(entry, referrer)将我的新弱引⽤的对象加进去entry 最后weak_entry_insert 把entry加⼊到我们的weak_table 销毁流程简图 销毁流程小结 首先根据对象地址获取所有weak指针地址的数组 然后遍历这个数组把对应的数据清空置为nil 同时，将weak_entry_t移除出弱引用表weak_table。 PSobjc4-756.2源码本文使用：objc4-756.2源码 进行分析 参考iOS底层学习 - 内存管理之weak原理探究 iOS weak实现原理","link":"/2021/02/17/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/11-weak%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/"},{"title":"WKWebview 白屏问题处理","text":"一、问题描述WKWebview 载入过程中有概率会出现整个 webview 空白的情况，我们分析认为这属于 iOS 系统的 bug，猜测大概或许有可能maybe出现的原因是网页重定向过多或者其他各种原因。 虽然是系统 bug，但还是要我们自己去解决。 二、尝试解决实验一：在 webViewWebContentProcessDidTerminate 回调函数中处理实验过程： 博客摘录： 1当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用`-webViewWebContentProcessDidTerminate:`回调函数，然后在该函数里执行`[webView reload]`去解决白屏问题。 实验结果： 页面即将白屏的时候并不走上面的代理方法。而且跟 WKWebView 内存占用没任何关系，因为我直接在 MacBook Pro with M1 chip 上跑真机也会出现白屏问题，使用电脑16 GB内存，足够大了。 实验二：在 webViewWebContentProcessDidTerminate 回调函数中处理实验过程： 博客摘录： 1当h5页面即将白屏时，会调用`-(void)webViewWebContentProcessDidTerminate:`方法，我们只需在这个方法中重新加载webview即可 实验结果： 页面即将白屏的时候并不走上面的代理方法。实验过程中发现出现白屏问题时有时候会调用：didFailNavigation:方法，并且当时的报错是重定向过多。但是有时候又不走didFailNavigation这个方法，所以也不能在这里去处理。 实验二：检测 webView.title 是否为空实验过程： 在-viewWillAppear的时候检测webView.title，如果为空则reload页面。 实验结果： 所有页面在-viewWillAppear的时候webView.title都为空，因为页面都没加载完，方案就有问题，所以 pass。 实验三：js 注入资源加载错误检测代码实验过程： 注入下面的 js 代码，监测到出错就重新加载网页 123456789101112// 监控资源加载错误(img,script,css,以及jsonp)，出错就重新加载window.addEventListener('error', function (e) { console.log(&quot;===&quot; + e.message + &quot;===&quot;); location.reload();}, true);window.onerror = function (errorMessage, scriptURI, lineNumber, columnNumber, errorObj) { console.log(&quot;错误信息：&quot;, errorMessage); console.log(&quot;出错文件：&quot;, scriptURI); console.log(&quot;出错行号：&quot;, lineNumber); console.log(&quot;出错列号：&quot;, columnNumber); console.log(&quot;错误详情：&quot;, errorObj);} 实验结果： 注入 js 代码后会出现页面无限重载问题，而且后续我们分析页面白屏是 iOS 系统问题，那么把问题的检测交给 H5 去做显然是不合理也不对的。 三、最终方案：像素遍历，纯白像素超过阈值就重新载入参考字节跳动团队的解决方案，采用在网页加载完毕后对当前 webview 的可视区域截图，并对此快照进行像素点遍历，如果纯白色像素所占百分比超过阈值，则认为出现白屏，然后让当前页面重新加载的方式去处理。 3.1 获取快照ios官方提供了简易的获取webview快照接口，通过异步回调拿到当前可视区域的屏幕截图。 1- (void)takeSnapshotWithConfiguration:(nullable WKSnapshotConfiguration *)snapshotConfiguration completionHandler:(void (^)(UIImage * _Nullable snapshotImage, NSError * _Nullable error))completionHandler API_AVAILABLE(ios(11.0)); 其中snapshotConfiguration参数可用于配置快照大小范围，默认截取当前客户端整个屏幕区域。当然要剔除导航栏，因为一般导航栏的颜色都是自定义的颜色，非纯白，会干扰检测结果。 12345678910111213141516- (void)judgeLoadingStatus:(WKWebView *)webview { if (@available(iOS 11.0, *)) { if (webView &amp;&amp; [webView isKindOfClass:[WKWebView class]]) { // 状态栏高度 CGFloat statusBarHeight = [[UIApplication sharedApplication] statusBarFrame].size.height; // 导航栏高度 CGFloat navigationHeight = webView.viewController.navigationController.navigationBar.frame.size.height; // ✅仅截图检测导航栏以下部分内容 WKSnapshotConfiguration *shotConfiguration = [[WKSnapshotConfiguration alloc] init]; shotConfiguration.rect = CGRectMake(0, statusBarHeight + navigationHeight, _webView.bounds.size.width, (_webView.bounds.size.height - navigationHeight - statusBarHeight)); [_webView takeSnapshotWithConfiguration:shotConfiguration completionHandler:^(UIImage * _Nullable snapshotImage, NSError * _Nullable error) { //todo }]; } }} 3.2 缩放快照 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度。 1234567891011121314- (UIImage *)scaleImage:(UIImage *)image { CGFloat scale = 0.2; CGSize newsize; newsize.width = floor(image.size.width * scale); newsize.height = floor(image.size.height * scale); if (@available(iOS 10.0, *)) { UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:newsize]; return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) { [image drawInRect:CGRectMake(0, 0, newsize.width, newsize.height)]; }]; } else { return image; }} 经测试缩放后遍历过程大概在20ms以内。 注意这里有个坑：由于缩放后的图的尺寸在 原图宽高*缩放系数后可能不是整数，在布置画布重绘时默认向上取整，这就造成重绘的画布比理论上缩放后的图大。在遍历缩放后图片的像素时，会将图外画布上的像素纳入考虑范围，导致实际白屏页像素占比并非100%。因此使用floor将其尺寸大小向下取整（使用 floor 函数）。 3.3 遍历快照遍历快照缩放后图片的像素点，对纯白像素占比大于99%的页面，认定其为白屏问题页。 12345678910111213141516171819202122232425262728293031323334353637// 遍历像素点 白色像素占比大于99%认定为白屏- (BOOL)searchEveryPixel:(UIImage *)image { CGImageRef cgImage = [image CGImage]; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 每个像素点包含r g b a 四个字节 size_t bytesPerRow = CGImageGetBytesPerRow(cgImage); size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage); CGDataProviderRef dataProvider = CGImageGetDataProvider(cgImage); CFDataRef data = CGDataProviderCopyData(dataProvider); UInt8 *buffer = (UInt8 *)CFDataGetBytePtr(data); int whiteCount = 0; int totalCount = 0; for (int j = 0; j &lt; height; j ++ ) { for (int i = 0; i &lt; width; i ++) { UInt8 *pt = buffer + j * bytesPerRow + i * (bitsPerPixel / 8); UInt8 red = * pt; UInt8 green = *(pt + 1); UInt8 blue = *(pt + 2); totalCount ++; if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254) { whiteCount ++; } } } float proportion = (float)whiteCount / totalCount ; NSLog(@&quot;当前像素点数：%d,白色像素点数:%d , 占比: %f&quot;,totalCount , whiteCount , proportion ); if (proportion &gt; 0.99) { return YES; } else { return NO; }} 注意这里有个坑：有时候出现白屏了，但是检测出来的 RGB 值有些为254，有些为255，所以需要if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254)这样处理。 3.4 使用在页面加载完成后调用-judgeLoadingStatus:方法判断是否出现白屏，出现了就重新刷新页面，经测试可以完美解决白屏问题。 12345678910111213141516171819- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation { @weakify(self); [self judgeLoadingStatus:webView withBlock:^(webviewLoadingStatus status) { @strongify(self); switch (status) { case WebViewErrorStatus: self.reloadTime += 1; if (self.reloadTime &gt; 2) { return; } [webView reload]; NSLog(@&quot;遇到白屏，重新加载🆘&quot;); break; default: break; } }];} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#pragma mark - 处理白屏问题// 判断是否白屏- (void)judgeLoadingStatus:(WKWebView *)webview withBlock:(void (^)(webviewLoadingStatus status))completionBlock { webviewLoadingStatus __block status = WebViewPendStatus; if (@available(iOS 11.0, *)) { if (webview) { // 状态栏高度 CGFloat statusBarHeight = [[UIApplication sharedApplication] statusBarFrame].size.height; // 导航栏高度 CGFloat navigationHeight = webview.viewController.navigationController.navigationBar.frame.size.height; WKSnapshotConfiguration *shotConfiguration = [[WKSnapshotConfiguration alloc] init]; // 仅截图检测导航栏以下部分内容(底部安全区域不影响) shotConfiguration.rect = CGRectMake(0, statusBarHeight + navigationHeight, webview.bounds.size.width, (webview.bounds.size.height - navigationHeight - statusBarHeight)); @weakify(self); [webview takeSnapshotWithConfiguration:shotConfiguration completionHandler:^(UIImage * _Nullable snapshotImage, NSError * _Nullable error) { @strongify(self); if (snapshotImage) { UIImage *scaleImage = [self scaleImage:snapshotImage]; BOOL isWhiteScreen = [self searchEveryPixel:scaleImage]; if (isWhiteScreen) { status = WebViewErrorStatus; } else { status = WebViewNormalStatus; } } if (completionBlock) { completionBlock(status); } }]; } }}// 遍历像素点 白色像素占比大于99%认定为白屏- (BOOL)searchEveryPixel:(UIImage *)image { CGImageRef cgImage = [image CGImage]; size_t width = CGImageGetWidth(cgImage); size_t height = CGImageGetHeight(cgImage); // 每个像素点包含r g b a 四个字节 size_t bytesPerRow = CGImageGetBytesPerRow(cgImage); size_t bitsPerPixel = CGImageGetBitsPerPixel(cgImage); CGDataProviderRef dataProvider = CGImageGetDataProvider(cgImage); CFDataRef data = CGDataProviderCopyData(dataProvider); UInt8 *buffer = (UInt8 *)CFDataGetBytePtr(data); int whiteCount = 0; int totalCount = 0; for (int j = 0; j &lt; height; j ++ ) { for (int i = 0; i &lt; width; i ++) { UInt8 *pt = buffer + j * bytesPerRow + i * (bitsPerPixel / 8); UInt8 red = * pt; UInt8 green = *(pt + 1); UInt8 blue = *(pt + 2); totalCount ++; if (red &gt;= 254 &amp;&amp; green &gt;= 254 &amp;&amp; blue &gt;= 254) { whiteCount ++; } } } float proportion = (float)whiteCount / totalCount ; NSLog(@&quot;当前像素点数：%d,白色像素点数:%d , 占比: %f&quot;,totalCount , whiteCount , proportion ); if (proportion &gt; 0.99) { return YES; } else { return NO; }}// 为了提升检测性能，考虑将快照缩放至1/5，减少像素点总数，从而加快遍历速度- (UIImage *)scaleImage:(UIImage *)image { CGFloat scale = 0.2; CGSize newsize; newsize.width = floor(image.size.width * scale); newsize.height = floor(image.size.height * scale); if (@available(iOS 10.0, *)) { UIGraphicsImageRenderer *renderer = [[UIGraphicsImageRenderer alloc] initWithSize:newsize]; return [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull rendererContext) { [image drawInRect:CGRectMake(0, 0, newsize.width, newsize.height)]; }]; } else { return image; }} 后记网上的答案真坑，说的一本正经，结果一个管用的都没有，有些不光不管用，理论都是错的。苹果真坑。","link":"/2021/02/22/iOS%C2%B7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/WKWebview-%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/"},{"title":"iOS+SQLite","text":"一、SQLite31.1 基本操作数据库操作最基本的无非就是增，删，改，查四个功能。增删改可以统一归为修改数据： 在 SQLite 中，修改数据的基本流程为： 第一步 sqlite3_open_v2 打开数据库第二步 sqlite3_prepare_v2 预处理 SQL 语句操作第三步 sqlite3_bind_xxx 绑定参数第四步 sqlite3_step / sqlite3_exec 执行 SQL 语句第五步 sqlite3_finalize 和 sqlite3_close 释放资源 1.2 APIsqlite3_open_v2打开数据库 ![image-20210225145814561](../../../../Library/Application Support/typora-user-images/image-20210225145814561.png) 参数1:数据库文件路径 参数2:数据库句柄 / 数据库实例 参数3:标记 有以下几种： SQLITE_OPEN_NOMUTEX: 设置数据库连接运行在多线程模式(没有指定单线程模式的情况下)SQLITE_OPEN_FULLMUTEX：设置数据库连接运行在串行模式。SQLITE_OPEN_SHAREDCACHE：设置运行在共享缓存模式。SQLITE_OPEN_PRIVATECACHE：设置运行在非共享缓存模式。SQLITE_OPEN_READWRITE：指定数据库连接可以读写。SQLITE_OPEN_CREATE：如果数据库不存在，则创建。 参数4:使用该数据库的虚拟机的名字，这里我们不需要用，直接传 NULL sqlite3_prepare_v2检查SQL语句的合法性（查询前的准备） 若语句合法即编译通过，则将语句产生的指令塞进 stmt 句柄（此时并未执行指令） ![image-20210225152333984](../../../../Library/Application Support/typora-user-images/image-20210225152333984.png) 参数1:数据库实例 参数2:需要检查的 SQL 语句 参数3:SQL 语句的最大字节长度，-1代表总长度 参数4:stmt 句柄，用来存储 SQL stmt 指令 参数5:指向 zSql 未使用部分的指针，传 null sqlite3_bind通过 prepare 接口可以支持参数化的 SQL 语句，即带问号的SQL语句。比如查询语句select * from t where id=?，或者插入语句insert into t(a,b,c) values(?,?,?)。由于问号是没有意义的，因此需要调用sqlite3_bind_xxx接口来绑定具体的参数。 主要有以下几类：sqlite3_bind_intsqlite3_bind_int64sqlite3_bind_doublesqlite3_bind_textsqlite3_bind_blobsqlite3_bind_null ![image-20210225153229805](../../../../Library/Application Support/typora-user-images/image-20210225153229805.png) 参数1:语句对象 参数2:参数开始执行的序号 参数3:我们要绑定的值 参数4:绑定的字符串的长度 参数5:指针，传 NULL sqlite3_step执行stmt句柄（执行存储在 stmt 句柄的指令） 如果指令能查询到下一行数据，就会返回SQLITE_ROW 如果指令（例如写入数据）不需要返还数据，就会返还SQLITE_DONE ![image-20210225153710058](../../../../Library/Application Support/typora-user-images/image-20210225153710058.png) 参数：stmt 句柄 sqlite3_exec直接编译并执行 SQL 语句 特点：1、没有SQL语法检查 2、每一句SQL语句即使完全一样，也会重新编译执行，对批量指令来说效率不高。 ![image-20210225154354420](../../../../Library/Application Support/typora-user-images/image-20210225154354420.png) 参数1:一个打开的数据库实例 参数2:需要执行的SQL语句 参数3:SQL语句执行完毕后的回调 参数4:回调函数的第1个参数 参数5:错误信息 sqlite3_finalize清理语句句柄(以便重复使用同一个 stmt 句柄) ![image-20210225154636156](../../../../Library/Application Support/typora-user-images/image-20210225154636156.png) 参数：stmt 句柄 sqlite3_close关闭数据库连接 ![image-20210225161715700](../../../../Library/Application Support/typora-user-images/image-20210225161715700.png) 参数：数据库实例 sqlite3_reset将已编译的SQL语句恢复到初始状态，保留语句相关的资源，重置后可重新绑定数据 ![image-20210225162034460](../../../../Library/Application Support/typora-user-images/image-20210225162034460.png) 参数：stmt 句柄 1.3 SQLite 多线程SQLite 多线程操作的特点为保证线程安全，SQLite 数据库只能并发读，不能并发写。 SQLite 多线程操作的正确方式 多线程读写，使用同一个数据库。【采用】 这种情况下由于使用的是同一个数据库连接，SQLite 内部有锁机制，不会出现异常。这种多线程操作并不是真正的并发操作，由于锁机制的存在所以仍然是阻塞的。 多线程读，单线程写，每个线程使用各自独立的数据库连接（但是需要开启wal模式，以开启数据库连接池）。 这种情况下是真的实现了多线程并发读操作，但是写操作仍能只可以单线程，如果多线程写(每个线程使用各自的数据库连接)就会出现问题。 两种方案对比： 理论上并发操作越多，方案2效率越高。实际测试也是如此。 三、iOS 中的使用方式对于方案一，采用异步函数+一个串行队列去操作同一个数据库(开启数据库后不关闭)。 这种情况下就会开辟一个子线程，同时串行的操作同一个数据库，所以既能够不阻塞 UI，又能够保证线程安全。 代码封装： XWTrackingAnalyticsDatabase.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445//// XWTrackingAnalyticsDatabase.h// XWTrackingSDK//// Created by IMO on 2021/2/20.//// 命令行验证：// 1. 进入数据库缓存的 Caches 路径// 2. 执行 sqlite3 XWTrackingAnalyticsDatabase.sqlite// 3. sqlite&gt; .tables// 4. sqlite&gt; select * from events#import &lt;Foundation/Foundation.h&gt;#import &lt;sqlite3.h&gt;NS_ASSUME_NONNULL_BEGIN@interface XWTrackingAnalyticsDatabase : NSObject@property (nonatomic, copy, readonly) NSString *filePath;@property (nonatomic) sqlite3 *database;/// 本地事件存储总量@property (nonatomic) NSUInteger eventCount;/// 初始化方法/// @param filePath 数据库路径，如果为空，则使用默认路径- (instancetype)initWithFilePath:(nullable NSString *)filePath NS_DESIGNATED_INITIALIZER;/// 向数据库中插入事件数据/// @param event 事件- (void)insertEvent:(NSDictionary *)event;/// 从数据库中获取事件数据/// @param count 获取事件数据的条数- (NSArray&lt;NSString *&gt; *)selectEventsForCount:(NSUInteger)count;/// 从数据库中删除一定数量的事件数据，返回是否删除成功/// @param count 删除事件数据的条数- (BOOL)deleteEventsForCount:(NSUInteger)count;@endNS_ASSUME_NONNULL_END XWTrackingAnalyticsDatabase.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#import &quot;XWTrackingAnalyticsDatabase.h&quot;static NSString * const XWTrackingAnalyticsDatabaseName = @&quot;XWTrackingAnalyticsDatabase.sqlite&quot;;@interface XWTrackingAnalyticsDatabase ()@property (nonatomic, strong) dispatch_queue_t queue;@end@implementation XWTrackingAnalyticsDatabase- (instancetype)init { return [self initWithFilePath:nil];}- (instancetype)initWithFilePath:(NSString *)filePath { self = [super init]; if (self) { _filePath = filePath ? : [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).lastObject stringByAppendingPathComponent:XWTrackingAnalyticsDatabaseName]; NSLog(@&quot;数据库路径是：%@&quot;, _filePath); // 初始化队列的唯一标识 NSString *label = [NSString stringWithFormat:@&quot;cn.imo.serialQueue.%p&quot;, self]; // 创建一个串行队列 _queue = dispatch_queue_create(label.UTF8String, DISPATCH_QUEUE_SERIAL); [self open]; [self queryLocalDatabaseEventCount]; } return self;}- (void)open { dispatch_async(self.queue, ^{ // 初始化 SQLite 库 if (sqlite3_open_v2(self.filePath.UTF8String, &amp;(self-&gt;_database), SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } char *error; // 创建数据库表的 SQL 语句 NSString *sql = @&quot;CREATE TABLE IF NOT EXISTS events (id INTEGER PRIMARY KEY AUTOINCREMENT, event BLOB);&quot;; // 运行创建表格的 SQL 语句 if (sqlite3_exec(self.database, sql.UTF8String, NULL, NULL, &amp;error) != SQLITE_OK) { return NSLog(@&quot;Create events Failure %s&quot;, error); } });}static sqlite3_stmt *insertStmt = NULL;- (void)insertEvent:(NSDictionary *)event { dispatch_async(self.queue, ^{ if (insertStmt) { // 重置插入语句，重置后可重新绑定数据 sqlite3_reset(insertStmt); } else { // 插入语句 NSString *sql = @&quot;INSERT INTO events (event) values(?)&quot;; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;insertStmt, NULL) != SQLITE_OK) { // 准备执行 SQL 语句失败，打印 log 返回失败 (NO) return NSLog(@&quot;SQlite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } } NSError *error = nil; // 将 event 转换成 JSON 数据 NSData *data = [NSJSONSerialization dataWithJSONObject:event options:NSJSONWritingPrettyPrinted error:&amp;error]; if (error) { // event 转换失败 return NSLog(@&quot;JSON Serialization error:%@&quot;, error); } // 将 JSON 数据与 stmt 绑定 sqlite3_bind_blob(insertStmt, 1, data.bytes, (int)data.length, SQLITE_TRANSIENT); // 执行 stmt if (sqlite3_step(insertStmt) != SQLITE_DONE) { // 执行失败 return NSLog(@&quot;Insert event into events error&quot;); } // 数据插入成功，事件数量加一 self.eventCount++; });}// 最后一次查询的事件数量static NSUInteger lastSelectEventCount = 50;static sqlite3_stmt *selectStmt = NULL;- (NSArray&lt;NSString *&gt; *)selectEventsForCount:(NSUInteger)count { NSMutableArray&lt;NSString *&gt; *events = [NSMutableArray arrayWithCapacity:count]; // 这里需要使用同步函数，否则会导致返回的事件不完整 dispatch_sync(self.queue, ^{ if (self.eventCount == 0) { return; } if (count != lastSelectEventCount) { lastSelectEventCount = count; selectStmt = NULL; } if (selectStmt) { // 重置查询语句，重置之后可以重新查询数据 sqlite3_reset(selectStmt); } else { // 查询语句（按 id 升序插） NSString *sql = [NSString stringWithFormat:@&quot;SELECT id, event FROM events ORDER BY id ASC LIMIT %lu&quot;, (unsigned long)count]; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;selectStmt, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } } // 执行 SQL 语句 while (sqlite3_step(selectStmt) == SQLITE_ROW) { // 将查询到的这条数据转换成 NSData 对象 NSData *data = [[NSData alloc] initWithBytes:sqlite3_column_blob(selectStmt, 1) length:sqlite3_column_bytes(selectStmt, 1)]; // 将查询到的事件数据转换成 JSON 字符串 NSString *jsonString = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];#if DEBUG NSLog(@&quot;%@&quot;, jsonString);#endif // 将 JSON 字符串添加到数组中 [events addObject:jsonString]; } }); return events;}- (BOOL)deleteEventsForCount:(NSUInteger)count { __block BOOL success = YES; dispatch_sync(self.queue, ^{ if (self.eventCount == 0) { return; } // 删除语句 NSString *sql = [NSString stringWithFormat:@&quot;DELETE FROM events WHERE id IN (SELECT id FROM events ORDER BY id ASC LIMIT %lu);&quot;, (unsigned long)count]; char *errmsg; // 执行删除语句 if (sqlite3_exec(self.database, sql.UTF8String, NULL, NULL, &amp;errmsg) != SQLITE_OK) { success = NO; return NSLog(@&quot;Failed to delete record msg=%s&quot;, errmsg); } self.eventCount = self.eventCount &lt; count ? 0 : self.eventCount - count; }); return success;}// 查询数据库中已缓存的事件条数- (void)queryLocalDatabaseEventCount { dispatch_async(self.queue, ^{ // 查询语句 NSString *sql = @&quot;SELECT count(*) FROM events;&quot;; sqlite3_stmt *stmt = NULL; // 准备执行 SQL 语句，获取 sqlite3_stmt if (sqlite3_prepare_v2(self.database, sql.UTF8String, -1, &amp;stmt, NULL) != SQLITE_OK) { return NSLog(@&quot;SQLite stmt prepare error:%s&quot;, sqlite3_errmsg(self.database)); } while (sqlite3_step(stmt) == SQLITE_ROW) { self.eventCount = sqlite3_column_int(stmt, 0); } });}@end 参考SQLite多线程并发操作 SQLite使用(三)&amp;&amp;核心API使用","link":"/2021/02/25/iOS%C2%B7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/iOS+SQLite/"}],"tags":[],"categories":[{"name":"iOS·底层原理","slug":"iOS·底层原理","link":"/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"iOS·质量&amp;效率","slug":"iOS·质量-效率","link":"/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"},{"name":"博客","slug":"博客","link":"/categories/%E5%8D%9A%E5%AE%A2/"},{"name":"iOS·问题记录","slug":"iOS·问题记录","link":"/categories/iOS%C2%B7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"iOS·数据存储","slug":"iOS·数据存储","link":"/categories/iOS%C2%B7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]}