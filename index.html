<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>IMO&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="IMO&#039;s Blog"><meta name="msapplication-TileImage" content="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="IMO&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="IMO&#039;s Blog"><meta property="og:url" content="http://evilimo.com/"><meta property="og:site_name" content="IMO&#039;s Blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://evilimo.com/img/og_image.png"><meta property="article:author" content="IMO"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://evilimo.com"},"headline":"IMO's Blog","image":["http://evilimo.com/img/og_image.png"],"author":{"@type":"Person","name":"IMO"},"description":""}</script><link rel="icon" href="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.4.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T00:50:11.112Z" title="2021-05-18T00:50:11.112Z">2021-05-18</time>发表</span><span class="level-item"><time dateTime="2021-05-18T07:29:53.486Z" title="2021-05-18T07:29:53.486Z">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/18-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E9%98%9F%E5%88%97%E5%8E%9F%E7%90%86/">18-多线程之GCD队列原理</a></h1><div class="content"><a id="more"></a>

<h2 id="如何定位源码"><a href="#如何定位源码" class="headerlink" title="如何定位源码"></a>如何定位源码</h2><p>已知要研究<code>GCD</code>，所以有以下几种选择源码的方法：</p>
<ul>
<li><p>Baidu/Google</p>
</li>
<li><p>下符号断点<code>dispatch_queue_create</code></p>
<p>首先写下测试代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> aaqueue = dispatch_queue_create(<span class="string">&quot;aa&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>然后添加符号断点：</p>
<img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210414164441728.png" alt="" style="zoom:50%;" />
</li>
<li><p>仅使用<code>Debug-&gt;Debug Workflow-&gt;Always show Disassembly</code>，断点到上面的测试代码，查看汇编也能看到定位在<code>libdispatch.dylib</code></p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415111205942.png"></p>
</li>
</ul>
<p>苹果官网的：<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="一、开始研究-GCD"><a href="#一、开始研究-GCD" class="headerlink" title="一、开始研究 GCD"></a>一、开始研究 GCD</h2><p>首先创建两个常见的队列，串行队列和并发队列，然后分别 <code>po</code> 一下，再顺便把主队列和全局队列分别一起给看了。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<ul>
<li><p>发现主队列的 <code>width</code> 和串行队列的 <code>width</code> 是一样的，其他的也有很多相同的，难怪说主队列是特殊的串行队列。</p>
</li>
<li><p>但是并发队列和全局队列的 <code>width</code> 却相差 1，有点奇怪。接下来我们就到源码中一探究竟吧。</p>
</li>
</ul>
<h2 id="二、创建队列在底层是怎样实现的"><a href="#二、创建队列在底层是怎样实现的" class="headerlink" title="二、创建队列在底层是怎样实现的"></a>二、创建队列在底层是怎样实现的</h2><p>先上结论：</p>
<ul>
<li>自定义并发队列和串行队列，是从<strong>根队列数组</strong>中取出模板属性，然后经过了一系列的开辟空间、构造、赋值等操作创建出来的。</li>
<li><strong>根队列数组</strong>是在<code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的。</li>
</ul>
<h3 id="2-1-自定义队列的创建"><a href="#2-1-自定义队列的创建" class="headerlink" title="2.1 自定义队列的创建"></a>2.1 自定义队列的创建</h3><p>根据我们的调用：<code>dispatch_queue_create(&quot;aa&quot;, NULL);</code>，全局搜索<code>dispatch_queue_create</code>。但是会出现搜索结果巨多的情况（66 results in 17 files），此时我们应该修改搜索条件：</p>
<ul>
<li>由于创建队列代码为<code>dispatch_queue_create(&quot;&quot;, NULL)</code>，所以搜索<code>dispatch_queue_create(</code>——将筛选结果降至（21 results in 6 files）</li>
<li>由于第一个参数为字符串，在c语言中用<code>const</code>修饰，所以搜索<code>dispatch_queue_create(const</code>——将筛选结果降至（2 results in 2 files），由此找到了我们需要看的底层代码</li>
</ul>
<h4 id="2-1-1-dispatch-queue-create"><a href="#2-1-1-dispatch-queue-create" class="headerlink" title="2.1.1 dispatch_queue_create"></a>2.1.1 dispatch_queue_create</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span></span><br><span class="line">dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> _dispatch_lane_create_with_target(label, attr,</span><br><span class="line">			DISPATCH_TARGET_QUEUE_DEFAULT, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现去调用了 <code>_dispatch_lane_create_with_target</code>方法，常规的接口隔离操作。</p>
<h4 id="2-1-2-dispatch-lane-create-with-target"><a href="#2-1-2-dispatch-lane-create-with-target" class="headerlink" title="2.1.2 _dispatch_lane_create_with_target"></a>2.1.2 _dispatch_lane_create_with_target</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span></span><br><span class="line">_dispatch_lane_create_with_target(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t dqa,</span><br><span class="line">		<span class="built_in">dispatch_queue_t</span> tq, <span class="keyword">bool</span> legacy)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// ✅2.3</span></span><br><span class="line">	dispatch_queue_attr_info_t dqai = _dispatch_queue_attr_to_info(dqa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 1: Normalize arguments (qos, overcommit, tq)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	dispatch_qos_t qos = dqai.dqai_qos;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_USER_INTERACTIVE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (qos == DISPATCH_QOS_MAINTENANCE) &#123;</span><br><span class="line">		dqai.dqai_qos = qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// !HAVE_PTHREAD_WORKQUEUE_QOS</span></span></span><br><span class="line"></span><br><span class="line">	_dispatch_queue_attr_overcommit_t overcommit = dqai.dqai_overcommit;</span><br><span class="line">	<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified &amp;&amp; tq) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tq-&gt;do_targetq) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify both overcommit and &quot;</span></span><br><span class="line">					<span class="string">&quot;a non-global target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tq &amp;&amp; dx_type(tq) == DISPATCH_QUEUE_GLOBAL_ROOT_TYPE) &#123;</span><br><span class="line">		<span class="comment">// Handle discrepancies between attr and target queue, attributes win</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tq-&gt;dq_priority &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) &#123;</span><br><span class="line">				<span class="comment">// 并发队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_enabled;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 串行队列</span></span><br><span class="line">				overcommit = _dispatch_queue_attr_overcommit_disabled;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">			qos = _dispatch_priority_qos(tq-&gt;dq_priority);</span><br><span class="line">		&#125;</span><br><span class="line">		tq = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tq &amp;&amp; !tq-&gt;do_targetq) &#123;</span><br><span class="line">		<span class="comment">// target is a pthread or runloop root queue, setting QoS or overcommit</span></span><br><span class="line">		<span class="comment">// is disallowed</span></span><br><span class="line">		<span class="keyword">if</span> (overcommit != _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(tq, <span class="string">&quot;Cannot specify an overcommit attribute &quot;</span></span><br><span class="line">					<span class="string">&quot;and use this kind of target queue&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_unspecified) &#123;</span><br><span class="line">			<span class="comment">// Serial queues default to overcommit!</span></span><br><span class="line">			overcommit = dqai.dqai_concurrent ?</span><br><span class="line">					_dispatch_queue_attr_overcommit_disabled :</span><br><span class="line">					_dispatch_queue_attr_overcommit_enabled;	<span class="comment">// 并发是...disable，串行是...enable</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">		<span class="comment">// ✅一定会走这里</span></span><br><span class="line">		<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">		tq = _dispatch_get_root_queue(</span><br><span class="line">				qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">				overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">			DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Step 2: Initialize the queue</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (legacy) &#123;</span><br><span class="line">		<span class="comment">// if any of these attributes is specified, use non legacy classes</span></span><br><span class="line">		<span class="keyword">if</span> (dqai.dqai_inactive || dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">			legacy = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">void</span> *vtable;</span><br><span class="line">	dispatch_queue_flags_t dqf = legacy ? DQF_MUTABLE : <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (dqai.dqai_concurrent) &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_concurrent);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		vtable = DISPATCH_VTABLE(queue_serial);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (dqai.dqai_autorelease_frequency) &#123;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_NEVER:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_NEVER;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM:</span><br><span class="line">		dqf |= DQF_AUTORELEASE_ALWAYS;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (label) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span> *tmp = _dispatch_strdup_if_mutable(label);</span><br><span class="line">		<span class="keyword">if</span> (tmp != label) &#123;</span><br><span class="line">			dqf |= DQF_LABEL_NEEDS_FREE;</span><br><span class="line">			label = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.4 开辟内存 - 生成相应的对象 queue</span></span><br><span class="line">	dispatch_lane_t dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dispatch_lane_s));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2.5 构造方法</span></span><br><span class="line">	_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br><span class="line">	<span class="comment">// 标签</span></span><br><span class="line">	dq-&gt;dq_label = label;</span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dq-&gt;dq_priority = _dispatch_priority_make((dispatch_qos_t)dqai.dqai_qos,</span><br><span class="line">			dqai.dqai_relpri);</span><br><span class="line">	<span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">		dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">		_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">		_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_retain(tq);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ✅2.6</span></span><br><span class="line">	dq-&gt;do_targetq = tq;</span><br><span class="line">	</span><br><span class="line">	_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">	<span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法较长，我们拆开重点代码进行分析。</p>
<h4 id="2-1-3-dispatch-queue-attr-to-info"><a href="#2-1-3-dispatch-queue-attr-to-info" class="headerlink" title="2.1.3 _dispatch_queue_attr_to_info"></a>2.1.3 _dispatch_queue_attr_to_info</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span> dqai = _dispatch_queue_attr_to_info(dqa);</span><br></pre></td></tr></table></figure>

<p>其中传入这个方法的参数<code>dqa</code>为<code>dispatch_queue_attr_t</code>类型的，串行队列传入的是<code>NULL</code>，并发传入的是<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<p>将<code>dqa</code>参数传入后，生成了<code>dispatch_queue_attr_info_t</code>对象<code>dqai</code>。</p>
<blockquote>
<p>我们可以发现<code>dispatch_queue_attr_info_t</code>是一个结构体位域的形式，里面包含了一些<code>dispatch_qos_t</code>等优先级的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_info_s</span> &#123;</span></span><br><span class="line">	<span class="keyword">dispatch_qos_t</span> dqai_qos : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">int</span>      dqai_relpri : <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_overcommit:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_autorelease_frequency:<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_concurrent:<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">uint16_t</span> dqai_inactive:<span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">dispatch_queue_attr_info_t</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>进入方法查看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_attr_info_t</span></span><br><span class="line">_dispatch_queue_attr_to_info(<span class="keyword">dispatch_queue_attr_t</span> dqa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">dispatch_queue_attr_info_t</span> dqai = &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 串行队列直接返回空结构体。后续代码都是对并发队列进行的操作</span></span><br><span class="line">	<span class="keyword">if</span> (!dqa) <span class="keyword">return</span> dqai;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_VARIANT_STATIC</span></span><br><span class="line">	<span class="keyword">if</span> (dqa == &amp;_dispatch_queue_attr_concurrent) &#123;</span><br><span class="line">		dqai.dqai_concurrent = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> dqai;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (dqa &lt; _dispatch_queue_attrs ||</span><br><span class="line">			dqa &gt;= &amp;_dispatch_queue_attrs[DISPATCH_QUEUE_ATTR_COUNT]) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(dqa-&gt;do_vtable, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 苹果的算法</span></span><br><span class="line">	<span class="keyword">size_t</span> idx = (<span class="keyword">size_t</span>)(dqa - _dispatch_queue_attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发队列结构体位域的默认配置和赋值</span></span><br><span class="line">	dqai.dqai_inactive = (idx % DISPATCH_QUEUE_ATTR_INACTIVE_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_INACTIVE_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并发数。✅重点关注。只有并发队列才有这个值</span></span><br><span class="line">	dqai.dqai_concurrent = !(idx % DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_CONCURRENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_relpri = -(<span class="keyword">int</span>)(idx % DISPATCH_QUEUE_ATTR_PRIO_COUNT);</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_PRIO_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优先级</span></span><br><span class="line">	dqai.dqai_qos = idx % DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_QOS_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_autorelease_frequency =</span><br><span class="line">			idx % DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_AUTORELEASE_FREQUENCY_COUNT;</span><br><span class="line"></span><br><span class="line">	dqai.dqai_overcommit = idx % DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line">	idx /= DISPATCH_QUEUE_ATTR_OVERCOMMIT_COUNT;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dqai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当为串行队列的时候，传入的参数为<code>NULL</code>，直接返回一个空结构体。所以代码后续对<code>dqai</code>的操作都是基于并发队列的，并通过此来<strong>进行判断取值</strong>。</p>
<p>那么对于并发队列，会根据传入的宏定义参数，通过位运算，来给<code>dqai</code>进行赋值，比较主要的有并发数（<code>dqai_concurrent</code>），优先级（<code>dqai_qos</code>）等。</p>
<h4 id="2-1-4-dispatch-object-alloc"><a href="#2-1-4-dispatch-object-alloc" class="headerlink" title="2.1.4 _dispatch_object_alloc"></a>2.1.4 _dispatch_object_alloc</h4><p>虽然在上一步获取到了<code>dispatch_queue_attr_info_t</code>相关的值，但是它并不是最终返回的线程，只是我们用来获取一些配置的临时变量而已。</p>
<p>看<code>_dispatch_lane_create_with_target</code>方法最后一行，发现最终返回的是一个<code>dispatch_lane_t</code>类型的<code>dq</code>的对象，所以<code>dispatch_lane_t</code>应该是最终生成的队列，我们可以发现它是由<code>_dispatch_object_alloc</code>方法创建出来的。</p>
<p>但是<code>_dispatch_object_alloc</code>方法并没有开源，所以我们不知道里面是如何实现的。</p>
<p>不过<code>_dispatch_object</code>很像OC中的<code>NSObject</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_lane_t</span> dq = _dispatch_object_alloc(vtable,</span><br><span class="line">			<span class="keyword">sizeof</span>(struct dispatch_lane_s));</span><br></pre></td></tr></table></figure>



<p><strong>dispatch_object_t</strong></p>
<p>通过搜索<code>dispatch_object</code>，发现并找不到我们需要的多线程抽象类，不过我们发现，一般多线程的对象后面都有<code>_t</code>，所以我们找到了<code>dispatch_object_t</code>这个多线程的抽象类。</p>
<p>我们可以发现其是一个联合体，和我们<code>isa</code>的结果极其类似，里面包含了我们常用的很多信息。因为联合体互斥，这样做有利于内存的优化，和更好的实现多态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span>	       <span class="comment">// 结构体指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>	       <span class="comment">// 队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>	   <span class="comment">// 参数值</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>	       <span class="comment">// 组</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_channel_s</span> *_<span class="title">dch</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>   <span class="comment">// 信号量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> DISPATCH_TRANSPARENT_UNION;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-5-dispatch-queue-init"><a href="#2-1-5-dispatch-queue-init" class="headerlink" title="2.1.5 _dispatch_queue_init"></a>2.1.5 _dispatch_queue_init</h4><p>当我们创建出<code>dispatch_lane_t</code>对象<code>dq</code>后，紧接着就执行<code>_dispatch_queue_init</code>构造方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_init(dq, dqf, dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span>, DISPATCH_QUEUE_ROLE_INNER |</span><br><span class="line">			(dqai.dqai_inactive ? DISPATCH_QUEUE_INACTIVE : <span class="number">0</span>));</span><br></pre></td></tr></table></figure>



<p>查看方法内部实现，发现通过<code>dispatch_queue_t dq = dqu._dq;</code>取出a队列后，对队列又进行了一系列的赋值，然后又返回了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_class_t</span></span><br><span class="line">_dispatch_queue_init(<span class="keyword">dispatch_queue_class_t</span> dqu, <span class="keyword">dispatch_queue_flags_t</span> dqf,</span><br><span class="line">		<span class="keyword">uint16_t</span> width, <span class="keyword">uint64_t</span> initial_state_bits)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> dq_state = DISPATCH_QUEUE_STATE_INIT_VALUE(width);</span><br><span class="line">	<span class="comment">// 取出队列</span></span><br><span class="line">	<span class="keyword">dispatch_queue_t</span> dq = dqu._dq;</span><br><span class="line"></span><br><span class="line">	dispatch_assert((initial_state_bits &amp; ~(DISPATCH_QUEUE_ROLE_MASK |</span><br><span class="line">			DISPATCH_QUEUE_INACTIVE)) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (initial_state_bits &amp; DISPATCH_QUEUE_INACTIVE) &#123;</span><br><span class="line">		dq-&gt;do_ref_cnt += <span class="number">2</span>; <span class="comment">// rdar://8181908 see _dispatch_lane_resume</span></span><br><span class="line">		<span class="keyword">if</span> (dx_metatype(dq) == _DISPATCH_SOURCE_TYPE) &#123;</span><br><span class="line">			dq-&gt;do_ref_cnt++; <span class="comment">// released when DSF_DELETED is set</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 进行了一系列赋值</span></span><br><span class="line">	dq_state |= initial_state_bits;</span><br><span class="line">	dq-&gt;do_next = DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">	dqf |= DQF_WIDTH(width);</span><br><span class="line">	os_atomic_store2o(dq, dq_atomic_flags, dqf, relaxed);</span><br><span class="line">	dq-&gt;dq_state = dq_state;</span><br><span class="line">	dq-&gt;dq_serialnum =</span><br><span class="line">			os_atomic_inc_orig(&amp;_dispatch_queue_serial_numbers, relaxed);</span><br><span class="line">	<span class="comment">// 又返回了</span></span><br><span class="line">	<span class="keyword">return</span> dqu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>关注一下这个方法中的第三个参数，是一个判断：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dqai.dqai_concurrent ?</span><br><span class="line">			DISPATCH_QUEUE_WIDTH_MAX : <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>判断了<code>dqai.dqai_concurrent</code>，我们知道串行是没有<code>dqai_concurrent</code>的，所以串行队列的这个属性为1，就表示串行队列的并发数为1。</p>
<p>那么并发队列的这个属性就为：<code>DISPATCH_QUEUE_WIDTH_MAX</code>。</p>
<p>查看<code>DISPATCH_QUEUE_WIDTH_MAX</code>宏定义，我们发现它的值为<code>DISPATCH_QUEUE_WIDTH_FULL-2</code>，即<code>0xFFE</code>，所以并发队列的最大并发数为<code>0xFFE</code>(4094)。</p>
<p>至于<code>-2</code>则是因为<code>-1</code>是为了不饱和，再<code>-1</code>是因为<code>DISPATCH_QUEUE_WIDTH_POOL</code>为创建全局队列时候所使用的，避免相同。</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/1-20210415093441963.png"></p>
<h4 id="2-1-6-dq-gt-do-targetq-tq"><a href="#2-1-6-dq-gt-do-targetq-tq" class="headerlink" title="2.1.6 dq-&gt;do_targetq = tq;"></a>2.1.6 dq-&gt;do_targetq = tq;</h4><p>执行完构造函数之后，接着又对<code>dq</code>进行了一些列赋值。</p>
<p>但是如果每次创建线程，所有的属性都要重新赋值的话，是比较耗性能的。所以苹果设计了基于“模板”的队列创建方式，这个”模板”就是我们的<code>do_targetq</code>属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标签</span></span><br><span class="line">dq-&gt;dq_label = label;</span><br><span class="line"><span class="comment">// 优先级</span></span><br><span class="line">dq-&gt;dq_priority = _dispatch_priority_make((<span class="keyword">dispatch_qos_t</span>)dqai.dqai_qos,</span><br><span class="line">		dqai.dqai_relpri);</span><br><span class="line"><span class="keyword">if</span> (overcommit == _dispatch_queue_attr_overcommit_enabled) &#123;</span><br><span class="line">	dq-&gt;dq_priority |= DISPATCH_PRIORITY_FLAG_OVERCOMMIT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!dqai.dqai_inactive) &#123;</span><br><span class="line">	_dispatch_queue_priority_inherit_from_target(dq, tq);</span><br><span class="line">	_dispatch_lane_inherit_wlh_from_target(dq, tq);</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_retain(tq);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅2.6</span></span><br><span class="line">dq-&gt;do_targetq = tq;</span><br><span class="line"></span><br><span class="line">_dispatch_object_debug(dq, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> _dispatch_trace_queue_create(dq)._dq;</span><br></pre></td></tr></table></figure>

<p>在方法中寻找，我们可以发现<code>tq</code>的创建是通过<code>_dispatch_get_root_queue</code>方法，即在根队列的基础上创建，然后赋值了优先级<code>qos</code>和<code>overcommit</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">	<span class="comment">// ✅一定会走这里</span></span><br><span class="line">	<span class="comment">// 2.7 从根队列获取 tq</span></span><br><span class="line">	tq = _dispatch_get_root_queue(</span><br><span class="line">			qos == DISPATCH_QOS_UNSPECIFIED ? DISPATCH_QOS_DEFAULT : qos, <span class="comment">// 4</span></span><br><span class="line">			overcommit == _dispatch_queue_attr_overcommit_enabled)-&gt;_as_dq; <span class="comment">// 并发为0 串行为1</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!tq)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Invalid queue attribute&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看<code>qos</code>的值，我们发现<code>DISPATCH_QOS_UNSPECIFIED</code>为0，且之前我们并没有赋值，所以一般情况下即执行<code>DISPATCH_QOS_DEFAULT</code>，为4，所以<code>qos</code>没指定的情况下为4。</p>
<p>接着看<code>overcommit</code>的值，根据上面<code>dqai</code>可以判断出，串行为1，并发为0</p>
<h4 id="2-1-7-dispatch-get-root-queue"><a href="#2-1-7-dispatch-get-root-queue" class="headerlink" title="2.1.7 _dispatch_get_root_queue"></a>2.1.7 _dispatch_get_root_queue</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_global_t</span></span><br><span class="line">_dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 4 - 1 = 3</span></span><br><span class="line">	<span class="comment">// 2 * 3 + 0/1 = 6/7</span></span><br><span class="line">	<span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，最终就是从==根队列数组==里通过下标来取出队列。</p>
<p>根据入参可以知道，下标为6或者7。也就是说从<strong>根队列数组</strong>中取出第六个和第七个队列。</p>
<h4 id="2-1-8-dispatch-root-queues"><a href="#2-1-8-dispatch-root-queues" class="headerlink" title="2.1.8 _dispatch_root_queues[]"></a>2.1.8 _dispatch_root_queues[]</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] = &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_IDX(n, flags) \</span></span><br><span class="line">		((flags &amp; DISPATCH_PRIORITY_FLAG_OVERCOMMIT) ? \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS_OVERCOMMIT : \</span><br><span class="line">		DISPATCH_ROOT_QUEUE_IDX_##n##_QOS)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DISPATCH_ROOT_QUEUE_ENTRY(n, flags, ...) \</span></span><br><span class="line">	[_DISPATCH_ROOT_QUEUE_IDX(n, flags)] = &#123; \</span><br><span class="line">		DISPATCH_GLOBAL_OBJECT_HEADER(queue_global), \</span><br><span class="line">		.dq_state = DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE, \</span><br><span class="line">		.do_ctxt = _dispatch_root_queue_ctxt(_DISPATCH_ROOT_QUEUE_IDX(n, flags)), \</span><br><span class="line">		.dq_atomic_flags = DQF_WIDTH(DISPATCH_QUEUE_WIDTH_POOL), \</span><br><span class="line">		.dq_priority = flags | ((flags &amp; DISPATCH_PRIORITY_FLAG_FALLBACK) ? \</span><br><span class="line">				_dispatch_priority_make_fallback(DISPATCH_QOS_##n) : \</span><br><span class="line">				_dispatch_priority_make(DISPATCH_QOS_##n, <span class="number">0</span>)), \</span><br><span class="line">		__VA_ARGS__ \</span><br><span class="line">	&#125;</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,  		<span class="comment">// 自定义串行队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">10</span>,			<span class="comment">// 自定义并发队列用这个</span></span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">			DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">11</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">12</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">13</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">14</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">15</span>,</span><br><span class="line">	),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过<strong>下标</strong>，我们可以得出如下结论。</p>
<ul>
<li>自定义并发队列<code>target</code>队列为<code>com.apple.root.default-qos</code></li>
<li>自定义串行队列<code>target</code>队列为<code>com.apple.root.default-qos.overcommit</code></li>
</ul>
<blockquote>
<p>至此，我们自定义的一个串行或者并发队列就已经根据模板创建完成了</p>
</blockquote>
<h4 id="2-1-9-验证"><a href="#2-1-9-验证" class="headerlink" title="2.1.9 验证"></a>2.1.9 验证</h4><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/Xnip2021-04-15_08-41-13.png"></p>
<p>回看我们开头打印的一些关于各种队列的信息，可以看到：</p>
<ul>
<li>串行队列、并发队列的<code>target</code>确实对应模板中的值</li>
<li>串行队列、并发队列、主队列、全局队列的<code>width</code>（<code>width</code>表示队列中的最大并发数）都与我们的分析一致，即：<ul>
<li>串行队列和主队列的<code>width</code>为1</li>
<li>自定义并发队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_MAX</code>，是满值-2，0xffe（4094）</li>
<li>全局队列的<code>width</code>为<code>DISPATCH_QUEUE_WIDTH_POOL</code>，是满值-1</li>
</ul>
</li>
</ul>
<blockquote>
<p>由此可见，我们对于底层的分析是正确的。</p>
</blockquote>
<h3 id="2-2-根队列数组的初始化"><a href="#2-2-根队列数组的初始化" class="headerlink" title="2.2 根队列数组的初始化"></a>2.2 根队列数组的初始化</h3><p>除了<code>dispatch_get_main_queue</code>，其他队列都是通过<code>_dispatch_root_queues</code>创建的，那么 <code>_dispatch_root_queues</code> 又是在哪创建的呢？</p>
<p>结论：</p>
<p><code>libdispatch_init</code>之后调用<code>_dispatch_introspection_init</code>，通过 for 循环，调用<code>_dispatch_trace_queue_create</code>，再取出<code>_dispatch_root_queues</code>里的地址指针一个个创建出来的</p>
<p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/image-20210415101634659.png"></p>
<h3 id="2-3-一图看懂自定义队列创建流程"><a href="#2-3-一图看懂自定义队列创建流程" class="headerlink" title="2.3 一图看懂自定义队列创建流程"></a>2.3 一图看懂自定义队列创建流程</h3><p><img src="https://raw.githubusercontent.com/speam/blogImgs/main/%E7%BB%98%E5%9B%BE.png"></p>
<h2 id="三、死锁的产生"><a href="#三、死锁的产生" class="headerlink" title="三、死锁的产生"></a>三、死锁的产生</h2><p>死锁的产生是由于任务的相互等待，那么底层又是怎么实现死锁的？或者说底层是怎么判断产生了死锁？</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718b1295dba40dd?imageView2/0/w/1280/h/960/ignore-error/1" alt="img"></p>
<h4 id="1-dispatch-sync"><a href="#1-dispatch-sync" class="headerlink" title="1.dispatch_sync"></a>1.dispatch_sync</h4><p>全局搜索<code>dispatch_sync(dispatch</code>，忽略<code>unlikely</code>小概率事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">void</span><br><span class="line">dispatch_sync(dispatch_queue_t dq, dispatch_block_t work)</span><br><span class="line">&#123;</span><br><span class="line">	uintptr_t dc_flags &#x3D; DC_FLAG_BLOCK;</span><br><span class="line">	if (unlikely(_dispatch_block_has_private_data(work))) &#123;</span><br><span class="line">		return _dispatch_sync_block_with_privdata(dq, work, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_sync_f(dq, work, _dispatch_Block_invoke(work), dc_flags);</span><br><span class="line">&#125;</span><br><span class="line">#endif &#x2F;&#x2F; __BLOCKS__</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="2-dispatch-sync-f"><a href="#2-dispatch-sync-f" class="headerlink" title="2._dispatch_sync_f"></a>2._dispatch_sync_f</h4><p>还是常规的中间层封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">static void</span><br><span class="line">_dispatch_sync_f(dispatch_queue_t dq, void *ctxt, dispatch_function_t func,</span><br><span class="line">		uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="3-dispatch-sync-f-inline"><a href="#3-dispatch-sync-f-inline" class="headerlink" title="3._dispatch_sync_f_inline"></a>3._dispatch_sync_f_inline</h4><ul>
<li><p>已知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行队列</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">width</span><br></pre></td></tr></table></figure>

<p>是1，所以串行队列满足</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dq-&gt;dq_width &#x3D;&#x3D; 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>return _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</code></li>
</ul>
</li>
<li><p><code>并发队列</code>会继续往下走</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line">static inline void</span><br><span class="line">_dispatch_sync_f_inline(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	if (likely(dq-&gt;dq_width &#x3D;&#x3D; 1)) &#123;</span><br><span class="line">		return _dispatch_barrier_sync_f(dq, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (unlikely(dx_metatype(dq) !&#x3D; _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(0, &quot;Queue type doesn&#39;t support dispatch_sync&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dispatch_lane_t dl &#x3D; upcast(dq)._dl;</span><br><span class="line">	&#x2F;&#x2F; Global concurrent queues and queues bound to non-dispatch threads</span><br><span class="line">	&#x2F;&#x2F; always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span><br><span class="line">	if (unlikely(!_dispatch_queue_try_reserve_sync_width(dl))) &#123;</span><br><span class="line">		return _dispatch_sync_f_slow(dl, ctxt, func, 0, dl, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (unlikely(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		return _dispatch_sync_recurse(dl, ctxt, func, dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_sync_invoke_and_complete(dl, ctxt, func DISPATCH_TRACE_ARG(</span><br><span class="line">			_dispatch_trace_item_sync_push_pop(dq, ctxt, func, dc_flags)));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="4-dispatch-barrier-sync-f"><a href="#4-dispatch-barrier-sync-f" class="headerlink" title="4._dispatch_barrier_sync_f"></a>4._dispatch_barrier_sync_f</h4><p><code>串行队列</code>和<code>栅栏函数</code>的比较相似，所以跳转到这里，还是中间层封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">static void</span><br><span class="line">_dispatch_barrier_sync_f(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	_dispatch_barrier_sync_f_inline(dq, ctxt, func, dc_flags);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="5-dispatch-barrier-sync-f-inline"><a href="#5-dispatch-barrier-sync-f-inline" class="headerlink" title="5._dispatch_barrier_sync_f_inline"></a>5._dispatch_barrier_sync_f_inline</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line">static inline void</span><br><span class="line">_dispatch_barrier_sync_f_inline(dispatch_queue_t dq, void *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_tid tid &#x3D; _dispatch_tid_self();</span><br><span class="line"></span><br><span class="line">	if (unlikely(dx_metatype(dq) !&#x3D; _DISPATCH_LANE_TYPE)) &#123;</span><br><span class="line">		DISPATCH_CLIENT_CRASH(0, &quot;Queue type doesn&#39;t support dispatch_sync&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dispatch_lane_t dl &#x3D; upcast(dq)._dl;</span><br><span class="line">	&#x2F;&#x2F; The more correct thing to do would be to merge the qos of the thread</span><br><span class="line">	&#x2F;&#x2F; that just acquired the barrier lock into the queue state.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; However this is too expensive for the fast path, so skip doing it.</span><br><span class="line">	&#x2F;&#x2F; The chosen tradeoff is that if an enqueue on a lower priority thread</span><br><span class="line">	&#x2F;&#x2F; contends with this fast path, this thread may receive a useless override.</span><br><span class="line">	&#x2F;&#x2F;</span><br><span class="line">	&#x2F;&#x2F; Global concurrent queues and queues bound to non-dispatch threads</span><br><span class="line">	&#x2F;&#x2F; always fall into the slow case, see DISPATCH_ROOT_QUEUE_STATE_INIT_VALUE</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 死锁</span><br><span class="line">	if (unlikely(!_dispatch_queue_try_acquire_barrier_sync(dl, tid))) &#123;</span><br><span class="line">		return _dispatch_sync_f_slow(dl, ctxt, func, DC_FLAG_BARRIER, dl,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (unlikely(dl-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">		return _dispatch_sync_recurse(dl, ctxt, func,</span><br><span class="line">				DC_FLAG_BARRIER | dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line">	_dispatch_introspection_sync_begin(dl);</span><br><span class="line">	_dispatch_lane_barrier_sync_invoke_and_complete(dl, ctxt, func</span><br><span class="line">			DISPATCH_TRACE_ARG(_dispatch_trace_item_sync_push_pop(</span><br><span class="line">					dq, ctxt, func, dc_flags | DC_FLAG_BARRIER)));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="5-1-dispatch-tid-self"><a href="#5-1-dispatch-tid-self" class="headerlink" title="5.1 _dispatch_tid_self"></a>5.1 _dispatch_tid_self</h6><p><code>_dispatch_tid_self</code>是个宏定义，最终调用<code>_dispatch_thread_getspecific</code>来获取当前线程id（线程是以<code>key-value</code>的形式存在的）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#define _dispatch_tid_self()		((dispatch_tid)_dispatch_thread_port())</span><br><span class="line"></span><br><span class="line">#if TARGET_OS_WIN32</span><br><span class="line">#define _dispatch_thread_port() ((mach_port_t)0)</span><br><span class="line">#elif !DISPATCH_USE_THREAD_LOCAL_STORAGE</span><br><span class="line">#if DISPATCH_USE_DIRECT_TSD</span><br><span class="line">#define _dispatch_thread_port() ((mach_port_t)(uintptr_t)\</span><br><span class="line">		_dispatch_thread_getspecific(_PTHREAD_TSD_SLOT_MACH_THREAD_SELF))</span><br><span class="line">#else</span><br><span class="line">#define _dispatch_thread_port() pthread_mach_thread_np(_dispatch_thread_self())</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是时候表演真正的技术了！接下来就是死锁的核心分析！</p>
</blockquote>
<h6 id="5-2-dispatch-queue-try-acquire-barrier-sync"><a href="#5-2-dispatch-queue-try-acquire-barrier-sync" class="headerlink" title="5.2 _dispatch_queue_try_acquire_barrier_sync"></a>5.2 _dispatch_queue_try_acquire_barrier_sync</h6><p><code>_dispatch_queue_try_acquire_barrier_sync</code>会从os底层获取到一个状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT</span><br><span class="line">static inline bool</span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync(dispatch_queue_class_t dq, uint32_t tid)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_queue_try_acquire_barrier_sync_and_suspend(dq._dl, tid, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE DISPATCH_WARN_RESULT</span><br><span class="line">static inline bool</span><br><span class="line">_dispatch_queue_try_acquire_barrier_sync_and_suspend(dispatch_lane_t dq,</span><br><span class="line">		uint32_t tid, uint64_t suspend_count)</span><br><span class="line">&#123;</span><br><span class="line">	uint64_t init  &#x3D; DISPATCH_QUEUE_STATE_INIT_VALUE(dq-&gt;dq_width);</span><br><span class="line">	uint64_t value &#x3D; DISPATCH_QUEUE_WIDTH_FULL_BIT | DISPATCH_QUEUE_IN_BARRIER |</span><br><span class="line">			_dispatch_lock_value_from_tid(tid) |</span><br><span class="line">			(suspend_count * DISPATCH_QUEUE_SUSPEND_INTERVAL);</span><br><span class="line">	uint64_t old_state, new_state;</span><br><span class="line">	&#x2F;&#x2F; 从底层获取信息 -- 状态信息 - 当前队列 - 线程</span><br><span class="line">	return os_atomic_rmw_loop2o(dq, dq_state, old_state, new_state, acquire, &#123;</span><br><span class="line">		uint64_t role &#x3D; old_state &amp; DISPATCH_QUEUE_ROLE_MASK;</span><br><span class="line">		if (old_state !&#x3D; (init | role)) &#123;</span><br><span class="line">			os_atomic_rmw_loop_give_up(break);</span><br><span class="line">		&#125;</span><br><span class="line">		new_state &#x3D; value | role;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="5-3-dispatch-sync-f-slow"><a href="#5-3-dispatch-sync-f-slow" class="headerlink" title="5.3 _dispatch_sync_f_slow"></a>5.3 _dispatch_sync_f_slow</h6><p>在<code>5.2</code>获取到<code>new_state</code>就会来到这里（死锁崩溃时的调用栈中就有这个函数）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">static void</span><br><span class="line">_dispatch_sync_f_slow(dispatch_queue_class_t top_dqu, void *ctxt,</span><br><span class="line">		dispatch_function_t func, uintptr_t top_dc_flags,</span><br><span class="line">		dispatch_queue_class_t dqu, uintptr_t dc_flags)</span><br><span class="line">&#123;</span><br><span class="line">	dispatch_queue_t top_dq &#x3D; top_dqu._dq;</span><br><span class="line">	dispatch_queue_t dq &#x3D; dqu._dq;</span><br><span class="line">	if (unlikely(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">		return _dispatch_sync_function_invoke(dq, ctxt, func);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pthread_priority_t pp &#x3D; _dispatch_get_priority();</span><br><span class="line">	struct dispatch_sync_context_s dsc &#x3D; &#123;</span><br><span class="line">		.dc_flags    &#x3D; DC_FLAG_SYNC_WAITER | dc_flags,</span><br><span class="line">		.dc_func     &#x3D; _dispatch_async_and_wait_invoke,</span><br><span class="line">		.dc_ctxt     &#x3D; &amp;dsc,</span><br><span class="line">		.dc_other    &#x3D; top_dq,</span><br><span class="line">		.dc_priority &#x3D; pp | _PTHREAD_PRIORITY_ENFORCE_FLAG,</span><br><span class="line">		.dc_voucher  &#x3D; _voucher_get(),</span><br><span class="line">		.dsc_func    &#x3D; func,</span><br><span class="line">		.dsc_ctxt    &#x3D; ctxt,</span><br><span class="line">		.dsc_waiter  &#x3D; _dispatch_tid_self(),</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	_dispatch_trace_item_push(top_dq, &amp;dsc);</span><br><span class="line">	__DISPATCH_WAIT_FOR_QUEUE__(&amp;dsc, dq);</span><br><span class="line"></span><br><span class="line">	if (dsc.dsc_func &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		dispatch_queue_t stop_dq &#x3D; dsc.dc_other;</span><br><span class="line">		return _dispatch_sync_complete_recurse(top_dq, stop_dq, top_dc_flags);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_dispatch_introspection_sync_begin(top_dq);</span><br><span class="line">	_dispatch_trace_item_pop(top_dq, &amp;dsc);</span><br><span class="line">	_dispatch_sync_invoke_and_complete_recurse(top_dq, ctxt, func,top_dc_flags</span><br><span class="line">			DISPATCH_TRACE_ARG(&amp;dsc));</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><code>_dispatch_trace_item_push</code>压栈操作，将执行任务push到队列中，按照<code>FIFO</code>执行</li>
<li><code>__DISPATCH_WAIT_FOR_QUEUE__</code>是崩溃栈的最后一个函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_NOINLINE</span><br><span class="line">static void</span><br><span class="line">__DISPATCH_WAIT_FOR_QUEUE__(dispatch_sync_context_t dsc, dispatch_queue_t dq)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 获取队列的状态，看是否是处于等待状态</span><br><span class="line">    uint64_t dq_state &#x3D; _dispatch_wait_prepare(dq);</span><br><span class="line">    if (unlikely(_dq_state_drain_locked_by(dq_state, dsc-&gt;dsc_waiter))) &#123;</span><br><span class="line">    	DISPATCH_CLIENT_CRASH((uintptr_t)dq_state,</span><br><span class="line">    			&quot;dispatch_sync called on queue &quot;</span><br><span class="line">    			&quot;already owned by current thread&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h6 id="5-4-dq-state-drain-locked-by"><a href="#5-4-dq-state-drain-locked-by" class="headerlink" title="5.4 _dq_state_drain_locked_by"></a>5.4 _dq_state_drain_locked_by</h6><p>比较当前等待的<code>value</code>和线程<code>tid</code>，如果为YES就返回回去进行报错处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line">static inline bool</span><br><span class="line">_dq_state_drain_locked_by(uint64_t dq_state, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	return _dispatch_lock_is_locked_by((dispatch_lock)dq_state, tid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DISPATCH_ALWAYS_INLINE</span><br><span class="line">static inline bool</span><br><span class="line">_dispatch_lock_is_locked_by(dispatch_lock lock_value, dispatch_tid tid)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; equivalent to _dispatch_lock_owner(lock_value) &#x3D;&#x3D; tid</span><br><span class="line">	&#x2F;&#x2F; ^ (异或运算法) 两个相同就会出现 0 否则为1</span><br><span class="line">	return ((lock_value ^ tid) &amp; DLOCK_OWNER_MASK) &#x3D;&#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>





<h2 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h2><p>我用的<a target="_blank" rel="noopener" href="https://github.com/speam/libdispatch.git">libdispatch源码</a></p>
<p>苹果官网的<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">libdispatch源码</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099201155079#heading-3">iOS GCD源码浅析</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904097871577102#heading-3">iOS底层学习 - 多线程之GCD队列原理篇</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T00:46:16.810Z" title="2021-05-18T00:46:16.810Z">2021-05-18</time>发表</span><span class="level-item"><time dateTime="2021-05-18T00:46:16.810Z" title="2021-05-18T00:46:16.810Z">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/">17-多线程之GCD应用</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/17-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%BA%94%E7%94%A8/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-18T00:45:29.115Z" title="2021-05-18T00:45:29.115Z">2021-05-18</time>发表</span><span class="level-item"><time dateTime="2021-05-18T10:14:30.183Z" title="2021-05-18T10:14:30.183Z">2021-05-18</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%88%9D%E6%8E%A2/">16-多线程之GCD初探</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/05/18/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8BGCD%E5%88%9D%E6%8E%A2/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-15T04:30:06.726Z" title="2021-05-15T04:30:06.726Z">2021-05-15</time>发表</span><span class="level-item"><time dateTime="2021-05-15T04:30:06.726Z" title="2021-05-15T04:30:06.726Z">2021-05-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《财务自由之路》读书笔记</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/05/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E8%B4%A2%E5%8A%A1%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-10T08:46:06.982Z" title="2021-05-10T08:46:06.982Z">2021-05-10</time>发表</span><span class="level-item"><time dateTime="2021-05-10T08:55:38.668Z" title="2021-05-10T08:55:38.668Z">2021-05-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%A9%98%E5%AD%90%E4%B8%8D%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E6%B0%B4%E6%9E%9C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《橘子不是唯一的水果》读书笔记</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/05/10/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%A9%98%E5%AD%90%E4%B8%8D%E6%98%AF%E5%94%AF%E4%B8%80%E7%9A%84%E6%B0%B4%E6%9E%9C%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-05-08T09:35:37.216Z" title="2021-05-08T09:35:37.216Z">2021-05-08</time>发表</span><span class="level-item"><time dateTime="2021-05-08T09:35:37.216Z" title="2021-05-08T09:35:37.216Z">2021-05-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Mac/">Mac</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/08/Mac/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">Mac应用程序无法打开或文件损坏的解决办法</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/05/08/Mac/Mac%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E6%88%96%E6%96%87%E4%BB%B6%E6%8D%9F%E5%9D%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-08T03:52:21.657Z" title="2021-04-08T03:52:21.657Z">2021-04-08</time>发表</span><span class="level-item"><time dateTime="2021-05-08T09:15:24.208Z" title="2021-05-08T09:15:24.208Z">2021-05-08</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E7%BB%9F%E8%AE%A1/">iOS·统计</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/08/iOS%C2%B7%E7%BB%9F%E8%AE%A1/%E5%9F%8B%E7%82%B9%20SDK%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/">埋点 SDK 使用指南</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/04/08/iOS%C2%B7%E7%BB%9F%E8%AE%A1/%E5%9F%8B%E7%82%B9%20SDK%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-04-06T09:26:50.359Z" title="2021-04-06T09:26:50.359Z">2021-04-06</time>发表</span><span class="level-item"><time dateTime="2021-05-12T06:36:23.397Z" title="2021-05-12T06:36:23.397Z">2021-05-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/04/06/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/15-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/">15-多线程之基础原理</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/04/06/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/15-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-28T06:50:13.719Z" title="2021-03-28T06:50:13.719Z">2021-03-28</time>发表</span><span class="level-item"><time dateTime="2021-05-16T02:13:58.807Z" title="2021-05-16T02:13:58.807Z">2021-05-16</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《指数基金投资指南》读书笔记</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/03/28/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E6%8C%87%E6%95%B0%E5%9F%BA%E9%87%91%E6%8A%95%E8%B5%84%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-03-26T03:09:32.152Z" title="2021-03-26T03:09:32.152Z">2021-03-26</time>发表</span><span class="level-item"><time dateTime="2021-03-30T07:10:28.287Z" title="2021-03-30T07:10:28.287Z">2021-03-30</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">iOS·底层原理</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/">14-KVO原理</a></h1><div class="content"><hr></div><a class="article-more button is-small is-size-7" href="/2021/03/26/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/14-KVO%E5%8E%9F%E7%90%86/#more">阅读更多</a></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">上一页</a></div><div class="pagination-next"><a href="/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/avatar4.png" alt="IMO"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">IMO</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">31</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">8</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://weibo.com/p/1005051936209935" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/speam"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://weibo.com/1936209935/profile?topnav=1&amp;wvr=6&amp;is_all=1"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/rainbowboompop"><i class="fab fa-twitter"></i></a></div></div></div><!--!--><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/04/"><span class="level-start"><span class="level-item">四月 2021</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Mac/"><span class="level-start"><span class="level-item">Mac</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%C2%B7%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">iOS·底层原理</span></span><span class="level-end"><span class="level-item tag">19</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%C2%B7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"><span class="level-start"><span class="level-item">iOS·数据存储</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%C2%B7%E7%BB%9F%E8%AE%A1/"><span class="level-start"><span class="level-item">iOS·统计</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%C2%B7%E8%B4%A8%E9%87%8F-%E6%95%88%E7%8E%87/"><span class="level-start"><span class="level-item">iOS·质量&amp;效率</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS%C2%B7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">iOS·问题记录</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%8D%9A%E5%AE%A2/"><span class="level-start"><span class="level-item">博客</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">读书笔记</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/speam/blogImgs@main/imglogo.png" alt="IMO&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 IMO</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/speam"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>